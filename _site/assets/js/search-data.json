{"0": {
    "doc": "Kafka Introduction",
    "title": "Kafka Introduction",
    "content": "Apache Kafka Official Link . Kafka refers to Apache Kafka, an open-source distributed event streaming platform developed by the Apache Software Foundation. It was created to handle large-scale, real-time data streaming and processing. Kafka is designed to be highly scalable, fault-tolerant, and durable, making it a popular choice for building data pipelines, real-time streaming applications, and event-driven architectures. At its core, Kafka operates as a distributed publish-subscribe messaging system. It allows producers to publish streams of records (messages) to topics, and consumers can subscribe to those topics to consume the messages. Topics act as message categories or feeds, and they are typically partitioned and replicated across multiple servers in a Kafka cluster to achieve high throughput and fault tolerance. Key concepts in Kafka include: . | Topics: A category or feed name to which records are published. | Producers: Applications or systems that publish (write) records to Kafka topics. | Consumers: Applications or systems that subscribe to (read) and process records from Kafka topics. | Partitions: Topics are divided into partitions, allowing for parallelism and scalability. Each partition is an ordered, immutable sequence of records. | Consumer Groups: Consumers can be organized into groups, where each consumer in a group reads from a specific subset of partitions in a topic. This allows for load balancing and fault tolerance. | . Kafka provides durability and fault tolerance by persisting records to disk, replicating them across multiple servers, and allowing configurable retention periods. It supports high-throughput ingestion, low-latency processing, and real-time stream processing with the help of various client libraries and integration with popular data processing frameworks like Apache Spark, Apache Flink, and Apache Storm. Overall, Kafka has become a popular choice for building scalable, real-time data streaming applications and is widely used in industries such as finance, e-commerce, social media, and more. Kafka producers . Kafka producers are applications or systems that publish data (records) to Kafka topics. They generate and send records to Kafka for further processing by consumers. Here’s a general overview of how to use Kafka to produce data: . | Set up a Kafka cluster: First, you need to set up a Kafka cluster consisting of one or more Kafka brokers. Kafka brokers are responsible for storing and replicating the topic partitions. You can follow the Kafka documentation or use a managed Kafka service provided by cloud providers. | Create a Kafka topic: You need to create a topic in Kafka to which you want to produce data. A topic is a named category or feed to which records are published. You can create a topic using the Kafka command-line tools or programmatically using the Kafka API. | Configure the producer: To produce data to Kafka, you’ll need to configure the producer. This involves specifying the Kafka broker addresses, serialization settings for the data, and any additional configurations like compression, acknowledgments, etc. You can configure the producer using properties files or programmatically. | Create a producer instance: In your application, you need to create an instance of the Kafka producer. The producer instance is responsible for establishing a connection to Kafka brokers and sending records. | Generate and send records: In your code, generate the records you want to publish to Kafka. Records can be any type of data, such as JSON, plain text, Avro, or binary. Each record should include a key (optional) and a value. The key is used to determine the partition to which the record will be written (if a key is not provided, the producer will select a random partition). | Publish records to a topic: Using the producer instance, send the generated records to a specific Kafka topic. You specify the topic name and the record(s) you want to send. The producer will handle partitioning, replication, and delivery of the records to Kafka brokers. | Handle errors and ensure delivery: Depending on your configuration, the producer can either wait for acknowledgments from Kafka brokers or continue producing records without waiting for acknowledgments. You can choose the level of reliability and durability you require. It’s important to handle any errors that may occur during the production process and implement appropriate error handling and retry mechanisms. | Close the producer: Once you have finished producing data, it’s good practice to close the Kafka producer to release any resources and ensure a graceful shutdown. | . It’s worth noting that Kafka provides various client libraries for different programming languages (e.g., Java, Python, Go, etc.), which simplify the process of producing data to Kafka. You can choose the library that suits your preferred programming language and integrate it into your application. Additionally, Kafka provides additional features and configurations to optimize and customize the producer behavior, such as batching, compression, message keys, and more. Exploring the Kafka documentation and resources specific to your programming language or Kafka client library will provide more detailed information on how to use Kafka producers effectively. Kafka consumers . Kafka consumers are applications or systems that subscribe to Kafka topics and consume (read) data (records) from those topics. They retrieve and process records published by producers in Kafka. Here’s an overview of Kafka consumers and their usage: . | Set up a Kafka cluster: Just like with producers, you need to set up a Kafka cluster consisting of one or more Kafka brokers. This cluster will store the Kafka topics and handle the distribution of data to consumers. You can follow the Kafka documentation or use a managed Kafka service provided by cloud providers. | Create a Kafka topic: You should have a Kafka topic already created to which you want to consume data. A topic acts as a named category or feed from which records are consumed. You can create a topic using the Kafka command-line tools or programmatically using the Kafka API. | Configure the consumer: To consume data from Kafka, you need to configure the consumer. This involves specifying the Kafka broker addresses, the consumer group to which the consumer belongs, the topic(s) to subscribe to, and other configurations like deserialization settings, offsets management, etc. The consumer can be configured using properties files or programmatically. | Create a consumer instance: In your application, you need to create an instance of the Kafka consumer. The consumer instance is responsible for establishing a connection to Kafka brokers, subscribing to the desired topics, and fetching records. | Subscribe to topics: Using the consumer instance, you need to subscribe to the Kafka topic(s) from which you want to consume data. You can subscribe to a single topic or multiple topics. The consumer will receive records from all partitions of the subscribed topics. | Fetch and process records: Once subscribed, the consumer starts fetching records from Kafka brokers. It pulls records from assigned partitions and delivers them to your application for processing. You can define how many records to fetch in each poll and how frequently to poll for new records. The consumer provides an iterator or a callback mechanism to access the fetched records. | Process records: In your code, you process the consumed records according to your application’s requirements. You can perform various operations like data transformation, analysis, storage, or forwarding to other systems. | Handle offsets and commit: Kafka provides a mechanism to manage offsets, which are pointers that track the progress of consumption for each consumer group. It enables consumers to resume consumption from where they left off in case of failures or restarts. You need to manage offsets and commit them based on the processed records to ensure data integrity and avoid duplicate processing. | Customize consumer behavior: Kafka offers various options to customize consumer behavior, such as specifying the starting offset, seeking to a specific offset, implementing custom partition assignment strategies, controlling the concurrency of records processing, and more. These configurations allow you to optimize the performance and reliability of your consumer application. | Graceful shutdown: When you’re done consuming data, it’s essential to gracefully shut down the consumer. This involves closing the consumer instance to release any resources and ensure a proper shutdown. | . Similar to Kafka producers, Kafka consumers have client libraries available for different programming languages. You can choose the library that aligns with your preferred programming language and integrate it into your application. Remember to refer to the Kafka documentation and resources specific to your chosen programming language or Kafka client library for detailed instructions on how to effectively use Kafka consumers. Partition in Kafka . In Apache Kafka, a partition is a basic unit of data organization and distribution within a topic. Topics in Kafka are divided into multiple partitions to allow for scalability, parallelism, and fault tolerance. Each partition is an ordered and immutable sequence of records. Partitions serve several purposes in Kafka: . | Scalability: By partitioning a topic, Kafka can distribute the load across multiple brokers and handle a higher volume of data. Each partition can be processed independently and in parallel. | Parallelism: Consumers can read from different partitions concurrently, enabling parallel processing of records. This improves the overall throughput and allows for efficient scalability. | Ordering: Records within a partition are strictly ordered based on their offsets. Kafka guarantees the order of records within a partition, ensuring that messages with the same key will always be written to the same partition. | Fault tolerance: Partitions are replicated across multiple brokers to provide fault tolerance. Replication ensures that if a broker or partition becomes unavailable, another replica can take over without losing data or interrupting data availability. | . To define the number of partitions for a Kafka topic, you can use one of the following approaches: . | Default Partitioning: If you don’t explicitly specify the number of partitions when creating a topic, Kafka will use the default partitioning strategy. The default strategy is based on the number of brokers in the cluster. Each broker will be assigned an equal number of partitions, resulting in a balanced distribution. | Manual Partitioning: You can explicitly define the number of partitions when creating a topic. By specifying the number of partitions, you have more control over the distribution and can tailor it to your specific use case. However, manual partitioning requires careful consideration to ensure load balancing and optimal performance. | . When deciding on the number of partitions, consider the following factors: . | Throughput: If you expect a high volume of data, you may want to increase the number of partitions to distribute the load across multiple brokers and enable parallel processing. | Consumer Parallelism: If you have multiple consumer instances or consumer groups, each additional partition allows for more consumers to process data concurrently. | Data Retention: The number of partitions affects the retention policy. Kafka retains messages based on time or size. With more partitions, Kafka can store a larger volume of data within a given retention period. | . It’s important to note that the number of partitions for a topic is typically defined when creating the topic, and it cannot be changed afterwards without re-creating the topic. Therefore, it’s essential to carefully consider your requirements and the anticipated workload before deciding on the number of partitions. In addition to the number of partitions, Kafka also provides control over how records are distributed across partitions using the message key. The key can be specified when producing messages, and Kafka uses a hash function to determine the partition to which the message will be written. This allows for message ordering and ensures that messages with the same key are always written to the same partition. If the key is not specified, Kafka will select a partition randomly for each message. Consumer group in Kafka . In Apache Kafka, a consumer group is a way to parallelize and distribute the consumption of data from one or more Kafka topics. A consumer group consists of multiple consumer instances that work together to consume data from the subscribed topics. When a Kafka topic is consumed by a consumer group, each partition within that topic is assigned to a single consumer instance within the group. This means that each consumer instance is responsible for reading data from a subset of partitions. By assigning partitions to different consumers within a group, Kafka ensures that records within a partition are processed in order, while allowing for parallel processing across partitions. The key characteristics and benefits of consumer groups in Kafka are: . | Parallel processing: Consumer groups enable parallel processing of data. Each consumer instance within the group can read from a subset of partitions simultaneously, allowing for concurrent consumption and improved throughput. | Load balancing: Kafka automatically balances the partition assignments across the available consumer instances within a group. As consumer instances join or leave the group, Kafka redistributes the partitions to ensure an even workload distribution. This allows for dynamic scalability and efficient resource utilization. | Fault tolerance: Consumer groups provide fault tolerance. If a consumer instance within a group becomes unavailable, Kafka automatically reassigns its partitions to the remaining instances, ensuring uninterrupted consumption and preventing data loss. | Offset management: Kafka maintains the offset, which represents the position within each partition from which a consumer group has consumed data. By keeping track of offsets, Kafka allows consumer instances to resume consumption from where they left off, even if they restart or join the group at a later time. This provides reliability and enables fault-tolerant consumption. | Exactly-once semantics: Kafka provides support for exactly-once message processing semantics when using consumer groups and committing offsets correctly. With proper configuration and careful handling of offsets, it is possible to achieve end-to-end exactly-once processing guarantees. | . Consumer groups are useful in scenarios where multiple instances of a consumer application need to work together to process data from a Kafka topic efficiently and concurrently. Examples include real-time data processing, stream analytics, and building distributed systems that rely on event-driven architectures. When creating a consumer group, you specify a unique group identifier. Each consumer instance within the group must have a unique identifier as well. Kafka uses these identifiers to manage partition assignments, offsets, and coordination among the consumer instances. It’s important to note that within a consumer group, each partition is assigned to only one consumer instance at a time. If you have more partitions than consumer instances, some consumer instances may remain idle until additional partitions are added or other instances join the group. Similarly, if you have more consumer instances than partitions, some instances will be idle as well. Consumer groups are managed by the Kafka client library used in your application. The client library provides the necessary APIs and mechanisms for creating, joining, and managing consumer groups, as well as handling partition assignments, offset commits, and rebalancing within the group. Kafka Topic: . In Apache Kafka, a topic is a category or feed name to which records (messages) are published. It is the fundamental unit of data organization in Kafka. Topics allow producers to write records and consumers to read records, providing a way to store and transmit data within the Kafka cluster. A Kafka topic can be thought of as a logical stream of records, and it represents a specific stream of data that you want to publish or consume. Topics are created in Kafka and are usually named based on the type or category of the data they contain. Key characteristics of Kafka topics include: . | Partitioning: Kafka topics are divided into multiple partitions. Each partition is an ordered and immutable sequence of records. Partitions enable parallelism and scalability by allowing multiple producers and consumers to work on different partitions concurrently. | Replication: Kafka provides the option to replicate topic partitions across multiple brokers for fault tolerance and high availability. Replication ensures that if a broker or partition becomes unavailable, another replica can take over the responsibility without data loss. | Ordering: Records within a partition are strictly ordered based on their offsets. Kafka guarantees the order of records within a partition, ensuring that messages with the same key are always written to the same partition and read in the same order. | Retention: Kafka allows you to configure a retention policy for topics, specifying how long the records within a topic should be retained. Retention can be based on time or size, and it determines the amount of historical data that is available for consumption. | Scalability: Kafka topics can handle high-throughput data streams. By increasing the number of partitions and distributing the load across multiple brokers, Kafka can handle large volumes of data and support concurrent processing by multiple producers and consumers. | . When publishing data to a Kafka topic, producers write records to a specific topic. Each record can have an optional key and a value. The key is used for determining the partition to which the record is written, ensuring that records with the same key are always stored in the same partition. On the other hand, consumers can subscribe to one or more Kafka topics and consume records from those topics. When consuming data, consumers receive records from the partitions to which they are assigned within the subscribed topics. It’s important to note that Kafka topics are created and managed within the Kafka cluster. Topics can be created and configured using the Kafka command-line tools, Kafka APIs, or administrative interfaces provided by Kafka clients or management tools. The number of partitions, replication factor, retention policy, and other configurations can be defined during topic creation. Topics in Kafka provide a powerful mechanism for organizing and distributing data streams, enabling reliable, scalable, and real-time data processing and analysis. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/1-Introduction/",
    "relUrl": "/docs/SpringBoot/Kafka/1-Introduction/"
  },"1": {
    "doc": "Hazelcast Introduction",
    "title": "Hazelcast Introduction",
    "content": "Hazelcast Official Link . Hazelcast is an open-source, in-memory data grid (IMDG) and stream processing platform. It provides a distributed computing solution for processing large amounts of data across multiple nodes and allows for high-performance and low-latency data access. Here are some key features and concepts related to Hazelcast: . | In-Memory Data Grid (IMDG): Hazelcast stores data in memory across a cluster of nodes, providing fast and efficient access to data. It distributes data across nodes using a partitioning scheme and provides automatic data replication for fault tolerance. | Distributed Computing: Hazelcast enables distributed computing by allowing you to execute operations on the data stored in the IMDG in parallel across the cluster. It supports distributed data structures like maps, queues, lists, sets, and more, which can be accessed and manipulated in a distributed manner. | High Availability and Fault Tolerance: Hazelcast automatically replicates data across multiple nodes to ensure high availability and fault tolerance. If a node fails, the data is automatically redistributed to other nodes in the cluster, ensuring uninterrupted access to the data. | Distributed Caching: Hazelcast can be used as a distributed cache, where frequently accessed data is stored in memory across the cluster, providing fast data retrieval and reducing the load on the underlying data sources. | Event Streaming: Hazelcast supports event-driven programming by providing an event journal that allows you to capture and process data change events in real-time. This enables building reactive applications and implementing event-driven architectures. | Integration with Various Technologies: Hazelcast integrates with popular frameworks and technologies, such as Java, .NET, Spring, Hibernate, Apache Kafka, Apache Spark, and more. This allows you to leverage Hazelcast within your existing application stack. | Clustering and Scaling: Hazelcast supports dynamic cluster formation, allowing nodes to join and leave the cluster without affecting the overall system. It also provides automatic load balancing and data rebalancing as the cluster size changes, ensuring efficient utilization of resources. | . Overall, Hazelcast provides a powerful and flexible platform for distributed computing, in-memory caching, and event streaming. It is suitable for a wide range of use cases, including high-performance data processing, real-time analytics, caching, and improving application scalability and resilience. Hazelcast distributed cache . Hazelcast Distributed Cache refers to the caching capabilities provided by the Hazelcast in-memory data grid (IMDG). It allows you to store and access data in a distributed manner across a cluster of nodes. In a distributed cache, data is stored in memory across multiple nodes instead of being stored in a single location. This enables faster data access and reduces the load on the underlying data sources or databases. By distributing the cache across a cluster, you can leverage the combined memory capacity of multiple nodes, providing greater storage capacity and better performance. Hazelcast provides a simple and intuitive API for working with distributed caching. It offers a distributed map data structure called IMap, which behaves similarly to a standard Java Map but operates in a distributed manner. You can store key-value pairs in the IMap, and Hazelcast automatically distributes the data across the cluster. Some key features and benefits of Hazelcast Distributed Cache include: . High Performance: By storing data in-memory across multiple nodes, Hazelcast Distributed Cache provides fast and low-latency data access, leading to improved application performance. | Scalability: The cache can scale horizontally by adding more nodes to the cluster. As the cluster grows, the cache can handle larger data sets and increased request loads. | Fault Tolerance: Hazelcast automatically replicates data across nodes, ensuring data availability even if a node fails. In case of node failure, the data is automatically redistributed to the remaining nodes. | Elasticity: Nodes can be dynamically added or removed from the cluster without interrupting the availability or functionality of the cache. | Consistency: Hazelcast offers configurable consistency models for cache operations, allowing you to choose between strong or eventual consistency based on your application requirements. | Integration: Hazelcast Distributed Cache can be easily integrated into various application frameworks and technologies, providing seamless caching capabilities for your applications. | . By utilizing Hazelcast Distributed Cache, you can optimize your application’s performance by caching frequently accessed data in memory, reducing the need for repetitive expensive database or remote service calls. It is particularly useful in scenarios where fast data access and low latency are critical, such as improving response times in web applications, speeding up data-intensive operations, or reducing the load on external systems. Event Streaming Hazelcast . Hazelcast provides event streaming capabilities through its built-in publish-subscribe (pub-sub) messaging system called the Distributed Event Journal. The Distributed Event Journal allows you to capture, publish, and consume events in a distributed and scalable manner within the Hazelcast cluster. Here’s how event streaming is achieved in Hazelcast: . | Event Journal Configuration: You configure the Distributed Event Journal in Hazelcast by specifying the desired settings such as the name of the journal, capacity, time-to-live (TTL) for events, and other relevant parameters. | Publishing Events: To publish an event, you write it to the Distributed Event Journal using the provided API. The event can be any data structure or object that represents the information you want to publish. Hazelcast ensures that the event is persisted and distributed across the cluster. | Subscribing to Events: Consumers interested in consuming events can subscribe to the Distributed Event Journal. Multiple consumers can subscribe to the same journal, and they will receive events in parallel. | Event Consumption: Consumers receive events from the Distributed Event Journal using the subscription mechanism. Hazelcast provides APIs to fetch events from the journal based on various criteria such as sequence numbers, time ranges, or the availability of new events. | Event Processing: Once consumers receive events, they can process them according to their application logic. This may involve performing real-time analytics, triggering actions or workflows, updating application state, or forwarding events to other systems. | Event Replay: Hazelcast allows consumers to replay events from a specific point in time. This is useful for scenarios where you need to rebuild application state or analyze events retroactively. | . The Distributed Event Journal in Hazelcast provides durability and fault tolerance by replicating events across multiple nodes in the cluster. If a node fails, the events are still accessible from other nodes, ensuring data availability. It’s important to note that while the Distributed Event Journal in Hazelcast provides event streaming capabilities within the Hazelcast cluster, if you need to integrate with external event streaming systems or frameworks like Apache Kafka or Apache Flink, you can leverage the connectors and integrations provided by Hazelcast to facilitate seamless data flow between systems. Overall, Hazelcast’s Distributed Event Journal enables event streaming within the Hazelcast cluster, allowing you to build reactive, event-driven applications and systems that can process and react to events in real-time. Example with Spring Boot . build.gradle . plugins { id 'java' id 'org.springframework.boot' version '2.7.14-SNAPSHOT' id 'io.spring.dependency-management' version '1.0.15.RELEASE' } group = 'com.example' version = '0.0.1-SNAPSHOT' java { sourceCompatibility = '1.8' } repositories { mavenCentral() maven { url 'https://repo.spring.io/milestone' } maven { url 'https://repo.spring.io/snapshot' } } dependencies { implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.springframework.boot:spring-boot-starter-cache' implementation 'com.hazelcast:hazelcast-all:4.0.2' runtimeOnly 'org.postgresql:postgresql' testImplementation 'org.springframework.boot:spring-boot-starter-test' } tasks.named('test') { useJUnitPlatform() } . hazelcast.xml . &lt;hazelcast xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-3.12.12.xsd\" xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;instance-name&gt;XML_Hazelcast_Instance&lt;/instance-name&gt; &lt;/hazelcast&gt; . HazelcastApplication.java . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @EnableCaching @SpringBootApplication public class HazelcastApplication { public static void main(String[] args) { SpringApplication.run(HazelcastApplication.class, args); } } . CompanyApplicationController.java . package com.example.Hazelcast.controller; import com.example.Hazelcast.model.Employee; import org.springframework.cache.annotation.Cacheable; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/v1/\") class CompanyApplicationController { @Cacheable(value = \"employee\") @GetMapping(\"employee/{id}\") public Employee getSubscriber(@PathVariable(\"id\") int id) throws InterruptedException { System.out.println(\"Finding employee information with id \" + id + \" ...\"); Thread.sleep(5000); return new Employee(id, \"John Smith\", \"CS\"); } } . Another Sample Spring Boot Example . build.gradle . plugins { id 'java' id 'org.springframework.boot' version '2.7.14-SNAPSHOT' id 'io.spring.dependency-management' version '1.0.15.RELEASE' } group = 'com.example' version = '0.0.1-SNAPSHOT' java { sourceCompatibility = '1.8' } repositories { mavenCentral() maven { url 'https://repo.spring.io/milestone' } maven { url 'https://repo.spring.io/snapshot' } } dependencies { implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.springframework.boot:spring-boot-starter-cache' implementation 'com.hazelcast:hazelcast-spring:4.2.1' implementation 'com.hazelcast:hazelcast:4.2.1' runtimeOnly 'org.postgresql:postgresql' testImplementation 'org.springframework.boot:spring-boot-starter-test' } tasks.named('test') { useJUnitPlatform() } . hazelcast.xml . &lt;hazelcast xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-4.1.xsd\"&gt; &lt;instance-name&gt;my-instance&lt;/instance-name&gt; &lt;network&gt; &lt;join&gt; &lt;multicast enabled=\"false\"/&gt; &lt;tcp-ip enabled=\"true\"&gt; &lt;member&gt;localhost&lt;/member&gt; &lt;/tcp-ip&gt; &lt;/join&gt; &lt;/network&gt; &lt;/hazelcast&gt; . HazelcastApplication.java . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication public class HazelcastApplication { public static void main(String[] args) { SpringApplication.run(HazelcastApplication.class, args); } } . SimpleController.java . package com.example.Hazelcast.controller; import com.hazelcast.core.HazelcastInstance; import com.hazelcast.map.IMap; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class SimpleController { @Autowired private HazelcastInstance hazelcastInstance; @GetMapping(\"/hello/{name}\") public String sayHello(@PathVariable String name) throws InterruptedException { IMap&lt;String, String&gt; cache = hazelcastInstance.getMap(\"myCache\"); if (cache.containsKey(name)) { return cache.get(name); } else { System.out.println(\"Hello waiting for 5sec..\"); Thread.sleep(5000); String message = \"Hello, \" + name + \"!\"; cache.put(name, message); return message; } } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/1-Introduction/",
    "relUrl": "/docs/SpringBoot/Hazelcast/1-Introduction/"
  },"2": {
    "doc": "String, StringBuffer, StringBuilder",
    "title": "What is heap memory",
    "content": "In Java, heap memory refers to a region of the computer’s memory that is allocated for dynamic memory allocation. It is the runtime data area where objects and arrays are allocated during the execution of a Java program. Key points about heap memory in Java: . | Object Storage: All objects and arrays in Java are allocated on the heap. When you create an object using the new keyword or dynamically allocate an array, the memory for that object or array is allocated on the heap. | Dynamic Allocation: The heap memory is managed dynamically by the Java Virtual Machine (JVM). Memory is allocated and deallocated as objects are created and garbage collected, respectively. | Lifetime: The lifetime of objects on the heap is not limited to the scope of a particular method or block. Objects can exist on the heap beyond the execution of the method or block that created them, as long as they are still reachable by references. | Garbage Collection: The JVM automatically performs garbage collection to reclaim memory occupied by objects that are no longer reachable or in use. Garbage collection identifies and removes objects that are no longer referenced, freeing up the corresponding memory on the heap. | Heap Size: The heap size is determined by JVM settings and can be configured using command-line options such as -Xmx (maximum heap size) and -Xms (initial heap size). The heap size affects the amount of memory available for allocating objects and can be adjusted based on the requirements of your Java application. | OutOfMemoryError: If the heap memory is exhausted and there is no more memory available for allocating objects, an OutOfMemoryError is thrown, indicating that the JVM cannot allocate any more memory on the heap. | . Heap memory plays a crucial role in Java programs as it is the primary memory area for storing objects and arrays. Understanding how heap memory is managed and configuring the appropriate heap size can help ensure efficient memory usage and avoid memory-related issues in Java applications. ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#what-is-heap-memory",
    "relUrl": "/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#what-is-heap-memory"
  },"3": {
    "doc": "String, StringBuffer, StringBuilder",
    "title": "Where int, char variable stored in memory",
    "content": "In Java, int and char variables are stored in different parts of memory: . | int Variables: int variables are used to store integer values. They are typically stored on the stack memory. The stack is a region of memory used for storing local variables and method call information during the execution of a program. When you declare an int variable within a method or block, its value is stored directly on the stack. The memory allocated for an int variable on the stack is typically fixed and released when the variable goes out of scope. | char Variables: char variables are used to store single character values. They are stored as 16-bit Unicode characters. Like int variables, char variables are also typically stored on the stack. When you declare a char variable within a method or block, its value is stored directly on the stack. The memory allocated for a char variable on the stack is typically fixed and released when the variable goes out of scope. | . It’s important to note that these variables are stored in memory locations that are managed by the JVM. The actual memory management and allocation details are abstracted away from the programmer. Here’s an example to illustrate the storage of int and char variables: . public class VariableExample { public static void main(String[] args) { int num = 42; // Stored on the stack char letter = 'A'; // Stored on the stack // ... } } . When you create an object or a String inside a method in Java, the memory storage for these variables depends on the type of variable and the context in which they are created. | Object Variables: If you create an object inside a method, the memory for the object itself is allocated on the heap. Objects in Java are dynamically allocated on the heap using the new keyword. Regardless of whether the object is created inside a method or outside, the object itself resides on the heap memory. public void someMethod() { Object obj = new Object(); // Object created on the heap // ... } . In this example, the obj variable is created on the stack, but it holds a reference to the actual object, which is allocated on the heap. | String Variables: In Java, String objects are also stored on the heap. When you create a String object using the new keyword, the memory for the String object is allocated on the heap, regardless of whether it is created inside a method or outside. public void someMethod() { String str = new String(\"Hello\"); // String object created on the heap // ... } . | . Similarly, the str variable is created on the stack, but it holds a reference to the String object, which resides on the heap. It’s important to understand that the variables themselves (e.g., obj, str) are stored on the stack, while the objects they refer to (e.g., the actual Object or String instances) are stored on the heap. The stack variables hold references to the actual objects, allowing you to access and manipulate them. The objects and strings created inside a method will be eligible for garbage collection once they are no longer referenced. The JVM’s garbage collector will automatically reclaim the memory occupied by these objects when they are no longer reachable. Keep in mind that this explanation covers the default behavior in Java. There are some optimizations, such as String interning, where string literals may be stored in a special pool called the “String pool” in the heap. However, for dynamically created objects and strings, they are allocated on the heap as explained above. Notes: . In the case of the statement String str = “ssssaa”;, the str variable will be created on the stack, while the actual String object will be created in a special area called the “String pool” in the heap memory. When you use a string literal like “ssssaa”, the Java compiler checks if an identical string already exists in the String pool. If it does, the existing string reference is assigned to the variable. If not, a new String object is created in the String pool, and its reference is assigned to the variable. Here’s an illustration of the memory allocation for the given statement: . Stack Memory: | | str |_________| String Pool in Heap Memory: ___________________ | \"ssssaa\" |___________________| . In this example, the str variable is created on the stack, and it holds a reference to the “ssssaa” string literal, which is located in the String pool in the heap memory. It’s important to note that string literals in Java are interned by default, meaning that the compiler optimizes and ensures that only one copy of each distinct string literal exists in memory. This allows multiple string variables to refer to the same string instance in the String pool, reducing memory usage. If you create additional String objects using the new keyword, such as String str = new String(“ssssaa”);, a separate String object will be created on the heap, regardless of whether the same string already exists in the String pool. However, using string literals directly, as in String str = “ssssaa”;, allows the compiler to optimize and reuse existing string instances in the String pool when possible. String s1 = new String(“test) and String s2 = “test” . In the statement String s1 = new String(“test”);, the s1 variable will be created on the stack, and a new String object will be created on the heap using the new keyword. Here’s an updated illustration of the memory allocation for the given statement: . Stack Memory: | | s1 |_________| Heap Memory: ___________________ | \"test\" |___________________| . In this example, the s1 variable is created on the stack, and it holds a reference to a new String object created on the heap using the new keyword. The new String(“test”) constructor explicitly creates a new String object, regardless of whether the same string already exists in the String pool. On the other hand, the statement String s2 = “test”; creates a String object in the String pool and assigns its reference to the s2 variable. Here’s an updated illustration of the memory allocation for the s2 statement: . Stack Memory: | | s2 |_________| String Pool in Heap Memory: ___________________ | \"test\" |___________________| . In this case, the s2 variable is created on the stack, and it holds a reference to the “test” string literal in the String pool. The string literal “test” is interned in the String pool, and if an identical string already exists, it is reused. Comparing s1 and s2, even though both variables reference the string “test,” they are different objects. s1 refers to a new String object created explicitly using new, while s2 refers to the interned string literal in the String pool. It’s worth noting that using string literals directly (String s2 = “test”;) is more efficient and generally preferred over using new String(“test”) since it avoids unnecessary object creation and allows string interning for better memory usage. ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#where-int-char-variable-stored-in-memory",
    "relUrl": "/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#where-int-char-variable-stored-in-memory"
  },"4": {
    "doc": "String, StringBuffer, StringBuilder",
    "title": "Difference between String pool vs heap",
    "content": "The main differences between the String pool and the heap in Java relate to their purpose, storage, and usage: . String Pool: . | The String pool, also known as the intern pool, is a special area in the heap memory. | It is a pool of unique string literals created at compile time or explicitly added to the pool using the String.intern() method. | String literals, such as “test”, are automatically interned and stored in the String pool. | String objects in the pool are shared among multiple references, reducing memory usage by avoiding duplicate string instances. | The String pool provides string interning, allowing efficient comparison of string literals using reference equality (==). | The pool exists for the entire lifetime of the JVM and is accessible to all classes and threads. | Strings stored in the String pool are typically immutable, meaning their values cannot be changed once created. | . Heap: . | The heap is a region of memory used for dynamic memory allocation in Java. | It is where objects, including strings, are allocated during runtime using the new keyword or other object creation mechanisms. | Objects created on the heap have a longer lifetime and can be accessed by multiple references. | The heap is divided into different generations (Young Generation, Old Generation) and managed by the JVM’s garbage collector for automatic memory management. | Unlike the String pool, the heap stores all types of objects, not just strings. | Objects stored in the heap can be mutable, allowing their values to be modified. | . Key Points: . | String literals are interned in the String pool, while dynamically created strings (e.g., using new String()) are stored on the heap. | The String pool is a smaller subset of the heap, dedicated to storing unique string literals and providing efficient string interning. | The heap is a larger area where all objects, including strings, are allocated dynamically during runtime. | The String pool reduces memory usage by sharing string instances, while the heap handles general object storage and memory allocation. | It’s important to note that the exact memory organization and behavior may vary across different JVM implementations. However, the concept of the String pool and the heap remains consistent in the Java programming language. | . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#difference-between-string-pool-vs-heap",
    "relUrl": "/docs/Java/Interview/1-String-StringBuffer-StringBuilder/#difference-between-string-pool-vs-heap"
  },"5": {
    "doc": "String, StringBuffer, StringBuilder",
    "title": "String, StringBuffer, StringBuilder",
    "content": "Difference between String, StringBuffer, StringBuilder . The main differences between String, StringBuffer, and StringBuilder in Java are related to their immutability, synchronization, and performance characteristics: . | String: String objects are immutable in Java, meaning their values cannot be changed once created. When you perform operations on a String, such as concatenation or substring, a new String object is created in memory. This immutability ensures thread-safety but can be less efficient for frequent modifications because of object creation overhead. | StringBuffer: StringBuffer is a mutable sequence of characters. It provides synchronized methods, making it safe for use in multi-threaded environments. When you modify a StringBuffer (e.g., append, insert, delete), the modifications happen directly on the underlying character array. The synchronized methods add overhead, making it slower in single-threaded scenarios compared to StringBuilder. | StringBuilder: StringBuilder is also a mutable sequence of characters, similar to StringBuffer. However, unlike StringBuffer, it is not synchronized, making it more efficient in single-threaded scenarios. StringBuilder is preferred over StringBuffer when you don’t require thread-safety. Like StringBuffer, modifications to a StringBuilder happen directly on the underlying character array. | . Choosing between StringBuffer and StringBuilder depends on the thread-safety requirements of your application. If you’re working in a multi-threaded environment and require thread-safety, use StringBuffer. If you’re working in a single-threaded environment or don’t need thread-safety, use StringBuilder for better performance. Here’s an example to illustrate the differences: . String str = \"Hello\"; str += \" World\"; // Creates a new String object StringBuffer stringBuffer = new StringBuffer(\"Hello\"); stringBuffer.append(\" World\"); // Modifies the existing StringBuffer object StringBuilder stringBuilder = new StringBuilder(\"Hello\"); stringBuilder.append(\" World\"); // Modifies the existing StringBuilder object . In this example, using String involves creating a new String object when concatenating “ World” to the original value. On the other hand, both StringBuffer and StringBuilder modify the existing object directly, avoiding unnecessary object creation. It’s important to consider the trade-offs between immutability, synchronization, and performance when choosing among String, StringBuffer, and StringBuilder based on your specific use case. ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/1-String-StringBuffer-StringBuilder/",
    "relUrl": "/docs/Java/Interview/1-String-StringBuffer-StringBuilder/"
  },"6": {
    "doc": "Caching",
    "title": "Caching",
    "content": "Caching . Hazelcast, an open-source in-memory data grid platform, provides various caching mechanisms to improve the performance and scalability of applications. Here are some of the different caching mechanisms available in Hazelcast: . | Near Cache: Near Cache is a local cache that sits close to the application and stores frequently accessed data from the underlying distributed cache. It helps reduce the network round trips by serving data from the local cache, thereby improving the overall application performance. | Distributed Cache: Hazelcast allows you to distribute the cache across a cluster of nodes. It partitions the data and distributes it across the nodes, providing high availability and scalability. Each node holds a portion of the cache, enabling parallel processing and reducing the load on individual nodes. | Replicated Cache: Replicated Cache is a type of distributed cache where the entire cache data is replicated on each node in the cluster. This mechanism provides high availability as each node can serve the data independently without relying on other nodes. However, it may consume more memory as the data is duplicated across nodes. | Partitioned Cache: Partitioned Cache is another type of distributed cache where the cache data is partitioned across the cluster nodes based on a configurable key. Each node owns a specific set of cache entries, allowing for parallel processing and improved scalability. Partitioning also helps distribute the load across the cluster. | Write-Through and Write-Behind Caches: Hazelcast supports both write-through and write-behind caching strategies. With write-through caching, every write operation updates the cache and the underlying data store simultaneously. In contrast, with write-behind caching, write operations update the cache immediately and asynchronously update the underlying data store at a later time, improving the write performance. | Expiration and Eviction Policies: Hazelcast offers various expiration and eviction policies to manage the lifecycle of cache entries. You can set expiration times to automatically remove entries from the cache after a certain period. Eviction policies help manage the cache size by removing less frequently used entries based on strategies like least recently used (LRU), least frequently used (LFU), or random eviction. | . These caching mechanisms in Hazelcast provide flexibility and performance optimization options for applications by reducing network latency, improving data access, and enabling efficient data distribution across clusters. Caching Topologies . To use Hazelcast as a distributed cache, you can choose one of the following topologies: . | Embedded mode: In this mode, the application and the cached data are stored on the same device. When a new entry is written to the cache, Hazelcast takes care of distributing it to the other members. | Client/server mode: In this mode, the cached data is separated from the application. Hazelcast members run on dedicated servers and applications connect to them through clients. | . Embedded mode . | Advantages: Data access is faster because applications don’t need to send a request to the cache cluster over the network. | Disadvantages: Hazelcast can be embedded only in Java applications. Each new instance of your application adds a new member to the cluster even if you don’t it. | . Client/server mode . | Advantages: Supports independent scaling of the application and the cache cluster. Allows you to write polyglot applications that can all connect to the same cache cluster. | Disadvantages: To read from a cache or write to it, clients need to make network requests, which leads to higher latency than embedded mode. | . Embedded caching with Hazelcast in a Spring Boot application: . pom.xml . &lt;dependencies&gt; &lt;!-- Other dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . Configure Hazelcast: . HazelcastConfig.java . import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import com.hazelcast.config.Config; import com.hazelcast.core.HazelcastInstance; import com.hazelcast.spring.cache.HazelcastCacheManager; @Configuration public class HazelcastConfig { @Bean public Config hazelcastConfig() { return new Config(); } @Bean public HazelcastInstance hazelcastInstance(Config hazelcastConfig) { return Hazelcast.newHazelcastInstance(hazelcastConfig); } @Bean public HazelcastCacheManager cacheManager(HazelcastInstance hazelcastInstance) { return new HazelcastCacheManager(hazelcastInstance); } } . This configuration class creates a Hazelcast instance and a HazelcastCacheManager bean to manage the caches. Enable Caching: . YourApplication.java . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching public class YourApplication { public static void main(String[] args) { SpringApplication.run(YourApplication.class, args); } } . Use Caching: . YourService.java . import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; @Service public class YourService { @Cacheable(\"yourCacheName\") public YourData getData(String id) { // Logic to retrieve data from a data source return yourData; } } . Hazelcast client-server topology in a Spring Boot application: . pom.xml . &lt;dependencies&gt; &lt;!-- Other dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . Configure Server: . Set up a Hazelcast server instance by creating a configuration file named hazelcast.xml in the src/main/resources directory. Here’s a sample configuration: . &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;hazelcast xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-4.3.xsd\"&gt; &lt;network&gt; &lt;port auto-increment=\"true\"&gt;5701&lt;/port&gt; &lt;join&gt; &lt;multicast enabled=\"false\"/&gt; &lt;tcp-ip enabled=\"true\"&gt; &lt;member&gt;localhost&lt;/member&gt; &lt;/tcp-ip&gt; &lt;/join&gt; &lt;/network&gt; &lt;/hazelcast&gt; . YourApplication.java . import com.hazelcast.client.config.ClientConfig; import com.hazelcast.client.config.ClientNetworkConfig; import com.hazelcast.client.config.ClientUserCodeDeploymentConfig; import com.hazelcast.client.HazelcastClient; import com.hazelcast.core.HazelcastInstance; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.Bean; @SpringBootApplication public class YourApplication { public static void main(String[] args) { SpringApplication.run(YourApplication.class, args); } @Bean public HazelcastInstance hazelcastInstance() { ClientConfig config = new ClientConfig(); ClientNetworkConfig networkConfig = config.getNetworkConfig(); networkConfig.addAddress(\"localhost:5701\"); // Configure the server address // Additional configuration if needed // config.setUserCodeDeploymentConfig(new ClientUserCodeDeploymentConfig().addClass(MyClass.class)); // config.setInstanceName(\"my-instance\"); // ... return HazelcastClient.newHazelcastClient(config); } } . In this example, we create a HazelcastInstance bean by configuring a ClientConfig object. The server address is specified in the addAddress method of the ClientNetworkConfig. You can also include additional configuration options as needed. Use Caching: . Once the Hazelcast client is configured, you can use it for caching in your service or repository classes. Follow the same steps as mentioned in the previous example for using caching with Hazelcast embedded mode. Near Cache in Hazelcast: . Near Cache in Hazelcast is a local cache that sits close to the client or application and stores frequently accessed data from the underlying distributed cache. It helps improve application performance by reducing the need for network round trips to fetch data from the remote cache. Advantages of Near Cache: . | Improved Performance: Near Cache reduces network latency by serving data from the local cache, eliminating the need to fetch data from the remote cache. This results in faster data access and improved overall application performance. | Reduced Network Traffic: With Near Cache, data is retrieved and stored locally, reducing the amount of network traffic between the client and the remote cache. This can significantly decrease the load on the network and improve scalability. | Lower Latency: Since data is stored locally, access to frequently used data is faster due to the reduced network round trips. This lowers the overall latency of accessing cached data. | Consistency: Near Cache keeps the data in sync with the remote cache by automatically invalidating or updating the cached data when changes occur in the remote cache. This ensures data consistency across the distributed cache. | . Disadvantages of Near Cache: . | Increased Memory Usage: Near Cache requires additional memory to store the cached data locally. Depending on the size of the cache and the amount of data stored, this can lead to increased memory consumption. | Staleness of Data: Near Cache introduces a level of eventual consistency. If data is updated in the remote cache, it may take some time for the changes to be propagated to the Near Cache. This can result in temporarily stale data until the Near Cache is refreshed. | Maintenance Overhead: Near Cache introduces an additional layer of caching that needs to be managed and maintained. This includes handling cache eviction, cache updates, and cache synchronization between the client and the remote cache. | . Here’s an example of how you can configure and use Near Cache in a Spring Boot application with Hazelcast: . pom.xml . &lt;dependencies&gt; &lt;!-- Other dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . Configure Hazelcast Client: . Create a configuration class to configure Hazelcast client in your application. For example, create a HazelcastClientConfig.java file: . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/2-caching_mechanishm/",
    "relUrl": "/docs/SpringBoot/Hazelcast/2-caching_mechanishm/"
  },"7": {
    "doc": "Java Comparator vs Comparable",
    "title": "Comparator vs Comparable in java",
    "content": "In Java, both Comparator and Comparable are interfaces used for sorting and ordering objects, but they serve different purposes. Comparable interface: . | The Comparable interface is implemented by a class whose instances can be sorted. | It defines a single method called compareTo(), which compares the object with another object of the same type. | The compareTo() method returns a negative integer, zero, or a positive integer based on whether the current object is less than, equal to, or greater than the other object, respectively. | By implementing Comparable, you enable the natural ordering of instances of your class. | Example usage: Sorting a list of strings in alphabetical order using Collections.sort(). | . Comparator interface: . | The Comparator interface is used to define custom comparison logic separate from the objects being compared. | It defines two methods: compare() and equals(). | The compare() method compares two objects and returns a negative integer, zero, or a positive integer based on the comparison. | By using Comparator, you can sort objects based on different criteria or multiple fields. | Comparator implementations can be passed to sorting methods like Collections.sort() or Arrays.sort() as an additional argument. | Example usage: Sorting a list of custom objects based on a specific field or a combination of fields. To summarize, Comparable is used for natural ordering and is implemented by the class whose instances need to be sorted. On the other hand, Comparator is used for custom ordering and can be implemented separately from the class being sorted. | . import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List; class Employee implements Comparable&lt;Employee&gt; { private String name; private int age; public Employee(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public int getAge() { return age; } @Override public int compareTo(Employee other) { return this.name.compareTo(other.name); } @Override public String toString() { return \"Employee [name=\" + name + \", age=\" + age + \"]\"; } } class AgeComparator implements Comparator&lt;Employee&gt; { @Override public int compare(Employee emp1, Employee emp2) { return emp1.getAge() - emp2.getAge(); } } public class SortingExample { public static void main(String[] args) { List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); employeeList.add(new Employee(\"John\", 30)); employeeList.add(new Employee(\"Alice\", 25)); employeeList.add(new Employee(\"Bob\", 35)); // Sort using Comparable (natural ordering) System.out.println(\"Sorted by name (Comparable):\"); Collections.sort(employeeList); for (Employee emp : employeeList) { System.out.println(emp); } // Sort using Comparator (custom ordering) System.out.println(\"\\nSorted by age (Comparator):\"); Comparator&lt;Employee&gt; ageComparator = new AgeComparator(); Collections.sort(employeeList, ageComparator); for (Employee emp : employeeList) { System.out.println(emp); } } } . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/2-comparator%20vs%20comparable/#comparator-vs-comparable-in-java",
    "relUrl": "/docs/Java/Interview/2-comparator%20vs%20comparable/#comparator-vs-comparable-in-java"
  },"8": {
    "doc": "Java Comparator vs Comparable",
    "title": "Java Comparator vs Comparable",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/2-comparator%20vs%20comparable/",
    "relUrl": "/docs/Java/Interview/2-comparator%20vs%20comparable/"
  },"9": {
    "doc": "Kafka Setup",
    "title": "To set up Kafka follow these steps:",
    "content": ". | Install Java: Kafka requires Java to run. Check if you have Java installed by opening Terminal and running the command java -version. | Download Kafka: Go to the Apache Kafka website (https://kafka.apache.org/downloads) and download the latest stable release of Kafka. Choose the binary version and download the .tgz file. | Extract Kafka: Open Terminal and navigate to the directory where you downloaded the Kafka .tgz file. Extract the contents of the file using the following command, replacing &lt;kafka-version&gt; with the actual version you downloaded: tar -xzf kafka_&lt;kafka-version&gt;.tgz . | Start the ZooKeeper server: Kafka uses ZooKeeper for coordination. Start ZooKeeper by running the following command from the Kafka directory: bin/zookeeper-server-start.sh config/zookeeper.properties . ZooKeeper will start running on localhost:2181. | Start the Kafka broker: Open a new Terminal window and navigate to the Kafka directory. Start the Kafka broker by running the following command: bin/kafka-server-start.sh config/server.properties . Kafka will start running on localhost:9092 by default. | Verify Kafka setup: Open a new Terminal window and run the following command to create a test topic: bin/kafka-topics.sh --create --topic test-topic --bootstrap-server localhost:9092 --partitions 1 --replication-factor 1 . This command creates a topic named “test-topic” with one partition and a replication factor of 1. | Publish and consume test messages: In separate Terminal windows, run the following commands to produce and consume test messages: . | Producer Terminal: bin/kafka-console-producer.sh --topic test-topic --bootstrap-server localhost:9092 . This will open a console where you can type and publish messages. | Consumer Terminal: bin/kafka-console-consumer.sh --topic test-topic --bootstrap-server localhost:9092 --from-beginning . | . | . Quick Debug: . anjanjana@Anjans-MacBook-Pro kafka-3.5.0-src % bin/zookeeper-server-start.sh config/zookeeper.properties Classpath is empty. Please build the project first e.g. by running './gradlew jar -PscalaVersion=2.13.10' anjanjana@Anjans-MacBook-Pro kafka-3.5.0-src % ./gradlew jar -PscalaVersion=2.13.10 . Run multiple Kafka brokers . To run multiple Kafka brokers, you need to configure and start multiple instances of Kafka on different ports. Each Kafka broker will act as an independent node in the Kafka cluster. Here are the general steps to run multiple Kafka brokers: . | Configure Kafka properties: Create separate configuration files for each Kafka broker. Copy the server.properties file, which is located in the Kafka installation directory, for each broker instance. Rename the copied files, such as server1.properties, server2.properties, and so on, for easy identification. | Update broker-specific properties: Open each configuration file and modify the following properties to ensure uniqueness for each broker: . | broker.id: Assign a unique ID to each broker. The ID must be an integer and should be different for each broker. | listeners: Set the listeners property to define the network interfaces and ports for each broker. For example, you can have PLAINTEXT://localhost:9092 for the first broker, PLAINTEXT://localhost:9093 for the second, and so on. | log.dirs: Specify different directories for the log files of each broker. It’s recommended to have separate directories to avoid data conflicts. | . | Configure ZooKeeper connection: In each configuration file, specify the connection details of the ZooKeeper ensemble by updating the zookeeper.connect property. Ensure that all brokers use the same ZooKeeper ensemble. | Start each Kafka broker: Open a separate Terminal window for each broker instance. Navigate to the Kafka installation directory and run the following command for each broker, replacing &lt;broker-id&gt; with the unique ID assigned to each broker, and &lt;config-file&gt; with the respective configuration file: bin/kafka-server-start.sh config/&lt;config-file&gt; . For example, to start the first broker with server1.properties: . bin/kafka-server-start.sh config/server1.properties . Similarly, start the other brokers with their respective configuration files. | Verify broker status: Once all the brokers are started, you can verify their status by running the following command for each broker in separate Terminal windows: bin/kafka-topics.sh --list --bootstrap-server localhost:&lt;port&gt; . Replace &lt;port&gt; with the appropriate port number for each broker (e.g., 9092, 9093, etc.). This command will list all the topics available on that particular broker. | . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/2-setup/#to-set-up-kafka-follow-these-steps",
    "relUrl": "/docs/SpringBoot/Kafka/2-setup/#to-set-up-kafka-follow-these-steps"
  },"10": {
    "doc": "Kafka Setup",
    "title": "Kafka Setup",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/2-setup/",
    "relUrl": "/docs/SpringBoot/Kafka/2-setup/"
  },"11": {
    "doc": "List, Set, Map interface",
    "title": "List, Set, Map interface",
    "content": "HashSet . In Java, a HashSet is implemented using a hash table. It internally uses a HashMap to store its elements. The HashSet class extends the AbstractSet class and implements the Set interface. Here’s how a HashSet is maintained: . | Hashing: When an element is added to a HashSet, its hash code is calculated using the hashCode() method of the element. The hash code is an integer value that represents the element’s internal state. | Bucket Calculation: The hash code is used to determine the bucket (or index) in the underlying array where the element will be stored. The bucket calculation is performed using the hashCode() value and the current capacity of the HashSet. | Handling Collisions: In case of hash code collisions (when two elements have the same hash code), a process called “chaining” is used. Chaining involves storing multiple elements in the same bucket by maintaining a linked list of elements. Each bucket can contain multiple elements in a linked list. | Equals Method: To handle potential hash collisions, the equals() method of the elements is used to check for actual equality between the elements within the same bucket. The equals() method is called to compare the added element with the existing elements in the bucket. | Load Factor and Rehashing: HashSet has a load factor, which determines when the underlying array should be resized. By default, the load factor is 0.75, which means that when the HashSet reaches 75% of its capacity, it automatically increases its capacity and rehashes the elements into the new array to maintain efficient performance. | . The use of hashing and linked lists (in case of collisions) allows HashSet to provide fast insertion, deletion, and retrieval operations with an average time complexity of O(1). Here’s an example to illustrate the basic usage of a HashSet: . import java.util.HashSet; import java.util.Set; public class HashSetExample { public static void main(String[] args) { Set&lt;String&gt; colors = new HashSet&lt;&gt;(); colors.add(\"Red\"); colors.add(\"Green\"); colors.add(\"Blue\"); colors.add(\"Red\"); // Duplicate element System.out.println(\"Colors in HashSet: \" + colors); } } . TreeSet . In Java, TreeSet is an implementation of the Set interface that provides a sorted, ordered set of elements. It uses a self-balancing binary search tree called a red-black tree as its underlying data structure. The elements in a TreeSet are stored in sorted order according to their natural ordering or a custom Comparator provided during construction. Key features of TreeSet: . | Sorted Order: TreeSet maintains the elements in sorted order. This allows efficient operations like range queries and finding the minimum or maximum element. | Unique Elements: Like other Set implementations, TreeSet does not allow duplicate elements. It ensures that each element in the set is unique. | Null Values: TreeSet does not allow null elements. If you try to insert a null element, it will throw a NullPointerException. | Fast Operations: TreeSet provides efficient performance for operations like insertion, deletion, and searching, thanks to the balanced tree structure. | NavigableSet Interface: TreeSet implements the NavigableSet interface, which provides additional navigation methods like lower(), higher(), floor(), and ceiling() for finding elements relative to a given value. | . Here’s an example that demonstrates the usage of TreeSet: . import java.util.Set; import java.util.TreeSet; public class TreeSetExample { public static void main(String[] args) { Set&lt;String&gt; fruits = new TreeSet&lt;&gt;(); // Adding elements to TreeSet fruits.add(\"Apple\"); fruits.add(\"Banana\"); fruits.add(\"Mango\"); fruits.add(\"Orange\"); fruits.add(\"Pineapple\"); // Printing the TreeSet System.out.println(\"Fruits in sorted order: \" + fruits); // Removing an element fruits.remove(\"Banana\"); System.out.println(\"After removing Banana: \" + fruits); // Checking if an element exists boolean containsMango = fruits.contains(\"Mango\"); System.out.println(\"Contains Mango? \" + containsMango); // Finding the size of the TreeSet int size = fruits.size(); System.out.println(\"Size of the TreeSet: \" + size); // Iterating over the TreeSet System.out.println(\"Iterating over the TreeSet:\"); for (String fruit : fruits) { System.out.println(fruit); } } } . To use objects in a TreeSet in Java, you need to ensure that the objects being stored in the set implement the Comparable interface or provide a custom Comparator to define the sorting order. Here’s an example: . import java.util.Set; import java.util.TreeSet; class Student implements Comparable&lt;Student&gt; { private String name; private int rollNumber; public Student(String name, int rollNumber) { this.name = name; this.rollNumber = rollNumber; } public String getName() { return name; } public int getRollNumber() { return rollNumber; } @Override public int compareTo(Student other) { return this.rollNumber - other.rollNumber; } @Override public String toString() { return \"Student [name=\" + name + \", rollNumber=\" + rollNumber + \"]\"; } } public class TreeSetExample { public static void main(String[] args) { Set&lt;Student&gt; studentSet = new TreeSet&lt;&gt;(); studentSet.add(new Student(\"Alice\", 1)); studentSet.add(new Student(\"Bob\", 2)); studentSet.add(new Student(\"Charlie\", 3)); studentSet.add(new Student(\"David\", 4)); studentSet.add(new Student(\"Emily\", 5)); System.out.println(\"Students in ascending order of roll number:\"); for (Student student : studentSet) { System.out.println(student); } } } . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/3-List%20Set/",
    "relUrl": "/docs/Java/Interview/3-List%20Set/"
  },"12": {
    "doc": "Hazelcast with Database",
    "title": "Hazelcast with Database",
    "content": "Here’s an example of a Spring Boot application that uses Hazelcast for distributed caching and PostgreSQL as the database: . pom.xml . &lt;dependencies&gt; &lt;!-- Spring Boot dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Hazelcast dependencies --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- PostgreSQL dependency --&gt; &lt;dependency&gt; &lt;groupId&gt;org.postgresql&lt;/groupId&gt; &lt;artifactId&gt;postgresql&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . application.properties . # Hazelcast configuration hazelcast.config=classpath:hazelcast.xml # PostgreSQL configuration spring.datasource.url=jdbc:postgresql://localhost:5432/mydatabase spring.datasource.username=dbuser spring.datasource.password=dbpassword spring.jpa.database-platform=org.hibernate.dialect.PostgreSQLDialect spring.jpa.hibernate.ddl-auto=update . Create a hazelcast.xml file in the src/main/resources directory to define the Hazelcast configuration: . &lt;hazelcast xsi:schemaLocation=\"http://www.hazelcast.com/schema/config hazelcast-config-3.12.xsd\" xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;group&gt; &lt;name&gt;myHazelcastCluster&lt;/name&gt; &lt;password&gt;myHazelcastPassword&lt;/password&gt; &lt;/group&gt; &lt;network&gt; &lt;port auto-increment=\"true\"&gt;5701&lt;/port&gt; &lt;join&gt; &lt;multicast enabled=\"false\"/&gt; &lt;tcp-ip enabled=\"true\"&gt; &lt;member&gt;localhost&lt;/member&gt; &lt;/tcp-ip&gt; &lt;/join&gt; &lt;/network&gt; &lt;map name=\"myCache\"&gt; &lt;time-to-live-seconds&gt;3600&lt;/time-to-live-seconds&gt; &lt;max-idle-seconds&gt;1800&lt;/max-idle-seconds&gt; &lt;eviction-policy&gt;LRU&lt;/eviction-policy&gt; &lt;max-size policy=\"PER_NODE\"&gt;10000&lt;/max-size&gt; &lt;/map&gt; &lt;/hazelcast&gt; . User.java . import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; private String email; // Getters and setters // ... } . UserRepository.java . import org.springframework.data.jpa.repository.JpaRepository; public interface UserRepository extends JpaRepository&lt;User, Long&gt; { // Add custom query methods if needed void deleteById(Long id); } . UserService.java . import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.List; @Service public class UserService { @Autowired private UserRepository userRepository; @Cacheable(\"myCache\") public List&lt;User&gt; getAllUsers() { return userRepository.findAll(); } @CacheEvict(value = \"myCache\", key = \"#id\") public void deleteUser(Long id) { userRepository.deleteById(id); } } . UserController.java . import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\"/users\") public class UserController { @Autowired private UserService userService; @DeleteMapping(\"/{id}\") public void deleteUser(@PathVariable Long id) { userService.deleteUser(id); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/3-hazelcast-with-db/",
    "relUrl": "/docs/SpringBoot/Hazelcast/3-hazelcast-with-db/"
  },"13": {
    "doc": "Kafka Producer",
    "title": "Kafka Producer",
    "content": "Kafka producer example . build.gradle . plugins { id 'java' id 'org.springframework.boot' version '3.1.1' id 'io.spring.dependency-management' version '1.1.0' } group = 'com.example' version = '0.0.1-SNAPSHOT' java { sourceCompatibility = '17' } repositories { mavenCentral() } dependencies { implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.springframework.kafka:spring-kafka' testImplementation 'org.springframework.boot:spring-boot-starter-test' testImplementation 'org.springframework.kafka:spring-kafka-test' } tasks.named('test') { useJUnitPlatform() } . KafkaProducerApplication.java . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class KafkaProducerApplication { public static void main(String[] args) { SpringApplication.run(KafkaProducerApplication.class, args); } } . KafkaConfig.java . import org.apache.kafka.clients.admin.AdminClient; import org.apache.kafka.clients.admin.AdminClientConfig; import org.apache.kafka.clients.admin.NewTopic; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.core.KafkaAdmin; import java.util.HashMap; import java.util.Map; @Configuration public class KafkaConfig { private final String bootstrapAddress = \"localhost:9092\"; @Bean public KafkaAdmin kafkaAdmin() { Map&lt;String, Object&gt; configs = new HashMap&lt;&gt;(); configs.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapAddress); return new KafkaAdmin(configs); } @Bean public AdminClient adminClient() { return AdminClient.create(kafkaAdmin().getConfigurationProperties()); } @Bean public NewTopic topic() { return new NewTopic(\"example-topic\", 3, (short) 1); } } . KafkaProducerService.java . import org.springframework.beans.factory.annotation.Autowired; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.stereotype.Service; @Service public class KafkaProducerService { private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; private final String topicName = \"example-topic\"; @Autowired public KafkaProducerService(KafkaTemplate&lt;String, String&gt; kafkaTemplate) { this.kafkaTemplate = kafkaTemplate; } public void sendMessage(String message, int partition) { kafkaTemplate.send(topicName, partition, null, message); System.out.println(\"Published message: \" + message + \" to partition: \" + partition); } public void sendMessage(String key, int partition, String message) { kafkaTemplate.send(topicName, partition, key, message); System.out.println(\"Published message: \" + message + \" to partition: \" + partition +\" key: \"+key); } } . KafkaProducerController.java . import com.example.kafka.producer.KafkaProducerService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class KafkaProducerController { private final KafkaProducerService kafkaProducerService; @Autowired public KafkaProducerController(KafkaProducerService kafkaProducerService) { this.kafkaProducerService = kafkaProducerService; } @PostMapping(\"/publish\") public void publishMessage(@RequestBody String message, @RequestParam(defaultValue = \"0\") int partition) { kafkaProducerService.sendMessage(message, partition); } @PostMapping(\"/publish-key\") public void publishMessage1(@RequestParam String key, @RequestParam(defaultValue = \"0\") int partition, @RequestBody String message) { kafkaProducerService.sendMessage(key, partition ,message); } } . Example in Spring Reactor . pom.xml . &lt;dependencies&gt; &lt;!-- Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Kafka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Reactor Kafka --&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor.kafka&lt;/groupId&gt; &lt;artifactId&gt;reactor-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . KafkaProducerService.java . import org.apache.kafka.clients.producer.ProducerRecord; import org.apache.kafka.clients.producer.RecordMetadata; import org.apache.kafka.common.serialization.StringSerializer; import org.springframework.kafka.core.DefaultKafkaProducerFactory; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.support.KafkaHeaders; import org.springframework.kafka.support.SendResult; import org.springframework.messaging.support.GenericMessage; import org.springframework.stereotype.Service; import org.springframework.util.concurrent.ListenableFuture; import reactor.core.publisher.Mono; import reactor.core.publisher.MonoSink; import javax.annotation.PostConstruct; import java.util.HashMap; import java.util.Map; @Service public class KafkaProducerService { private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; public KafkaProducerService(KafkaTemplate&lt;String, String&gt; kafkaTemplate) { this.kafkaTemplate = kafkaTemplate; } public Mono&lt;RecordMetadata&gt; sendMessage(String topic, String key, String value) { ProducerRecord&lt;String, String&gt; record = new ProducerRecord&lt;&gt;(topic, key, value); GenericMessage&lt;ProducerRecord&lt;String, String&gt;&gt; message = new GenericMessage&lt;&gt;(record); message.getHeaders().add(KafkaHeaders.MESSAGE_KEY, key); return Mono.create(sink -&gt; { ListenableFuture&lt;SendResult&lt;String, String&gt;&gt; future = kafkaTemplate.send(message); future.addCallback(result -&gt; { RecordMetadata metadata = result.getRecordMetadata(); sink.success(metadata); }, ex -&gt; sink.error(ex)); }); } @PostConstruct private void configureSerializer() { Map&lt;String, Object&gt; configs = new HashMap&lt;&gt;(); configs.put(\"key.serializer\", StringSerializer.class); configs.put(\"value.serializer\", StringSerializer.class); ((DefaultKafkaProducerFactory&lt;?, ?&gt;) kafkaTemplate.getProducerFactory()).setConfigurationProperties(configs); } } . In this example, we define a KafkaProducerService class that handles sending messages to Kafka. The sendMessage method takes a topic, key, and value, and creates a ProducerRecord and a GenericMessage similar to the previous example. We use Mono.create to create a custom Mono, which allows us to bridge between the reactive and callback-based world. Inside this custom Mono, we use kafkaTemplate.send to send the message asynchronously. We add a success and error callback to handle the result of the send operation. If successful, we retrieve the RecordMetadata and call sink.success(metadata) to emit it. If there’s an error, we call sink.error(ex) to emit the error. The @PostConstruct method configureSerializer sets the serializer properties for the Kafka producer factory used by the KafkaTemplate. In this example, we’re using StringSerializer for both the key and value serializers. KafkaProducerController.java . import org.apache.kafka.clients.producer.RecordMetadata; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class KafkaProducerController { private final KafkaProducerService producerService; public KafkaProducerController(KafkaProducerService producerService) { this.producerService = producerService; } @PostMapping(\"/messages\") public Mono&lt;RecordMetadata&gt; sendMessage(@RequestBody MessageRequest request) { return producerService.sendMessage(request.getTopic(), request.getKey(), request.getValue()); } } . MessageRequest.java . public class MessageRequest { private String topic; private String key; private String value; // Getters and setters // Constructors } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/3-kafka-producer/",
    "relUrl": "/docs/SpringBoot/Kafka/3-kafka-producer/"
  },"14": {
    "doc": "SpringBoot",
    "title": "Scopes in springBoot",
    "content": "In Spring Boot, scopes define the lifecycle and visibility of beans managed by the Spring container. Spring Boot provides several standard scopes that control when and how beans are created, used, and destroyed. Here are the commonly used scopes in Spring Boot: . | Singleton: This is the default scope in Spring Boot. In singleton scope, a single instance of the bean is created for the entire application context. The same instance is shared and returned whenever the bean is requested. | Prototype: In prototype scope, a new instance of the bean is created each time it is requested. This means that every time you request the bean, you get a new instance. | Request: In request scope, a new instance of the bean is created for each HTTP request. The bean is bound to the lifecycle of the web request and is available only within that specific request. | Session: In session scope, a new instance of the bean is created for each user session. The bean is bound to the lifecycle of the user session and is available throughout the duration of the session. | Application: In application scope, a single instance of the bean is created for the entire web application. The bean is shared across multiple requests and sessions. | WebSocket: In WebSocket scope, a new instance of the bean is created for each WebSocket connection. The bean is bound to the lifecycle of the WebSocket connection and is available only within that specific connection. | . You can specify the scope of a bean using the @Scope annotation on the bean declaration in Spring Boot. For example: . import org.springframework.context.annotation.Scope; import org.springframework.stereotype.Component; @Component @Scope(\"prototype\") public class MyPrototypeBean { // Bean implementation } . In this example, the MyPrototypeBean is annotated with @Scope(“prototype”), indicating that it should be created in the prototype scope. It’s important to understand the implications of each scope and choose the appropriate scope for your beans based on their usage and requirements. Design pattern of SpringBoot . Spring Boot is a popular Java framework that simplifies the development of Java-based applications, especially web applications. It follows several design patterns to provide modular, scalable, and maintainable code. Here are some common design patterns used in Spring Boot: . | Dependency Injection (DI) and Inversion of Control (IoC): Spring Boot extensively utilizes the DI and IoC design patterns. These patterns enable loose coupling between components by removing the direct dependencies between them. Spring Boot’s IoC container (application context) manages the creation and wiring of objects, allowing you to inject dependencies through constructor injection, setter injection, or field injection. | MVC (Model-View-Controller): Spring Boot encourages the use of the MVC pattern for building web applications. The MVC pattern separates the application into three components: the model (data), the view (user interface), and the controller (logic). Spring Boot provides the Spring MVC module, which simplifies the implementation of the MVC pattern. | Repository Pattern: Spring Boot encourages the use of the Repository pattern to handle data access. The Repository pattern abstracts the data access layer and provides a consistent interface for performing CRUD (Create, Read, Update, Delete) operations on data entities. Spring Data JPA, a part of Spring Boot, provides a powerful implementation of the Repository pattern. | Singleton Pattern: Spring Boot’s IoC container manages objects as singletons by default. Singleton objects are created only once, and the container shares the same instance across multiple requests. This pattern helps in optimizing resource usage and improving performance. | Builder Pattern: Spring Boot utilizes the Builder pattern in various configurations and bean definitions. The Builder pattern provides a way to construct complex objects step by step, allowing you to define optional parameters and improve readability. | Template Method Pattern: Spring Boot’s JDBC template and JdbcTemplate classes follow the Template Method pattern. This pattern defines a skeleton algorithm in a base class and allows derived classes to provide specific implementation details. In the case of JdbcTemplate, the template methods provide a common structure for executing database operations, while the specific implementation is left to the derived classes. | Observer Pattern: Spring Boot’s event-driven programming model is based on the Observer pattern. The framework provides an event mechanism where components can publish events, and other components can subscribe to those events. This decoupled approach allows components to react to events without explicit dependencies. | . These are just a few examples of the design patterns used in Spring Boot. The framework incorporates various other patterns, such as Factory, Proxy, Decorator, and more, to provide a robust and flexible development experience. Spring Security . Spring Security is a powerful and widely-used security framework for Java applications. It provides comprehensive security services for securing your application, including authentication, authorization, session management, and various attack protections. To implement Spring Security in your application, you can follow these general steps: . Add Spring Security Dependency: Include the Spring Security dependency in your project’s build configuration. If you are using Maven, you can add the following dependency to your pom.xml file: . &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; . | Configure Spring Security: Create a configuration class that extends WebSecurityConfigurerAdapter and override its methods to configure security settings. You can define authentication providers, authorization rules, session management, and more. For example: | . @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/public/**\").permitAll() .antMatchers(\"/admin/**\").hasRole(\"ADMIN\") .anyRequest().authenticated() .and() .formLogin() .loginPage(\"/login\") .permitAll() .and() .logout() .permitAll(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .inMemoryAuthentication() .withUser(\"user\").password(\"{noop}password\").roles(\"USER\") .and() .withUser(\"admin\").password(\"{noop}password\").roles(\"ADMIN\"); } } . In this example, we configure the HTTP security rules, define a login page, specify which URLs require authentication or authorization, and provide in-memory user credentials. | Implement UserDetailsService (Optional): If you want to load user details from a database or other external sources, you can implement the UserDetailsService interface and override its loadUserByUsername() method. | Secure URLs: Annotate your controller methods with appropriate annotations to enforce security. For example, you can use @PreAuthorize or @Secured annotations to specify access restrictions based on user roles or permissions. | . To authorize user authentication using a database in Spring Security, you can follow these steps: . | Set up your Database: Configure your database and create a table to store user details, including usernames, passwords, and authorities/roles. You can use any database of your choice, such as MySQL, PostgreSQL, or H2. | Implement UserDetailsService: Create a class that implements the UserDetailsService interface provided by Spring Security. This interface is responsible for loading user details from the database. You need to override the loadUserByUsername() method to fetch user details based on the provided username. Within this method, query your database and retrieve the user details, including the password and authorities. Here’s an example using JPA and Hibernate: . | . @Service public class UserDetailsServiceImpl implements UserDetailsService { @Autowired private UserRepository userRepository; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user = userRepository.findByUsername(username) .orElseThrow(() -&gt; new UsernameNotFoundException(\"User not found\")); return new org.springframework.security.core.userdetails.User( user.getUsername(), user.getPassword(), getAuthorities(user.getRoles()) ); } private Collection&lt;? extends GrantedAuthority&gt; getAuthorities(Set&lt;Role&gt; roles) { return roles.stream() .map(role -&gt; new SimpleGrantedAuthority(role.getName())) .collect(Collectors.toList()); } } . In this example, UserRepository is a custom repository interface that interacts with your database to fetch user information. The getAuthorities() method converts the user’s roles into a collection of GrantedAuthority objects required by Spring Security. | Configure Authentication Provider: In your security configuration class, override the configure(AuthenticationManagerBuilder auth) method to configure the authentication provider. Use the userDetailsService() method to set your custom UserDetailsService implementation: | . @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(passwordEncoder()); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } // Other security configurations... } . In this example, we are using the BCryptPasswordEncoder as the password encoder, which is recommended for password storage. | Secure Endpoints: Use the @PreAuthorize or @Secured annotations on your controller methods to define access restrictions based on user roles or authorities. For example: | . @RestController public class MyController { @GetMapping(\"/admin\") @PreAuthorize(\"hasRole('ADMIN')\") public String adminEndpoint() { // Handle request for admin-only functionality } // Other endpoints... } . In this case, the /admin endpoint is accessible only to users with the “ADMIN” role. | Enable Global Method Security: In your security configuration class (annotated with @EnableWebSecurity), enable global method security by adding the @EnableGlobalMethodSecurity annotation. This allows you to use annotations such as @Secured for method-level security: | . @Configuration @EnableWebSecurity @EnableGlobalMethodSecurity(securedEnabled = true) public class SecurityConfig extends WebSecurityConfigurerAdapter { // Configuration details... } . | Use @Secured Annotation: Annotate your methods or endpoints with @Secured and specify the required roles in the annotation. For example: @RestController public class MyController { @GetMapping(\"/admin\") @Secured(\"ROLE_ADMIN\") public String adminEndpoint() { // Handle request for admin-only functionality return \"Admin Endpoint\"; } @GetMapping(\"/user\") @Secured({\"ROLE_USER\", \"ROLE_ADMIN\"}) public String userEndpoint() { // Handle request for user functionality return \"User Endpoint\"; } // Other endpoints... } . | . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/4-Springbot/#scopes-in-springboot",
    "relUrl": "/docs/Java/Interview/4-Springbot/#scopes-in-springboot"
  },"15": {
    "doc": "SpringBoot",
    "title": "SpringBoot",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/4-Springbot/",
    "relUrl": "/docs/Java/Interview/4-Springbot/"
  },"16": {
    "doc": "Hazelcast with Cloud",
    "title": "Hazelcast with Cloud",
    "content": "To use Hazelcast with Spring Boot in an AWS cloud environment . Create a hazelcast.xml file in the src/main/resources directory to configure Hazelcast: . &lt;hazelcast xsi:schemaLocation=\"http://www.hazelcast.com/schema/config hazelcast-config-3.12.xsd\" xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;network&gt; &lt;join&gt; &lt;tcp-ip enabled=\"false\"/&gt; &lt;multicast enabled=\"false\"/&gt; &lt;aws enabled=\"true\"&gt; &lt;access-key&gt;YOUR_AWS_ACCESS_KEY&lt;/access-key&gt; &lt;secret-key&gt;YOUR_AWS_SECRET_KEY&lt;/secret-key&gt; &lt;region&gt;YOUR_AWS_REGION&lt;/region&gt; &lt;/aws&gt; &lt;/join&gt; &lt;/network&gt; &lt;cache name=\"myCache\"&gt; &lt;max-size&gt;10000&lt;/max-size&gt; &lt;eviction size=\"10000\" max-size-policy=\"ENTRY_COUNT\" eviction-policy=\"LFU\"/&gt; &lt;time-to-live-seconds&gt;600&lt;/time-to-live-seconds&gt; &lt;/cache&gt; &lt;/hazelcast&gt; . To configure Hazelcast with GCP and Kubernetes, you can follow these steps: . | Set up a Kubernetes cluster on GCP: . | Log in to your GCP Console. | Navigate to the Kubernetes Engine service. | Create a new cluster with the desired configuration, selecting the appropriate machine types, number of nodes, and networking options. | Wait for the cluster to be created. | . | Deploy Hazelcast in the Kubernetes cluster: . | Create a Hazelcast deployment file, hazelcast.yaml, to define the Hazelcast deployment and service resources. Here’s an example: ```yaml apiVersion: apps/v1 kind: Deployment metadata: name: hazelcast labels: app: hazelcast spec: replicas: 3 selector: matchLabels: app: hazelcast template: metadata: labels: app: hazelcast spec: containers: . | name: hazelcast image: hazelcast/hazelcast:latest ports: . | containerPort: 5701 resources: limits: memory: 512Mi requests: memory: 256Mi — apiVersion: v1 kind: Service metadata: name: hazelcast-service labels: app: hazelcast spec: selector: app: hazelcast ports: | . | . | protocol: TCP port: 5701 targetPort: 5701 ``` This example deploys Hazelcast with three replicas and exposes port 5701 for communication. | . | This example deploys Hazelcast with three replicas and exposes port 5701 for communication. | Apply the Hazelcast deployment and service YAML files using the kubectl command: kubectl apply -f hazelcast.yaml . | . | Configure the Spring Boot application to connect to the Hazelcast cluster: . | Add the Hazelcast dependency to your pom.xml file: ```xml | . | . com.hazelcast hazelcast com.hazelcast hazelcast-kubernetes * Create a `hazelcast.yaml` file in the `src/main/resources` directory to configure the Hazelcast Kubernetes discovery: ```yml hazelcast: discovery: discovery-strategies: - class: com.hazelcast.kubernetes.HazelcastKubernetesDiscoveryStrategy properties: service-dns: hazelcast-service.default.svc.cluster.local service-dns-timeout: \"5\" service-name: hazelcast-service namespace: default . This configuration uses the HazelcastKubernetesDiscoveryStrategy to discover and connect to the Hazelcast cluster running in the Kubernetes environment. Adjust the service-name and namespace properties according to your Hazelcast service name and Kubernetes namespace. | Use Hazelcast caching in your Spring Boot application: | . | Annotate the methods that you want to cache with the @Cacheable annotation from the org.springframework.cache.annotation package. For example: ```java import org.springframework.cache.annotation.Cacheable; | . // … . @Cacheable(“myCache”) public List getAllUsers() { // Fetch users from your data source } ``` . | Deploy your Spring Boot application to the Kubernetes cluster: . | Build your Spring Boot application into a container image and push it to a container registry. | Deploy your application to the Kubernetes cluster, ensuring it has access to the Hazelcast cluster and the necessary configuration. | . | . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/4-hazelcast-with-cloud/",
    "relUrl": "/docs/SpringBoot/Hazelcast/4-hazelcast-with-cloud/"
  },"17": {
    "doc": "Kafka Consumer",
    "title": "How to avoid multiple consumers consuming the same message",
    "content": "To avoid multiple consumers consuming the same message, you can make use of partitions in Apache Kafka. Each topic in Kafka is divided into one or more partitions, and each message within a partition is assigned a unique offset. By default, Kafka assigns messages to partitions in a round-robin fashion, ensuring that each partition is consumed by only one consumer within a consumer group. This ensures that multiple consumers within the same group don’t process the same message. To implement this in your Spring Boot application, you need to configure the number of partitions for the topic and set the group.id property appropriately. Here’s an updated example: KafkaConsumerConfig.java . import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.common.serialization.StringDeserializer; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory; import org.springframework.kafka.core.DefaultKafkaConsumerFactory; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.core.consumer.KafkaConsumerFactory; import java.util.HashMap; import java.util.Map; @Configuration public class KafkaConsumerConfig { @Value(\"${spring.kafka.bootstrap-servers}\") private String bootstrapServers; @Value(\"${spring.kafka.consumer.group-id}\") private String groupId; @Value(\"${spring.kafka.consumer.concurrency}\") private int concurrency; @Bean public Map&lt;String, Object&gt; consumerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, 1); // Ensures each consumer gets only one record per poll return props; } @Bean public KafkaConsumerFactory&lt;String, String&gt; consumerFactory() { return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(concurrency); factory.getContainerProperties().setPollTimeout(3000); // Adjust the poll timeout as per your needs return factory; } } . In the above code, we’ve added a new property concurrency which represents the number of consumer instances within the same consumer group. This allows multiple consumers to process messages concurrently. KafkaConsumer.java . import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Component; @Component public class KafkaConsumer { @KafkaListener(topics = \"my-topic\", groupId = \"my-group\") public void consume(String message) { // Process the received message System.out.println(\"Received message: \" + message); } } . Ensure that you have created the topic with multiple partitions before running the application. You can do this using the Kafka command-line tools or programmatically using the Kafka Admin Client in your application. By configuring the appropriate number of partitions and consumer group, Kafka ensures that each message within a partition is consumed by only one consumer instance at a time. This way, you can avoid multiple consumers consuming the same message. Note: If you need strict ordering of messages, where each message is processed in the order it is received, you should use a single partition for the topic. Using multiple partitions allows for parallel processing but may not guarantee strict message ordering across partitions. consumer group.id . The consumer group.id in Apache Kafka is a property that identifies a group of consumers that work together to consume messages from one or more topics. Kafka uses this property to manage the distribution of messages across the consumers within the group. When multiple consumers belong to the same consumer group and subscribe to the same topic, Kafka ensures that each message is delivered to only one consumer within the group. This ensures load balancing and allows for parallel processing of messages. The group.id serves as an identifier for the consumer group and helps Kafka keep track of the progress of each consumer within the group. Kafka maintains the offset for each consumer, which represents the position of the last consumed message within each partition. By tracking the offsets, Kafka ensures that each consumer within the group continues from where it left off in case of failures or restarts. Here are some key points about the group.id property: . | Consumers with the same group.id belong to the same consumer group. | Each partition within a topic is consumed by only one consumer within the group at a time. | Kafka automatically balances the partitions across consumers in the group, ensuring that each consumer gets a roughly equal number of partitions to process. | If a consumer within the group fails or leaves the group, Kafka automatically reassigns its partitions to other active consumers in the group. | Each consumer group maintains its own set of offsets, allowing consumers to work independently and process messages at their own pace. | . By setting different group.id values for different consumer groups, you can have multiple independent groups consuming messages from the same or different topics. This allows for scalability and flexibility in distributing the workload across multiple consumer instances. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/4-kafka-consumer/#how-to-avoid-multiple-consumers-consuming-the-same-message",
    "relUrl": "/docs/SpringBoot/Kafka/4-kafka-consumer/#how-to-avoid-multiple-consumers-consuming-the-same-message"
  },"18": {
    "doc": "Kafka Consumer",
    "title": "Kafka Consumer",
    "content": "Kafka consumer using Spring Kafka(Listener based): . pom.xml . &lt;dependencies&gt; &lt;!-- Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Kafka --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-kafka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; . KafkaConsumerConfig.java . import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.common.serialization.StringDeserializer; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.kafka.annotation.EnableKafka; import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory; import org.springframework.kafka.core.DefaultKafkaConsumerFactory; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.core.consumer.KafkaConsumerFactory; import java.util.HashMap; import java.util.Map; @Configuration @EnableKafka public class KafkaConsumerConfig { private final String bootstrapServers = \"localhost:9092\"; private final String groupId = \"my-consumer-group\"; @Bean public Map&lt;String, Object&gt; consumerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; } @Bean public KafkaConsumerFactory&lt;String, String&gt; consumerFactory() { return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } @Bean public ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; kafkaListenerContainerFactory() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); return factory; } @Bean public KafkaTemplate&lt;String, String&gt; kafkaTemplate() { return new KafkaTemplate&lt;&gt;(consumerFactory()); } } . KafkaConsumerService.java . import org.springframework.kafka.annotation.KafkaListener; import org.springframework.stereotype.Service; @Service public class KafkaConsumerService { @KafkaListener(topics = \"my-topic\") public void consumeMessage(String message) { System.out.println(\"Received message: \" + message); // Process the received message } } . In this example, we define a KafkaConsumerService class that handles consuming messages from Kafka. We use the @KafkaListener annotation to specify the topic(s) to listen to. In this case, we listen to the \"my-topic\" topic. The consumeMessage method is the actual message consumer. It takes the received message as a parameter and performs any necessary processing. In this example, we simply print the received message to the console, but you can implement your own business logic. SpringBootKafkaConsumerApplication.java . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class SpringBootKafkaConsumerApplication { public static void main(String[] args) { SpringApplication.run(SpringBootKafkaConsumerApplication.class, args); } } . Kafka Consumer using poll based . KafkaConsumer.java . import org.apache.kafka.clients.consumer.Consumer; import org.apache.kafka.clients.consumer.ConsumerConfig; import org.apache.kafka.clients.consumer.ConsumerRecord; import org.apache.kafka.clients.consumer.ConsumerRecords; import org.apache.kafka.clients.consumer.KafkaConsumer; import org.apache.kafka.common.serialization.StringDeserializer; import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; import java.time.Duration; import java.util.Collections; import java.util.Properties; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; @Component public class KafkaConsumer { @Value(\"${kafka.bootstrap.servers}\") private String bootstrapServers; @Value(\"${kafka.consumer.group-id}\") private String groupId; @Value(\"${kafka.topic}\") private String topic; private ExecutorService executorService; private Consumer&lt;String, Object&gt; consumer; @PostConstruct public void initialize() { executorService = Executors.newFixedThreadPool(10); consumer = createConsumer(); consumer.subscribe(Collections.singletonList(topic)); executorService.submit(this::consumeMessages); } @PreDestroy public void shutdown() { consumer.wakeup(); executorService.shutdown(); } private Consumer&lt;String, Object&gt; createConsumer() { Properties props = new Properties(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.GROUP_ID_CONFIG, groupId); return new KafkaConsumer&lt;&gt;(props); } private void consumeMessages() { try { while (true) { ConsumerRecords&lt;String, Object&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, Object&gt; record : records) { executorService.submit(() -&gt; { // Process the consumed message String key = record.key(); Object value = record.value(); System.out.println(\"Received message: key = \" + key + \", value = \" + value); }); } } } catch (Exception e) { // Handle exception } finally { consumer.close(); } } } . In this updated version, the @KafkaListener annotation is removed, and the consumer.poll() method is used to poll for new messages. The initialize() method is annotated with @PostConstruct, which ensures that it is called after the bean is constructed. Inside this method, the Kafka consumer is created, subscribed to the topic, and a separate thread is started to consume messages using consumer.poll(). The shutdown() method, annotated with @PreDestroy, is called when the application is shutting down. It triggers the consumer.wakeup() method to interrupt the poll() loop and gracefully shutdown the consumer and executor service. Kafka consumer wakeup method . The wakeup method is used in Apache Kafka Consumer API to interrupt the consumer’s fetch loop and cause it to throw a WakeupException. This can be useful in situations where you want to shut down a consumer gracefully, without waiting for the poll loop to complete. For example, you may have a scenario where you want to stop consuming messages from a topic and perform some cleanup actions. You can call the wakeup method on the consumer instance in another thread, which will interrupt the poll method and allow you to perform your cleanup logic before closing the consumer. Here’s an example implementation: . class KafkaConsumerRunner { private final Consumer&lt;String, String&gt; consumer; private volatile boolean shutdown = false; public void runConsumer() { try { while (!shutdown) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); // process the records } } catch (WakeupException e) { if (!shutdown) { throw e; } } finally { consumer.close(); } } public void shutdown() { shutdown = true; consumer.wakeup(); } } . In this example, the runConsumer method polls for messages from a Kafka topic and processes them. The shutdown method sets the shutdown flag to true and calls wakeup on the consumer instance, which will interrupt the poll method and allow for clean shutdown of the consumer. consumerThreadPool.shutdown() is used to stop the execution of tasks in a thread pool. It stops accepting new tasks, but waits for the running tasks to complete. When all running tasks are completed, the thread pool is considered shut down. In your case, you would use this method to stop the thread pool that is executing the consumer’s polling loop. After that, you would call consumer.wakeup() to interrupt the polling loop and trigger a WakeupException, allowing you to perform any necessary cleanup logic before closing the consumer. Here’s an example implementation: . class KafkaConsumerRunner{ private final ExecutorService consumerThreadPool; private final Consumer&lt;String, String&gt; consumer; private volatile boolean shutdown = false; public void runConsumer() { try { while (!shutdown) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); // process the records } } catch (WakeupException e) { if (!shutdown) { throw e; } } finally { consumer.close(); } } public void shutdown() { shutdown = true; consumer.wakeup(); consumerThreadPool.shutdown(); } } . In this example, the shutdown method sets the shutdown flag to true and calls consumerThreadPool.shutdown() to stop the consumer’s thread pool, and then calls consumer.wakeup() to interrupt the poll method and trigger a WakeupException. This allows you to perform any necessary cleanup logic before closing the consumer. Implement multiple listener . In Spring Boot, you can implement multiple listeners for Kafka by creating multiple methods and annotating them with @KafkaListener. Each method should have a unique topic and group id. For example: . @KafkaListener(topics = \"topic1\", groupId = \"group1\") public void listenTopic1(String message) { // handle message for topic1 } @KafkaListener(topics = \"topic2\", groupId = \"group2\") public void listenTopic2(String message) { // handle message for topic2 } . You can also configure multiple listeners by creating multiple Kafka listener container factories and configuring them with different group ids and concurrency. @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory1() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); factory.getContainerProperties().setPollTimeout(3000); return factory; } . You can then annotate your listener methods with the appropriate container factory bean. @KafkaListener(topics = \"topic1\", containerFactory = \"kafkaListenerContainerFactory1\") public void listenTopic1(String message) { // handle message for topic1 } . Here’s a sample example in Spring Boot to implement multiple listeners for Kafka: . @SpringBootApplication public class KafkaMultipleListenersExample { @Value(\"${kafka.bootstrap-servers}\") private String bootstrapServers; public static void main(String[] args) { SpringApplication.run(KafkaMultipleListenersExample.class, args); } @Bean public Map&lt;String, Object&gt; consumerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; } @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory() { return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory1() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); return factory; } @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory2() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(2); return factory; } @KafkaListener(topics = \"topic1\", containerFactory = \"kafkaListenerContainerFactory1\") public void listenTopic1(String message) { System.out.println(\"Received message from topic1: \" + message); } @KafkaListener(topics = \"topic2\", containerFactory = \"kafkaListenerContainerFactory2\") public void listenTopic2(String message) { System.out.println(\"Received message from topic2: \" + message); } } . In this example, we have two listener methods listenTopic1 and listenTopic2 each for a different topic. Each of these methods is annotated with @KafkaListener and configured to use a different Kafka listener container factory kafkaListenerContainerFactory1 and kafkaListenerContainerFactory2 respectively. These container factories are created and configured using the kafkaListenerContainerFactory1 and kafkaListenerContainerFactory2 methods. In Spring Boot, the Kafka consumer is automatically managed by the framework, so you do not need to explicitly shut it down when the application stops. When the application context is closed, for example, when the application is shut down or restarted, the consumer is automatically closed and all its resources are cleaned up. However, if you need to manually shut down the consumer in a controlled manner, you can use the KafkaListenerEndpointRegistry to get a reference to the listener container and stop it. Here’s an example: . @Autowired private KafkaListenerEndpointRegistry kafkaListenerEndpointRegistry; ... @PreDestroy public void stopKafkaConsumer() { kafkaListenerEndpointRegistry.stop(); } . In this example, the stopKafkaConsumer method annotated with @PreDestroy is called when the application is shut down, and it stops the Kafka consumer using the KafkaListenerEndpointRegistry. Difference between kafka poll and kafka listener . The difference between using the Kafka consumer poll method and the Kafka listener in Spring Boot is in the way that messages are consumed from a Kafka topic. Kafka Consumer Poll: . The poll method is a low-level API that allows you to manually poll for messages from a Kafka topic. You have to manage the consumer offsets and handle the consumer rebalance events yourself. You also have to handle threading, batching, and error handling yourself. Example: . public void pollKafka() { Consumer&lt;String, String&gt; consumer = createConsumer(); while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) { System.out.println(\"Received message: \" + record.value()); } } } . Kafka Listener: . The Kafka listener in Spring Boot provides a higher-level abstraction on top of the poll method. The listener automatically manages the consumer offsets and handles the consumer rebalance events for you. The framework also provides built-in support for batch processing, error handling, and concurrency control. Example: . @KafkaListener(topics = \"topic\") public void listen(String message) { System.out.println(\"Received message: \" + message); } . In general, the Kafka listener is easier to use and provides more features compared to the poll method, making it the preferred choice for most use cases in a Spring Boot application. Note1 . The poll mechanism in Kafka is a low-level API that allows you to manually poll for messages from a Kafka topic. You have to manage the consumer offsets, handle the consumer rebalance events, handle threading, batching, and error handling yourself. Here are some use cases where using the poll mechanism might be appropriate: . | Custom processing logic: When you need to implement custom processing logic that is not supported by the Kafka listener, you might choose to use the poll mechanism. For example, if you need to process messages in a specific order, you might use the poll method to implement the custom logic. | Real-time streaming: When you need to process messages in real-time, you might choose to use the poll mechanism. This allows you to have full control over the polling frequency and the processing of messages. | Legacy applications: If you have an existing application that uses the poll mechanism, you might continue to use it instead of switching to the Kafka listener. | Performance optimization: If you have specific performance requirements and need to fine-tune the polling frequency and batch size, you might choose to use the poll mechanism. | . In general, the poll mechanism is more complex and requires more manual work compared to the Kafka listener, but it offers more control and flexibility over the consumption of messages from a Kafka topic . Note 2 . Spring Framework managed Kafka listener is best suited for simple to moderate data processing and can handle the load with its automatic partition assignment and offset management. On the other hand, the Kafka Consumer API with manual poll approach provides more control and customization over the consumption process, making it suitable for more complex and large scale data processing scenarios. Ultimately, the choice between these two approaches should be based on the specific requirements of your use case and the trade-off between ease of use and customization. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/4-kafka-consumer/",
    "relUrl": "/docs/SpringBoot/Kafka/4-kafka-consumer/"
  },"19": {
    "doc": "Kafka Broker",
    "title": "Kafka Broker",
    "content": "Kafka replications . To create Kafka replications, you need to configure a Kafka cluster with multiple broker instances. Replication in Kafka provides fault tolerance and high availability by maintaining multiple copies of each partition across different brokers. Here’s a step-by-step guide to creating Kafka replications: . | Set up a Kafka Cluster: Install and configure Apache Kafka on multiple servers or virtual machines. Each server will run a Kafka broker. Ensure that all servers have network connectivity and can communicate with each other. | Configure Kafka Properties: Open the Kafka configuration file (server.properties) on each broker. You can find this file in the Kafka installation directory. Modify the following properties: . | broker.id: Assign a unique identifier to each broker in the cluster. | listeners: Set the network listeners to allow communication between brokers. It should include the hostname/IP and the port (e.g., PLAINTEXT://localhost:9092). | log.dirs: Specify the directory where Kafka stores its data and logs. Each broker should have a separate directory. | num.partitions: Set the number of partitions for each topic. Replication is performed at the partition level. | . | Configure Replication Properties: To enable replication, modify the following properties in the server.properties file: . | default.replication.factor: Set the desired replication factor for topics that don’t have a specific replication factor assigned. This value should be greater than 1. | min.insync.replicas: Specify the minimum number of replicas that must be in sync for a producer to consider a message as successfully written. | . | Start Kafka Brokers: Start the Kafka brokers on each server using the kafka-server-start command, pointing to the corresponding server.properties file. Run this command on each broker. | Create Topics: Use the Kafka command-line tool (kafka-topics.sh or kafka-topics.bat) to create topics with the desired replication factor. For example, to create a topic named \"mytopic\" with a replication factor of 3 and 8 partitions, run the following command: kafka-topics.sh --create --topic mytopic --partitions 8 --replication-factor 3 --bootstrap-server localhost:9092 . | Verify Replication: Use the Kafka command-line tool to describe the topic and verify that the replication factor is correctly set. Run the following command: kafka-topics.sh --describe --topic mytopic --bootstrap-server localhost:9092 . The output should show the replication factor and the list of replicas for each partition. | . With these steps, you have successfully created a Kafka cluster with replications. Kafka will automatically handle data replication and synchronization across the brokers, ensuring fault tolerance and high availability. Kafka replications using Docker . To create Kafka replications using Docker, you can follow these steps: . | Install Docker: Install Docker on your machine by following the official Docker documentation for your operating system. | Create a Docker Network: Create a Docker network to allow communication between Kafka and ZooKeeper containers. Run the following command to create a bridge network: docker network create kafka-network . | Create a ZooKeeper Container: Kafka relies on ZooKeeper for coordination. Run the following command to create a ZooKeeper container: docker run -d --name zookeeper --network kafka-network -p 2181:2181 -p 2888:2888 -p 3888:3888 zookeeper . | Create Kafka Broker Containers: Create multiple Kafka broker containers, each representing a broker in the Kafka cluster. Run the following command to create a Kafka container: docker run -d --name kafka1 --network kafka-network -p 9092:9092 -e KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 -e KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka1:9092 -e KAFKA_BROKER_ID=1 -e KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=3 confluentinc/cp-kafka . Repeat the above command, incrementing the broker ID (KAFKA_BROKER_ID) and container name (--name) for each additional Kafka broker. | Create Kafka Topics: Use the Kafka container to create topics with the desired replication factor. Run the following command to create a topic named “mytopic” with a replication factor of 3 and 8 partitions: docker exec -it kafka1 kafka-topics --create --topic mytopic --partitions 8 --replication-factor 3 --bootstrap-server kafka1:9092 . Replace kafka1 with the appropriate container name or hostname for your Kafka broker. | Verify Replication: Use the Kafka container to describe the topic and verify the replication factor. Run the following command: docker exec -it kafka1 kafka-topics --describe --topic mytopic --bootstrap-server kafka1:9092 . The output should display the replication factor and the list of replicas for each partition. | . By following these steps, you will have a Kafka cluster with replications running in Docker containers. The containers will be connected to each other through the Docker network, and you can interact with the cluster using the provided container names or hostnames. Kafka broker in the AWS . Designing a production-ready Kafka broker in the AWS cloud involves considering several aspects for scalability, reliability, and high availability. Here’s a recommended design for a Kafka broker in AWS: . | Kafka Cluster Deployment: . | Use Amazon EC2 instances to host Kafka brokers. EC2 provides scalable compute capacity. | Deploy Kafka brokers across multiple Availability Zones (AZs) within an AWS region to ensure fault tolerance. | Choose EC2 instance types based on your workload requirements (e.g., CPU, memory, storage). | Auto Scaling: Set up Auto Scaling groups to automatically add or remove Kafka broker instances based on the workload. | . | Networking and Security: . | Create a Virtual Private Cloud (VPC) to isolate your Kafka cluster. | Use private subnets for Kafka brokers and place them within the selected AZs. | Configure security groups to control inbound and outbound traffic to Kafka brokers (e.g., allow traffic from specific IP ranges, ports). | Enable VPC flow logs to monitor network traffic. | Use AWS Identity and Access Management (IAM) roles to manage access and permissions for your Kafka brokers. | . | Storage: . | Use Amazon Elastic Block Store (EBS) volumes to provide durable block-level storage for Kafka broker data. | Select the appropriate storage type (e.g., General Purpose SSD, Provisioned IOPS) based on your performance requirements. | Consider using EBS snapshots for regular backups and disaster recovery purposes. | . | Data Replication and Availability: . | Configure Kafka replication to maintain multiple copies of each partition across different brokers. | Set a suitable replication factor (e.g., 3) to ensure fault tolerance. | Use Kafka’s internal replication mechanisms (e.g., leader and follower replicas) for data synchronization. | . | Monitoring and Observability: . | Utilize Amazon CloudWatch for monitoring Kafka broker metrics, such as CPU utilization, disk usage, and network traffic. | Enable enhanced monitoring to collect more granular metrics. | Set up CloudWatch Alarms to alert on critical metrics or anomalies. | Integrate with AWS CloudTrail for auditing and tracking API calls. | Consider using additional monitoring tools like Prometheus or Grafana for advanced monitoring and visualization. | . | Backups and Disaster Recovery: . | Regularly back up Kafka data by taking snapshots of EBS volumes or using other suitable backup solutions. | Enable cross-region replication for disaster recovery purposes by replicating Kafka data to another AWS region. | Establish a disaster recovery plan and perform periodic drills to ensure its effectiveness. | . | Integration with Other AWS Services: . | Integrate with AWS Identity and Access Management (IAM) for fine-grained access control and authentication. | Use Amazon CloudWatch Logs for centralized log management and analysis. | Consider integrating with AWS Lambda for event-driven processing or data transformations. | Leverage AWS CloudFormation or AWS Elastic Beanstalk for infrastructure provisioning and management. | . | . Kafka broker in Kubernetes . To achieve a similar design for a Kafka broker in Kubernetes, you can follow these steps: . | Set up Kubernetes Cluster: . | Create a Kubernetes cluster using a managed Kubernetes service like Amazon Elastic Kubernetes Service (EKS), Google Kubernetes Engine (GKE), or Azure Kubernetes Service (AKS). | Configure the cluster with the desired number of worker nodes based on your workload requirements. | . | Deploy Kafka Brokers: . | Create a Kafka deployment in Kubernetes, specifying the desired number of replicas for the Kafka brokers. | Define a Kubernetes StatefulSet to ensure stable network identities for each Kafka broker instance. | Configure the Kafka deployment with appropriate resource limits (CPU, memory) based on your workload requirements. | Use a persistent volume or persistent volume claim (PVC) to provide durable storage for Kafka data. | . | Networking and Security: . | Define Kubernetes Services to expose Kafka brokers internally within the cluster or externally to the outside world. | Utilize Kubernetes Ingress resources or load balancers to provide external access to Kafka brokers. | Configure network policies to control inbound and outbound traffic to the Kafka brokers. | Utilize Kubernetes Secrets or external secret management systems to securely manage Kafka credentials and configuration. | . | Data Replication and Availability: . | Configure Kafka replication within the Kubernetes StatefulSet to maintain multiple replicas of each Kafka broker. | Set a suitable replication factor to ensure fault tolerance and data availability. | Utilize Kafka’s built-in replication mechanisms (e.g., leader and follower replicas) for data synchronization. | . | Monitoring and Observability: . | Deploy Kubernetes monitoring solutions such as Prometheus and Grafana for collecting and visualizing Kafka broker metrics. | Utilize Kubernetes native monitoring tools like Kubernetes Dashboard or custom Kubernetes metrics APIs. | Integrate Kafka broker logs with a centralized logging solution like Elasticsearch, Fluentd, and Kibana (EFK) stack or the ELK stack. | Configure Kubernetes probes (liveness and readiness) to monitor the health of Kafka brokers. | . | Backups and Disaster Recovery: . | Implement backup and restore mechanisms for Kafka data within Kubernetes. | Utilize volume snapshots or external backup tools to regularly back up Kafka data. | Consider implementing disaster recovery strategies by replicating Kafka data across different Kubernetes clusters or regions. | . | Scaling and Updates: . | Utilize Kubernetes Horizontal Pod Autoscaling (HPA) to automatically scale the Kafka deployment based on defined metrics (e.g., CPU utilization, message throughput). | Implement rolling updates or canary deployments to ensure seamless upgrades of Kafka brokers without affecting data availability. | . | Integration with Other Kubernetes Services: . | Integrate with Kubernetes Service Mesh frameworks like Istio or Linkerd for advanced traffic management, security, and observability. | Utilize Kubernetes RBAC (Role-Based Access Control) for fine-grained access control to Kafka resources. | Integrate with Kubernetes-native message queuing systems like Apache Pulsar or RabbitMQ for enhanced messaging capabilities. | . | . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/5-Kafka-broker/",
    "relUrl": "/docs/SpringBoot/Kafka/5-Kafka-broker/"
  },"20": {
    "doc": "Annotations in Hazelcast",
    "title": "Annotations in Hazelcast",
    "content": ". | In Spring Boot with Hazelcast, you can use annotations to configure and customize the behavior of Hazelcast within your application. Here are some of the commonly used annotations in Spring Boot with Hazelcast: | . | @EnableCaching: This annotation is used to enable caching support in your Spring Boot application. It allows you to cache method results, thereby improving performance. Hazelcast can be configured as the caching provider using this annotation. | @EnableHazelcastHttpSession: This annotation enables Hazelcast as the provider for distributed HTTP sessions in your Spring Boot application. It automatically configures Hazelcast’s HttpSession integration, allowing session data to be stored in a distributed manner. | @EnableHazelcastRepositories: This annotation is used to enable Hazelcast as the backend for Spring Data repositories. It scans the specified package(s) for repository interfaces and creates implementations backed by Hazelcast. | @EnableHazelcastCluster: This annotation is used to enable Hazelcast clustering support in your Spring Boot application. It sets up a Hazelcast cluster by creating and configuring a Hazelcast instance based on the provided configuration. | @HazelcastInstance: This annotation is used to inject the Hazelcast instance into your Spring Bean. You can use it on a field, setter method, or constructor to automatically inject the Hazelcast instance configured for your application. | @HazelcastAware: This annotation is used to inject Hazelcast-specific objects into your Spring Bean. It can be used to inject Hazelcast IMap, IQueue, ILock, ITopic, and other Hazelcast data structures or components into your application beans. | @HazelcastPartitionedMap: This annotation is used to create a Hazelcast Partitioned Map. Partitioned maps can provide high-performance and scalable data storage for large datasets. | . These are just a few examples of the annotations used in Spring Boot with Hazelcast. The specific annotations you’ll use may depend on your requirements and the functionality you want to achieve with Hazelcast in your application. Here’s an example of using the @EnableHazelcastHttpSession annotation in a Spring Boot application: . pom.xml . &lt;!-- Spring Session with Hazelcast --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession; import org.springframework.session.data.hazelcast.config.annotation.web.http.EnableHazelcastHttpSession; @SpringBootApplication @EnableHazelcastHttpSession(maxInactiveIntervalInSeconds = 180) // Set session expiration time to 180 seconds (3 minutes) public class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } } . In the above example, the maxInactiveIntervalInSeconds attribute of the @EnableHazelcastHttpSession annotation is set to 180, which means that the session will be invalidated if there is no activity for 3 minutes. When a session is invalidated due to expiration or when the user manually logs out, Hazelcast will automatically remove the corresponding session data from the distributed session store. Additionally, you can manually remove session data using Spring Session’s SessionRepository interface. Here’s an example: . import org.springframework.beans.factory.annotation.Autowired; import org.springframework.session.Session; import org.springframework.session.SessionRepository; import org.springframework.web.bind.annotation.DeleteMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class SessionController { @Autowired private SessionRepository&lt;? extends Session&gt; sessionRepository; @DeleteMapping(\"/sessions/{sessionId}\") public void deleteSession(@PathVariable String sessionId) { sessionRepository.deleteById(sessionId); } } . Here’s an example of using the @EnableHazelcastRepositories annotation in a Spring Boot application: . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.data.hazelcast.repository.config.EnableHazelcastRepositories; @SpringBootApplication @EnableHazelcastRepositories(basePackages = \"com.example.repository\") // Enable Hazelcast as the backend for Spring Data repositories public class MyApp { public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } } . In the above example, the @EnableHazelcastRepositories annotation is used to enable Hazelcast as the backend for Spring Data repositories. It specifies the basePackages attribute, which defines the package(s) where your repository interfaces are located. pom.xml . &lt;!-- Spring Data with Hazelcast --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . import org.springframework.data.repository.CrudRepository; public interface UserRepository extends CrudRepository&lt;User, Long&gt; { // Custom query methods and repository operations } . In this example, the UserRepository interface extends CrudRepository from Spring Data, allowing you to perform CRUD (Create, Read, Update, Delete) operations on the User entity. Spring Data will handle the implementation details, leveraging Hazelcast as the storage backend for these repositories. You can then inject and use the repository in your services or controllers to interact with the underlying data store. import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; // Getters and setters } . import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; @RestController @RequestMapping(\"/users\") public class UserController { @Autowired private UserRepository userRepository; @PostMapping public User createUser(@RequestBody User user) { return userRepository.save(user); } @GetMapping(\"/{id}\") public User getUserById(@PathVariable Long id) { return userRepository.findById(id) .orElseThrow(() -&gt; new NotFoundException(\"User not found with id: \" + id)); } // Other CRUD operations and custom queries } . Here’s a complete example of using the @EnableHazelcastCluster annotation in a Spring Boot application to enable Hazelcast clustering: . pom.xml . &lt;!-- Hazelcast --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . Next, create a Hazelcast configuration file named hazelcast.xml in the src/main/resources directory with the desired configuration. For example: . &lt;hazelcast xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-4.2.xsd\"&gt; &lt;network&gt; &lt;join&gt; &lt;multicast enabled=\"false\"/&gt; &lt;tcp-ip enabled=\"true\"&gt; &lt;member&gt;127.0.0.1&lt;/member&gt; &lt;!-- Replace with actual IP addresses of cluster members --&gt; &lt;/tcp-ip&gt; &lt;/join&gt; &lt;/network&gt; &lt;/hazelcast&gt; . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; import com.hazelcast.config.Config; import com.hazelcast.config.FileSystemXmlConfig; @SpringBootApplication @EnableCaching @EnableHazelcastCluster public class MyApp { public static void main(String[] args) { Config config = new FileSystemXmlConfig(\"src/main/resources/hazelcast.xml\"); SpringApplication.run(MyApp.class, args); } } . In this example, the @EnableHazelcastCluster annotation enables Hazelcast clustering in the Spring Boot application. The Config object is created using the hazelcast.xml configuration file. Note that in a real-world scenario, you may need to adjust the network configuration in the hazelcast.xml file based on your deployment environment. Replace the element with the actual IP addresses or hostnames of the cluster members. Now you can use Hazelcast features, such as caching and distributed data structures, in your application. You can also leverage Spring’s caching annotations (@Cacheable, @CachePut, etc.) along with Hazelcast to cache method results. Here’s a complete example of using the @HazelcastInstance annotation in a Spring Boot application to inject the Hazelcast instance: . pom.xml . &lt;!-- Hazelcast --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . import com.hazelcast.core.IMap; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import com.hazelcast.core.HazelcastInstance; @SpringBootApplication public class MyApp { @Autowired private HazelcastInstance hazelcastInstance; public static void main(String[] args) { SpringApplication.run(MyApp.class, args); } public void useHazelcastInstance() { IMap&lt;String, Integer&gt; map = hazelcastInstance.getMap(\"my-distributed-map\"); map.put(\"key\", 42); Integer value = map.get(\"key\"); System.out.println(\"Value: \" + value); } } . @HazelcastAware and @HazelcastPartitionedMap . The @HazelcastAware and @HazelcastPartitionedMap annotations are not built-in annotations provided by Spring Boot or Hazelcast. However, I can provide you with an example of a custom implementation of these annotations using Hazelcast in a Spring Boot application. import org.springframework.beans.factory.annotation.Autowired; import java.lang.annotation.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) @Autowired public @interface HazelcastAware { } . import java.lang.annotation.*; @Target(ElementType.FIELD) @Retention(RetentionPolicy.RUNTIME) public @interface HazelcastPartitionedMap { String name() default \"\"; } . import com.hazelcast.core.HazelcastInstance; import com.hazelcast.core.IMap; import org.springframework.beans.factory.annotation.Autowired; public class MyService { @HazelcastAware private HazelcastInstance hazelcastInstance; @HazelcastPartitionedMap(name = \"myPartitionedMap\") private IMap&lt;String, String&gt; partitionedMap; // Use the injected Hazelcast objects in your application // ... } . import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.ConfigurableApplicationContext; @SpringBootApplication public class MyApp { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(MyApp.class, args); MyService myService = context.getBean(MyService.class); // Use the myService instance } } . Note: Since the @HazelcastAware and @HazelcastPartitionedMap annotations are custom annotations, you would need to handle the logic for injecting the Hazelcast objects and managing partitioned maps manually, potentially using Hazelcast’s APIs and configurations within the custom annotations. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/5-hazelcast-annotations/",
    "relUrl": "/docs/SpringBoot/Hazelcast/5-hazelcast-annotations/"
  },"21": {
    "doc": "Thread",
    "title": "Thread in Java",
    "content": "In Java, a thread is a lightweight unit of execution that allows concurrent execution of code within a program. It represents a single sequential flow of control within a program. Threads in Java are created by either extending the Thread class or implementing the Runnable interface. Here are the two approaches: . 1. Extending the Thread class: . | Create a new class that extends the Thread class. | Override the run()` method in the new class to define the code that will run concurrently. | Create an instance of the new class. | Call the start() method on the instance to start the execution of the thread. | . Example: . public class MyThread extends Thread { public void run() { // Code to be executed concurrently } } // Creating and starting a new thread MyThread thread = new MyThread(); thread.start(); . | Implementing the Runnable interface: | . | Create a new class that implements the Runnable interface. | Implement the run() method defined by the Runnable interface with the code that will run concurrently. | Create an instance of the new class. | Create a new Thread instance, passing the instance of the class implementing Runnable as a parameter to the Thread constructor. | Call the start() method on the Thread instance to start the execution of the thread. | . Example: . public class MyRunnable implements Runnable { public void run() { // Code to be executed concurrently } } // Creating and starting a new thread MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); . Both approaches allow you to execute code concurrently within your program. Using threads can be beneficial when you want to perform tasks simultaneously or handle tasks that may block, such as network operations or time-consuming computations, without blocking the main execution flow of the program. Certainly! Here’s a complete example that demonstrates creating and running a thread using both approaches: . Approach 1: Extending the Thread class . public class MyThread extends Thread { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.println(\"Thread: \" + i); try { Thread.sleep(500); // Sleep for 500 milliseconds } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { MyThread thread = new MyThread(); thread.start(); for (int i = 1; i &lt;= 5; i++) { System.out.println(\"Main Thread: \" + i); try { Thread.sleep(500); // Sleep for 500 milliseconds } catch (InterruptedException e) { e.printStackTrace(); } } } } . Approach 2: Implementing the Runnable interface . public class MyRunnable implements Runnable { public void run() { for (int i = 1; i &lt;= 5; i++) { System.out.println(\"Thread: \" + i); try { Thread.sleep(500); // Sleep for 500 milliseconds } catch (InterruptedException e) { e.printStackTrace(); } } } public static void main(String[] args) { MyRunnable myRunnable = new MyRunnable(); Thread thread = new Thread(myRunnable); thread.start(); for (int i = 1; i &lt;= 5; i++) { System.out.println(\"Main Thread: \" + i); try { Thread.sleep(500); // Sleep for 500 milliseconds } catch (InterruptedException e) { e.printStackTrace(); } } } } . Differences . The main difference between using the Thread class and implementing the Runnable interface lies in the class hierarchy and flexibility. Using the Thread class: . | By extending the Thread class, your class becomes a subclass of Thread, and you can directly override the run() method to define the code that will run concurrently. | This approach is suitable when your class needs to have additional thread-related functionality or when you want to customize the behavior of the Thread class itself. | However, it limits your class’s ability to extend other classes since Java does not support multiple inheritance. If your class already extends another class, using the Runnable interface is a more flexible option. | . Implementing the Runnable interface: . | By implementing the Runnable interface, your class can still define the code that will run concurrently by implementing the run() method, but it does not become a thread itself. | This approach is suitable when you want your class to be more flexible and share the same instance with multiple threads or reuse the same instance with different Thread objects. | It allows your class to extend another class or implement other interfaces, providing more flexibility and avoiding the limitation of single inheritance. | Additionally, using the Runnable interface separates the task (the run() method) from the thread (the Thread instance), promoting a separation of concerns. | . Here are some use cases for each approach: . Using the Thread class: . | You want to customize or extend the functionality of the Thread class itself. | You have a specific need for thread-related methods or properties provided by the Thread class. | You don’t need to extend any other class or can work around the limitation of single inheritance. | . Using the Runnable interface: . | You want your class to be more flexible and reusable by implementing multiple interfaces or extending another class. | You want to separate the task logic from the thread logic to promote a separation of concerns. | You want to share the same task implementation among multiple threads or reuse the same task implementation with different Thread objects. | . In general, using the Runnable interface is often recommended due to its flexibility and better support for object-oriented design principles. It allows for better code organization and reuse, especially when dealing with complex systems or multi-threaded applications. — . In Java, a thread is an independent unit of execution, and it does not have a return value like a regular method. Once a thread starts executing, it continues until the run() method completes or an uncaught exception is thrown. However, there are a few ways to obtain a result or communicate information from a thread to the rest of the program: . | Instance Variables: You can define instance variables within the class that extends Thread or implements Runnable and use them to store the result or any other information you need. Other parts of the program can access these variables after the thread has completed its execution. | Shared Data Structures: You can use shared data structures, such as ArrayList, Queue, or Map, to exchange data between threads. Synchronization mechanisms, like locks or concurrent collections, can be used to ensure thread-safe access to these shared data structures. | Callbacks or Listener Interfaces: You can define callback methods or listener interfaces that are invoked by the thread when it completes its execution or reaches a specific state. Other parts of the program can register callbacks or listeners and receive the result or relevant information when the thread finishes. | CompletableFuture (Java 8+): The CompletableFuture class provides a powerful mechanism to handle asynchronous computations and obtain results from them. It allows you to chain multiple operations, handle exceptions, and wait for the completion of the computation. | . Here’s a simplified example using CompletableFuture to demonstrate how you can obtain a result from a thread: . import java.util.concurrent.*; public class MyThread implements Callable&lt;String&gt; { public String call() { // Perform some computation String result = \"Thread execution completed\"; return result; } public static void main(String[] args) throws InterruptedException, ExecutionException { ExecutorService executor = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = executor.submit(new MyThread()); // Perform other tasks while the thread is executing String result = future.get(); // Blocks until the thread completes and returns the result System.out.println(result); executor.shutdown(); } } . In this example, the MyThread class implements the Callable interface and overrides the call() method, which performs some computation and returns a result. The ExecutorService is used to submit the task as a Callable and obtain a Future object. The get() method is then called on the Future object to retrieve the result. Interprocess communication (IPC) . In Java, interprocess communication (IPC) can be achieved using various mechanisms. Here are a few commonly used methods for IPC in Java: . Socket Programming: . | TCP/IP or UDP sockets can be used to establish communication between processes running on different machines or on the same machine. | The java.net package provides classes like Socket and ServerSocket for TCP/IP communication, and DatagramSocket and DatagramPacket for UDP communication. | Sockets allow bidirectional communication by exchanging data through input and output streams. | . Java RMI (Remote Method Invocation): . | Java RMI enables communication between processes running on different JVMs (Java Virtual Machines). | It allows you to invoke methods on remote objects as if they were local objects. | RMI uses Java interfaces and the java.rmi package to define remote objects and their methods. | . Java Messaging Service (JMS): . | JMS is a Java API for asynchronous messaging between applications. | It provides a way for different processes to exchange messages through message queues or topics. | JMS implementations, like Apache ActiveMQ or RabbitMQ, can be used for messaging between Java processes. | . Shared Memory: . | Shared memory allows processes to communicate by accessing shared regions of memory. | In Java, you can use the java.nio package to create shared memory regions and use byte buffers to read and write data. | Libraries like Java Native Access (JNA) or Java Native Interface (JNI) can be used to interact with native code and access shared memory. | . File-Based Communication: . | Processes can communicate by reading and writing to shared files. | One process writes data to a file, and the other process periodically checks the file for new data. | Proper synchronization mechanisms, like locks or signaling, should be used to ensure data integrity and avoid conflicts. | . Remote Procedure Calls (RPC): . | RPC allows processes to call procedures or functions on remote systems. | Libraries like Apache Thrift or gRPC provide RPC frameworks that support communication between different programming languages. | These are some of the common methods for interprocess communication in Java. The choice of method depends on factors such as the nature of communication, the network environment, the desired level of abstraction, and the specific requirements of the application. | . How to communicate between threads . In Java, there are several ways to communicate between threads. Here are some common mechanisms: . Shared Objects: . | Threads can communicate by accessing and modifying shared objects in memory. | The shared objects can be regular objects or data structures like ArrayList, Queue, or Map. | Proper synchronization mechanisms, such as locks or synchronized blocks, should be used to ensure thread-safe access to shared objects and prevent data races or inconsistencies. | . Wait and Notify: . | The wait() and notify() methods provided by the Object class can be used for thread synchronization and communication. | Threads can wait for a condition using the wait() method, and other threads can notify them when the condition is met using the notify() or notifyAll() methods. | This mechanism allows threads to coordinate and communicate by signaling each other. | . Blocking Queues: . | Java’s BlockingQueue interface and its implementations, like ArrayBlockingQueue or LinkedBlockingQueue, provide a thread-safe way to pass data between threads. | One thread can put an item into the queue using the put() or offer() methods, and another thread can take items from the queue using the take() or poll() methods. | Blocking queues handle the synchronization and blocking operations internally, making it easier to implement producer-consumer scenarios or thread pools. | . CountDownLatch and CyclicBarrier: . | The CountDownLatch and CyclicBarrier classes from the java.util.concurrent package can be used for synchronization and coordination between threads. | A CountDownLatch allows one or more threads to wait until a specified number of operations or events complete. | A CyclicBarrier allows a set of threads to wait until all threads reach a barrier point before continuing. | . Thread Signaling: . | Threads can use shared boolean flags or variables to signal each other. | One thread can set a flag or update a variable, and other threads can check the flag or variable periodically to respond accordingly. | Care should be taken to ensure proper synchronization and visibility of shared variables to avoid race conditions or stale data. | These are some of the common mechanisms for thread communication in Java. The choice of mechanism depends on the specific requirements of the application and the type of communication needed between the threads. It’s important to ensure proper synchronization and thread safety to avoid data inconsistencies and race conditions. | . Difference between Callable and Runnable . In Java, both Callable and Runnable are interfaces that are commonly used to define tasks or actions that can be executed concurrently. The main difference between them lies in the return value and the ability to throw exceptions. Here are the key distinctions: . | Return Value: | . | Runnable does not have a return value. The run() method in the Runnable interface has a void return type, meaning it does not return a value. | Callable defines a call() method that returns a value. The call() method has a generic return type () and returns an object of that type. | . | Exception Throwing: | . | Runnable cannot throw checked exceptions directly. The run() method of Runnable does not declare any checked exceptions. | Callable can throw checked exceptions. The call() method of Callable can declare checked exceptions that need to be handled or propagated. | . | Usage with Executors: | . | Runnable is commonly used with the Executor framework (ExecutorService, ThreadPoolExecutor) to submit tasks for execution. | Callable is also used with the Executor framework, but it is specifically designed for returning a value or throwing exceptions. It is often used when you need to execute a task and obtain a result. | . Here’s a simple code example to illustrate the usage of Runnable and Callable: . import java.util.concurrent.*; public class RunnableVsCallable { public static void main(String[] args) throws InterruptedException, ExecutionException { Runnable runnableTask = () -&gt; { System.out.println(\"Runnable task executed\"); }; Callable&lt;String&gt; callableTask = () -&gt; { System.out.println(\"Callable task executed\"); return \"Callable result\"; }; ExecutorService executor = Executors.newSingleThreadExecutor(); // Execute the Runnable task executor.execute(runnableTask); // Execute the Callable task and obtain the result Future&lt;String&gt; future = executor.submit(callableTask); String result = future.get(); System.out.println(\"Callable result: \" + result); executor.shutdown(); } } . Executors and ExecutorService . In Java, the Executors class and ExecutorService interface are part of the concurrency utility framework, which provides a higher-level abstraction for managing and executing concurrent tasks. They simplify the process of creating and managing threads in a concurrent application. Executors: . | The Executors class provides factory methods for creating different types of ExecutorService instances. | It offers static methods to create thread pools with fixed or variable numbers of threads, single-threaded executors, or cached thread pools. | Thread pools created by the Executors class manage the execution of tasks and provide features like thread reuse, scheduling, and task queuing. | . ExecutorService: . | The ExecutorService interface extends the Executor interface and provides additional functionality. | It represents an asynchronous execution service that manages the execution of tasks submitted via the execute() or submit() methods. | The ExecutorService provides methods to submit tasks, control their execution, and obtain Future objects for monitoring task progress and obtaining results. | It also provides methods for shutting down the executor gracefully, allowing running tasks to complete while rejecting new tasks. | . Here’s an example that demonstrates the usage of Executors and ExecutorService to execute tasks concurrently: . import java.util.concurrent.*; public class ExecutorExample { public static void main(String[] args) { ExecutorService executorService = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 5; i++) { Runnable task = () -&gt; { String threadName = Thread.currentThread().getName(); System.out.println(\"Task executed by \" + threadName); }; executorService.execute(task); } executorService.shutdown(); } } . In this example, a fixed thread pool with three threads is created using Executors.newFixedThreadPool(3). Five tasks, defined as Runnable instances, are submitted to the executor service using the execute() method. The executor service manages the execution of these tasks concurrently among the available threads in the thread pool. Finally, the shutdown() method is called to gracefully shut down the executor service. Using ExecutorService instead of managing threads manually provides benefits such as thread reuse, thread pool management, and task scheduling. It abstracts away the complexities of managing threads, improves code organization, and helps in building scalable and efficient concurrent applications. CompletableFuture . CompletableFuture is a class introduced in Java 8 as part of the java.util.concurrent package. It represents a promise or future result of an asynchronous computation. It provides a powerful and flexible way to handle asynchronous tasks and their results. Here are some key features and functionalities of CompletableFuture: . Asynchronous Execution: . | CompletableFuture supports asynchronous execution of tasks. | Tasks can be executed asynchronously using methods like runAsync() and supplyAsync(). | Asynchronous tasks are executed in separate threads, allowing the calling thread to continue with other operations. | . Chaining and Composition: . | CompletableFuture supports chaining and composition of multiple tasks. | Tasks can be combined using methods like thenApply(), thenAccept(), and thenCompose(). | Chained tasks can depend on the result of previous tasks, allowing for complex workflows and dependencies. | . Exception Handling: . | CompletableFuture provides mechanisms for handling exceptions that occur during task execution. | Exceptions can be handled using methods like exceptionally() and handle(). | Exceptional results can be propagated through the chain of CompletableFuture instances. | . Waiting for Completion and Obtaining Results: . | CompletableFuture allows you to wait for the completion of asynchronous tasks and obtain their results. | You can use methods like get() or join() to block and wait for the result. | CompletableFuture also supports timeouts and cancellation of tasks. | . Combining Multiple Results: . | CompletableFuture provides methods for combining the results of multiple tasks. | You can use methods like thenCombine(), thenAcceptBoth(), or allOf() to combine and process results from multiple CompletableFuture instances. | . Integration with Concurrency Framework: . | CompletableFuture integrates well with other components of the concurrency framework, such as ExecutorService. | You can specify an executor for executing the asynchronous tasks using methods like runAsync() and supplyAsync(). | Here’s a simplified example that demonstrates the usage of CompletableFuture: . | . import java.util.concurrent.*; public class CompletableFutureExample { public static void main(String[] args) throws InterruptedException, ExecutionException { CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; \"Hello\") .thenApplyAsync(result -&gt; result + \" World\") .thenApplyAsync(String::toUpperCase); String finalResult = future.get(); System.out.println(finalResult); } } . In this example, a CompletableFuture is created using the supplyAsync() method, which asynchronously executes a task that supplies the initial string “Hello”. Then, two transformations (thenApplyAsync()) are chained to the future, where the string is appended with “ World” and converted to uppercase. Finally, the result is obtained using the get() method. CompletableFuture provides many more methods and functionalities, allowing you to handle complex asynchronous tasks and their results with ease. It is a powerful tool for writing concurrent and asynchronous code in Java. ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/5-thread/#thread-in-java",
    "relUrl": "/docs/Java/Interview/5-thread/#thread-in-java"
  },"22": {
    "doc": "Thread",
    "title": "Thread",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/5-thread/",
    "relUrl": "/docs/Java/Interview/5-thread/"
  },"23": {
    "doc": "Cache Annotations in Hazelcast",
    "title": "Cache Annotations in Hazelcast",
    "content": "Here are the annotations provided by Hazelcast for handling caching: . | @Cacheable: This annotation is used to indicate that a method’s result should be cached. When a method annotated with @Cacheable is invoked, Hazelcast checks if the cache already contains the requested data. If it does, the cached result is returned instead of executing the method. | @CachePut: This annotation is used to update the cache with the result of a method invocation. When a method annotated with @CachePut is invoked, Hazelcast updates the cache with the method’s return value, regardless of whether the cache already contains an entry for the given key. | @CacheEvict: This annotation is used to remove entries from the cache. When a method annotated with @CacheEvict is invoked, Hazelcast removes the corresponding entry from the cache. This annotation supports various options for cache eviction, such as evicting a specific entry, all entries in a cache, or entries based on certain conditions. | @Caching: This annotation is used to apply multiple cache-related annotations to a single method. With @Caching, you can combine multiple caching annotations like @Cacheable, @CachePut, and @CacheEvict to define complex caching behavior for a method. | . Here’s an example that demonstrates the usage of Hazelcast caching annotations in a Spring Boot application with MongoDB as the data store. pom.xml . &lt;!-- Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Data MongoDB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Hazelcast Integration --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . @SpringBootApplication @EnableCaching public class HazelcastCacheExampleApplication { public static void main(String[] args) { SpringApplication.run(HazelcastCacheExampleApplication.class, args); } } . @Document(collection = \"persons\") public class Person { @Id private String id; private String name; private int age; // Constructors, getters, setters } . public interface PersonRepository extends MongoRepository&lt;Person, String&gt; { @Cacheable(\"persons\") Person findByName(String name); @CachePut(value = \"persons\", key = \"#person.name\") Person save(Person person); @CacheEvict(value = \"persons\", allEntries = true) void deleteAll(); } . In the repository interface, we have used the Hazelcast caching annotations: . | @Cacheable: Caches the result of the findByName method based on the name parameter. | @CachePut: Updates the cache with the saved Person object. The cache key is derived from the name property of the Person object. | @CacheEvict: Clears the entire cache when the deleteAll method is invoked. | . @Service public class PersonService { private final PersonRepository personRepository; public PersonService(PersonRepository personRepository) { this.personRepository = personRepository; } public Person findPersonByName(String name) { return personRepository.findByName(name); } public Person savePerson(Person person) { return personRepository.save(person); } public void deleteAllPersons() { personRepository.deleteAll(); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/6-hazelcast-cache-annotations/",
    "relUrl": "/docs/SpringBoot/Hazelcast/6-hazelcast-cache-annotations/"
  },"24": {
    "doc": "Java 8",
    "title": "Java 8",
    "content": "Java 8, released in March 2014, introduced several significant features and enhancements to the Java programming language. Some of the main features of Java 8 include: . | Lambda Expressions: Lambda expressions allow you to write more concise and expressive code. They enable the functional programming style by treating functions as first-class citizens. With lambda expressions, you can pass behavior as arguments to methods or assign them to variables. They greatly simplify writing code using functional interfaces, such as Predicate, Consumer, and Function. | Stream API: The Stream API provides a new abstraction for working with sequences of elements. Streams allow you to process collections of data in a functional and declarative manner. You can perform various operations, such as filtering, mapping, and reducing, on streams. Streams are designed to be efficient and can leverage parallel processing to take advantage of multiple cores. | Default Methods: Default methods allow you to add new methods to existing interfaces without breaking the implementations of classes that implement those interfaces. This feature was introduced to support backward compatibility with existing code while allowing interfaces to evolve. | Functional Interfaces: Java 8 introduced the @FunctionalInterface annotation, which indicates that an interface is intended to be used as a functional interface. A functional interface is an interface that has a single abstract method and can be used with lambda expressions. The java.util.function package provides a set of predefined functional interfaces, such as Predicate, Consumer, and Function. | Method References: Method references allow you to refer to a method without executing it. They provide a shorthand syntax for lambda expressions and make the code more readable. Method references can be used when the lambda expression only calls an existing method, without any additional logic. | Optional: The Optional class provides a container object that may or may not contain a non-null value. It encourages a more explicit and null-safe coding style by forcing developers to handle the possibility of null values explicitly. It helps avoid NullPointerExceptions and makes code more robust. | Date/Time API: Java 8 introduced a new date and time API in the java.time package, which provides improved support for date and time manipulation. The new API is more intuitive, thread-safe, and offers better functionality for working with dates, times, intervals, and time zones. | . These are some of the main features introduced in Java 8. They brought significant improvements to the language, making it more expressive, efficient, and flexible. Lambda Expression . A lambda expression in Java is a concise way to represent an anonymous function—a function that doesn’t have a name and can be treated as a value. It allows you to pass behavior as an argument to methods or assign it to variables. Lambda expressions enable functional programming and can be used in various use cases where you need to work with functional interfaces. Here’s an example of a lambda expression: . List&lt;String&gt; names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); // Using lambda expression to sort the names in ascending order Collections.sort(names, (name1, name2) -&gt; name1.compareTo(name2)); // Printing the sorted names names.forEach(System.out::println); . Lambda expressions have several use cases: . | Functional Interfaces: Lambda expressions are commonly used with functional interfaces, which are interfaces that have a single abstract method. They allow you to pass behavior as an argument to methods that expect functional interfaces. | Collection Processing: Lambda expressions work well with the Stream API introduced in Java 8. You can use lambda expressions to perform operations like filtering, mapping, and reducing on collections in a concise and declarative way. | Event Handling: Lambda expressions can be used for event handling in graphical user interfaces (GUIs) or other event-driven applications. Instead of implementing a separate class for each event handler, you can use lambda expressions to define the behavior directly. | Multithreading: Lambda expressions can be utilized to simplify multithreading code by expressing parallelizable tasks as functional interfaces. | . Overall, lambda expressions provide a more expressive and concise way to write code, especially when working with functional interfaces and performing operations on collections or dealing with event-driven programming. Stream API . The Stream API in Java 8 provides a powerful set of functions for processing sequences of elements in a functional and declarative way. It offers several use cases and advantages, including: . | Collection Operations: The Stream API allows you to perform various operations on collections, such as filtering, mapping, sorting, and reducing. For example: | . List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // Example 1: Filtering even numbers List&lt;Integer&gt; evenNumbers = numbers.stream() .filter(n -&gt; n % 2 == 0) .collect(Collectors.toList()); // Example 2: Doubling the numbers List&lt;Integer&gt; doubledNumbers = numbers.stream() .map(n -&gt; n * 2) .collect(Collectors.toList()); // Example 3: Summing all numbers int sum = numbers.stream() .reduce(0, Integer::sum); . In these examples, the Stream API allows you to easily filter elements, transform them, and perform aggregations on the collection. | Parallel Processing: The Stream API supports parallel processing, which means that operations can be executed concurrently on multiple threads. This can significantly improve performance when dealing with large datasets. You can use the parallel() method to convert a sequential stream to a parallel stream. | . List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); int sum = numbers.parallelStream() .reduce(0, Integer::sum); . In this example, the parallelStream() method is used to convert the stream to a parallel stream, and the reduction operation is performed concurrently. | Lazy Evaluation: The Stream API uses lazy evaluation, which means that intermediate operations are only executed when required. This allows for efficient processing, especially when dealing with large datasets or infinite streams. Intermediate operations such as filter() and map() are not evaluated until a terminal operation, like collect() or forEach(), is called. | . List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); // Example: Printing only the first three even numbers numbers.stream() .filter(n -&gt; n % 2 == 0) .limit(3) .forEach(System.out::println); . In this example, the filter() and limit() operations are only evaluated for the first three even numbers encountered. | Code Readability and Conciseness: The Stream API provides a more expressive and concise way to write code for collection processing. It allows you to chain multiple operations together, making the code more readable and reducing the need for intermediate variables. ```java List names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\"); | . // Example: Printing names in uppercase names.stream() .map(String::toUpperCase) .forEach(System.out::println); . In this example, the `map()` operation is used to transform each name to uppercase before printing it. The Stream API offers many more operations and functionalities, such as grouping, partitioning, flat-mapping, and more. It simplifies collection processing, promotes a functional programming style, and provides performance benefits through parallel processing and lazy evaluation. # The Optional class The `Optional` class in Java is part of the java.util package and was introduced in Java 8. It is used to represent an optional value, which can be either present or absent. The main purpose of Optional is to avoid `NullPointerException` by explicitly indicating the possibility of a value being absent. Here's an example to illustrate the use of `Optional`: ```java import java.util.Optional; public class OptionalExample { public static void main(String[] args) { String name = \"John Doe\"; Optional&lt;String&gt; optionalName = Optional.of(name); // Checking if the value is present if (optionalName.isPresent()) { System.out.println(\"Name is present: \" + optionalName.get()); } else { System.out.println(\"Name is absent\"); } // Performing an action if the value is present optionalName.ifPresent(n -&gt; System.out.println(\"Hello, \" + n)); // Using a default value if the value is absent String defaultValue = \"Guest\"; String result = optionalName.orElse(defaultValue); System.out.println(\"Result: \" + result); // Transforming the value with a mapping function String transformed = optionalName.map(n -&gt; \"Mr. \" + n).orElse(defaultValue); System.out.println(\"Transformed: \" + transformed); // Using a supplier to provide a default value if the value is absent String supplied = optionalName.orElseGet(() -&gt; \"Unknown\"); System.out.println(\"Supplied: \" + supplied); // Throwing an exception if the value is absent String value = optionalName.orElseThrow(() -&gt; new IllegalArgumentException(\"Name is required\")); } } . In this example, an Optional&lt;String&gt; named optionalName is created with the value “John Doe” using Optional.of(name). | The isPresent() method is used to check if the value is present, and get() retrieves the value if it is present. | The ifPresent() method allows performing an action if the value is present. | The orElse() method returns a default value if the value is absent. | The map() method transforms the value using a mapping function. | The orElseGet() method provides a default value using a supplier if the value is absent. | The orElseThrow() method throws an exception if the value is absent. | By using Optional, you can handle cases where a value might be absent and design your code accordingly. It encourages explicit handling of nullable values and provides a more expressive and safer way to work with potentially absent values, reducing the chances of NullPointerExceptions. | . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/6-java8/",
    "relUrl": "/docs/Java/Interview/6-java8/"
  },"25": {
    "doc": "Kafka Miscellaneous",
    "title": "Kafka Miscellaneous",
    "content": "Maximum size of the message does Kafka server can receive? . In Apache Kafka, the maximum size of a message that the server can receive is determined by the max.message.bytes configuration property. This property specifies the maximum size, in bytes, of a Kafka message that can be accepted by the broker. The default value of max.message.bytes is set to 1,048,576 bytes (1 MB). However, you can modify this value in the Kafka broker configuration (server.properties) to accommodate larger message sizes if needed. To change the maximum message size, follow these steps: . | Locate the server.properties file, typically found in the Kafka installation directory. | Open server.properties in a text editor. | Search for the max.message.bytes property. If it doesn’t exist, you can add it. | Modify the value to the desired maximum message size. For example, to set the maximum size to 10 MB, use the following configuration: max.message.bytes=10485760 . Note: The value is in bytes. | Save the server.properties file. | Restart the Kafka broker for the changes to take effect. | . Keep in mind that increasing the maximum message size impacts the memory requirements of the Kafka broker. Larger messages consume more memory, so ensure that your broker instances have sufficient resources to handle the expected message sizes. Additionally, consider the network bandwidth and client configurations to accommodate larger message payloads. Explain what is Zookeeper in Kafka? Can we use Kafka without Zookeeper? . ZooKeeper is a centralized coordination service that plays a critical role in the operation and coordination of Apache Kafka. It is used for maintaining configuration information, coordinating distributed processes, and providing a reliable and highly available infrastructure for Kafka. In Kafka, ZooKeeper performs the following key functions: . | Cluster Coordination: ZooKeeper keeps track of the status of Kafka brokers, topics, partitions, and consumer groups. It maintains a distributed and replicated data store that acts as the source of truth for the Kafka cluster’s metadata. | Leader Election: ZooKeeper facilitates the election of a leader for each partition in Kafka. The leader is responsible for handling read and write requests for a particular partition while followers replicate the data. | Topic Configuration: ZooKeeper stores the configuration details for Kafka topics, including the number of partitions, replication factor, and topic-specific settings. | Consumer Group Coordination: ZooKeeper helps manage consumer groups in Kafka. It keeps track of the offset (position) of each consumer group in the topic partitions and enables rebalancing of consumers when new consumers join or existing ones leave. | Failover and Recovery: ZooKeeper enables fault tolerance and high availability in Kafka. It tracks the liveness of Kafka brokers and can initiate leader re-elections when a broker fails or becomes unreachable. | . Kafka’s dependency on ZooKeeper is inherent in its design, at least until version 2.8.0. However, starting from Kafka 2.8.0, there is an ongoing effort to remove the dependency on ZooKeeper and introduce a new internal metadata management system called the Kafka Raft Metadata Mode. This mode eliminates the need for an external ZooKeeper cluster for managing Kafka’s metadata. While Kafka’s integration with ZooKeeper is currently essential, it’s important to note that future versions of Kafka are expected to provide the option to run without an external ZooKeeper dependency. In summary, as of the current versions, ZooKeeper is an integral part of Apache Kafka, responsible for cluster coordination, leader election, configuration management, and consumer group coordination. However, upcoming versions of Kafka are moving towards eliminating the need for an external ZooKeeper cluster. Explain how you can improve the throughput of a remote consumer? . To improve the throughput of a remote consumer in Kafka, you can consider the following strategies: . | Increase Consumer Parallelism: One way to improve throughput is by increasing the number of consumer instances running in parallel. By adding more consumer instances, you can distribute the workload across multiple threads or processes, allowing for concurrent processing of Kafka messages. This approach can increase the overall consumption rate and throughput. | Optimize Consumer Configuration: . | Adjust fetch.min.bytes and fetch.max.bytes: Configure the fetch.min.bytes and fetch.max.bytes properties to optimize the amount of data fetched in each request. Increasing these values can reduce the number of round trips required to fetch messages, improving overall throughput. | Tune fetch.max.wait.ms: Set an optimal value for fetch.max.wait.ms to control the maximum time the consumer waits for more messages to arrive before returning a response. A shorter wait time can increase responsiveness and throughput. | Optimize max.partition.fetch.bytes: Adjust the max.partition.fetch.bytes property to increase the maximum amount of data fetched from each partition in a single request. This can minimize the number of requests needed to fetch messages, improving efficiency. | . | Increase Consumer Batch Size: Adjust the max.poll.records property to increase the maximum number of records fetched in each consumer poll. A larger batch size allows for more efficient processing and can improve throughput. | Enable Compression: If the network bandwidth is a bottleneck, enable compression for the consumer. By compressing the data during transmission, you can reduce the amount of network traffic, leading to improved throughput. | Optimize Network and Latency: . | Reduce Network Round-Trips: Minimize network round-trips by ensuring the consumer is close to the Kafka brokers and reducing network latency. Consider deploying consumers closer to the Kafka cluster or use low-latency network connections. | Optimize Network Buffer Sizes: Adjust the network buffer sizes (socket.send.buffer.bytes and socket.receive.buffer.bytes) to match the expected message sizes and network conditions. Properly tuned buffer sizes can minimize latency and improve throughput. | . | Utilize Consumer Groups: Use multiple consumer groups to parallelize the processing of messages. Each consumer group operates independently and can consume messages from different partitions, distributing the workload and increasing throughput. | Monitor and Fine-Tune: . | Monitor Consumer Lag: Track consumer lag, which indicates the time lag between the production and consumption of messages. High consumer lag can indicate a bottleneck that needs to be addressed. | Monitor Resource Utilization: Keep an eye on the CPU, memory, and network utilization of the consumer instances. If any resource is underutilized or overloaded, adjust the consumer configuration or scale up the resources accordingly. | . | . It’s important to note that the effectiveness of these strategies may vary based on your specific application requirements, Kafka cluster setup, and network conditions. Conduct performance tests and experiments to identify the most effective optimizations for your use case and monitor the impact of changes on the overall throughput. Explain how you can get exactly once messaging from Kafka during data production? . Ensuring exactly once messaging semantics in Kafka during data production involves a combination of configuration settings and proper application design. Kafka provides a feature called “Idempotent Producer” that helps achieve exactly once semantics. Here’s an overview of the steps involved: . | Enable Idempotent Producer: . | When creating a Kafka producer, set the enable.idempotence property to true in the producer’s configuration. This property ensures that the producer sends messages in an idempotent manner, eliminating duplicate messages caused by retries or network issues. | . | Set Message Key: . | Assign a unique and deterministic key to each message being produced. Kafka uses the message key for partitioning and deduplication purposes. | . | Configure Acknowledgments: . | Set the acks property to all in the producer’s configuration. This setting ensures that the producer receives acknowledgment from all replicas of the partition before considering a message as successfully written. This helps prevent message loss in case of leader failures. | . | Handle Retry and Errors: . | Implement appropriate error handling and retry mechanisms in your application. Handle transient errors and exceptions gracefully to avoid producing duplicate messages unintentionally. | . | Handle Producer Failures: . | In the event of a producer failure or crash, ensure that the producer resumes producing from the last committed offset by maintaining the necessary metadata and tracking the produced messages. | . | Configure Transactions (Optional): . | If you require atomicity and consistency guarantees across multiple partitions or topics, you can use Kafka transactions. By configuring a Kafka producer with transactional support, you can ensure that messages produced as part of a single transaction are either all successfully written or none of them are. | To use transactions, set the transactional.id property in the producer’s configuration and follow the Kafka transactional API guidelines for initializing and committing transactions. | . | . By enabling the Idempotent Producer, setting message keys, configuring acknowledgments, handling retries and errors, and optionally using Kafka transactions, you can achieve exactly once messaging semantics during data production in Kafka. However, it’s important to note that exactly once semantics in Kafka applies to data production only, and consuming applications need to handle deduplication and idempotence on their end to ensure exactly once semantics during data consumption. SprigBoot Example: . Here’s an example of a Spring Boot code snippet for a Kafka producer that incorporates the mentioned features to achieve exactly once messaging semantics during data production: . import org.apache.kafka.clients.producer.*; import org.apache.kafka.common.serialization.StringSerializer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.kafka.core.DefaultKafkaProducerFactory; import org.springframework.kafka.core.KafkaTemplate; import org.springframework.kafka.core.ProducerFactory; import org.springframework.stereotype.Component; import java.util.Properties; @Component public class KafkaProducerExample { private final KafkaTemplate&lt;String, String&gt; kafkaTemplate; @Autowired public KafkaProducerExample(KafkaTemplate&lt;String, String&gt; kafkaTemplate) { this.kafkaTemplate = kafkaTemplate; } public void sendMessage(String key, String message) { ProducerRecord&lt;String, String&gt; producerRecord = new ProducerRecord&lt;&gt;(\"your_topic_name\", key, message); // Configure producer properties Properties props = new Properties(); props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, \"your_bootstrap_servers\"); props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class); props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class); // Enable idempotent producer props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"true\"); // Configure acknowledgments props.put(ProducerConfig.ACKS_CONFIG, \"all\"); // Configure retries and backoff props.put(ProducerConfig.RETRIES_CONFIG, Integer.MAX_VALUE); props.put(ProducerConfig.MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION, \"1\"); // Configure optional Kafka transactions // Uncomment the following lines if you want to use Kafka transactions // props.put(ProducerConfig.TRANSACTIONAL_ID_CONFIG, \"your_transactional_id\"); // props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, \"false\"); ProducerFactory&lt;String, String&gt; producerFactory = new DefaultKafkaProducerFactory&lt;&gt;(props); KafkaProducer&lt;String, String&gt; kafkaProducer = producerFactory.createProducer(); try { // Initiate Kafka transaction (if enabled) // Uncomment the following line if you want to use Kafka transactions // kafkaProducer.initTransactions(); // Begin Kafka transaction (if enabled) // Uncomment the following line if you want to use Kafka transactions // kafkaProducer.beginTransaction(); // Send the message kafkaProducer.send(producerRecord, new Callback() { @Override public void onCompletion(RecordMetadata metadata, Exception exception) { if (exception == null) { // Message successfully sent // Commit Kafka transaction (if enabled) // Uncomment the following line if you want to use Kafka transactions // kafkaProducer.commitTransaction(); } else { // Error occurred while sending message exception.printStackTrace(); // Rollback Kafka transaction (if enabled) // Uncomment the following line if you want to use Kafka transactions // kafkaProducer.abortTransaction(); } } }); // Flush and close the producer kafkaProducer.flush(); kafkaProducer.close(); } catch (Exception e) { e.printStackTrace(); // Rollback Kafka transaction (if enabled) // Uncomment the following line if you want to use Kafka transactions // kafkaProducer.abortTransaction(); } } } . Make sure to replace the placeholders (your_topic_name, your_bootstrap_servers, your_transactional_id) with the actual values for your Kafka setup. Also, uncomment the relevant sections if you want to use Kafka transactions. In this example, the KafkaProducerExample class is a Spring Bean that can be autowired and used to send messages to Kafka with the desired exactly once messaging semantics. You can call the sendMessage method with the appropriate key and message to produce messages to the specified Kafka topic. Remember to include the necessary dependencies in your pom.xml file, such as spring-kafka and kafka-clients, and configure the Kafka-related properties in your Spring Boot application’s application.properties or application.yml file. In-Sync Replicas (ISR) in Kafka: . In Kafka, ISR stands for In-Sync Replicas. It refers to the set of replicas that are fully caught up with the leader for a given partition and are in sync with the latest data. In-Sync Replicas play a crucial role in ensuring fault tolerance and durability in Kafka. Here are the key aspects of In-Sync Replicas (ISR) in Kafka: . | Replication in Kafka: Kafka replicates each partition across multiple brokers to provide fault tolerance and high availability. Each partition has one leader and multiple replicas. | Leader and Follower Replicas: For each partition, one broker acts as the leader, handling all read and write requests for that partition. The remaining brokers serve as follower replicas, which replicate the data from the leader. The leader receives all the writes, and the followers synchronize their data with the leader. | In-Sync Replicas (ISR): ISR represents the subset of follower replicas that are up-to-date with the leader. In order to maintain consistency, the leader waits for a configurable amount of time for the replicas in the ISR to acknowledge the receipt of messages. The leader considers a message as “committed” once it has been replicated by all replicas in the ISR. | Acknowledgment and Commit: When producing messages, Kafka allows producers to specify an acknowledgment configuration (acks) for the messages. Producers can choose to wait for acknowledgment from the leader only (acks=1), all replicas in the ISR (acks=all), or no acknowledgment (acks=0). | Durability and Fault Tolerance: The ISR mechanism ensures durability and fault tolerance. If a leader fails, one of the in-sync replicas is elected as the new leader. This ensures that the new leader is selected from a set of replicas that are guaranteed to have the most up-to-date data. By waiting for acknowledgment from the replicas in the ISR, Kafka ensures that messages are not lost even in the event of a leader failure. | Out-of-Sync Replicas: Replicas that are not in the ISR are referred to as out-of-sync replicas. These replicas are behind the leader in terms of data replication and are considered potential candidates for synchronization to become part of the ISR again. | . The ISR mechanism in Kafka ensures that data is replicated reliably across multiple brokers and provides strong consistency guarantees. It enables Kafka to maintain fault tolerance, durability, and data consistency in the face of failures and ensures that messages are not lost or duplicated. Churn in ISR . In the context of Apache Kafka, churn in the In-Sync Replicas (ISR) refers to the frequent changes in the set of replicas that are considered in sync with the leader for a given partition. ISR churn occurs when replicas repeatedly join or leave the ISR, resulting in increased network traffic, metadata updates, and potential performance impacts. Churn in ISR can have several consequences, including: . | Increased Network Traffic: When replicas frequently join or leave the ISR, it triggers data replication and synchronization across the brokers. This increased replication activity generates additional network traffic and can impact the overall network bandwidth utilization. | Metadata Updates: Kafka brokers maintain metadata about the ISR for each partition, and when changes occur, metadata updates need to propagate throughout the cluster. Frequent ISR changes result in more metadata updates, which can increase the load on the ZooKeeper or other metadata management systems used by Kafka. | Performance Impacts: ISR churn can have performance implications. When replicas join or leave the ISR, the leader may need to wait for acknowledgments from the replicas in the ISR before considering a message as committed. Frequent ISR changes can introduce additional latency and potentially impact the overall throughput of the Kafka cluster. | Leader Re-Election: If the leader of a partition fails or goes offline, Kafka initiates a leader re-election process to select a new leader from the remaining replicas. Frequent ISR changes can increase the frequency of leader re-elections, potentially affecting the overall stability and availability of the Kafka cluster. | . Reducing churn in the ISR is important for maintaining stable performance, reducing network overhead, and ensuring consistency and durability in Kafka. Strategies to reduce churn include optimizing configuration parameters, improving network stability, monitoring replica lags, proper resource provisioning, and ensuring appropriate broker placement to minimize the impact of failures or maintenance activities. Explain how you can reduce churn in ISR? When does broker leave the ISR? . Reducing churn in the In-Sync Replicas (ISR) of Apache Kafka is crucial for maintaining high availability, consistency, and durability. ISR churn occurs when brokers frequently join or leave the ISR, leading to increased network traffic and potential performance degradation. Here are some strategies to reduce ISR churn: . | Adjust min.insync.replicas Configuration: . | Kafka has a configuration parameter called min.insync.replicas that determines the minimum number of in-sync replicas required for a leader to consider a write as successful. Setting this value too low can increase the chances of churn as replicas may fall out of sync frequently. Increasing this value can help reduce churn at the cost of potential availability. | . | Increase Replication Factors: . | Consider increasing the replication factor for topics to have more replicas in the ISR. With a higher number of in-sync replicas, the likelihood of frequent ISR changes decreases, leading to reduced churn. However, this comes with increased resource requirements and potential network overhead. | . | Optimize Network and Broker Stability: . | Ensure that your Kafka cluster is built on a stable and reliable network infrastructure. Minimize network disruptions, latency, and packet loss, which can trigger frequent ISR changes. Stable network connections and consistent broker performance contribute to reduced churn. | . | Proper Capacity Planning: . | Adequately provision resources such as CPU, memory, disk I/O, and network bandwidth for Kafka brokers. Insufficient resources can lead to increased latency and unavailability, causing frequent ISR changes. Monitor resource utilization regularly and scale the cluster based on observed patterns and workload requirements. | . | Monitor Replica Lags: . | Keep track of replica lag, which indicates the difference in the data replication progress between the leader and follower replicas. Monitor and address cases where replica lag consistently grows, as it may lead to frequent ISR changes. Consider adjusting the replication configuration or scaling resources to mitigate lag-related churn. | . | Optimize Broker Placement: . | Distribute Kafka brokers across different physical hosts, racks, or Availability Zones to minimize the impact of hardware failures or maintenance activities on the ISR. Avoid colocating all replicas of a partition on the same set of brokers. | . | Leverage Rack Awareness: . | Utilize Kafka’s rack awareness feature to ensure replicas are distributed across multiple racks or failure domains. This helps reduce the chances of multiple replicas going offline simultaneously due to rack-level failures, reducing ISR churn. | . | Implement Backoff and Retry Mechanisms: . | Implement appropriate retry and backoff mechanisms in the application code to handle transient network or broker failures. Retrying too aggressively can increase ISR churn due to frequent leader changes. Using exponential backoff and retry strategies can help mitigate unnecessary churn. | . | . The decision for a broker to leave the ISR occurs when it fails to send a required acknowledgment to the leader within a configurable timeout. This can happen due to network disruptions, hardware failures, or high broker resource utilization. If a broker repeatedly fails to send acknowledgments, it is considered out of sync and exits the ISR. The leader may then initiate leader re-election to ensure consistency and durability by selecting a new leader from the remaining in-sync replicas. In the Producer, when does QueueFullException occur? . In Apache Kafka, the QueueFullException can occur in the producer when the internal message queue used for buffering the messages to be sent to the Kafka brokers becomes full. This exception is thrown when the producer attempts to add a new message to the internal queue but finds it already at capacity. The QueueFullException typically occurs under the following circumstances: . | High Message Production Rate: If the rate at which the producer is producing messages exceeds the rate at which the messages can be sent to the Kafka brokers, the internal message queue can become full. This situation can happen when the producers are generating messages at a faster pace than the network or broker can handle. | Congestion or Slow Downstream Systems: If the downstream systems, such as the Kafka brokers or the network, experience congestion or slowdowns, the producer may accumulate messages in its internal queue due to delays in message transmission. If the accumulation exceeds the capacity of the queue, the QueueFullException can be thrown. | Limited Producer Resources: The QueueFullException can also occur if the producer does not have sufficient resources allocated to handle the incoming message load. Insufficient memory or other resource limitations can lead to a full internal queue, resulting in the exception. | . To handle the QueueFullException, you can consider the following approaches: . | Retry Mechanism: Implement a retry mechanism in your producer code to handle the exception. You can retry sending the message after a delay or implement an exponential backoff strategy to avoid overwhelming the producer. | Throttling or Rate Limiting: Implement throttling or rate limiting mechanisms in your producer to control the message production rate and prevent the queue from becoming full. This can involve setting appropriate limits or using external rate limiting techniques. | Increase Producer Resources: Ensure that the producer has sufficient resources allocated to handle the message load. This includes increasing the memory, adjusting buffer sizes, or scaling up the producer instances as needed. | Monitor and Optimize Performance: Regularly monitor the performance and throughput of your producer and the Kafka cluster. Identify any bottlenecks or issues that may lead to a full queue, and optimize the system accordingly. | . It’s important to note that handling the QueueFullException depends on your specific application requirements, message production rate, and the available resources in your producer environment. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/6-kafka-miscellaneous/",
    "relUrl": "/docs/SpringBoot/Kafka/6-kafka-miscellaneous/"
  },"26": {
    "doc": "hazelcast.xml",
    "title": "hazelcast.xml",
    "content": "Here’s an example of a complete hazelcast.xml file . &lt;hazelcast xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-4.2.xsd\"&gt; &lt;!-- Cluster Name --&gt; &lt;cluster-name&gt;my-cluster&lt;/cluster-name&gt; &lt;!-- Network Configuration --&gt; &lt;network&gt; &lt;!-- Join Configuration --&gt; &lt;join&gt; &lt;!-- Multicast Configuration (for discovery in the same network) --&gt; &lt;multicast enabled=\"true\"&gt; &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt; &lt;multicast-port&gt;54327&lt;/multicast-port&gt; &lt;/multicast&gt; &lt;!-- TCP/IP Configuration (for static IP-based discovery) --&gt; &lt;tcp-ip enabled=\"false\"&gt; &lt;interface&gt;127.0.0.1&lt;/interface&gt; &lt;member-list&gt; &lt;member&gt;127.0.0.1&lt;/member&gt; &lt;/member-list&gt; &lt;/tcp-ip&gt; &lt;/join&gt; &lt;/network&gt; &lt;!-- Map Configuration --&gt; &lt;map name=\"my-map\"&gt; &lt;!-- In-Memory Format --&gt; &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt; &lt;!-- Eviction Policy --&gt; &lt;eviction-policy&gt;LRU&lt;/eviction-policy&gt; &lt;!-- Max Size Policy --&gt; &lt;max-size policy=\"PER_NODE\"&gt;1000&lt;/max-size&gt; &lt;!-- Time-To-Live (Expiration) --&gt; &lt;time-to-live-seconds&gt;3600&lt;/time-to-live-seconds&gt; &lt;/map&gt; &lt;!-- Near Cache Configuration --&gt; &lt;near-cache name=\"my-near-cache\"&gt; &lt;!-- In-Memory Format --&gt; &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt; &lt;!-- Eviction Policy --&gt; &lt;eviction eviction-policy=\"LRU\" max-size-policy=\"PER_NODE\" size=\"1000\"/&gt; &lt;!-- Time-To-Live (Expiration) --&gt; &lt;time-to-live-seconds&gt;600&lt;/time-to-live-seconds&gt; &lt;!-- Invalidate Policy --&gt; &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt; &lt;/near-cache&gt; &lt;/hazelcast&gt; . | &lt;cluster-name&gt;: Specifies the name of the Hazelcast cluster. All members with the same cluster name will form a cluster and discover each other. | &lt;network&gt;: Configures the network settings for the Hazelcast cluster. | &lt;join&gt;: Specifies the discovery mechanism for cluster members. | &lt;multicast&gt;: Enables multicast-based discovery. Members in the same network can discover each other using multicast communication. | &lt;multicast-group&gt;: Specifies the multicast group IP address. | &lt;multicast-port&gt;: Specifies the multicast port number. | . | &lt;tcp-ip&gt;: Enables static IP-based discovery. Members connect to specific IP addresses to discover other members. | &lt;interface&gt;: Specifies the network interface to bind to. | &lt;member-list&gt;: Lists the IP addresses of the members to be discovered. | . | . | &lt;map&gt;: Configures the settings for a specific distributed map in Hazelcast. | &lt;name&gt;: Specifies the name of the distributed map. | &lt;in-memory-format&gt;: Specifies the format for storing map entries in memory (OBJECT or BINARY). | &lt;eviction-policy&gt;: Specifies the eviction policy when the map reaches its maximum size (e.g., LRU, LFU, etc.). | &lt;max-size&gt;: Specifies the maximum size of the map (policy can be PER_NODE or PER_PARTITION). | &lt;time-to-live-seconds&gt;: Specifies the time-to-live (expiration) duration in seconds for map entries. | . | &lt;near-cache&gt;: Configures a near cache for a specific distributed map. | &lt;name&gt;: Specifies the name of the distributed map associated with the near cache. | &lt;in-memory-format&gt;: Specifies the format for storing near cache entries in memory (OBJECT or BINARY). | &lt;eviction&gt;: Configures the eviction settings for the near cache (eviction-policy, max-size-policy, and size). | &lt;time-to-live-seconds&gt;: Specifies the time-to-live (expiration) duration in seconds for near cache entries. | &lt;invalidate-on-change&gt;: Specifies whether the near cache should be invalidated on map entry changes. | . | . These are some of the commonly used elements in the hazelcast.xml file. However, Hazelcast provides many more configuration options and elements to fine-tune the behavior and performance of your distributed cache. Here’s an example that demonstrates how to configure a Spring Boot application with a distributed cache using Hazelcast, where the near cache is updated based on changes in the distributed cache in the server cache cluster. &lt;!-- Spring Boot Starter --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Hazelcast Integration --&gt; &lt;dependency&gt; &lt;groupId&gt;com.hazelcast&lt;/groupId&gt; &lt;artifactId&gt;hazelcast-spring&lt;/artifactId&gt; &lt;/dependency&gt; . @SpringBootApplication public class HazelcastNearCacheExampleApplication { public static void main(String[] args) { SpringApplication.run(HazelcastNearCacheExampleApplication.class, args); } } . application.properties . # Hazelcast Configuration hazelcast.config=hazelcast.xml . hazelcast.xml . &lt;hazelcast xmlns=\"http://www.hazelcast.com/schema/config\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.hazelcast.com/schema/config http://www.hazelcast.com/schema/config/hazelcast-config-4.2.xsd\"&gt; &lt;!-- Cluster Name --&gt; &lt;cluster-name&gt;my-cluster&lt;/cluster-name&gt; &lt;!-- Network Configuration --&gt; &lt;network&gt; &lt;!-- Join Configuration --&gt; &lt;join&gt; &lt;!-- Multicast Configuration (for discovery in the same network) --&gt; &lt;multicast enabled=\"true\"&gt; &lt;multicast-group&gt;224.2.2.3&lt;/multicast-group&gt; &lt;multicast-port&gt;54327&lt;/multicast-port&gt; &lt;/multicast&gt; &lt;/join&gt; &lt;/network&gt; &lt;!-- Map Configuration --&gt; &lt;map name=\"my-distributed-map\"&gt; &lt;!-- Near Cache Configuration --&gt; &lt;near-cache name=\"my-near-cache\"&gt; &lt;!-- Invalidate Policy --&gt; &lt;invalidate-on-change&gt;true&lt;/invalidate-on-change&gt; &lt;/near-cache&gt; &lt;/map&gt; &lt;/hazelcast&gt; . In this configuration: . | my-cluster is the name of the Hazelcast cluster. | Multicast is enabled for discovering members in the same network. | There is a distributed map named my-distributed-map with a near cache named my-near-cache. | The near cache is configured with invalidate-on-change set to true, indicating that it should be updated based on changes in the distributed cache. | . @Service public class DistributedCacheService { @Autowired private HazelcastInstance hazelcastInstance; public void putToCache(String key, String value) { IMap&lt;String, String&gt; distributedMap = hazelcastInstance.getMap(\"my-distributed-map\"); distributedMap.put(key, value); } public String getFromCache(String key) { IMap&lt;String, String&gt; distributedMap = hazelcastInstance.getMap(\"my-distributed-map\"); return distributedMap.get(key); } public void removeFromCache(String key) { IMap&lt;String, String&gt; distributedMap = hazelcastInstance.getMap(\"my-distributed-map\"); distributedMap.remove(key); } } . @RestController public class CacheController { @Autowired private DistributedCacheService cacheService; @PostMapping(\"/cache\") public ResponseEntity&lt;String&gt; putToCache(@RequestParam String key, @RequestParam String value) { cacheService.putToCache(key, value); return ResponseEntity.ok(\"Value added to cache\"); } @GetMapping(\"/cache/{key}\") public ResponseEntity&lt;String&gt; getFromCache(@PathVariable String key) { String value = cacheService.getFromCache(key); if (value != null) { return ResponseEntity.ok(value); } return ResponseEntity.notFound().build(); } @DeleteMapping(\"/cache/{key}\") public ResponseEntity&lt;String&gt; removeFromCache(@PathVariable String key) { cacheService.removeFromCache(key); return ResponseEntity.ok(\"Value removed from cache\"); } } . In this example, the DistributedCacheService class interacts with the distributed cache using the Hazelcast instance. The CacheController provides REST endpoints to put a value into the cache, retrieve a value from the cache, and remove a value from the cache. When a value is put into or removed from the distributed cache, the near cache associated with the my-near-cache configuration will be updated automatically due to the invalidate-on-change setting. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/7-hazelcast_xml/",
    "relUrl": "/docs/SpringBoot/Hazelcast/7-hazelcast_xml/"
  },"27": {
    "doc": "Composition, Aggregation, and Association",
    "title": "Composition, Aggregation, and Association",
    "content": "Composition, Aggregation, and Association . In Java design, composition, aggregation, and association are three different relationships between classes that define how objects interact with each other. These relationships play a crucial role in designing the structure and behavior of an application. Let’s explore each one in more detail: . Composition: . Composition represents a strong “has-a” relationship between two classes, where the existence of one class is dependent on the other. In composition, the child class cannot exist independently of the parent class. If the parent object is destroyed, the child object is also destroyed. The child class is an integral part of the parent class and cannot be reused elsewhere. Example: . class Car { private Engine engine; public Car() { engine = new Engine(); } } . In this example, the Car class has a composition relationship with the Engine class. The Car class creates an instance of the Engine class in its constructor, indicating that an engine is an essential part of a car. Aggregation: . Aggregation represents a “has-a” relationship between two classes, but the child class can exist independently of the parent class. It is a weaker relationship compared to composition. In aggregation, the child class can be shared among multiple parent classes. When the parent object is destroyed, the child object can still exist. Example: . class Department { private List&lt;Employee&gt; employees; public Department() { employees = new ArrayList&lt;&gt;(); } } . In this example, the Department class has an aggregation relationship with the Employee class. The Department class contains a list of employees, but the employees can exist independently and can be associated with multiple departments. Association: . Association represents a relationship between two classes, indicating that objects of one class are connected to objects of another class. It is a looser relationship compared to composition and aggregation. Unlike composition and aggregation, association does not imply ownership or dependence. Example: . class Student { private List&lt;Course&gt; courses; } . In this example, the Student class has an association with the Course class. The Student class can have a list of courses, but the courses can exist independently, and they are not an integral part of the Student class. It’s important to note that these relationships are conceptual and can be implemented using appropriate class member variables and methods in Java. The choice of composition, aggregation, or association depends on the desired behavior and the nature of the relationship between the classes. ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/7-java-opps/",
    "relUrl": "/docs/Java/Interview/7-java-opps/"
  },"28": {
    "doc": "Exception",
    "title": "Exception",
    "content": "What is the difference between checked and unchecked exceptions in Java? Provide examples of each. In Java, exceptions are categorized into two types: checked exceptions and unchecked exceptions. Checked Exceptions: . Checked exceptions are the exceptions that must be declared in the method signature using the throws keyword or handled using a try-catch block. The compiler enforces the handling or declaring of checked exceptions at compile-time. Examples of checked exceptions include IOException, SQLException, and ClassNotFoundException. Example: . import java.io.FileReader; import java.io.IOException; public class FileHandler { public void readFile(String fileName) throws IOException { FileReader fileReader = new FileReader(fileName); // Perform file reading operations fileReader.close(); } } . In the above example, the readFile method throws a checked exception IOException, which is a checked exception related to input/output operations. It must be handled or declared in the method signature. Unchecked Exceptions: . Unchecked exceptions, also known as runtime exceptions, do not require explicit handling or declaring in the method signature. They occur due to programming errors or exceptional conditions that can be avoided with proper coding practices. Examples of unchecked exceptions include NullPointerException, ArrayIndexOutOfBoundsException, and ArithmeticException. Example: . public class Divider { public double divide(int dividend, int divisor) { return dividend / divisor; } } . In the above example, the divide method does not handle or declare any checked exceptions. However, if the divisor parameter is passed as 0, it will throw an unchecked exception ArithmeticException at runtime. It’s important to note that unchecked exceptions can still be caught and handled using try-catch blocks, but it’s not mandatory. In summary, checked exceptions need to be explicitly handled or declared, while unchecked exceptions do not require explicit handling. The distinction between checked and unchecked exceptions helps in managing exceptional situations and enforcing proper exception handling practices in Java programs. Here are a few more examples of both checked and unchecked exceptions in Java: . Checked Exceptions: . | FileNotFoundException: Thrown when a file or directory is not found. | ParseException: Thrown when an error occurs while parsing a string into a specific format. | InterruptedException: Thrown when a thread is interrupted while it is waiting, sleeping, or otherwise occupied. | SQLException: Thrown when an error occurs during database access or interaction. | . Unchecked Exceptions: . | NullPointerException: Thrown when a null reference is used where an object is expected. | ArrayIndexOutOfBoundsException: Thrown when an invalid index is used to access an array. | ArithmeticException: Thrown when an arithmetic operation encounters an exceptional condition, such as division by zero. | ClassCastException: Thrown when an invalid type casting operation is performed. | . Here are additional examples of both checked and unchecked exceptions: . Checked Exceptions: . | IOException: Thrown when an I/O error occurs, such as failure in reading or writing to a file. | ClassNotFoundException: Thrown when a class is not found at runtime. | IllegalAccessException: Thrown when access to a class, method, or field is denied. | InterruptedException: Thrown when a thread is interrupted. | . Unchecked Exceptions: . | IllegalArgumentException: Thrown when an illegal argument is passed to a method. | IllegalStateException: Thrown when the state of an object is inappropriate for the requested operation. | UnsupportedOperationException: Thrown when an unsupported operation is invoked. | OutOfMemoryError: Thrown when the Java Virtual Machine (JVM) runs out of memory. | It’s important to note that these are just a few examples, and there are many more exceptions available in Java. Additionally, you can also create your own custom exceptions by extending the Exception class or one of its subclasses to handle specific exceptional conditions in your application. | . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/8-exception/",
    "relUrl": "/docs/Java/Interview/8-exception/"
  },"29": {
    "doc": "Map Interface",
    "title": "Map Interface",
    "content": "TreeMap and HashMap . | HashMap and TreeMap are both implementations of the Map interface in Java, but they have some key differences: . | Ordering: HashMap does not guarantee any particular order of its elements. The elements are stored in an unordered manner based on the hash code of the keys. On the other hand, TreeMap maintains its elements in sorted order based on the natural ordering of the keys or a custom Comparator provided during initialization. | Performance: HashMap provides constant-time performance (O(1)) for basic operations like get() and put(), assuming a good hash function and proper load factor. In contrast, TreeMap provides logarithmic-time performance (O(log n)) for basic operations due to the underlying red-black tree structure used for sorting. | Sorting: As mentioned earlier, TreeMap sorts its elements based on the keys. This makes it useful when you need a sorted map based on natural ordering or a custom Comparator. HashMap does not have any built-in sorting capability. | Null Keys: HashMap allows a single null key and multiple null values. On the other hand, TreeMap does not allow null keys but can have multiple null values. | Iteration: HashMap provides faster iteration since it does not have to maintain any specific order. TreeMap, being sorted, provides iteration in the sorted order of keys. | Memory Overhead: TreeMap generally requires more memory compared to HashMap because it needs to maintain the additional tree structure for sorting. | Use Cases: HashMap is typically used when you require fast lookups and do not care about the order of elements. TreeMap is suitable when you need to maintain a sorted map or perform range-based operations, such as finding the nearest key or values within a certain range. | . ",
    "url": "https://1001anjan.github.io/docs/Java/Interview/9-Map-interface/",
    "relUrl": "/docs/Java/Interview/9-Map-interface/"
  },"30": {
    "doc": "Interview Preparation",
    "title": "Collection Framework",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. What is a Framework? . A framework is a set of classes and interfaces which provide a ready-made architecture. In order to implement a new feature or a class, there is no need to define a framework. Advantages of the Collection Framework: . | Consistent API | Reduces programming effort | Increases program speed and quality | . Hierarchy of the Collection Framework: . ",
    "url": "https://1001anjan.github.io/docs/java/collection#collection-framework",
    "relUrl": "/docs/java/collection#collection-framework"
  },"31": {
    "doc": "Interview Preparation",
    "title": "Interview Preparation",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/java/collection",
    "relUrl": "/docs/java/collection"
  },"32": {
    "doc": "Database",
    "title": "Database Quick notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Database/database/#database-quick-notes",
    "relUrl": "/docs/Database/database/#database-quick-notes"
  },"33": {
    "doc": "Database",
    "title": "Database",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Database/database/",
    "relUrl": "/docs/Database/database/"
  },"34": {
    "doc": "PostGress SQL indexing",
    "title": "PostGress SQL indexing quick notes",
    "content": ". | List all the indexes created on the table SELECT * FROM pg_indexes WHERE tablename = 'table-name'; . | Analysis SQL query EXPLAIN ANALYZE SELECT col1 FROM table_name WHERE col2 = 'value' ORDER BY col2 DESC LIMIT 1 . | . ",
    "url": "https://1001anjan.github.io/db-1-PostGress%20SQL%20indexing%20quick%20notes/#postgress-sql-indexing-quick-notes",
    "relUrl": "/db-1-PostGress SQL indexing quick notes/#postgress-sql-indexing-quick-notes"
  },"35": {
    "doc": "PostGress SQL indexing",
    "title": "PostGress SQL indexing",
    "content": " ",
    "url": "https://1001anjan.github.io/db-1-PostGress%20SQL%20indexing%20quick%20notes/",
    "relUrl": "/db-1-PostGress SQL indexing quick notes/"
  },"36": {
    "doc": "UUID Key Notes",
    "title": "UUID Key Notes",
    "content": "IS it possible duplicate UUID in database . In theory, UUID (Universally Unique Identifier) values should be unique globally, however, in practice, the chance of generating a duplicate UUID value is extremely low. However, if you are using a database, it is recommended to enforce a unique constraint on the UUID column to prevent any accidental duplicates from being inserted into the database. In the case of Neo4j, you can use the built-in constraint functionality to enforce uniqueness on a UUID property. This will ensure that no duplicates are inserted into the database and, if an attempt to insert a duplicate is made, an error will be returned. Create UUID in postgress sql . To generate a universally unique identifier (UUID) in PostgreSQL, you can use the uuid-ossp extension and its uuid-generate-v4() function. Here’s an example: . CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"; SELECT uuid_generate_v4(); . Note that you need to have the necessary privileges to install the uuid-ossp extension on your database. Here’s an example of how you can generate a UUID in Java: . import java.util.UUID; public class Main { public static void main(String[] args) { UUID uuid = UUID.randomUUID(); System.out.println(\"UUID: \" + uuid); } } . This code generates a new, unique UUID each time it is run, and outputs it to the console. The UUID.randomUUID() method returns a randomly generated UUID object, which is then printed using println. import java.util.UUID; public class Main { public static void main(String[] args) { UUID uuid1 = UUID.fromString(\"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"); UUID uuid2 = UUID.fromString(\"f81d4fae-7dec-11d0-a765-00a0c91e6bf6\"); UUID uuid3 = UUID.randomUUID(); System.out.println(\"uuid1: \" + uuid1); System.out.println(\"uuid2: \" + uuid2); System.out.println(\"uuid3: \" + uuid3); System.out.println(\"\\nValidating UUIDs:\"); validateUUID(uuid1); validateUUID(uuid2); validateUUID(uuid3); System.out.println(\"\\nComparing UUIDs:\"); compareUUIDs(uuid1, uuid2); compareUUIDs(uuid2, uuid3); } public static void validateUUID(UUID uuid) { String uuidString = uuid.toString(); try { UUID.fromString(uuidString); System.out.println(uuidString + \" is a valid UUID\"); } catch (IllegalArgumentException e) { System.out.println(uuidString + \" is not a valid UUID\"); } } public static void compareUUIDs(UUID uuid1, UUID uuid2) { if (uuid1.equals(uuid2)) { System.out.println(uuid1 + \" is equal to \" + uuid2); } else { System.out.println(uuid1 + \" is not equal to \" + uuid2); } } } . This code generates three UUIDs: two that are equal, and one that is random. The validateUUID method takes a UUID as input, and uses UUID.fromString to attempt to parse it. If parsing is successful, the UUID is considered valid and a message to that effect is printed. If parsing fails, the UUID is considered invalid and a different message is printed. The compareUUIDs method compares two UUIDs for equality and prints a message indicating whether they are equal or not. ",
    "url": "https://1001anjan.github.io/db-1-UUID-key-notes/",
    "relUrl": "/db-1-UUID-key-notes/"
  },"37": {
    "doc": "Spring JPA, JOOQ, iBatis",
    "title": "Spring JPA, JOOQ, iBatis JDBC driver Comparison",
    "content": "Spring JPA . Spring JPA is a part of the Spring framework that provides support for Java Persistence API (JPA), a Java standard for accessing relational databases. It offers a simple and flexible way to integrate JPA with the Spring framework, allowing developers to work with databases using Java objects, and managing database transactions and persistence operations in a transparent manner. Spring JPA abstracts the underlying JPA implementation, providing a unified interface for accessing data in the database and enabling seamless integration with other Spring projects such as Spring Data, Spring Security, etc. iBATIS . iBATIS and MyBatis are both object-relational mapping (ORM) frameworks for Java that provide persistence layer for applications. However, there are some differences between the two: . | Development History: iBATIS was developed by Apache Software Foundation and was later acquired by Google. MyBatis was developed by Clinton Begin as an alternative to iBATIS and was later donated to Apache Software Foundation. | XML Configuration: iBATIS uses XML configuration files to map Java objects to SQL statements. MyBatis supports both XML and annotation-based configuration. | Statement Management: iBATIS uses the SqlMapClient API to manage SQL statements, while MyBatis uses the SqlSession API. | . In a Spring Boot application, MyBatis is a better choice as it provides more options for configuration, has a simpler API, and is more actively maintained and developed than iBATIS. It’s worth noting that both iBATIS and MyBatis are now part of the Apache MyBatis project, and both are effectively the same product . jOOQ . jOOQ can be used in a Spring Boot application as a library for accessing databases. The following are the steps to integrate jOOQ with Spring Boot: . | Add the jOOQ library to your project dependencies. | Generate the jOOQ classes for your database schema using the jOOQ code generator. | Configure a DataSource for your database in your Spring Boot application. | Create a jOOQ Configuration object and set the DataSource, dialect, and other settings as needed. | Use the jOOQ Configuration to create a DSLContext, which provides the fluent API for querying the database. | Inject the DSLContext into your repositories or services using dependency injection. | Use the DSLContext to write type-safe and readable SQL-like code for accessing the database. | . In this way, jOOQ can be integrated with Spring Boot to provide a type-safe and readable API for accessing databases. The code generation and high level of abstraction provided by jOOQ can help reduce the amount of boilerplate code and make it easier to write correct and efficient database access code. Compare jOOQ and MyBatis/iBATIS . jOOQ and MyBatis/iBATIS are both Java frameworks for accessing databases, but they approach the problem from different angles: . | Code Generation: jOOQ uses code generation to create Java classes that represent database tables and other database objects, allowing for type-safe and easy-to-read SQL-like code. MyBatis/iBATIS, on the other hand, use XML or annotations to map Java objects to SQL statements, which are executed at runtime. | Abstraction Level: jOOQ provides a high level of abstraction and a fluent API for querying databases, while MyBatis/iBATIS provide a lower level of abstraction and give more control over the actual SQL being executed. | Performance: jOOQ’s code generation and high level of abstraction come with a performance cost, as the generated code may be slower than manually written SQL. MyBatis/iBATIS can offer better performance in certain scenarios, as the SQL can be optimized for a specific database and use of caching can be optimized. | Maintenance: jOOQ requires code generation to be run whenever the database schema changes, which can be time-consuming and may introduce bugs. MyBatis/iBATIS are more flexible in this regard, as changes to the database schema can be made without requiring code changes. | . In conclusion, jOOQ is a good choice for projects that prioritize a type-safe and readable API, while MyBatis/iBATIS may be a better choice for projects that prioritize performance and need more control over the SQL being executed. Compare jOOQ and Spring Data JPA . jOOQ and Spring Data JPA are both libraries for accessing databases in a Java application, but they have some significant differences: . | Abstraction Level: Spring Data JPA provides a higher level of abstraction than jOOQ, as it uses the Java Persistence API (JPA) to map Java objects to database tables and provides a repository-based API for querying the database. jOOQ, on the other hand, provides a lower level of abstraction and a SQL-like fluent API for querying the database. | Code Generation: jOOQ uses code generation to create Java classes that represent database tables and other database objects, allowing for type-safe and easy-to-read SQL-like code. Spring Data JPA, on the other hand, does not require code generation and uses annotations and interfaces to define the mapping between Java objects and database tables. | Performance: jOOQ’s code generation and high level of abstraction come with a performance cost, as the generated code may be slower than manually written SQL. Spring Data JPA can offer better performance in certain scenarios, as the query optimization can be done at runtime using the JPA criteria API. | Maintenance: jOOQ requires code generation to be run whenever the database schema changes, which can be time-consuming and may introduce bugs. Spring Data JPA is more flexible in this regard, as changes to the database schema can be made without requiring code changes. | . In conclusion, Spring Data JPA is a good choice for projects that prioritize a higher level of abstraction and ease of use, while jOOQ may be a better choice for projects that prioritize a type-safe and readable API and need more control over the SQL being executed. Compare Spring Data JPA and iBATIS . Spring Data JPA and iBATIS are both Java frameworks for accessing databases, but they approach the problem from different angles: . | Abstraction Level: Spring Data JPA provides a higher level of abstraction than iBATIS, as it uses the Java Persistence API (JPA) to map Java objects to database tables and provides a repository-based API for querying the database. iBATIS, on the other hand, provides a lower level of abstraction and uses XML or annotations to map Java objects to SQL statements, which are executed at runtime. | Code Generation: Spring Data JPA does not require code generation and uses annotations and interfaces to define the mapping between Java objects and database tables. iBATIS, on the other hand, uses XML or annotations to map Java objects to SQL statements. | Performance: Spring Data JPA can offer good performance, as the query optimization can be done at runtime using the JPA criteria API. iBATIS can also offer good performance, as the SQL can be optimized for a specific database and use of caching can be optimized. | Maintenance: Spring Data JPA is more flexible in terms of maintenance, as changes to the database schema can be made without requiring code changes. iBATIS requires changes to the mapping XML or annotations whenever the database schema changes. | . In conclusion, Spring Data JPA is a good choice for projects that prioritize a higher level of abstraction and ease of use, while iBATIS may be a better choice for projects that need more control over the SQL being executed and require fine-grained performance optimization. Java code example using spring jpa, ibatis and jooq . Here are code examples in Java that demonstrate the use of Spring Data JPA, iBATIS, and jOOQ for accessing a database. Spring Data JPA: . @Entity public class User { @Id @GeneratedValue(strategy=GenerationType.IDENTITY) private Long id; private String name; private String email; // getters and setters } public interface UserRepository extends JpaRepository&lt;User, Long&gt; { List&lt;User&gt; findByName(String name); } @Service public class UserService { private final UserRepository userRepository; @Autowired public UserService(UserRepository userRepository) { this.userRepository = userRepository; } public List&lt;User&gt; findByName(String name) { return userRepository.findByName(name); } } . iBATIS: . public class User { private Long id; private String name; private String email; // getters and setters } public interface UserMapper { List&lt;User&gt; findByName(String name); } @Service public class UserService { private final SqlSessionTemplate sqlSessionTemplate; @Autowired public UserService(SqlSessionTemplate sqlSessionTemplate) { this.sqlSessionTemplate = sqlSessionTemplate; } public List&lt;User&gt; findByName(String name) { UserMapper userMapper = sqlSessionTemplate.getMapper(UserMapper.class); return userMapper.findByName(name); } } . jOOQ: . public class User { private Long id; private String name; private String email; // getters and setters } public class UserRecord extends UpdatableRecordImpl&lt;UserRecord&gt; { public UserRecord() { super(USER); } // setters and getters } @Service public class UserService { private final DSLContext dslContext; @Autowired public UserService(DSLContext dslContext) { this.dslContext = dslContext; } public List&lt;User&gt; findByName(String name) { return dslContext.selectFrom(USER) .where(USER.NAME.eq(name)) .fetchInto(User.class); } } . Note that these are just simple examples to illustrate the differences in the APIs. In a real-world application, you would need to add more error handling, data validation, and other logic to make the code robust and scalable. ",
    "url": "https://1001anjan.github.io/db-1-Spring%20JPA,%20JOOQ,%20iBatis/#spring-jpa-jooq-ibatis-jdbc-driver-comparison",
    "relUrl": "/db-1-Spring JPA, JOOQ, iBatis/#spring-jpa-jooq-ibatis-jdbc-driver-comparison"
  },"38": {
    "doc": "Spring JPA, JOOQ, iBatis",
    "title": "Spring JPA, JOOQ, iBatis",
    "content": " ",
    "url": "https://1001anjan.github.io/db-1-Spring%20JPA,%20JOOQ,%20iBatis/",
    "relUrl": "/db-1-Spring JPA, JOOQ, iBatis/"
  },"39": {
    "doc": "DataBase Session and Connection",
    "title": "DataBase Session and Connection",
    "content": "DataBase Session and Connection . Generally, executing multiple SQL queries in a single session can improve performance by reducing the overhead of establishing and tearing down multiple database connections. However, in some cases, it may be beneficial to use multiple sessions, for example, when there is a need to isolate transactions and ensure data consistency, or when there are concurrent requests that need to access the database simultaneously. Ultimately, the decision of whether to use a single session or multiple sessions should be based on the specific requirements and constraints of your application and the underlying database management system. Handle concurrent request of using database session . Handling concurrent requests in a database session requires proper synchronization and management of the database sessions to prevent race conditions, deadlocks, and other concurrency-related issues. Here are some common approaches to handle concurrent requests: . | Locking: This involves locking the relevant rows, tables, or the entire database to prevent concurrent access. However, locking can lead to reduced performance and the possibility of deadlocks. | Transactions: Transactions allow you to group multiple SQL statements into a single, atomic unit of work. When a transaction is committed, all changes are made permanent, and when a transaction is rolled back, all changes are discarded. | Connection Pooling: Connection pooling is a technique where a pool of database connections is maintained, and connections are reused as needed. This reduces the overhead of creating and destroying database connections for each request. | Optimistic Locking: Optimistic locking is a concurrency control technique that assumes that multiple transactions can complete without affecting each other. Conflicts are detected at commit time and resolved by restarting the transaction. | . These are just a few of the techniques used to handle concurrent requests in a database session. The specific approach that’s best for your application will depend on the type and volume of concurrent requests, the underlying database management system, and other constraints. How to handle concurrent request required to access database in springboot . In Spring Boot, you can handle concurrent database access requests by using either of the following methods: . | Pessimistic locking: In this approach, a lock is acquired on the database record that you are accessing, and other threads have to wait until the lock is released. You can use the @Transactional annotation and set the isolation property to Isolation.SERIALIZABLE to enable pessimistic locking in Spring Boot. | Optimistic locking: In this approach, multiple threads can access the database record simultaneously, but if two or more threads try to update the same record at the same time, one of them will fail, and you will have to handle the failure gracefully. You can enable optimistic locking in Spring Boot by using the @Version annotation on the version field in your entity class and using the saveAndFlush() method to update the record. | . It is also recommended to use a database connection pool to manage the database connections effectively and avoid connection exhaustion. Spring Boot provides built-in support for HikariCP, which is a high-performance connection pool. Here is a complete example of handling concurrent database access requests using JPA in Spring Boot: . @Entity public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; @Version private Integer version; // getters and setters } @Repository public interface UserRepository extends JpaRepository&lt;User, Integer&gt; { } @Service public class UserService { @Autowired private UserRepository userRepository; @Transactional public void updateUser(Integer id, String name) { User user = userRepository.findById(id).orElseThrow(() -&gt; new RuntimeException(\"User not found\")); user.setName(name); try { userRepository.saveAndFlush(user); } catch (OptimisticLockingFailureException e) { // handle optimistic locking failure } } } @SpringBootApplication public class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); } } . In the example above, we have defined an User entity class, a UserRepository interface that extends the JpaRepository interface provided by Spring Data JPA, and a UserService class that performs the database operations. The UserService class is annotated with the @Transactional annotation to enable transaction management. The updateUser method performs the update operation on the user record and handles the optimistic locking failure, if any, using the OptimisticLockingFailureException exception. The Application class is the main class that starts the Spring Boot application. This is just a basic example to give you an idea of how you can handle concurrent database access requests using JPA in Spring Boot. You can customize the example as per your needs and requirements. Example using connection pooling . Here is an example of how you can configure connection pooling in Spring Boot using the HikariCP library: . | First, add the following dependency in your pom.xml file: ```xml | . com.zaxxer HikariCP 3.4.5 Next, add the following configuration in your `application.properties` or `application.yml` file: ```yaml spring.datasource.url=jdbc:mysql://localhost:3306/test spring.datasource.username=user spring.datasource.password=password spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver spring.datasource.hikari.maximum-pool-size=5 spring.datasource.hikari.idle-timeout=30000 . This configuration sets the maximum pool size to 5 and the idle timeout to 30 seconds. You can adjust these values as per your needs and requirements. Finally, make sure to use the DataSource bean provided by Spring Boot instead of creating your own. Spring Boot automatically configures the DataSource bean to use the HikariCP library. That’s it. You have successfully configured connection pooling in Spring Boot using the HikariCP library. You can now use the DataSource bean in your code to access the database and handle concurrent database access requests. dataSource bean with example . A DataSource bean is a Java object that represents a database connection pool and is used to manage database connections in a Java application. In Spring Boot, you can define a DataSource bean using the DataSourceBuilder class provided by Spring. Here is an example of how you can define a DataSource bean in Spring Boot: . @Configuration public class DataSourceConfig { @Bean @ConfigurationProperties(prefix = \"spring.datasource\") public DataSource dataSource() { return DataSourceBuilder.create().build(); } } . In the example above, the DataSourceConfig class is annotated with the @Configuration annotation, indicating that it is a configuration class. The dataSource method is annotated with the @Bean annotation, indicating that it is a bean method. The @ConfigurationProperties annotation is used to bind the properties in the application.properties or application.yml file with the DataSource bean. The prefix attribute of the @ConfigurationProperties annotation is set to \"spring.datasource\", which specifies that only the properties that start with \"spring.datasource\" should be bound to the DataSource bean. The dataSource method creates a DataSource object using the DataSourceBuilder class and returns it. The build method of the DataSourceBuilder class is called to build the DataSource object. This is just a basic example to give you an idea of how you can define a DataSource bean in Spring Boot. You can customize the example as per your needs and requirements. For example, you can specify the type of the DataSource bean, configure the connection pool properties, and so on. Handle concurrent request using iBatis . iBATIS is an SQL Mapping framework for Java, .NET, and other platforms. To handle concurrent requests in iBATIS, you can use connection pooling to manage a pool of database connections and ensure that each request is executed on a separate, dedicated connection. This way, each request is executed in isolation, avoiding any concurrency issues. Here’s an example of how you can configure connection pooling in iBATIS for a Java application: . | Create a data source for the database connection pool using a library such as Apache Commons DBCP. | Configure the iBATIS SqlMapConfig.xml file to use the data source. | . &lt;dataSources&gt; &lt;dataSource type=\"SIMPLE\"&gt; &lt;property name=\"JDBC.Driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"JDBC.ConnectionURL\" value=\"jdbc:mysql://localhost/test\"/&gt; &lt;property name=\"JDBC.Username\" value=\"username\"/&gt; &lt;property name=\"JDBC.Password\" value=\"password\"/&gt; &lt;/dataSource&gt; &lt;/dataSources&gt; . In your Java code, use the SqlMapClient instance to execute SQL statements. The SqlMapClient instance will automatically use a connection from the connection pool to execute the statement. SqlMapClient sqlMap = SqlMapClientBuilder.buildSqlMapClient(reader); sqlMap.queryForList(\"getUsers\"); . This is just a simple example of how you can handle concurrent requests in iBATIS using connection pooling. You may need to make additional configurations and optimizations depending on your specific use case. SpringBoot Example: . Here’s an example of how you can handle concurrent requests in a Spring Boot application using iBATIS and connection pooling: . | Add the iBATIS and connection pooling dependencies to your pom.xml file: ```xml | . org.mybatis mybatis 3.5.5 org.apache.commons commons-dbcp2 2.8.0 2. Create a configuration class to configure the data source and iBATIS SqlSessionFactory: ```java @Configuration public class MyBatisConfig { @Bean public DataSource dataSource() { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"username\"); dataSource.setPassword(\"password\"); dataSource.setInitialSize(5); dataSource.setMaxTotal(10); return dataSource; } @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); return sessionFactory.getObject(); } } . | Create a repository class to interact with the database using iBATIS: ```java @Repository public class UserRepository { | . private final SqlSession sqlSession; . @Autowired public UserRepository(SqlSession sqlSession) { this.sqlSession = sqlSession; } . public List findAll() { return sqlSession.selectList(\"findAllUsers\"); } } . 4. Create a service class to handle the business logic: ```java @Service public class UserService { private final UserRepository userRepository; @Autowired public UserService(UserRepository userRepository) { this.userRepository = userRepository; } public List&lt;User&gt; findAll() { return userRepository.findAll(); } } . | Finally, create a controller to handle HTTP requests: ```java @RestController public class UserController { | . private final UserService userService; . @Autowired public UserController(UserService userService) { this.userService = userService; } . @GetMapping(“/users”) public List findAll() { return userService.findAll(); } } . With this setup, each HTTP request will be executed in a separate iBATIS SqlSession, ensuring that each request is executed in isolation and avoiding any concurrency issues. The connection pool will manage a pool of database connections and ensure that each request is executed on Here's how you can define connection pooling in the above example code: 1. In the `MyBatisConfig` class, create a `DataSource` bean using Apache Commons DBCP's `BasicDataSource` class: ```java @Bean public DataSource dataSource() { BasicDataSource dataSource = new BasicDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"username\"); dataSource.setPassword(\"password\"); dataSource.setInitialSize(5); dataSource.setMaxTotal(10); return dataSource; } . | In the same MyBatisConfig class, use the DataSource bean to create a SqlSessionFactory bean: @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); return sessionFactory.getObject(); } . | . With these changes, the DataSource bean will be used to create the SqlSessionFactory bean, and the SqlSessionFactory bean will be used to create the SqlSession instances in the UserRepository class. The BasicDataSource class will manage the connection pool and ensure that each request is executed on a separate, dedicated connection. ",
    "url": "https://1001anjan.github.io/db-1-DataBase%20Session%20and%20Connection/",
    "relUrl": "/db-1-DataBase Session and Connection/"
  },"40": {
    "doc": "Health Check PostGress SQL",
    "title": "Health Check PostGress SQL",
    "content": "A health check in Spring Boot is a way to monitor the status of your application’s components and dependencies, such as a PostgreSQL database. To perform a health check on a PostgreSQL database, you can create a custom health indicator in your Spring Boot application that connects to the database and checks its status. Here is an example of how you could implement this: . | Add the following dependency to your build.gradle or pom.xml file to include the PostgreSQL JDBC driver: | . dependencies { implementation 'org.postgresql:postgresql:42.2.14' } . | Create a new class that implements the HealthIndicator interface: ```java import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; | . import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; . @Component public class PostgresHealthIndicator implements HealthIndicator { . @Override public Health health() { try { Class.forName(\"org.postgresql.Driver\"); Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost:5432/postgres\", \"postgres\", \"password\"); connection.close(); return Health.up().build(); } catch (ClassNotFoundException | SQLException e) { return Health.down().build(); } } } ``` . | In the health method, you can connect to the PostgreSQL database using the JDBC driver, and return a Health.up().build() if the connection is successful. If the connection fails, return Health.down().build() to indicate that the database is not healthy. | . You can access the health status of the database by visiting the /actuator/health endpoint in your application. Note: You should customize the JDBC connection string, username, and password in the code to match your PostgreSQL database configuration. ",
    "url": "https://1001anjan.github.io/db-1-Health%20Check%20PostGress%20SQL/",
    "relUrl": "/db-1-Health Check PostGress SQL/"
  },"41": {
    "doc": "DSA Easy Difficulty",
    "title": "DSA Easy Difficulty",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/difficulty-easy/",
    "relUrl": "/docs/DAS-Difficulty-Easy/difficulty-easy/"
  },"42": {
    "doc": "DSA Hard Difficulty",
    "title": "Difficulty Hard",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/DSA-Difficulty-Hard/difficulty-hard/#difficulty-hard",
    "relUrl": "/docs/DSA-Difficulty-Hard/difficulty-hard/#difficulty-hard"
  },"43": {
    "doc": "DSA Hard Difficulty",
    "title": "DSA Hard Difficulty",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/DSA-Difficulty-Hard/difficulty-hard/",
    "relUrl": "/docs/DSA-Difficulty-Hard/difficulty-hard/"
  },"44": {
    "doc": "DSA Medium Difficulty",
    "title": "Difficulty Medium",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Medium/difficulty-medium/#difficulty-medium",
    "relUrl": "/docs/DAS-Difficulty-Medium/difficulty-medium/#difficulty-medium"
  },"45": {
    "doc": "DSA Medium Difficulty",
    "title": "DSA Medium Difficulty",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Medium/difficulty-medium/",
    "relUrl": "/docs/DAS-Difficulty-Medium/difficulty-medium/"
  },"46": {
    "doc": "Easy Set 1",
    "title": "Easy Set 1",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/",
    "relUrl": "/docs/data-structure/ds-easy-set-1/"
  },"47": {
    "doc": "Easy Set 10",
    "title": "Easy Set 10",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-10",
    "relUrl": "/docs/data-structure/data-structure-easy-set-10"
  },"48": {
    "doc": "Easy Set 11",
    "title": "Easy Set 11",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-11",
    "relUrl": "/docs/data-structure/data-structure-easy-set-11"
  },"49": {
    "doc": "Easy Set 12",
    "title": "Easy Set 12",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-12",
    "relUrl": "/docs/data-structure/data-structure-easy-set-12"
  },"50": {
    "doc": "Easy Set 13",
    "title": "Easy Set 13",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-13",
    "relUrl": "/docs/data-structure/data-structure-easy-set-13"
  },"51": {
    "doc": "Easy Set 14",
    "title": "Easy Set 14",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-14",
    "relUrl": "/docs/data-structure/data-structure-easy-set-14"
  },"52": {
    "doc": "Easy Set 2",
    "title": "Easy Set 2",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-2",
    "relUrl": "/docs/data-structure/data-structure-easy-set-2"
  },"53": {
    "doc": "Easy Set 3",
    "title": "Easy Set 3",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-3",
    "relUrl": "/docs/data-structure/data-structure-easy-set-3"
  },"54": {
    "doc": "Easy Set 4",
    "title": "Easy Set 4",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-4",
    "relUrl": "/docs/data-structure/data-structure-easy-set-4"
  },"55": {
    "doc": "Easy Set 5",
    "title": "Easy Set 5",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-5",
    "relUrl": "/docs/data-structure/data-structure-easy-set-5"
  },"56": {
    "doc": "Easy Set 6",
    "title": "Easy Set 6",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-6",
    "relUrl": "/docs/data-structure/data-structure-easy-set-6"
  },"57": {
    "doc": "Easy Set 7",
    "title": "Easy Set 7",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-7",
    "relUrl": "/docs/data-structure/data-structure-easy-set-7"
  },"58": {
    "doc": "Easy Set 8",
    "title": "Easy Set 8",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-8",
    "relUrl": "/docs/data-structure/data-structure-easy-set-8"
  },"59": {
    "doc": "Easy Set 9",
    "title": "Easy Set 9",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-9",
    "relUrl": "/docs/data-structure/data-structure-easy-set-9"
  },"60": {
    "doc": "Hard Set 1",
    "title": "Data Structure Hard Set 1",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-hard-set-1/#data-structure-hard-set-1",
    "relUrl": "/docs/data-structure/ds-hard-set-1/#data-structure-hard-set-1"
  },"61": {
    "doc": "Hard Set 1",
    "title": "Hard Set 1",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-hard-set-1/",
    "relUrl": "/docs/data-structure/ds-hard-set-1/"
  },"62": {
    "doc": "Medium Set 1",
    "title": "Data Structure Medium Set 1",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-1/#data-structure-medium-set-1",
    "relUrl": "/docs/data-structure/ds-medium-set-1/#data-structure-medium-set-1"
  },"63": {
    "doc": "Medium Set 1",
    "title": "Medium Set 1",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-1/",
    "relUrl": "/docs/data-structure/ds-medium-set-1/"
  },"64": {
    "doc": "Medium Set 2",
    "title": "Data Structure Medium Set 2",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-2/#data-structure-medium-set-2",
    "relUrl": "/docs/data-structure/ds-medium-set-2/#data-structure-medium-set-2"
  },"65": {
    "doc": "Medium Set 2",
    "title": "Medium Set 2",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-2/",
    "relUrl": "/docs/data-structure/ds-medium-set-2/"
  },"66": {
    "doc": "Medium Set 3",
    "title": "Medium Set 3",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-3/",
    "relUrl": "/docs/data-structure/ds-medium-set-3/"
  },"67": {
    "doc": "Medium Set 4",
    "title": "Medium Set 4",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-4/",
    "relUrl": "/docs/data-structure/ds-medium-set-4/"
  },"68": {
    "doc": "Hazelcast",
    "title": "Quick Notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/hazelcast/#quick-notes",
    "relUrl": "/docs/SpringBoot/Hazelcast/hazelcast/#quick-notes"
  },"69": {
    "doc": "Hazelcast",
    "title": "Hazelcast",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Hazelcast/hazelcast/",
    "relUrl": "/docs/SpringBoot/Hazelcast/hazelcast/"
  },"70": {
    "doc": "Home",
    "title": "Learning with Anjan",
    "content": "Apply Dark Theme . All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. Have Some Fun Now Contact Me Find me on LinkedIn . ",
    "url": "https://1001anjan.github.io/#learning-with-anjan",
    "relUrl": "/#learning-with-anjan"
  },"71": {
    "doc": "Home",
    "title": "Have Some Fun",
    "content": "Hey.. There. It’s ME. Name toh upar dekha hoga. What can I do for YOU? or for ME? Technically it’s NOTHING… Humans are self+ish(oriented). But, . All leaders/politicians are not wrong. So, . KEEP LEARNING... KEEP LEARNING... KEEP LEARNING... Once you started to learn, You start to IMAGINE. Now, . KEEP IMAGINING... KEEP IMAGINING... KEEP IMAGINING... Once the World started to accept your frequencies. The MAGIC will happen. Till then, . KEEP BELIEVING... KEEP LISTINING... KEEP BELIEVING... KEEP LISTINING... And finally stay HAPPY, and Have SOME MORE FUN. Because, . The Circle will be maintained! You cant't Escape it. The Only Answer GOD Knows OR made by someone. ",
    "url": "https://1001anjan.github.io/#have-some-fun",
    "relUrl": "/#have-some-fun"
  },"72": {
    "doc": "Home",
    "title": "Now, take a Deep Breath. Sometimes we forget to do this.",
    "content": ". | Find my Android News APP on Google Play Store. ONE MORE LIGHT . | Try out my web app for Video, Audio, and Text messaging. iMeet . Do you like to offer some coffee? . | . ",
    "url": "https://1001anjan.github.io/#now-take-a-deep-breath-sometimes-we-forget-to-do-this",
    "relUrl": "/#now-take-a-deep-breath-sometimes-we-forget-to-do-this"
  },"73": {
    "doc": "Home",
    "title": "Contact",
    "content": "email: link2anjan@gmail.com location 1: Bangalore, India location 2: Kolkata, India location 3: Digha, India . ",
    "url": "https://1001anjan.github.io/#contact",
    "relUrl": "/#contact"
  },"74": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "https://1001anjan.github.io/",
    "relUrl": "/"
  },"75": {
    "doc": "Collection",
    "title": "Interview Preparation",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/java/interviews#interview-preparation",
    "relUrl": "/docs/java/interviews#interview-preparation"
  },"76": {
    "doc": "Collection",
    "title": "Collection",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/java/interviews",
    "relUrl": "/docs/java/interviews"
  },"77": {
    "doc": "Java",
    "title": "Java Quick Notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Java/java/#java-quick-notes",
    "relUrl": "/docs/Java/java/#java-quick-notes"
  },"78": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Java/java/",
    "relUrl": "/docs/Java/java/"
  },"79": {
    "doc": "Kafka",
    "title": "Application Development with Kafka",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Kafka/kafka/#application-development-with-kafka",
    "relUrl": "/docs/Kafka/kafka/#application-development-with-kafka"
  },"80": {
    "doc": "Kafka",
    "title": "Kafka",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Kafka/kafka/",
    "relUrl": "/docs/Kafka/kafka/"
  },"81": {
    "doc": "Kafka",
    "title": "Quick Notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/kafka/#quick-notes",
    "relUrl": "/docs/SpringBoot/Kafka/kafka/#quick-notes"
  },"82": {
    "doc": "Kafka",
    "title": "Kafka",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Kafka/kafka/",
    "relUrl": "/docs/SpringBoot/Kafka/kafka/"
  },"83": {
    "doc": "Scale microservice depending on cup utilization",
    "title": "kubernetes scale microservice depending on cup utilization",
    "content": "To scale a microservice based on CPU utilization in Kubernetes, you can use the Horizontal Pod Autoscaler (HPA) feature. The HPA will automatically adjust the number of replicas in a deployment based on observed CPU utilization. Here is a general process to set up HPA: . | Create a deployment that manages your microservice | Annotate the deployment with the target CPU utilization | Create a HorizontalPodAutoscaler object that references the deployment | Verify that the HPA is properly scaling the replicas of your deployment | . Here is an example YAML configuration for an HPA: . apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: my-microservice-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: my-microservice-deployment minReplicas: 1 maxReplicas: 10 metrics: - type: Resource resource: name: cpu targetAverageUtilization: 50 . In this example, the HPA will target a CPU utilization of 50% and scale the replicas of the deployment named “my-microservice-deployment” from a minimum of 1 replica to a maximum of 10 replicas. Here is a complete example of deploying a Docker image and auto-scaling based on CPU utilization using Kubernetes and YAML configurations: . | Deployment YAML: ```yaml apiVersion: apps/v1 kind: Deployment metadata: name: my-microservice-deployment spec: replicas: 1 selector: matchLabels: app: my-microservice template: metadata: labels: app: my-microservice spec: containers: . | name: my-microservice image: my-microservice:latest resources: requests: cpu: 100m ports: . | containerPort: 80 ``` | . | . | Horizontal Pod Autoscaler YAML: apiVersion: autoscaling/v2beta1 kind: HorizontalPodAutoscaler metadata: name: my-microservice-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: Deployment name: my-microservice-deployment minReplicas: 1 maxReplicas: 10 metrics: - type: Resource resource: name: cpu targetAverageUtilization: 50 . | Apply the configurations using the kubectl command line tool: kubectl apply -f deployment.yaml kubectl apply -f hpa.yaml . This will deploy your Docker image as a microservice and configure the HPA to monitor the CPU utilization of the deployment and adjust the number of replicas based on the target utilization. | . ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kube-0-how%20to%20scale%20microservice/#kubernetes-scale-microservice-depending-on-cup-utilization",
    "relUrl": "/docs/Kubernetese/kube-0-how%20to%20scale%20microservice/#kubernetes-scale-microservice-depending-on-cup-utilization"
  },"84": {
    "doc": "Scale microservice depending on cup utilization",
    "title": "Scale microservice depending on cup utilization",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kube-0-how%20to%20scale%20microservice/",
    "relUrl": "/docs/Kubernetese/kube-0-how%20to%20scale%20microservice/"
  },"85": {
    "doc": "Getting Started Spring Reactor",
    "title": "Scale postgres DB in kubernetes",
    "content": "In Kubernetes, you can scale a PostgreSQL database by increasing or decreasing the number of replicas in a StatefulSet. This allows you to handle an increase in traffic and number of connections by creating additional replicas of your database. To achieve this, you need to define a Horizontal Pod Autoscaler (HPA) that monitors the number of connections to the database and scales the number of replicas accordingly. The HPA will use metrics like CPU utilization, memory usage, and database connection count to determine when to scale. For example, if you set the HPA to increase the number of replicas when the number of database connections exceeds a certain threshold, the HPA will create additional replicas of the PostgreSQL database to handle the increased traffic. This way, you can ensure that your database is able to handle an increase in the number of connections and traffic, without any downtime or disruption to your application. Here is an example YAML file to deploy a PostgreSQL database in Kubernetes using a StatefulSet and HPA: . apiVersion: apps/v1 kind: StatefulSet metadata: name: postgres spec: selector: matchLabels: app: postgres serviceName: postgres-svc replicas: 1 template: metadata: labels: app: postgres spec: containers: - name: postgres image: postgres:12.4 ports: - containerPort: 5432 env: - name: POSTGRES_USER value: \"postgres\" - name: POSTGRES_PASSWORD value: \"postgres\" - name: POSTGRES_DB value: \"postgres\" volumeMounts: - name: data mountPath: /var/lib/postgresql/data volumeClaimTemplates: - metadata: name: data annotations: volume.beta.kubernetes.io/storage-class: \"standard\" spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 2Gi --- apiVersion: autoscaling/v2beta2 kind: HorizontalPodAutoscaler metadata: name: postgres-hpa spec: scaleTargetRef: apiVersion: apps/v1 kind: StatefulSet name: postgres minReplicas: 1 maxReplicas: 5 metrics: - type: Object object: target: apiVersion: extensions/v1beta1 kind: Ingress name: postgres-ingress metricName: postgres-connections targetValue: 1000 . ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kube-1-kubernetese%20scale%20postgress/#scale-postgres-db-in-kubernetes",
    "relUrl": "/docs/Kubernetese/kube-1-kubernetese%20scale%20postgress/#scale-postgres-db-in-kubernetes"
  },"86": {
    "doc": "Getting Started Spring Reactor",
    "title": "Getting Started Spring Reactor",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kube-1-kubernetese%20scale%20postgress/",
    "relUrl": "/docs/Kubernetese/kube-1-kubernetese%20scale%20postgress/"
  },"87": {
    "doc": "Scale aws RDS",
    "title": "Scale aws RDS",
    "content": "You can scale an Amazon RDS instance depending on the number of connections by using Amazon CloudWatch Alarms and Amazon RDS Auto Scaling. Here’s how to set it up: . | Create a CloudWatch Alarm to monitor the number of connections: In the CloudWatch console, create an alarm that triggers when the number of connections to the RDS instance exceeds a specified threshold. | Create an RDS Auto Scaling policy: In the RDS console, create an RDS Auto Scaling policy that specifies the desired minimum and maximum capacity for the RDS instance. | Link the CloudWatch Alarm and RDS Auto Scaling policy: In the RDS Auto Scaling policy, link the CloudWatch Alarm to the RDS Auto Scaling policy. | Monitor the RDS instance: In the CloudWatch console, monitor the number of connections to the RDS instance. When the number of connections exceeds the threshold, the CloudWatch Alarm triggers and the RDS Auto Scaling policy222222222 scales the RDS instance up or down to meet the desired capacity. | . By using this setup, you can ensure that your RDS instance can handle an increase in the number of connections, without any downtime or disruption to your application. Here’s an example of how you can write a Terraform script to scale an Amazon RDS instance depending on the number of connections: . provider \"aws\" { region = \"us-west-2\" } module \"rds_instance\" { source = \"terraform-aws-modules/rds/aws\" version = \"5.6.0\" identifier = \"mydb\" engine = \"postgres\" size = \"db.t2.micro\" max_capacity = 5 min_capacity = 1 alarm_actions = [module.scale_policy.arn] vpc_security_group_ids = [aws_security_group.rds.id] } module \"scale_policy\" { source = \"terraform-aws-modules/appautoscaling/aws\" version = \"4.0.0\" name = \"rds-instance-scale-policy\" policy_type = \"TargetTrackingScaling\" service_namespace = \"rds\" resource_id = aws_db_instance.rds.id scalable_dimension = \"rds:dbInstance:ReadReplicaCount\" target_tracking_config = { target_value = 1000 predefined_metric_specification = { predefined_metric_type = \"RDSReaderAverageConnections\" } } } resource \"aws_security_group\" \"rds\" { name = \"rds-security-group\" description = \"Allow all inbound traffic\" ingress { from_port = 0 to_port = 65535 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] } } . This Terraform script creates an Amazon RDS instance and sets up the necessary scaling policy using the AWS Application Auto Scaling module. The rds_instance module sets the minimum and maximum capacity for the RDS instance, and links the scaling policy to the CloudWatch Alarm using the alarm_actions argument. The scale_policy module creates the scaling policy and sets the target value for the number of connections. The Terraform script also creates a security group that allows all inbound traffic to the RDS instance. ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kube-2-scale%20aws%20rds/",
    "relUrl": "/docs/Kubernetese/kube-2-scale%20aws%20rds/"
  },"88": {
    "doc": "Kubernetes",
    "title": "Application Development with Kubernetes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kubernetese/#application-development-with-kubernetes",
    "relUrl": "/docs/Kubernetese/kubernetese/#application-development-with-kubernetes"
  },"89": {
    "doc": "Kubernetes",
    "title": "Kubernetes",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Kubernetese/kubernetese/",
    "relUrl": "/docs/Kubernetese/kubernetese/"
  },"90": {
    "doc": "Max Points on a Line",
    "title": "Max Points on a Line",
    "content": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line. Example 1: . Input: points = [[1,1],[2,2],[3,3]] Output: 3 . Example 2: . Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]] Output: 4 . Constraints: . | 1 &lt;= points.length &lt;= 300 | points[i].length == 2 | -10^4 &lt;= xi, yi &lt;= 10^4 | All the points are unique. | . Solution: . In this example, three interesting lines contain the point (4,1)(4, 1)(4,1) – the first line contains the points (4,1)(4, 1)(4,1) and (5,3)(5, 3)(5,3), the second one contains (4,1)(4, 1)(4,1), (3,2)(3, 2)(3,2), (2,3)(2, 3)(2,3) and (1,4)(1, 4)(1,4) and the third one contains (4,1)(4, 1)(4,1) and (1,1)(1, 1)(1,1). The angles between the X axis and the vectors from (4,1)(4, 1)(4,1) to the points (3,2)(3, 2)(3,2), (2,3)(2, 3)(2,3) and (1,4)(1, 4)(1,4) are equal (denoted with the green arc in the picture). In other words, all these vectors have the same atan2. On the other side, the vector from (4,1)(4, 1)(4,1) to (5,3)(5, 3)(5,3) has a different atan2 (denoted with the red arc). From this example, one can make the following observation: . We call a point outside if it belongs to a line, but it doesn’t lie between any other two points on this line (it’s one of the edges). The vectors from an outside point to all other points on the line have the same atan2. Now the problem reduces to the following: . For a fixed point points[i], consider all other points points[j] and calculate the atan2 for each vector points[j] - points[i] (the vector with the magnitudes (points[j].x - points[i].x, points[j].y - points[i].y)). Then find the maximum number of times some angle value occurs among the calculated values. One can use a hash map for this. class Solution { public int maxPoints(int[][] points) { int n = points.length; if(n == 1) return 1; int result = 2; for(int i = 0; i &lt; n; i++){ Map&lt;Double, Integer&gt; map = new HashMap&lt;&gt;(); for(int j = 0; j &lt; n; j++){ if(i != j){ map.merge(Math.atan2(points[i][1] - points[j][1], points[i][0] - points[j][0]), 1, Integer::sum); } } result = Math.max(result, Collections.max(map.values()) + 1); } return result; } } . Complexity Analysis . | Time complexity: O(n^2) | Space complexity: O(n). We store O(n) values of atan2 in the hash map. | . ",
    "url": "https://1001anjan.github.io/problem-1-Max%20Points%20on%20a%20Line/",
    "relUrl": "/problem-1-Max Points on a Line/"
  },"91": {
    "doc": "Odd Even Linked List",
    "title": "Odd Even Linked List",
    "content": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. Example 1: . Input: head = [1,2,3,4,5] Output: [1,3,5,2,4] . Example 2: . Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] . Constraints: . | The number of nodes in the linked list is in the range [0, 104]. | -10^6 &lt;= Node.val &lt;= 10^6 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode oddEvenList(ListNode head) { if(head == null) return head; ListNode oddList, evenList, ptr, qtr; // create first node oddList = ptr = head; head = head.next; if(head == null) return oddList; evenList = qtr = head; head = head.next; boolean f = true; while(head != null){ if(f){ ptr.next = head; ptr = head; }else{ qtr.next = head; qtr = head; } head = head.next; f = !f; } ptr.next = evenList; qtr.next = null; return oddList; } } . ",
    "url": "https://1001anjan.github.io/problem-1-Odd%20Even%20Linked%20List/",
    "relUrl": "/problem-1-Odd Even Linked List/"
  },"92": {
    "doc": "Two Sum",
    "title": "1. Two Sum",
    "content": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: . Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: . Input: nums = [3,2,4], target = 6 Output: [1,2] . Example 3: . Input: nums = [3,3], target = 6 Output: [0,1] . Constraints: . 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 . Only one valid answer exists. Solution . Time Complexity: O(n) Space Complexity: O(n) . class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; map = new HashMap(); int [] result = new int[2]; result[0] = -1; result[1] = -1; for(int i=0; i&lt;nums.length; i++){ if(map.containsKey(target - nums[i])){ result[0] = map.get(target - nums[i]); result[1] = i; }else{ map.put(nums[i],i); } } return result; } } . Related solution . Since elements are not sorted, we can sort the list in O(nlog(n)) complexity. Space complexity O(1) . class Solution { public boolean twoSum(int[] nums, int target) { Arrays.sort(nums); int i = 0; int j = nums.length - 1; while(i&lt;j){ if(nums[i] + nums[j] == target){ return true; } if(nums[i] + nums[j] &gt; target){ j--; }else{ i++; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-1-two-sum/#1-two-sum",
    "relUrl": "/problem-1-two-sum/#1-two-sum"
  },"93": {
    "doc": "Two Sum",
    "title": "Two Sum",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-1-two-sum/",
    "relUrl": "/problem-1-two-sum/"
  },"94": {
    "doc": "3Sum Closest",
    "title": "3Sum Closest",
    "content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 1: . Input: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Example 2: . Input: nums = [0,0,0], target = 1 Output: 0 Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0). Constraints: . | 3 &lt;= nums.length &lt;= 500 | -1000 &lt;= nums[i] &lt;= 1000 | -10^4 &lt;= target &lt;= 10^4 | . Solution: . class Solution { public int threeSumClosest(int[] nums, int target) { int diff = Integer.MAX_VALUE, z = nums.length - 1; int ans = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 1 &amp;&amp; diff != 0; i++){ int l = i + 1, u = z; while(l &lt; u){ int s = nums[i] + nums[l] + nums[u]; int d = target - s; if(Math.abs(d) &lt; Math.abs(diff)){ diff = d; ans = s; } if(s &lt; target){ l++; }else{ u--; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-10-3Sum%20Closest/",
    "relUrl": "/problem-10-3Sum Closest/"
  },"95": {
    "doc": "Search Insert Position",
    "title": "Search Insert Position",
    "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: . Input: nums = [1,3,5,6], target = 5 Output: 2 . Example 2: . Input: nums = [1,3,5,6], target = 2 Output: 1 . Example 3: . Input: nums = [1,3,5,6], target = 7 Output: 4 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums contains distinct values sorted in ascending order. | -104 &lt;= target &lt;= 104 | . Solution . class Solution { public int searchInsert(int[] nums, int target) { if(nums == null || nums.length == 0) return 0; int i = 0; // start index int j = nums.length-1; // last index while(i&lt;=j){ int mid = (i + j)/2; // middle index if(nums[mid] == target) return mid; // stop iterating when get target in our array else if(nums[mid] &lt; target) i = mid + 1; // goto right-half in array else j = mid - 1; // goto left half in array } return i; } } . ",
    "url": "https://1001anjan.github.io/problem-10-search-insert-position/",
    "relUrl": "/problem-10-search-insert-position/"
  },"96": {
    "doc": "House Robber II",
    "title": "House Robber II",
    "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: . Input: nums = [2,3,2] Output: 3 Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2: . Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 3: . Input: nums = [1,2,3] Output: 3 . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int rob(int[] nums) { int n = nums.length; if (n == 1) { return nums[0]; } return Math.max(robFrom(nums, 0, n - 2), robFrom(nums, 1, n - 1)); } public int robFrom(int[] nums, int lo, int hi) { int currMax = 0; int prevMax = 0; for (int i = lo; i &lt;= hi; i++) { int temp = currMax; currMax = Math.max(currMax, prevMax + nums[i]); prevMax = temp; } return currMax; } } . ",
    "url": "https://1001anjan.github.io/problem-100-House%20Robber%20II/",
    "relUrl": "/problem-100-House Robber II/"
  },"97": {
    "doc": "Reverse Words in a String III",
    "title": "Reverse Words in a String III",
    "content": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: . Input: s = \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" . Example 2: . Input: s = \"God Ding\" Output: \"doG gniD\" . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | s contains printable ASCII characters. | s does not contain any leading or trailing spaces. | There is at least one word in s. | All the words in s are separated by a single space. | . Solution: . class Solution { public String reverseWords(String s) { char[] str = s.toCharArray(); int i = 0; while(i&lt;str.length){ if(str[i] != ' '){ int l = i; int u = i; while(u&lt;str.length){ if(str[u] == ' ') break; u++; } i = u; u--; while(l&lt;u){ char ch = str[l]; str[l] = str[u]; str[u] = ch; l++; u--; } }else i++; } return new String(str); } } . public class Solution { public String reverseWords(String s) { String words[] = s.split(\" \"); StringBuilder res=new StringBuilder(); for (String word: words) res.append(new StringBuffer(word).reverse().toString() + \" \"); return res.toString().trim(); } } . ",
    "url": "https://1001anjan.github.io/problem-100-Reverse-Words-in-a-String-III/",
    "relUrl": "/problem-100-Reverse-Words-in-a-String-III/"
  },"98": {
    "doc": "Combination Sum III",
    "title": "Combination Sum III",
    "content": "Find all valid combinations of k numbers that sum up to n such that the following conditions are true: . | Only numbers 1 through 9 are used. | Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order. | . Example 1: . Input: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2: . Input: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3: . Input: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination. Constraints: . | 2 &lt;= k &lt;= 9 | 1 &lt;= n &lt;= 60 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); proceesCombinationSum3(1, k, n, ans, new ArrayList&lt;&gt;()); return ans; } private void proceesCombinationSum3(int start, int k, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; k || target &lt; 0) return; if(list.size() == k &amp;&amp; target == 0){ ans.add(new ArrayList&lt;&gt;(list)); } for(int i = start; i &lt; 10; i++){ list.add(i); proceesCombinationSum3(i + 1, k, target - i, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-101-Combination%20Sum%20III/",
    "relUrl": "/problem-101-Combination Sum III/"
  },"99": {
    "doc": "Maximum Depth of N-ary Tree",
    "title": "Maximum Depth of N-ary Tree",
    "content": "Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: . Input: root = [1,null,3,2,4,null,5,6] Output: 3 . Example 2: . Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 . Constraints: . | The total number of nodes is in the range [0, 104]. | The depth of the n-ary tree is less than or equal to 1000. | . Solution: . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; */ class Solution { public int maxDepth(Node root) { if(root == null) return 0; int dp = 1; for(Node node : root.children){ dp = Math.max(dp, maxDepth(node) + 1); } return dp; } } . ",
    "url": "https://1001anjan.github.io/problem-101-Maximum-Depth-of-N-ary-Tree/",
    "relUrl": "/problem-101-Maximum-Depth-of-N-ary-Tree/"
  },"100": {
    "doc": "Array Partition I",
    "title": "Array Partition I",
    "content": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), …, (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. Example 1: . Input: nums = [1,4,3,2] Output: 4 Explanation: All possible pairings (ignoring the ordering of elements) are: 1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4 So the maximum possible sum is 4. Example 2: . Input: nums = [6,2,6,5,1,2] Output: 9 Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9. Constraints: . | 1 &lt;= n &lt;= 104 | nums.length == 2 * n | -104 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int arrayPairSum(int[] nums) { int max = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i = i+2) max += nums[i]; return max; } } . Counting sort : . https://leetcode.com/problems/array-partition-i/solution/ . class Solution { final static int K = 10000; public int arrayPairSum(int[] nums) { // Store the frequency of each element int[] elementToCount = new int[2 * K + 1]; for (int element : nums) { // Add K to element to offset negative values elementToCount[element + K]++; } // Initialize sum to zero int maxSum = 0; boolean isEvenIndex = true; for (int element = 0; element &lt;= 2 * K; element++) { while (elementToCount[element] &gt; 0) { // Add element if it is at even position maxSum += (isEvenIndex ? element - K : 0); // Flip the value (one to zero or zero to one) isEvenIndex = !isEvenIndex; // Decrement the frequency count elementToCount[element]--; } } return maxSum; } } . ",
    "url": "https://1001anjan.github.io/problem-102-Array-Partition-I/",
    "relUrl": "/problem-102-Array-Partition-I/"
  },"101": {
    "doc": "Count Complete Tree Nodes",
    "title": "Count Complete Tree Nodes",
    "content": "Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity. Example 1: . Input: root = [1,2,3,4,5,6] Output: 6 . Example 2: . Input: root = [] Output: 0 . Example 3: . Input: root = [1] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [0, 5 * 10^4]. | 0 &lt;= Node.val &lt;= 5 * 10^4 | The tree is guaranteed to be complete. | . Solution: . class Solution { public int countNodes(TreeNode root) { // edge conditions if (root == null) { return 0; } int left = helper1(root); int right = helper2(root); if (left == right) { return (1&lt;&lt;left)-1; } return countNodes(root.left) + countNodes(root.right) + 1; } private int helper1(TreeNode root) { if (root == null) { return 0; } return 1 + helper1(root.left); } private int helper2(TreeNode root) { if (root == null) { return 0; } return 1 + helper2(root.right); } } . ",
    "url": "https://1001anjan.github.io/problem-102-Count%20Complete%20Tree%20Nodes/",
    "relUrl": "/problem-102-Count Complete Tree Nodes/"
  },"102": {
    "doc": "Binary Tree Tilt",
    "title": "Binary Tree Tilt",
    "content": "Given the root of a binary tree, return the sum of every tree node’s tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child. Example 1: . Input: root = [1,2,3] Output: 1 Explanation: Tilt of node 2 : |0-0| = 0 (no children) Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3) Sum of every tilt : 0 + 0 + 1 = 1 . Example 2: . Input: root = [4,2,9,3,5,null,7] Output: 15 Explanation: Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 5 : |0-0| = 0 (no children) Tilt of node 7 : |0-0| = 0 (no children) Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5) Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7) Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16) Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15 . Example 3: . Input: root = [21,7,14,1,1,2,2,3,3] Output: 9 . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int totalTilt = 0; public int findTilt(TreeNode root) { this.totalTilt = 0; calculateTilt(root); return this.totalTilt; } public int calculateTilt(TreeNode root){ if(root == null) return 0; int leftTilt = calculateTilt(root.left); int rightTilt = calculateTilt(root.right); this.totalTilt += Math.abs(leftTilt - rightTilt); // return the sum of values starting from this node. return root.val + leftTilt + rightTilt; } } . ",
    "url": "https://1001anjan.github.io/problem-103-Binary-Tree-Tilt/",
    "relUrl": "/problem-103-Binary-Tree-Tilt/"
  },"103": {
    "doc": "Majority Element II",
    "title": "Majority Element II",
    "content": "Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Example 1: . Input: nums = [3,2,3] Output: [3] . Example 2: . Input: nums = [1] Output: [1] . Example 3: . Input: nums = [1,2] Output: [1,2] . Constraints: . | 1 &lt;= nums.length &lt;= 5 * 10^4 | -10^9 &lt;= nums[i] &lt;= 10^9 . | Follow up: Could you solve the problem in linear time and in O(1) space? | . Solution: . class Solution { public List&lt;Integer&gt; majorityElement(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(nums); int t = nums.length / 3; int c = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i - 1] == nums[i]) c++; else{ if(c &gt; t) ans.add(nums[i - 1]); c = 1; } } if(c &gt; t) ans.add(nums[nums.length - 1]); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-103-Majority%20Element%20II/",
    "relUrl": "/problem-103-Majority Element II/"
  },"104": {
    "doc": "Kth Smallest Element in a BST",
    "title": "Kth Smallest Element in a BST",
    "content": "Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree. Example 1: . Input: root = [3,1,4,null,2], k = 1 Output: 1 . Example 2: . Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 . Constraints: . | The number of nodes in the tree is n. | 1 &lt;= k &lt;= n &lt;= 104 | 0 &lt;= Node.val &lt;= 104 . | Follow up: If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize? | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int kthSmallest(TreeNode root, int k) { List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); inoderTraverse(root, list); return list.get(k - 1); } public void inoderTraverse(TreeNode root, List&lt;Integer&gt; list){ if(root == null) return; inoderTraverse(root.left, list); list.add(root.val); inoderTraverse(root.right, list); } } . ",
    "url": "https://1001anjan.github.io/problem-104-Kth%20Smallest%20Element%20in%20a%20BST/",
    "relUrl": "/problem-104-Kth Smallest Element in a BST/"
  },"105": {
    "doc": "Reshape the Matrix",
    "title": "Reshape the Matrix",
    "content": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: . Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] . Example 2: . Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]] . Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= m, n &lt;= 100 | -1000 &lt;= mat[i][j] &lt;= 1000 | 1 &lt;= r, c &lt;= 300 | . Solution: . class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int m = mat.length; int n = mat[0].length; if(m*n != r*c) return mat; int[][] result = new int[r][c]; int k,l; k = l = 0; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ result[k][l] = mat[i][j]; l++; if(l == c){ l = 0; k++; } } } return result; } } . class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int m = mat.length; int n = mat[0].length; if((m*n)!=(r*c)) return mat; int reshape[][] = new int[r][c]; for(int i=0;i&lt;(m*n);i++){ reshape[i/c][i%c]=mat[i/n][i%n]; } return reshape; } } . ",
    "url": "https://1001anjan.github.io/problem-104-Reshape-the-Matrix/",
    "relUrl": "/problem-104-Reshape-the-Matrix/"
  },"106": {
    "doc": "Lowest Common Ancestor of a Binary Search Tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” . Example 1: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: . Input: root = [2,1], p = 2, q = 1 Output: 2 . Constraints: . | The number of nodes in the tree is in the range [2, 10^5]. | -10^9 &lt;= Node.val &lt;= 10^9 | All Node.val are unique. | p != q | p and q will exist in the BST. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val){ return lowestCommonAncestor(root.left, p, q); }else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val){ return lowestCommonAncestor(root.right, p, q); }else{ return root; } } } . ",
    "url": "https://1001anjan.github.io/problem-105-Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree/",
    "relUrl": "/problem-105-Lowest Common Ancestor of a Binary Search Tree/"
  },"107": {
    "doc": "Subtree of Another Tree",
    "title": "Subtree of Another Tree",
    "content": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself. Example 1: . Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true . Example 2: . Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false . Constraints: . | The number of nodes in the root tree is in the range [1, 2000]. | The number of nodes in the subRoot tree is in the range [1, 1000]. | -104 &lt;= root.val &lt;= 104 | -104 &lt;= subRoot.val &lt;= 104 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s3 = new Stack&lt;&gt;(); s1.push(root); int count = countNode(subRoot); System.out.println(\"Count: \"+count); while(!s1.isEmpty()){ TreeNode node = s1.pop(); if(node.val == subRoot.val){ TreeNode sub = subRoot; s2.clear(); s3.clear(); s2.push(node); s3.push(sub); int c = 0; while(!s3.isEmpty()){ TreeNode n1 = s3.pop(); if(s2.isEmpty()) break; TreeNode n2 = s2.pop(); if(n1.val != n2.val) break; if(n1.left != null){ if(n2.left == null) break; s3.push(n1.left); s2.push(n2.left); } if(n1.left == null &amp;&amp; n2.left != null) break; if(n1.right != null){ if(n2.right == null) break; s3.push(n1.right); s2.push(n2.right); } if(n1.right == null &amp;&amp; n2.right != null) break; c++; } if(c == count) return true; } if(node.left != null) s1.push(node.left); if(node.right != null) s1.push(node.right); } return false; } public int countNode(TreeNode head){ if(head == null) return 0; return 1 + countNode(head.left) + countNode(head.right); } } . Hash solution . The main idea of this solution is that every subtree of root can be hashed. The general technique is called Merkle Tree Hashing. Consider a tree with a root value of v. Recursively hash the left and right subtree (storing their hashes in a global list - in my code the ArrayList hashes). In my code, my hash combiner function is (v + LB + R * BB)%M. | B is the base of the hash, M is the mod of the hash. | L and R are the hashes of the left and right subtrees, which can be calculated recursively via DFS. After we compute the hashes of all subtrees of root, we can check to see if any of them equal the hash of subRoot. | . The time complexity is O(N) because our DFS processes each node of the tree. At each step, the actual hashing is O(1). The space complexity is O(N) because we store the hashes of each node. class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { Merkle mht = new Merkle(root); long H = (new Merkle(subRoot)).hash(); for (long h: mht.hashes) { if (h==H) return true; } return false; } static class Merkle { long B = 20051L; long M = 1000000007L; ArrayList&lt;Long&gt; hashes; public Merkle(TreeNode t) { hashes = new ArrayList&lt;Long&gt;(); dfs(t); } //hash of the entire tree long hash() { return hashes.get(hashes.size()-1); } //left is *B, right is *B^2 long dfs(TreeNode t) { long H = t.val+10004; if (t.left != null) { H += dfs(t.left)*B; } if (t.right != null) { H += dfs(t.right)*B*B; } H %= M; hashes.add(H); return H; } } } . Recursive . class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if(root == null){ return false; }else if(isSameTree(root, subRoot)){ //checking if they overlap each other or not return true; }else if(isSubtree(root.left, subRoot)){ //checking on left child of root if subTree matches there return true; }else{ //checking on right child of root if subTree matches there return isSubtree(root.right, subRoot); } } public boolean isSameTree(TreeNode root, TreeNode subRoot){ if(root == null || subRoot == null){ return root == null &amp;&amp; subRoot == null; }else if(root.val == subRoot.val){ //if val is same at both nodes, then only we will check forward if(isSameTree(root.left, subRoot.left) == false){ //now checking left part of both of them return false; } //now checking right part of both of them return isSameTree(root.right, subRoot.right); }else{ return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-105-Subtree-of-Another-Tree/",
    "relUrl": "/problem-105-Subtree-of-Another-Tree/"
  },"108": {
    "doc": "Lowest Common Ancestor of a Binary Tree",
    "title": "Lowest Common Ancestor of a Binary Tree",
    "content": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” . Example 1: . Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2: . Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3: . Input: root = [1,2], p = 1, q = 2 Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 10^5]. | -10^9 &lt;= Node.val &lt;= 10^9 | All Node.val are unique. | p != q | p and q will exist in the tree. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null &amp;&amp; right != null) return root; if(left == null) return right; if(right == null) return left; return null; } } . ",
    "url": "https://1001anjan.github.io/problem-106-Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree/",
    "relUrl": "/problem-106-Lowest Common Ancestor of a Binary Tree/"
  },"109": {
    "doc": "N-ary Tree Preorder Traversal",
    "title": "N-ary Tree Preorder Traversal",
    "content": "Given the root of an n-ary tree, return the preorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples) . Example 1: . Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | 0 &lt;= Node.val &lt;= 104 | The height of the n-ary tree is less than or equal to 1000. | . Solution . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; */ class Solution { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) { if(root == null) return list; list.add(root.val); for(Node n : root.children) preorder(n); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-106-N-ary-Tree-Preorder-Traversal/",
    "relUrl": "/problem-106-N-ary-Tree-Preorder-Traversal/"
  },"110": {
    "doc": "Longest Harmonious Subsequence",
    "title": "Longest Harmonious Subsequence",
    "content": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1. Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences. A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Example 1: . Input: nums = [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3]. Example 2: . Input: nums = [1,2,3,4] Output: 2 . Example 3: . Input: nums = [1,1,1,1] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 2 * 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution: . public class Solution { public int findLHS(int[] nums) { HashMap &lt; Integer, Integer &gt; map = new HashMap &lt; &gt; (); int res = 0; for (int num: nums) { map.put(num, map.getOrDefault(num, 0) + 1); } for (int key: map.keySet()) { if (map.containsKey(key + 1)) res = Math.max(res, map.get(key) + map.get(key + 1)); } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-107-Longest-Harmonious-Subsequence/",
    "relUrl": "/problem-107-Longest-Harmonious-Subsequence/"
  },"111": {
    "doc": "Product of Array Except Self",
    "title": "Product of Array Except Self",
    "content": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i]. The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. You must write an algorithm that runs in O(n) time and without using the division operation. Example 1: . Input: nums = [1,2,3,4] Output: [24,12,8,6] . Example 2: . Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] . Constraints: . | 2 &lt;= nums.length &lt;= 10^5 | -30 &lt;= nums[i] &lt;= 30 | The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. | . Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.) . Solution: . class Solution { public int[] productExceptSelf(int[] nums) { int pod = 1; int zero = 0; for(int n : nums){ if(n == 0) zero++; else pod *= n; if(zero &gt; 1) break; } if(zero &gt; 1){ for(int i = 0; i &lt; nums.length; i++){ nums[i] = 0; } return nums; } if(zero == 1){ for(int i = 0; i &lt; nums.length; i++){ if(nums[i] == 0) nums[i] = pod; else nums[i] = 0; } return nums; } for(int i = 0; i &lt; nums.length; i++){ nums[i] = pod / nums[i]; } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-107-Product%20of%20Array%20Except%20Self/",
    "relUrl": "/problem-107-Product of Array Except Self/"
  },"112": {
    "doc": "Construct String from Binary Tree",
    "title": "Construct String from Binary Tree",
    "content": "Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: . Input: root = [1,2,3,4] Output: \"1(2(4))(3)\" Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\" . Example 2: . Input: root = [1,2,3,null,4] Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public String tree2str(TreeNode root) { if(root == null) return \"\"; if(root.left == null &amp;&amp; root.right == null) return root.val + \"\"; if(root.right == null) return root.val+\"(\"+tree2str(root.left)+\")\"; return root.val+\"(\"+tree2str(root.left)+\")(\"+tree2str(root.right)+\")\"; } } . Non-recursive: . public class Solution { public String tree2str(TreeNode t) { if (t == null) return \"\"; Stack &lt; TreeNode &gt; stack = new Stack &lt; &gt; (); stack.push(t); Set &lt; TreeNode &gt; visited = new HashSet &lt; &gt; (); StringBuilder s = new StringBuilder(); while (!stack.isEmpty()) { t = stack.peek(); if (visited.contains(t)) { stack.pop(); s.append(\")\"); } else { visited.add(t); s.append(\"(\" + t.val); if (t.left == null &amp;&amp; t.right != null) s.append(\"()\"); if (t.right != null) stack.push(t.right); if (t.left != null) stack.push(t.left); } } return s.substring(1, s.length() - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-108-Construct-String-from-Binary-Tree/",
    "relUrl": "/problem-108-Construct-String-from-Binary-Tree/"
  },"113": {
    "doc": "Search a 2D Matrix II",
    "title": "Search a 2D Matrix II",
    "content": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: . | Integers in each row are sorted in ascending from left to right. | Integers in each column are sorted in ascending from top to bottom. | . Example 1: . Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5 Output: true . Example 2: . Input: matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20 Output: false . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= n, m &lt;= 300 | -10^9 &lt;= matrix[i][j] &lt;= 10^9 | All the integers in each row are sorted in ascending order. | All the integers in each column are sorted in ascending order. | -10^9 &lt;= target &lt;= 10^9 | . Solution: . class Solution { public boolean searchMatrix(int[][] matrix, int target) { int row = 0; int col = matrix[0].length - 1; while(col &gt;= 0 &amp;&amp; row &lt; matrix.length){ if(matrix[row][col] == target) return true; if(matrix[row][col] &gt; target){ if(col &gt;= 0) col --; else row ++; }else{ if(row &lt; matrix.length){ row ++; }else{ col --; } } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-108-Search%20a%202D%20Matrix%20II/",
    "relUrl": "/problem-108-Search a 2D Matrix II/"
  },"114": {
    "doc": "Count Primes",
    "title": "Count Primes",
    "content": "Given an integer n, return the number of prime numbers that are strictly less than n. Example 1: . Input: n = 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Example 2: . Input: n = 0 Output: 0 . Example 3: . Input: n = 1 Output: 0 . Constraints: . | 0 &lt;= n &lt;= 5 * 10^6 | . Solution: . class Solution { public int countPrimes(int n) { boolean[] notPrime = new boolean[n]; int count = 0; for(int i = 2; i &lt; n; i++){ if(notPrime[i] == false){ count ++; for(int j = 2; (i * j) &lt; n ; j++){ notPrime[i * j] = true; } } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-109-Count%20Primes/",
    "relUrl": "/problem-109-Count Primes/"
  },"115": {
    "doc": "Merge Two Binary Trees",
    "title": "Merge Two Binary Trees",
    "content": "You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. Example 1: . Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] . Example 2: . Input: root1 = [1], root2 = [1,2] Output: [2,2] . Constraints: . | The number of nodes in both trees is in the range [0, 2000]. | -104 &lt;= Node.val &lt;= 104 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if(root1 == null) return root2; if(root2 == null) return root1; root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } } . Non-recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if(root1 == null) return root2; if(root2 == null) return root1; Stack&lt;TreeNode&gt; s1 = new Stack&lt;TreeNode&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;TreeNode&gt;(); TreeNode h1, h2; h1 = root1; h2 = root2; s1.push(h1); s2.push(h2); while(!s1.isEmpty() &amp;&amp; !s2.isEmpty()){ h1 = s1.pop(); h2 = s2.pop(); h1.val = h1.val + h2.val; if(h1.left != null &amp;&amp; h2.left != null){ s1.push(h1.left); s2.push(h2.left); } if(h1.right !=null &amp;&amp; h2.right != null){ s1.push(h1.right); s2.push(h2.right); } if(h1.left == null &amp;&amp; h2.left != null){ h1.left = h2.left; h2.left = null; } if(h1.right == null &amp;&amp; h2.right != null){ h1.right = h2.right; h2.right = null; } } return root1; } } . ",
    "url": "https://1001anjan.github.io/problem-109-Merge-Two-Binary-Trees/",
    "relUrl": "/problem-109-Merge-Two-Binary-Trees/"
  },"116": {
    "doc": "Letter Combinations of a Phone Number",
    "title": "Letter Combinations of a Phone Number",
    "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1: . Input: digits = \"23\" Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] . Example 2: . Input: digits = \"\" Output: [] . Example 3: . Input: digits = \"2\" Output: [\"a\",\"b\",\"c\"] . Constraints: . | 0 &lt;= digits.length &lt;= 4 | digits[i] is a digit in the range [‘2’, ‘9’]. | . Solution: . class Solution { String[] mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; public List&lt;String&gt; letterCombinations(String digits) { int n = digits.length(); if(n == 0) return new ArrayList&lt;String&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n == 1){ for(char ch : mp[Character.getNumericValue(digits.charAt(0))].toCharArray()){ result.add(String.valueOf(ch)); } return result; } List&lt;String&gt; ans = letterCombinations(digits.substring(1,n)); for(char ch : mp[Character.getNumericValue(digits.charAt(0))].toCharArray()){ for(String s : ans){ result.add(ch+s); } } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-11-Letter%20Combinations%20of%20a%20Phone%20Number/",
    "relUrl": "/problem-11-Letter Combinations of a Phone Number/"
  },"117": {
    "doc": "Maximum Subarray",
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: . Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: . Input: nums = [1] Output: 1 . Example 3: . Input: nums = [5,4,-1,7,8] Output: 23 . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -104 &lt;= nums[i] &lt;= 104 | . Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. class Solution { public int maxSubArray(int[] nums) { int prevSum = nums[0]; int currentSum = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if(currentSum + nums[i]&lt; nums[i]){ currentSum = nums[i]; }else{ currentSum += nums[i]; } prevSum = Math.max(prevSum, currentSum); } return Math.max(prevSum, currentSum); } } . ",
    "url": "https://1001anjan.github.io/problem-11-maximum-subarray/",
    "relUrl": "/problem-11-maximum-subarray/"
  },"118": {
    "doc": "Kth Largest Element in an Array",
    "title": "Kth Largest Element in an Array",
    "content": "Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. You must solve it in O(n) time complexity. Example 1: . Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 . Example 2: . Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 . Constraints: . | 1 &lt;= k &lt;= nums.length &lt;= 10^5 | -10^4 &lt;= nums[i] &lt;= 10^4 | . Solution: . Using Quick select, O(n) . class Solution { public int findKthLargest(int[] nums, int k) { // implementing using quick select algorithm. avarage case time complexity O(n), wrost case O(n^2). // calculating target index k = nums.length - k; // initializing target list boundaries int lower = 0; int upper = nums.length - 1; while(lower &lt; upper){ // finding pivote element index int pivote = partitionList(nums, lower, upper); if(pivote &lt; k){ lower = pivote + 1; }else if(pivote &gt; k){ upper = pivote - 1; }else return nums[pivote]; } return nums[k]; } private int partitionList(int[] nums, int start, int end){ int pivote = start; while(start &lt;= end){ while(start &lt;= end &amp;&amp; nums[start] &lt;= nums[pivote])start ++; while(start &lt;= end &amp;&amp; nums[end] &gt; nums[pivote]) end --; if(start &gt; end) break; swap(nums, start, end); } swap(nums, pivote, end); return end; } public void swap(int[] nums, int i, int j){ int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; } } . Using Max Heap . class Solution { public int findKthLargest(int[] nums, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;(){ public int compare(Integer a, Integer b){ return b.compareTo(a); } }); for(int n : nums) pq.offer(n); for(int i = 1; i &lt; k; i++) pq.poll(); return pq.peek(); } } . ",
    "url": "https://1001anjan.github.io/problem-110-Kth%20Largest%20Element%20in%20an%20Arrays/",
    "relUrl": "/problem-110-Kth Largest Element in an Arrays/"
  },"119": {
    "doc": "Maximum Product of Three Numbers",
    "title": "Maximum Product of Three Numbers",
    "content": "Given an integer array nums, find three numbers whose product is maximum and return the maximum product. Example 1: . Input: nums = [1,2,3] Output: 6 . Example 2: . Input: nums = [1,2,3,4] Output: 24 . Example 3: . Input: nums = [-1,-2,-3] Output: -6 . Constraints: . | 3 &lt;= nums.length &lt;= 104 | -1000 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); } } . public class Solution { public int maximumProduct(int[] nums) { int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; for (int n: nums) { if (n &lt;= min1) { min2 = min1; min1 = n; } else if (n &lt;= min2) { // n lies between min1 and min2 min2 = n; } if (n &gt;= max1) { // n is greater than max1, max2 and max3 max3 = max2; max2 = max1; max1 = n; } else if (n &gt;= max2) { // n lies betweeen max1 and max2 max3 = max2; max2 = n; } else if (n &gt;= max3) { // n lies betwen max2 and max3 max3 = n; } } return Math.max(min1 * min2 * max1, max1 * max2 * max3); } } . ",
    "url": "https://1001anjan.github.io/problem-110-Maximum-Product-of-Three-Numbers/",
    "relUrl": "/problem-110-Maximum-Product-of-Three-Numbers/"
  },"120": {
    "doc": "Average of Levels in Binary Tree",
    "title": "Average of Levels in Binary Tree",
    "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2: . Input: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -231 &lt;= Node.val &lt;= 231 - 1 | . Solution: . BFS . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; result = new ArrayList&lt;Double&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()){ Queue&lt;TreeNode&gt; tempQueue = new LinkedList&lt;TreeNode&gt;(); double count = 0; double sum = 0; while(!queue.isEmpty()){ TreeNode node = queue.remove(); sum += node.val; count++; if(node.left != null) tempQueue.add(node.left); if(node.right != null) tempQueue.add(node.right); } queue = tempQueue; result.add(sum/count); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-111-Average-of-Levels-in-Binary-Tree/",
    "relUrl": "/problem-111-Average-of-Levels-in-Binary-Tree/"
  },"121": {
    "doc": "Basic Calculator II",
    "title": "Basic Calculator II",
    "content": "Given a string s which represents an expression, evaluate this expression and return its value. The integer division should truncate toward zero. You may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1]. Note: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval(). Example 1: . Input: s = \"3+2*2\" Output: 7 . Example 2: . Input: s = \" 3/2 \" Output: 1 . Example 3: . Input: s = \" 3+5 / 2 \" Output: 5 . Constraints: . | 1 &lt;= s.length &lt;= 3 * 10^5 | s consists of integers and operators (‘+’, ‘-‘, ‘*’, ‘/’) separated by some number of spaces. | s represents a valid expression. | All the integers in the expression are non-negative integers in the range [0, 2^31 - 1]. | The answer is guaranteed to fit in a 32-bit integer. | . Solution: . class Solution { public int calculate(String s) { char prevOp = '+'; // previous operator int prevValue = 0; // previous number int result = 0; // total result int value = 0; // current value int i = 0; int len = s.length(); while(i &lt; len){ if(s.charAt(i) == ' '){ i++; continue; } char ch = s.charAt(i); while(Character.isDigit(ch)){ value = value * 10 + ch - '0'; i++; if(i &gt;= len) break; ch = s.charAt(i); } switch(prevOp){ case '+': result += prevValue; prevValue = value; break; case '-': result += prevValue; prevValue = -value; break; case '*': prevValue = prevValue * value; break; case '/': prevValue = prevValue / value; break; } i++; prevOp = ch; value = 0; } return result + prevValue; } } . ",
    "url": "https://1001anjan.github.io/problem-111-Basic%20Calculator%20II/",
    "relUrl": "/problem-111-Basic Calculator II/"
  },"122": {
    "doc": "Different Ways to Add Parentheses",
    "title": "Different Ways to Add Parentheses",
    "content": "Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order. The test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 104. Example 1: . Input: expression = \"2-1-1\" Output: [0,2] Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 . Example 2: . Input: expression = \"2*3-4*5\" Output: [-34,-14,-10,-10,10] Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 . Constraints: . | 1 &lt;= expression.length &lt;= 20 | expression consists of digits and the operator ‘+’, ‘-‘, and ‘*’. | All the integer values in the input expression are in the range [0, 99]. | . Solution: . class Solution { public List&lt;Integer&gt; diffWaysToCompute(String expression) { List&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); for(int i = 0; i &lt; expression.length(); i++){ char ch = expression.charAt(i); if(isOperator(ch)){ List&lt;Integer&gt; part1 = diffWaysToCompute(expression.substring(0,i)); List&lt;Integer&gt; part2 = diffWaysToCompute(expression.substring(i + 1)); for(Integer p1 : part1){ for(Integer p2 : part2){ switch(ch){ case '+' : ans.add(p1 + p2); break; case '-' : ans.add(p1 - p2); break; case '*' : ans.add(p1 * p2); break; } } } } } if(ans.size() == 0) ans.add(Integer.valueOf(expression)); return ans; } public boolean isOperator(char ch){ if(ch == '+' || ch == '-' || ch == '*') return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-112-Different%20Ways%20to%20Add%20Parentheses/",
    "relUrl": "/problem-112-Different Ways to Add Parentheses/"
  },"123": {
    "doc": "Maximum Average Subarray I",
    "title": "Maximum Average Subarray I",
    "content": "You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Example 1: . Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000 Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75 . Example 2: . Input: nums = [5], k = 1 Output: 5.00000 . Constraints: . | n == nums.length | 1 &lt;= k &lt;= n &lt;= 105 | -104 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public double findMaxAverage(int[] nums, int k) { double sum = 0; for(int i=0; i&lt;k; i++) sum += nums[i]; double res = sum; for(int i=k; i&lt;nums.length; i++){ sum += nums[i] - nums[i-k]; res = Math.max(res,sum); } return res/k; } } . ",
    "url": "https://1001anjan.github.io/problem-112-Maximum-Average-Subarray-I/",
    "relUrl": "/problem-112-Maximum-Average-Subarray-I/"
  },"124": {
    "doc": "Set Mismatch",
    "title": "Set Mismatch",
    "content": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: . Input: nums = [1,2,2,4] Output: [2,3] . Example 2: . Input: nums = [1,1] Output: [1,2] . Constraints: . | 2 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int[] findErrorNums(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; res = new HashSet&lt;Integer&gt;(); int index = 0; // finding duplipactes for(int n: nums){ if(set.contains(n)){ res.add(n); }else{ set.add(n); } } // finding missing elements for(int i = 1; i&lt;=nums.length; i++){ if(!set.contains(i)) res.add(i); } int[] ans = new int[res.size()]; for(int n: res){ ans[index++] = n; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-113-Set-Mismatch/",
    "relUrl": "/problem-113-Set-Mismatch/"
  },"125": {
    "doc": "Ugly Number II",
    "title": "Ugly Number II",
    "content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return the nth ugly number. Example 1: . Input: n = 10 Output: 12 Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers. Example 2: . Input: n = 1 Output: 1 Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Constraints: . | 1 &lt;= n &lt;= 1690 | . Solution: . Time Limit Exceeded . class Solution { public int nthUglyNumber(int n) { if(n == 1) return 1; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); set.add(1); int cnt = 1; int k = 2; while(cnt != n){ if(k % 2 == 0 &amp;&amp; set.contains(k / 2)){ cnt++; set.add(k); }else if(k % 3 == 0 &amp;&amp; set.contains(k / 3)){ cnt++; set.add(k); }else if(k % 5 == 0 &amp;&amp; set.contains(k / 5)){ cnt++; set.add(k); } k++; } return k - 1; } } . O(n) complexity . The ugly-number sequence is 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, … because every number can only be divided by 2, 3, 5, one way to look at the sequence is to split the sequence to three groups as below: . (1) 1×2, 2×2, 3×2, 4×2, 5×2, … (2) 1×3, 2×3, 3×3, 4×3, 5×3, … (3) 1×5, 2×5, 3×5, 4×5, 5×5, … . We can find that every subsequence is the ugly-sequence itself (1, 2, 3, 4, 5, …) multiply 2, 3, 5. Then we use similar merge method as merge sort, to get every ugly number from the three subsequence. Every step we choose the smallest one, and move one step after,including nums with same value. class Solution { public int nthUglyNumber(int n) { int[] ugly = new int[n]; ugly[0] = 1; int factorOf2 = 2, factorOf3 = 3, factorOf5 = 5; int factor2Index = 0, factor3Index = 0, factor5Index = 0; for(int i = 1; i &lt; n; i++){ int min = Math.min(factorOf2, Math.min(factorOf3, factorOf5)); ugly[i] = min; if(factorOf2 == min){ factorOf2 = 2 * ugly[++factor2Index]; } if(factorOf3 == min){ factorOf3 = 3 * ugly[++factor3Index]; } if(factorOf5 == min){ factorOf5 = 5 * ugly[++factor5Index]; } } return ugly[n - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-113-Ugly%20Number%20II/",
    "relUrl": "/problem-113-Ugly Number II/"
  },"126": {
    "doc": "H-Index",
    "title": "H-Index",
    "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper, return compute the researcher’s h-index. According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each. If there are several possible values for h, the maximum one is taken as the h-index. Example 1: . Input: citations = [3,0,6,1,5] Output: 3 Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: . Input: citations = [1,3,1] Output: 1 . Constraints: . | n == citations.length | 1 &lt;= n &lt;= 5000 | 0 &lt;= citations[i] &lt;= 1000 | . Solution: . class Solution { public int hIndex(int[] citations) { int n = citations.length; int[] bucket = new int[n + 1]; for(int num : citations){ if(num &gt;= n) bucket[n]++; else bucket[num]++; } int count = 0; for(int i = n; i &gt;= 0; i--){ count += bucket[i]; if(count &gt;= i) return i; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-114-H-Index/",
    "relUrl": "/problem-114-H-Index/"
  },"127": {
    "doc": "Two Sum IV - Input is a BST",
    "title": "Two Sum IV - Input is a BST",
    "content": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: . Input: root = [5,3,6,2,4,null,7], k = 9 Output: true . Example 2: . Input: root = [5,3,6,2,4,null,7], k = 28 Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -104 &lt;= Node.val &lt;= 104 | root is guaranteed to be a valid binary search tree. | -105 &lt;= k &lt;= 105 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean findTarget(TreeNode root, int k) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); // set.add(root.val); while(!queue.isEmpty()){ TreeNode node = queue.remove(); if(set.contains(k - node.val)){ return true; } set.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-114-Two-Sum-IV-Input-is-a-BST/",
    "relUrl": "/problem-114-Two-Sum-IV-Input-is-a-BST/"
  },"128": {
    "doc": "H-Index II",
    "title": "H-Index II",
    "content": "Given an array of integers citations where citations[i] is the number of citations a researcher received for their ith paper and citations is sorted in an ascending order, return compute the researcher’s h-index. According to the definition of h-index on Wikipedia: A scientist has an index h if h of their n papers have at least h citations each, and the other n − h papers have no more than h citations each. If there are several possible values for h, the maximum one is taken as the h-index. You must write an algorithm that runs in logarithmic time. Example 1: . Input: citations = [0,1,3,5,6] Output: 3 Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3. Example 2: . Input: citations = [1,2,100] Output: 2 . Constraints: . | n == citations.length | 1 &lt;= n &lt;= 10^5 | 0 &lt;= citations[i] &lt;= 1000 | citations is sorted in ascending order. | . Solution: . class Solution { public int hIndex(int[] citations) { int len = citations.length; int s = 0; int e = len - 1; while(s &lt;= e){ int mid = (s + e)/2; if(citations[mid] &gt;= len - mid){ e = mid - 1; }else{ s = mid + 1; } } return len - s; } } . ",
    "url": "https://1001anjan.github.io/problem-115-H-Index%20II/",
    "relUrl": "/problem-115-H-Index II/"
  },"129": {
    "doc": "Robot Return to Origin",
    "title": "Robot Return to Origin",
    "content": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are ‘R’ (right), ‘L’ (left), ‘U’ (up), and ‘D’ (down). Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise. Note: The way that the robot is “facing” is irrelevant. ‘R’ will always make the robot move to the right once, ‘L’ will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. Example 1: . Input: moves = \"UD\" Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: . Input: moves = \"LL\" Output: false Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves. Constraints: . | 1 &lt;= moves.length &lt;= 2 * 104 | moves only contains the characters ‘U’, ‘D’, ‘L’ and ‘R’. | . Solution: . class Solution { public boolean judgeCircle(String moves) { int l,r,u,d; l = r = u = d = 0; for(int i=0; i&lt;moves.length(); i++){ if(moves.charAt(i) == 'R') r++; else if(moves.charAt(i) == 'D') d++; else if(moves.charAt(i) == 'U') u++; else l++; } return (r == l &amp;&amp; d == u) ; } } . ",
    "url": "https://1001anjan.github.io/problem-115-Robot-Return-to-Origin/",
    "relUrl": "/problem-115-Robot-Return-to-Origin/"
  },"130": {
    "doc": "Perfect Squares",
    "title": "Perfect Squares",
    "content": "Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not. Example 1: . Input: n = 12 Output: 3 Explanation: 12 = 4 + 4 + 4. Example 2: . Input: n = 13 Output: 2 Explanation: 13 = 4 + 9. Constraints: . | 1 &lt;= n &lt;= 10^4 | . Solution: . Time Limit Exceeded . class Solution { public int numSquares(int n) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); int level = 0; q.offer(0); while(!q.isEmpty()){ int size = q.size(); Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;(); while(size -- &gt; 0){ int x = q.poll(); for(int i = 1; i &lt;= n; i++){ int v = x + i *i; if(v == n) return level + 1; if(v &lt; n ) q1.offer(v); else break; } } q = q1; level ++; } return level; } } . class Solution { public int numSquares(int n) { int max=(int)Math.sqrt(n); int res=Integer.MAX_VALUE; return dfs(n,res,max,0); } private int dfs(int target,int res,int num,int count){ if(target==0){ res=Math.min(res,count); return res; } for(int i=num;i&gt;0;i--){ int square=(int)Math.pow(i,2); if(square&gt;target) continue; if(count+1&lt;res) res=dfs(target-square,res,i,count+1); } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-116-Perfect%20Squares/",
    "relUrl": "/problem-116-Perfect Squares/"
  },"131": {
    "doc": "Second Minimum Node In a Binary Tree",
    "title": "Second Minimum Node In a Binary Tree",
    "content": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: . Input: root = [2,2,5,null,null,5,7] Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. Example 2: . Input: root = [2,2,2] Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value. Constraints: . | The number of nodes in the tree is in the range [1, 25]. | 1 &lt;= Node.val &lt;= 231 - 1 | root.val == min(root.left.val, root.right.val) for each internal node of the tree. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int findSecondMinimumValue(TreeNode root) { Long min1,min2; min1 = min2 = Long.MAX_VALUE; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()){ TreeNode node = queue.remove(); if(min1&gt;node.val &amp;&amp; min2&gt;node.val){ min2 = min1; min1 = Long.valueOf(node.val); }else if(min2&gt;node.val &amp;&amp; node.val != min1){ min2 = Long.valueOf(node.val); } if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } System.out.println(min1+\" \"+min2); if(Long.MAX_VALUE == min2) return -1; return min2.intValue(); } } . ",
    "url": "https://1001anjan.github.io/problem-116-Second-Minimum-Node-In-a-Binary-Tree/",
    "relUrl": "/problem-116-Second-Minimum-Node-In-a-Binary-Tree/"
  },"132": {
    "doc": "Longest Continuous Increasing Subsequence",
    "title": "Longest Continuous Increasing Subsequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l &lt; r) such that it is [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] and for each l &lt;= i &lt; r, nums[i] &lt; nums[i + 1]. Example 1: . Input: nums = [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3. Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element 4. Example 2: . Input: nums = [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly increasing. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution: . class Solution { public int findLengthOfLCIS(int[] nums) { int currCount = 1; int prevCount = 1; for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&lt;nums[i]) currCount++; else{ prevCount = Math.max(prevCount, currCount); currCount = 1; } } return Math.max(prevCount, currCount); } } . ",
    "url": "https://1001anjan.github.io/problem-117-Longest-Continuous-Increasing-Subsequence/",
    "relUrl": "/problem-117-Longest-Continuous-Increasing-Subsequence/"
  },"133": {
    "doc": "Peeking Iterator",
    "title": "Peeking Iterator",
    "content": "Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations. Implement the PeekingIterator class: . | PeekingIterator(Iterator nums) Initializes the object with the given integer iterator iterator. | int next() Returns the next element in the array and moves the pointer to the next element. | boolean hasNext() Returns true if there are still elements in the array. | int peek() Returns the next element in the array without moving the pointer. | . Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions. Example 1: . Input [\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 2, 2, 3, false] Explanation PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3] peekingIterator.next(); // return 1, the pointer moves to the next element [1,2,3]. peekingIterator.peek(); // return 2, the pointer does not move [1,2,3]. peekingIterator.next(); // return 2, the pointer moves to the next element [1,2,3] peekingIterator.next(); // return 3, the pointer moves to the next element [1,2,3] peekingIterator.hasNext(); // return False . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | All the calls to next and peek are valid. | At most 1000 calls will be made to next, hasNext, and peek. | . Solution: . // Java Iterator interface reference: // https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html class PeekingIterator implements Iterator&lt;Integer&gt; { Integer next = null; Iterator&lt;Integer&gt; itr; public PeekingIterator(Iterator&lt;Integer&gt; iterator) { // initialize any member here. itr = iterator; next = itr.hasNext() ? itr.next() : null; } // Returns the next element in the iteration without advancing the iterator. public Integer peek() { return next; } // hasNext() and next() should behave the same as in the Iterator interface. // Override them if needed. @Override public Integer next() { Integer val = next; next = itr.hasNext()? itr.next() : null; return val; } @Override public boolean hasNext() { return next != null; } } . ",
    "url": "https://1001anjan.github.io/problem-117-Peeking%20Iterator/",
    "relUrl": "/problem-117-Peeking Iterator/"
  },"134": {
    "doc": "Find the Duplicate Number",
    "title": "Find the Duplicate Number",
    "content": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive. There is only one repeated number in nums, return this repeated number. You must solve the problem without modifying the array nums and uses only constant extra space. Example 1: . Input: nums = [1,3,4,2,2] Output: 2 . Example 2: . Input: nums = [3,1,3,4,2] Output: 3 . Constraints: . | 1 &lt;= n &lt;= 10^5 | nums.length == n + 1 | 1 &lt;= nums[i] &lt;= n | All the integers in nums appear only once except for precisely one integer which appears two or more times. | . Follow up: . | How can we prove that at least one duplicate number must exist in nums? | Can you solve the problem in linear runtime complexity? | . Solution: . Using cycle detection . class Solution { public int findDuplicate(int[] nums) { int slow = 0; int fast = 0; do{ slow = nums[slow]; fast = nums[nums[fast]]; }while(slow != fast); fast = 0; do{ slow = nums[slow]; fast = nums[fast]; }while(slow != fast); return slow; } } . Using swap . class Solution { public int findDuplicate(int[] nums) { while(nums[0] != nums[nums[0]]){ int n = nums[nums[0]]; nums[nums[0]] = nums[0]; nums[0] = n; } return nums[0]; } } . ",
    "url": "https://1001anjan.github.io/problem-118-Find%20the%20Duplicate%20Number/",
    "relUrl": "/problem-118-Find the Duplicate Number/"
  },"135": {
    "doc": "Valid Palindrome II",
    "title": "Valid Palindrome II",
    "content": "Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: . Input: s = \"aba\" Output: true . Example 2: . Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: . Input: s = \"abc\" Output: false . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of lowercase English letters. | . Solution: . class Solution { private boolean checkPalindrome(String s, int i, int j) { while (i &lt; j) { if (s.charAt(i) != s.charAt(j)) { return false; } i++; j--; } return true; } public boolean validPalindrome(String s) { int i = 0; int j = s.length() - 1; while (i &lt; j) { // Found a mismatched pair - try both deletions if (s.charAt(i) != s.charAt(j)) { return (checkPalindrome(s, i, j - 1) || checkPalindrome(s, i + 1, j)); } i++; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-118-Valid-Palindrome-II/",
    "relUrl": "/problem-118-Valid-Palindrome-II/"
  },"136": {
    "doc": "Binary Number with Alternating Bits",
    "title": "Binary Number with Alternating Bits",
    "content": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: . Input: n = 5 Output: true Explanation: The binary representation of 5 is: 101 . Example 2: . Input: n = 7 Output: false Explanation: The binary representation of 7 is: 111. Example 3: . Input: n = 11 Output: false Explanation: The binary representation of 11 is: 1011. Constraints: . | 1 &lt;= n &lt;= 231 - 1 | . Solution: . class Solution { public boolean hasAlternatingBits(int n) { int curr = n%2; n = n/2; while(n&gt;0){ if(curr == n%2) return false; curr = n%2; n = n/2; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-119-Binary-Number-with-Alternating-Bits/",
    "relUrl": "/problem-119-Binary-Number-with-Alternating-Bits/"
  },"137": {
    "doc": "Longest Increasing Subsequence",
    "title": "Longest Increasing Subsequence",
    "content": "Given an integer array nums, return the length of the longest strictly increasing subsequence. Example 1: . Input: nums = [10,9,2,5,3,7,101,18] Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. Example 2: . Input: nums = [0,1,0,3,2,3] Output: 4 . Example 3: . Input: nums = [7,7,7,7,7,7,7] Output: 1 . Constraints: . | 1 &lt;= nums.length &lt;= 2500 | -10^4 &lt;= nums[i] &lt;= 10^4 . | Follow up: Can you come up with an algorithm that runs in O(n log(n)) time complexity? | . Solution: . class Solution { public int lengthOfLIS(int[] nums) { int[] dp = new int[nums.length]; int len = 0; for(int n : nums){ int i = Arrays.binarySearch(dp, 0, len, n); if(i &lt; 0) i = -(i + 1); dp[i] = n; if(i == len) len ++; } return len; } } . ",
    "url": "https://1001anjan.github.io/problem-119-Longest%20Increasing%20Subsequence/",
    "relUrl": "/problem-119-Longest Increasing Subsequence/"
  },"138": {
    "doc": "Length of Last Word",
    "title": "Length of Last Word",
    "content": "Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: . Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5. Example 2: . Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4. Example 3: . Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6. Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of only English letters and spaces ‘ ‘. | There will be at least one word in s. | . Solution . class Solution { public int lengthOfLastWord(String s) { int l = 0; s = s.trim(); for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) == ' ') break; l++; } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-12-length-of-last-word/",
    "relUrl": "/problem-12-length-of-last-word/"
  },"139": {
    "doc": "Remove Nth Node From End of List",
    "title": "Remove Nth Node From End of List",
    "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: . Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] . Example 2: . Input: head = [1], n = 1 Output: [] . Example 3: . Input: head = [1,2], n = 1 Output: [1] . Constraints: . | The number of nodes in the list is sz. | 1 &lt;= sz &lt;= 30 | 0 &lt;= Node.val &lt;= 100 | 1 &lt;= n &lt;= sz | . Follow up: Could you do this in one pass? . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode ptr, qtr; // Corner cases if(head.next == null) return null; // Since n &gt;=1 ptr = qtr = head; while(n &gt; 0){ qtr = qtr.next; n --; } // Traversing to the end node while(qtr != null &amp;&amp; qtr.next != null){ ptr = ptr.next; qtr = qtr.next; } if(qtr == null){ ptr = head.next; head = null; return ptr; } // deleting node qtr = ptr.next; ptr.next = qtr.next; return head; } } . ",
    "url": "https://1001anjan.github.io/problem-12-Remove%20Nth%20Node%20From%20End%20of%20List/",
    "relUrl": "/problem-12-Remove Nth Node From End of List/"
  },"140": {
    "doc": "Search in a Binary Search Tree",
    "title": "Search in a Binary Search Tree",
    "content": "You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. Example 1: . Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] . Example 2: . Input: root = [4,2,7,1,3], val = 5 Output: [] . Constraints: . | The number of nodes in the tree is in the range [1, 5000]. | 1 &lt;= Node.val &lt;= 107 | root is a binary search tree. | 1 &lt;= val &lt;= 107 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode searchBST(TreeNode root, int val) { if(root == null) return null; if(root.val == val) return root; if(root.val&gt;val) return searchBST(root.left, val); else return searchBST(root.right, val); } } . ",
    "url": "https://1001anjan.github.io/problem-120-Search-in-a-Binary-Search-Tree/",
    "relUrl": "/problem-120-Search-in-a-Binary-Search-Tree/"
  },"141": {
    "doc": "Top K Frequent Elements",
    "title": "Top K Frequent Elements",
    "content": "Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order. Example 1: . Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] . Example 2: . Input: nums = [1], k = 1 Output: [1] . Constraints: . | 1 &lt;= nums.length &lt;= 10^5 | -10^4 &lt;= nums[i] &lt;= 10^4 | k is in the range [1, the number of unique elements in the array]. | It is guaranteed that the answer is unique. | Follow up: Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. | . Solution: . class Solution { public int[] topKFrequent(int[] nums, int k) { List&lt;Integer[]&gt; list = new ArrayList&lt;&gt;(); Arrays.sort(nums); int count = 1; for(int i = 0; i &lt; nums.length - 1; i++){ if(nums[i] == nums[i + 1]) count++; else{ list.add(new Integer[]{nums[i], count}); count = 1; } } list.add(new Integer[]{nums[nums.length - 1], count}); Collections.sort(list, (a, b) -&gt; { return b[1] - a[1]; }); int[] ans = new int[k]; for(int i = 0; i &lt; k; i++){ ans[i] = list.get(i)[0]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-120-Top%20K%20Frequent%20Elements/",
    "relUrl": "/problem-120-Top K Frequent Elements/"
  },"142": {
    "doc": "Binary Search",
    "title": "Binary Search",
    "content": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: . Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 . Example 2: . Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt; nums[i], target &lt; 104 | All the integers in nums are unique. | nums is sorted in ascending order. | . Solution: . class Solution { public int search(int[] nums, int target) { int l = 0; int u = nums.length - 1; while(l&lt;=u){ int mid = (l+u)/2; if(nums[mid] == target) return mid; if(nums[mid]&gt;target) u = mid - 1; else l = mid + 1; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-121-Binary-Search/",
    "relUrl": "/problem-121-Binary-Search/"
  },"143": {
    "doc": "Robot Bounded In Circle",
    "title": "Robot Bounded In Circle",
    "content": "On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that: . | The north direction is the positive direction of the y-axis. | The south direction is the negative direction of the y-axis. | The east direction is the positive direction of the x-axis. | The west direction is the negative direction of the x-axis. | The robot can receive one of three instructions: . | “G”: go straight 1 unit. | “L”: turn 90 degrees to the left (i.e., anti-clockwise direction). | “R”: turn 90 degrees to the right (i.e., clockwise direction). | The robot performs the instructions given in order, and repeats them forever. | . Return true if and only if there exists a circle in the plane such that the robot never leaves the circle. Example 1: . Input: instructions = \"GGLLGG\" Output: true Explanation: The robot is initially at (0, 0) facing the north direction. \"G\": move one step. Position: (0, 1). Direction: North. \"G\": move one step. Position: (0, 2). Direction: North. \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West. \"L\": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South. \"G\": move one step. Position: (0, 1). Direction: South. \"G\": move one step. Position: (0, 0). Direction: South. Repeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 1) --&gt; (0, 0). Based on that, we return true. Example 2: . Input: instructions = \"GG\" Output: false Explanation: The robot is initially at (0, 0) facing the north direction. \"G\": move one step. Position: (0, 1). Direction: North. \"G\": move one step. Position: (0, 2). Direction: North. Repeating the instructions, keeps advancing in the north direction and does not go into cycles. Based on that, we return false. Example 3: . Input: instructions = \"GL\" Output: true Explanation: The robot is initially at (0, 0) facing the north direction. \"G\": move one step. Position: (0, 1). Direction: North. \"L\": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West. \"G\": move one step. Position: (-1, 1). Direction: West. \"L\": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South. \"G\": move one step. Position: (-1, 0). Direction: South. \"L\": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East. \"G\": move one step. Position: (0, 0). Direction: East. \"L\": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North. Repeating the instructions, the robot goes into the cycle: (0, 0) --&gt; (0, 1) --&gt; (-1, 1) --&gt; (-1, 0) --&gt; (0, 0). Based on that, we return true. Constraints: . | 1 &lt;= instructions.length &lt;= 100 | instructions[i] is ‘G’, ‘L’ or, ‘R’. | . Solution: . class Solution { public boolean isRobotBounded(String instructions) { int[] pos = new int[]{0,0}; char curr = 'N'; for(char ch : instructions.toCharArray()){ switch(ch){ case 'G' : move(pos, curr); break; case 'R' : case 'L' : curr = changeDirection(curr, ch); break; } } if(pos[0] == 0 &amp;&amp; pos[1] == 0) return true; if(curr == 'N' &amp;&amp; !(pos[0] == 0 &amp;&amp; pos[1] == 0)) return false; return true; } public void move(int[] pos, char dir){ switch(dir){ case 'N' : pos[1]++; break; case 'S' : pos[1]--; break; case 'E' : pos[0]++; break; case 'W' : pos[0]--; break; } } public char changeDirection(char curr, char ins){ switch(curr){ case 'N' : return ins == 'L'? 'W' : 'E'; case 'S' : return ins == 'L'? 'E' : 'W'; case 'E' : return ins == 'L'? 'N' : 'S'; case 'W' : return ins == 'L'? 'S' : 'N'; } throw null; } } . Let chopper help explain. Starting at the origin and face north (0,1), after one sequence of instructions, if chopper return to the origin, he is obvious in an circle. if chopper finishes with face not towards north, it will get back to the initial status in another one or three sequences. Explanation (x,y) is the location of chopper. d[i] is the direction he is facing. i = (i + 1) % 4 will turn right i = (i + 3) % 4 will turn left Check the final status after instructions. Complexity . Time O(N) Space O(1) . class Solution { public boolean isRobotBounded(String ins) { int x = 0, y = 0, i = 0, d[][] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} }; for (int j = 0; j &lt; ins.length(); ++j) if (ins.charAt(j) == 'R') i = (i + 1) % 4; else if (ins.charAt(j) == 'L') i = (i + 3) % 4; else { x += d[i][0]; y += d[i][1]; } return x == 0 &amp;&amp; y == 0 || i &gt; 0; } } . ",
    "url": "https://1001anjan.github.io/problem-121-Robot%20Bounded%20In%20Circle/",
    "relUrl": "/problem-121-Robot Bounded In Circle/"
  },"144": {
    "doc": "Design HashSet",
    "title": "Design HashSet",
    "content": "Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: . | void add(key) Inserts the value key into the HashSet. | bool contains(key) Returns whether the value key exists in the HashSet or not. | void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. | . Example 1: . Input [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"] [[], [1], [2], [1], [3], [2], [2], [2], [2]] Output [null, null, null, true, false, null, true, null, false] . Explanation . MyHashSet myHashSet = new MyHashSet(); myHashSet.add(1); // set = [1] myHashSet.add(2); // set = [1, 2] myHashSet.contains(1); // return True myHashSet.contains(3); // return False, (not found) myHashSet.add(2); // set = [1, 2] myHashSet.contains(2); // return True myHashSet.remove(2); // set = [1] myHashSet.contains(2); // return False, (already removed) . Constraints: . | 0 &lt;= key &lt;= 106 | At most 104 calls will be made to add, remove, and contains. | . Solution: . class MyHashSet { private boolean [] data; public MyHashSet() { data = new boolean[1000001]; } public void add(int key) { data[key] = true; } public void remove(int key) { data[key] = false; } public boolean contains(int key) { return data[key]; } } /** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */ . ",
    "url": "https://1001anjan.github.io/problem-122-Design-HashSet/",
    "relUrl": "/problem-122-Design-HashSet/"
  },"145": {
    "doc": "Flatten Nested List Iterator",
    "title": "Flatten Nested List Iterator",
    "content": "You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it. Implement the NestedIterator class: . | NestedIterator(List nestedList) Initializes the iterator with the nested list nestedList. | int next() Returns the next integer in the nested list. | boolean hasNext() Returns true if there are still some integers in the nested list and false otherwise. | . Your code will be tested with the following pseudocode: . initialize iterator with nestedList res = [] while iterator.hasNext() append iterator.next() to the end of res return res . If res matches the expected flattened list, then your code will be judged as correct. Example 1: . Input: nestedList = [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2: . Input: nestedList = [1,[4,[6]]] Output: [1,4,6] Explanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Constraints: . | 1 &lt;= nestedList.length &lt;= 500 | The values of the integers in the nested list is in the range [-10^6, 10^6]. | . Solution: . /** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger { * * // @return true if this NestedInteger holds a single integer, rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, if it holds a nested list * // Return empty list if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * } */ public class NestedIterator implements Iterator&lt;Integer&gt; { Iterator itr; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public NestedIterator(List&lt;NestedInteger&gt; nestedList) { processNestedList(nestedList); itr = list.iterator(); } @Override public Integer next() { return (Integer)itr.next(); } @Override public boolean hasNext() { return itr.hasNext(); } public void processNestedList(List&lt;NestedInteger&gt; nestedList){ for(NestedInteger ni : nestedList){ if(ni.isInteger()){ list.add(ni.getInteger()); }else{ processNestedList(ni.getList()); } } } } /** * Your NestedIterator object will be instantiated and called as such: * NestedIterator i = new NestedIterator(nestedList); * while (i.hasNext()) v[f()] = i.next(); */ . ",
    "url": "https://1001anjan.github.io/problem-122-Flatten%20Nested%20List%20Iterator/",
    "relUrl": "/problem-122-Flatten Nested List Iterator/"
  },"146": {
    "doc": "Design HashMap",
    "title": "Design HashMap",
    "content": "Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: . | MyHashMap() initializes the object with an empty map. | void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. | int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. | void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. | . Example 1: . Input [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] . Explanation . MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] . Constraints: . | 0 &lt;= key, value &lt;= 106 | At most 104 calls will be made to put, get, and remove. | . Solution: . class MyHashMap { int data[]; public MyHashMap() { data = new int[1000001]; Arrays.fill(data,-1); } public void put(int key, int value) { data[key] = value; } public int get(int key) { return data[key]; } public void remove(int key) { data[key] = -1; } } /** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */ . ",
    "url": "https://1001anjan.github.io/problem-123-Design-HashMap/",
    "relUrl": "/problem-123-Design-HashMap/"
  },"147": {
    "doc": "House Robber III",
    "title": "House Robber III",
    "content": "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called root. Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that all houses in this place form a binary tree. It will automatically contact the police if two directly-linked houses were broken into on the same night. Given the root of the binary tree, return the maximum amount of money the thief can rob without alerting the police. Example 1: . Input: root = [3,2,3,null,3,null,1] Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2: . Input: root = [3,4,5,1,3,null,1] Output: 9 Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. Constraints: . | The number of nodes in the tree is in the range [1, 10^4]. | 0 &lt;= Node.val &lt;= 10^4 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int rob(TreeNode root) { int[] res = processRob(root); return Math.max(res[0], res[1]); } // res[0] == include current node // res[1] = exculude current node public int[] processRob(TreeNode root){ if(root == null) return new int[]{0, 0}; int[] left = processRob(root.left); int[] right = processRob(root.right); int includeCurrentNode = left[1] + right[1] + root.val; int excludeCurrentNode = Math.max(left[0], left[1]) + Math.max(right[0] , right[1]); return new int[]{includeCurrentNode, excludeCurrentNode}; } } . ",
    "url": "https://1001anjan.github.io/problem-123-House%20Robber%20III/",
    "relUrl": "/problem-123-House Robber III/"
  },"148": {
    "doc": "Find Pivot Index",
    "title": "Find Pivot Index",
    "content": "Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1. Example 1: . Input: nums = [1,7,3,6,5,6] Output: 3 Explanation: The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 Right sum = nums[4] + nums[5] = 5 + 6 = 11 . Example 2: . Input: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Example 3: . Input: nums = [2,1,-1] Output: 0 Explanation: The pivot index is 0. Left sum = 0 (no elements to the left of index 0) Right sum = nums[1] + nums[2] = 1 + -1 = 0 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -1000 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int pivotIndex(int[] nums) { int sum = 0, leftsum = 0; for (int x: nums) sum += x; for (int i = 0; i &lt; nums.length; ++i) { if (leftsum == sum - leftsum - nums[i]) return i; leftsum += nums[i]; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-124-Find-Pivot-Index/",
    "relUrl": "/problem-124-Find-Pivot-Index/"
  },"149": {
    "doc": "Increasing Triplet Subsequence",
    "title": "Increasing Triplet Subsequence",
    "content": "Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i &lt; j &lt; k and nums[i] &lt; nums[j] &lt; nums[k]. If no such indices exists, return false. Example 1: . Input: nums = [1,2,3,4,5] Output: true Explanation: Any triplet where i &lt; j &lt; k is valid. Example 2: . Input: nums = [5,4,3,2,1] Output: false Explanation: No triplet exists. Example 3: . Input: nums = [2,1,5,0,4,6] Output: true Explanation: The triplet (3, 4, 5) is valid because nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6. Constraints: . | 1 &lt;= nums.length &lt;= 5 * 10^5 | -2^31 &lt;= nums[i] &lt;= 2^31 - 1 | . Follow up: Could you implement a solution that runs in O(n) time complexity and O(1) space complexity? . Solution: . public class Solution { public boolean increasingTriplet(int[] nums) { int min = Integer.MAX_VALUE, secondMin = Integer.MAX_VALUE; for(int num : nums){ if(num &lt;= min) min = num; else if(num &lt; secondMin) secondMin = num; else if(num &gt; secondMin) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-124-Increasing%20Triplet%20Subsequence/",
    "relUrl": "/problem-124-Increasing Triplet Subsequence/"
  },"150": {
    "doc": "Possible Bipartition",
    "title": "Possible Bipartition",
    "content": "We want to split a group of n people (labeled from 1 to n) into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Given the integer n and the array dislikes where dislikes[i] = [ai, bi] indicates that the person labeled ai does not like the person labeled bi, return true if it is possible to split everyone into two groups in this way. Example 1: . Input: n = 4, dislikes = [[1,2],[1,3],[2,4]] Output: true Explanation: group1 [1,4] and group2 [2,3]. Example 2: . Input: n = 3, dislikes = [[1,2],[1,3],[2,3]] Output: false . Example 3: . Input: n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]] Output: false . Constraints: . | 1 &lt;= n &lt;= 2000 | 0 &lt;= dislikes.length &lt;= 10^4 | dislikes[i].length == 2 | 1 &lt;= dislikes[i][j] &lt;= n | ai &lt; bi | All the pairs of dislikes are unique. | . Solution: . class Solution { public boolean possibleBipartition(int n, int[][] dislikes) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); // creating adjacency list for(int[] arr : dislikes){ adj.computeIfAbsent(arr[0], value -&gt; new ArrayList&lt;&gt;()).add(arr[1]); adj.computeIfAbsent(arr[1], value -&gt; new ArrayList&lt;&gt;()).add(arr[0]); } // initilizing all nodes color as -1 (-1 -&gt; not colored, 0 -&gt; RED, 1-&gt; Green) int[] color = new int[n + 1]; Arrays.fill(color, -1); for(int i = 1; i &lt;= n; i++){ if(color[i] == -1 &amp;&amp; !bsfCheck(i, adj, color)) return false; } return true; } public boolean bsfCheck(int source, Map&lt;Integer, List&lt;Integer&gt;&gt; adj, int[] color){ // making staring node as RED color color[source] = 0; Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(source); while(!q.isEmpty()){ int node = q.poll(); // traversing all adjacent node if(!adj.containsKey(node)) continue; for(int n : adj.get(node)){ if(color[node] == color[n]) return false; // if not processed the node for the coloring if(color[n] == -1){ color[n] = 1 - color[node]; q.add(n); } } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-125-Possible%20Bipartition/",
    "relUrl": "/problem-125-Possible Bipartition/"
  },"151": {
    "doc": "Self Dividing Numbers",
    "title": "Self Dividing Numbers",
    "content": "A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right]. Example 1: . Input: left = 1, right = 22 Output: [1,2,3,4,5,6,7,8,9,11,12,15,22] . Example 2: . Input: left = 47, right = 85 Output: [48,55,66,77] . Constraints: . | 1 &lt;= left &lt;= right &lt;= 104 | . Solution: . class Solution { public List&lt;Integer&gt; selfDividingNumbers(int left, int right) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); while(left&lt;=right){ if(isSelfDividingNumber(left)) result.add(left); left++; } return result; } public boolean isSelfDividingNumber(int num){ int n = num; while(n&gt;0){ int d = n%10; if(d == 0 || num%d&gt;0) return false; n = n/10; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-125-Self-Dividing-Numbers/",
    "relUrl": "/problem-125-Self-Dividing-Numbers/"
  },"152": {
    "doc": "Find Smallest Letter Greater Than Target",
    "title": "Find Smallest Letter Greater Than Target",
    "content": "Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target. Note that the letters wrap around. For example, if target == ‘z’ and letters == [‘a’, ‘b’], the answer is ‘a’. Example 1: . Input: letters = [\"c\",\"f\",\"j\"], target = \"a\" Output: \"c\" . Example 2: . Input: letters = [\"c\",\"f\",\"j\"], target = \"c\" Output: \"f\" . Example 3: . Input: letters = [\"c\",\"f\",\"j\"], target = \"d\" Output: \"f\" . Constraints: . | 2 &lt;= letters.length &lt;= 104 | letters[i] is a lowercase English letter. | letters is sorted in non-decreasing order. | letters contains at least two different characters. | target is a lowercase English letter. | . Solution: . class Solution { public char nextGreatestLetter(char[] letters, char target) { for(int i = 0; i&lt;letters.length; i++){ if(letters[i]&gt;target) return letters[i]; } return letters[0]; } } . Binary search . class Solution { public char nextGreatestLetter(char[] letters, char target) { int lo = 0, hi = letters.length; while (lo &lt; hi) { int mi = lo + (hi - lo) / 2; if (letters[mi] &lt;= target) lo = mi + 1; else hi = mi; } return letters[lo % letters.length]; } } . ",
    "url": "https://1001anjan.github.io/problem-126-Find-Smallest-Letter-Greater-Than-Target/",
    "relUrl": "/problem-126-Find-Smallest-Letter-Greater-Than-Target/"
  },"153": {
    "doc": "Verify Preorder Serialization of a Binary Tree",
    "title": "Verify Preorder Serialization of a Binary Tree",
    "content": "One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as ‘#’. For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where ‘#’ represents a null node. Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree. It is guaranteed that each comma-separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid. | For example, it could never contain two consecutive commas, such as “1,,3”. Note: You are not allowed to reconstruct the tree. | . Example 1: . Input: preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\" Output: true . Example 2: . Input: preorder = \"1,#\" Output: false . Example 3: . Input: preorder = \"9,#,#,1\" Output: false . Constraints: . | 1 &lt;= preorder.length &lt;= 10^4 | preorder consist of integers in the range [0, 100] and ‘#’ separated by commas ‘,’. | . Solution: . Using stack . class Solution { public boolean isValidSerialization(String preorder) { if(preorder.length() == 1) return preorder.charAt(0) == '#'; Stack&lt;Character&gt; st = new Stack&lt;&gt;(); String[] strs = preorder.split(\",\"); for(int i = 0; i &lt; strs.length - 1; i++){ if(!strs[i].equals(\"#\")){ st.push('L'); }else{ if(st.isEmpty()) return false; st.pop(); } } return st.isEmpty(); } } . class Solution { public boolean isValidSerialization(String preorder) { String[] strs = preorder.split(\",\"); int degree = -1; // root has no indegree, for compensate init with -1 for (String str: strs) { degree++; // all nodes have 1 indegree (root compensated) if (degree &gt; 0) { // total degree should never exceeds 0 return false; } if (!str.equals(\"#\")) {// only non-leaf node has 2 outdegree degree -= 2; } } return degree == 0; } } . ",
    "url": "https://1001anjan.github.io/problem-126-Verify%20Preorder%20Serialization%20of%20a%20Binary%20Tree/",
    "relUrl": "/problem-126-Verify Preorder Serialization of a Binary Tree/"
  },"154": {
    "doc": "Largest Number At Least Twice of Others",
    "title": "Largest Number At Least Twice of Others",
    "content": "You are given an integer array nums where the largest integer is unique. Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise. Example 1: . Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1. Example 2: . Input: nums = [1,2,3,4] Output: -1 Explanation: 4 is less than twice the value of 3, so we return -1. Constraints: . | 1 &lt;= nums.length &lt;= 50 | 0 &lt;= nums[i] &lt;= 100 | The largest element in nums is unique. | . Solution: . class Solution { public int dominantIndex(int[] nums) { int max = nums[0]; int index = 0; for(int i =0; i&lt;nums.length; i++){ if(max&lt;nums[i]) { max = nums[i]; index = i; } } for(int i=0; i&lt;nums.length; i++){ if(i != index &amp;&amp; max&lt;nums[i]*2) return -1; } return index; } } . ",
    "url": "https://1001anjan.github.io/problem-127-Largest-Number-At-Least-Twice-of-Others/",
    "relUrl": "/problem-127-Largest-Number-At-Least-Twice-of-Others/"
  },"155": {
    "doc": "Wiggle Sort II",
    "title": "Wiggle Sort II",
    "content": "Given an integer array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…. You may assume the input array always has a valid answer. Example 1: . Input: nums = [1,5,1,1,6,4] Output: [1,6,1,5,1,4] Explanation: [1,4,1,5,1,6] is also accepted. Example 2: . Input: nums = [1,3,2,2,3,1] Output: [2,3,1,3,1,2] . Constraints: . | 1 &lt;= nums.length &lt;= 5 * 10^4 | 0 &lt;= nums[i] &lt;= 5000 | It is guaranteed that there will be an answer for the given input nums. | Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? | . Solution: . class Solution { public void wiggleSort(int[] nums) { // base condition if(nums.length &lt; 2) return; // median index int k = nums.length / 2; // find median element int median = findMedianElement(nums, 0, nums.length - 1, k); // put odd position with greater than median number int odd = 1; for(int i = k; i &lt; nums.length; i++){ if(nums[i] &gt; median){ swap(nums, odd, i); odd += 2; } } while(odd &lt; nums.length &amp;&amp; nums[odd] == median) odd += 2; // it's possible that odd positions have not been perfectly filled by elements larger than median. // thus we need some elements equal to median // put elements equal to median on odd position first, then on even position 0, 2, 4 ... int even = 0; for(int i = 0; i&lt; nums.length; i += 2) { if(nums[i] == median) { if(odd &lt; nums.length) { swap(nums, i, odd); odd += 2; while(odd &lt; nums.length &amp;&amp; nums[odd] == median) odd += 2; } else { swap(nums, i, even); even += 2; } } } } public int findMedianElement(int[] nums, int start, int end, int k){ int p = partition(nums, start, end); if(p == k) return nums[k]; if(p &gt; k) return findMedianElement(nums, start, p - 1, k); else return findMedianElement(nums, p + 1, end, k); } public int partition(int[] nums, int start, int end){ int pivote = start; while(start &lt;= end){ while(start &lt;= end &amp;&amp; nums[start] &lt;= nums[pivote]) start ++; while(start &lt;= end &amp;&amp; nums[pivote] &lt; nums[end]) end --; if(start &gt; end) break; swap(nums, start, end); } swap(nums, pivote, end); return end; } public void swap(int[] nums, int i, int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } . ",
    "url": "https://1001anjan.github.io/problem-127-Wiggle%20Sort%20II/",
    "relUrl": "/problem-127-Wiggle Sort II/"
  },"156": {
    "doc": "Maximum Product of Word Lengths",
    "title": "Maximum Product of Word Lengths",
    "content": "Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0. Example 1: . Input: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"] Output: 16 Explanation: The two words can be \"abcw\", \"xtfn\". Example 2: . Input: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"] Output: 4 Explanation: The two words can be \"ab\", \"cd\". Example 3: . Input: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"] Output: 0 Explanation: No such pair of words. Constraints: . | 2 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length &lt;= 1000 | words[i] consists only of lowercase English letters. | . Solution: . class Solution { public int maxProduct(String[] words) { // base condition if(words == null || words.length &lt; 2) return 0; int maxProd = 0; int[] value = new int [words.length]; for(int i = 0; i &lt; words.length; i++){ for(int j = 0; j &lt; words[i].length(); j++){ value[i] |= 1 &lt;&lt; (words[i].charAt(j) - 'a'); } } for(int i = 0; i &lt; words.length - 1; i++){ for(int j = i + 1; j &lt; words.length; j++){ if((value[i] &amp; value[j]) == 0){ maxProd = Math.max(maxProd, words[i].length() * words[j].length()); } } } return maxProd; } } . ",
    "url": "https://1001anjan.github.io/problem-128-Maximum%20Product%20of%20Word%20Lengths/",
    "relUrl": "/problem-128-Maximum Product of Word Lengths/"
  },"157": {
    "doc": "Prime Number of Set Bits in Binary Representation",
    "title": "Prime Number of Set Bits in Binary Representation",
    "content": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of 1’s present when written in binary. For example, 21 written in binary is 10101, which has 3 set bits. Example 1: . Input: left = 6, right = 10 Output: 4 Explanation: 6 -&gt; 110 (2 set bits, 2 is prime) 7 -&gt; 111 (3 set bits, 3 is prime) 8 -&gt; 1000 (1 set bit, 1 is not prime) 9 -&gt; 1001 (2 set bits, 2 is prime) 10 -&gt; 1010 (2 set bits, 2 is prime) 4 numbers have a prime number of set bits. Example 2: . Input: left = 10, right = 15 Output: 5 Explanation: 10 -&gt; 1010 (2 set bits, 2 is prime) 11 -&gt; 1011 (3 set bits, 3 is prime) 12 -&gt; 1100 (2 set bits, 2 is prime) 13 -&gt; 1101 (3 set bits, 3 is prime) 14 -&gt; 1110 (3 set bits, 3 is prime) 15 -&gt; 1111 (4 set bits, 4 is not prime) 5 numbers have a prime number of set bits. Constraints: . | 1 &lt;= left &lt;= right &lt;= 106 | 0 &lt;= right - left &lt;= 104 | . Solution: . class Solution { public int countPrimeSetBits(int left, int right) { int count = 0; for(int i = left; i&lt;=right; i++){ int count1s = countBits(i); if(count1s&gt;0 &amp;&amp; isPrime(count1s)){ count++; } } return count; } public int countBits(int k){ int answer=0; while(k!=0){ answer++; k=k&amp;(k-1); } return answer; } public boolean isPrime(int num){ if(num == 1) return false; if(num == 2 || num == 3) return true; for(int i = 2; i&lt;=Math.sqrt(num); i++){ if(num%i == 0) return false; } return true; } } . class Solution { public int countPrimeSetBits(int left, int right) { int ans=0; Integer[]arr=new Integer[]{2,3,5,7,11,13,17,19}; Set&lt;Integer&gt;set=new HashSet&lt;&gt;(Arrays.asList(arr)); //System.out.println(set); for(int i=left;i&lt;=right;i++){ int count=count(i); if(set.contains(count))ans++; } return ans; } int count(int x){ int count=0; while(x!=0){ x-=(x&amp;-x); count++; } return count; } } . class Solution { public int countPrimeSetBits(int left, int right) { int cnt=0; for(int i=left;i&lt;=right;i++) if(isPrime(Integer.bitCount(i))) cnt++; return cnt; } public static boolean isPrime(int num) { if(num&lt;=1) return false; for(int i=2;(i*i)&lt;=num;i++) if((num%i)==0) return false; return true; } } . class Solution { public int countPrimeSetBits(int left, int right) { HashSet&lt;Integer&gt;prime=new HashSet&lt;&gt;(); prime.add(2); prime.add(3); prime.add(5); prime.add(7); prime.add(11); prime.add(13); prime.add(17); prime.add(19); prime.add(23); prime.add(29); prime.add(31); int cnt=0; for(int i=left;i&lt;=right;i++) if(prime.contains(Integer.bitCount(i))) cnt++; return cnt; } } . ",
    "url": "https://1001anjan.github.io/problem-128-Prime-Number-of-Set-Bits-in-Binary-Representation/",
    "relUrl": "/problem-128-Prime-Number-of-Set-Bits-in-Binary-Representation/"
  },"158": {
    "doc": "Number of Lines To Write String",
    "title": "Number of Lines To Write String",
    "content": "You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, and so on. You are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s. Return an array result of length 2 where: . | result[0] is the total number of lines. | result[1] is the width of the last line in pixels. | . Example 1: . Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\" Output: [3,60] Explanation: You can write s as follows: abcdefghij // 100 pixels wide klmnopqrst // 100 pixels wide uvwxyz // 60 pixels wide There are a total of 3 lines, and the last line is 60 pixels wide. Example 2: . Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\" Output: [2,4] Explanation: You can write s as follows: bbbcccdddaa // 98 pixels wide a // 4 pixels wide There are a total of 2 lines, and the last line is 4 pixels wide. Constraints: . | widths.length == 26 | 2 &lt;= widths[i] &lt;= 10 | 1 &lt;= s.length &lt;= 1000 | s contains only lowercase English letters. | . Solution: . class Solution { public int[] numberOfLines(int[] widths, String s) { int lines = 1; int lastWidth = 0; for(char ch : s.toCharArray()){ lastWidth += widths[ch-'a']; if(lastWidth&gt;100){ lines++; lastWidth = widths[ch-'a']; } } return new int[]{lines,lastWidth}; } } . ",
    "url": "https://1001anjan.github.io/problem-129-Number-of-Lines-To-Write-String/",
    "relUrl": "/problem-129-Number-of-Lines-To-Write-String/"
  },"159": {
    "doc": "Remove Duplicate Letters",
    "title": "Remove Duplicate Letters",
    "content": "Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results. Example 1: . Input: s = \"bcabc\" Output: \"abc\" . Example 2: . Input: s = \"cbacdcbc\" Output: \"acdb\" . Constraints: . | 1 &lt;= s.length &lt;= 10^4 | s consists of lowercase English letters. | . Solution: . class Solution { public String removeDuplicateLetters(String s) { Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); int[] lastIndex = new int[26]; int len = s.length(); for(int i = 0; i &lt; len; i++){ lastIndex[s.charAt(i) - 'a'] = i; } Set&lt;Character&gt; seen = new HashSet&lt;&gt;(); stack.push(s.charAt(0)); seen.add(stack.peek()); for(int i = 1; i &lt; len; i++){ char ch = s.charAt(i); if(seen.contains(ch)) continue; while(!stack.isEmpty()){ char c = stack.peek(); if(c &gt; ch &amp;&amp; lastIndex[c - 'a'] &gt; i){ stack.pop(); seen.remove(c); }else{ break; } } seen.add(ch); stack.push(ch); } StringBuilder sb = new StringBuilder(); while(!stack.isEmpty()) sb.append(stack.pop()); return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-129-Remove%20Duplicate%20Letters/",
    "relUrl": "/problem-129-Remove Duplicate Letters/"
  },"160": {
    "doc": "Generate Parentheses",
    "title": "Generate Parentheses",
    "content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1: . Input: n = 3 Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] . Example 2: . Input: n = 1 Output: [\"()\"] . Constraints: . | 1 &lt;= n &lt;= 8 | . Solution: . class Solution { public List&lt;String&gt; generateParenthesis(int n){ if(n == 1){ return new ArrayList(Arrays.asList(\"()\")); } List&lt;String&gt; list = generateParenthesis(n - 1); Set&lt;String&gt; ans = new HashSet&lt;&gt;(); for(String str : list){ for(int i = 0; i &lt; str.length(); i++){ if(str.charAt(i) == '('){ ans.add(str.substring(0, i + 1)+\"()\"+str.substring(i + 1, str.length())); } } ans.add(str+\"()\"); } return new ArrayList(ans); } } . class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; ans = new ArrayList(); if (n == 0) { ans.add(\"\"); } else { for (int c = 0; c &lt; n; ++c) for (String left: generateParenthesis(c)) for (String right: generateParenthesis(n-1-c)) ans.add(\"(\" + left + \")\" + right); } return ans; } } . class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; } public void generateAll(char[] current, int pos, List&lt;String&gt; result) { if (pos == current.length) { if (valid(current)) result.add(new String(current)); } else { current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); } } public boolean valid(char[] current) { int balance = 0; for (char c: current) { if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; } return (balance == 0); } } . ",
    "url": "https://1001anjan.github.io/problem-13-Generate%20Parentheses/",
    "relUrl": "/problem-13-Generate Parentheses/"
  },"161": {
    "doc": "Plus One",
    "title": "Plus One",
    "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s. Increment the large integer by one and return the resulting array of digits. Example 1: . Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]. Example 2: . Input: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]. Example 3: . Input: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]. Constraints: . | 1 &lt;= digits.length &lt;= 100 | 0 &lt;= digits[i] &lt;= 9 | digits does not contain any leading 0’s. | . Solution . class Solution { public int[] plusOne(int[] digits) { for(int i=digits.length-1; i&gt;=0; i--){ if(digits[i] &lt; 9){ digits[i] = digits[i] + 1; break; }else{ digits[i] = 0; } } if(digits[0] == 0){ int[] updatedDigits = new int[digits.length+1]; updatedDigits[0] = 1; for(int i=0; i&lt;digits.length; i++){ updatedDigits[i+1] = digits[i]; } return updatedDigits; } return digits; } } . Other . class Solution { public int[] plusOne(int[] digits) { int []result = new int[digits.length+1]; result[digits.length] = (digits[digits.length-1]+1)%10; int c = (digits[digits.length-1]+1)/10; digits[digits.length-1] = (digits[digits.length-1]+1)%10; int c1 = c; for(int i = digits.length-2; i&gt;=0; i--){ result[i+1] = (digits[i]+c1)%10; c = (digits[i]+c)/10; digits[i] = (digits[i]+c1)%10; c1 = c; } result[0] = c; if(c&gt;0){ return result; } return digits; } } . ",
    "url": "https://1001anjan.github.io/problem-13-plus-one/",
    "relUrl": "/problem-13-plus-one/"
  },"162": {
    "doc": "Minimum Height Trees",
    "title": "Minimum Height Trees",
    "content": "A tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree. Given a tree of n nodes labelled from 0 to n - 1, and an array of n - 1 edges where edges[i] = [ai, bi] indicates that there is an undirected edge between the two nodes ai and bi in the tree, you can choose any node of the tree as the root. When you select a node x as the root, the result tree has height h. Among all possible rooted trees, those with minimum height (i.e. min(h)) are called minimum height trees (MHTs). Return a list of all MHTs’ root labels. You can return the answer in any order. The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf. Example 1: . Input: n = 4, edges = [[1,0],[1,2],[1,3]] Output: [1] Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT. Example 2: . Input: n = 6, edges = [[3,0],[3,1],[3,2],[3,4],[5,4]] Output: [3,4] . Constraints: . | 1 &lt;= n &lt;= 2 * 10^4 | edges.length == n - 1 | 0 &lt;= ai, bi &lt; n | ai != bi | All the pairs (ai, bi) are distinct. | The given input is guaranteed to be a tree and there will be no repeated edges. | . Solution: . Time Limit Exceeded . class Solution { public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) { // base case Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); List&lt;Integer[]&gt; nodeHeight = new ArrayList&lt;&gt;(); List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if(n == 0) return ans; if(n == 1){ ans.add(0); return ans; } for(int[] arr : edges){ adj.computeIfAbsent(arr[0], value -&gt; new ArrayList&lt;&gt;()).add(arr[1]); adj.computeIfAbsent(arr[1], value -&gt; new ArrayList&lt;&gt;()).add(arr[0]); } for(int i = 0; i &lt; n; i++){ Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); Set&lt;Integer&gt; seen = new HashSet&lt;&gt;(); q.offer(i); seen.add(i); int height = 0; while(!q.isEmpty()){ int size = q.size(); Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;(); while(size &gt; 0){ List&lt;Integer&gt; list = adj.get(q.poll()); for(int in : list){ if(seen.contains(in)) continue; q1.offer(in); seen.add(in); } size --; } height ++; q = q1; } nodeHeight.add(new Integer[]{i, height}); } int min = Collections.min(nodeHeight, (a, b) -&gt; (a[1].compareTo(b[1])))[1]; for(Integer[] inr : nodeHeight){ if(inr[1] == min) ans.add(inr[0]); } return ans; } } . removing leaves – finding centroid . class Solution { public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) { Set&lt;Integer&gt;[] adj = new HashSet[n]; // initializing adjacency list for all the nodes for(int i = 0; i &lt; n; i++){ adj[i] = new HashSet&lt;&gt;(); } // setting adges for the nodes for(int[] arr : edges){ adj[arr[0]].add(arr[1]); adj[arr[1]].add(arr[0]); } List&lt;Integer&gt; leaves = new ArrayList&lt;&gt;(); Set&lt;Integer&gt; process = new HashSet&lt;&gt;(); int n1 = n; while(n &gt; 2 ){ leaves.clear(); // calculate leaves node for(int i = 0; i &lt; adj.length; i++){ if(adj[i].size() == 1){ leaves.add(i); } } // detach leave node for(Integer l : leaves){ adj[new ArrayList&lt;&gt;(adj[l]).get(0)].remove(l); adj[l].clear(); } n -= leaves.size(); process.addAll(leaves); } List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; n1; i++){ if(!process.contains(i)) ans.add(i); } return ans; } } . Improvement . class Solution { public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) { // edge cases if (n &lt; 2) { ArrayList&lt;Integer&gt; centroids = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) centroids.add(i); return centroids; } // Build the graph with the adjacency list ArrayList&lt;Set&lt;Integer&gt;&gt; neighbors = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) neighbors.add(new HashSet&lt;Integer&gt;()); for (int[] edge : edges) { Integer start = edge[0], end = edge[1]; neighbors.get(start).add(end); neighbors.get(end).add(start); } // Initialize the first layer of leaves ArrayList&lt;Integer&gt; leaves = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++) if (neighbors.get(i).size() == 1) leaves.add(i); // Trim the leaves until reaching the centroids int remainingNodes = n; while (remainingNodes &gt; 2) { remainingNodes -= leaves.size(); ArrayList&lt;Integer&gt; newLeaves = new ArrayList&lt;&gt;(); // remove the current leaves along with the edges for (Integer leaf : leaves) { // the only neighbor left for the leaf node Integer neighbor = neighbors.get(leaf).iterator().next(); // remove the edge along with the leaf node neighbors.get(neighbor).remove(leaf); if (neighbors.get(neighbor).size() == 1) newLeaves.add(neighbor); } // prepare for the next round leaves = newLeaves; } // The remaining nodes are the centroids of the graph return leaves; } } . ",
    "url": "https://1001anjan.github.io/problem-130-Minimum%20Height%20Trees/",
    "relUrl": "/problem-130-Minimum Height Trees/"
  },"163": {
    "doc": "Shortest Distance to a Character",
    "title": "Shortest Distance to a Character",
    "content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s. The distance between two indices i and j is abs(i - j), where abs is the absolute value function. Example 1: . Input: s = \"loveleetcode\", c = \"e\" Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2. Example 2: . Input: s = \"aaab\", c = \"b\" Output: [3,2,1,0] . Constraints: . | 1 &lt;= s.length &lt;= 104 | s[i] and c are lowercase English letters. | It is guaranteed that c occurs at least once in s. | . Solution: . class Solution { public int[] shortestToChar(String s, char c) { int[] ans = new int[s.length()]; int index = Integer.MAX_VALUE; // Scan left to right for(int i=0; i&lt;s.length(); i++){ if(s.charAt(i) == c) index = i; ans[i] = Math.abs(index - i); } // Scan right to left for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) == c) index = i; ans[i] = Math.min(ans[i], Math.abs(index - i)); } return ans; } } . class Solution { public int[] shortestToChar(String S, char C) { TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); //add all indexes of C into tree set for(int i = 0;i &lt; S.length();i++) if(S.charAt(i) == C) set.add(i); int[] result = new int[S.length()]; for(int i = 0;i &lt; S.length();i++){ if(!set.contains(i)){ Integer left = set.floor(i); Integer right = set.ceiling(i); if(left == null) left = Integer.MAX_VALUE; if (right == null) right = Integer.MAX_VALUE; result[i] = Math.min(Math.abs(left - i),Math.abs(right -i )); }else{ result[i] = 0; } } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-130-Shortest-Distance-to-a-Character/",
    "relUrl": "/problem-130-Shortest-Distance-to-a-Character/"
  },"164": {
    "doc": "Course Schedule",
    "title": "Course Schedule",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. | For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false. | . Example 1: . Input: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2: . Input: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. Constraints: . | 1 &lt;= numCourses &lt;= 2000 | 0 &lt;= prerequisites.length &lt;= 5000 | prerequisites[i].length == 2 | 0 &lt;= ai, bi &lt; numCourses | All the pairs prerequisites[i] are unique. | . Solution: . Graph based solution . class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { Map&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for (int[] p : prerequisites) { map.computeIfAbsent(p[0], value -&gt; new HashSet&lt;&gt;()).add(p[1]); } while (!map.isEmpty()) { if(dfs(map.keySet().iterator().next(), map, new HashSet&lt;&gt;())) return false; } return true; } private boolean dfs(int start, Map&lt;Integer,Set&lt;Integer&gt;&gt; map, Set&lt;Integer&gt; visited) { if (visited.contains(start)) return true; if (!map.containsKey(start)) return false; visited.add(start); while (!map.get(start).isEmpty()) { int n = map.get(start).iterator().next(); if (dfs(n, map, visited)) return true; map.get(start).remove(n); } map.remove(start); visited.remove(start); return false; } } . ",
    "url": "https://1001anjan.github.io/problem-131-Course%20Schedule/",
    "relUrl": "/problem-131-Course Schedule/"
  },"165": {
    "doc": "Goat Latin",
    "title": "Goat Latin",
    "content": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: . | If a word begins with a vowel (‘a’, ‘e’, ‘i’, ‘o’, or ‘u’), append “ma” to the end of the word. ** For example, the word “apple” becomes “applema”. | If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add “ma”. ** For example, the word “goat” becomes “oatgma”. | Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1. ** For example, the first word gets “a” added to the end, the second word gets “aa” added to the end, and so on. | . Return the final sentence representing the conversion from sentence to Goat Latin. Example 1: . Input: sentence = \"I speak Goat Latin\" Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" . Example 2: . Input: sentence = \"The quick brown fox jumped over the lazy dog\" Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" . Constraints: . | 1 &lt;= sentence.length &lt;= 150 | sentence consists of English letters and spaces. | sentence has no leading or trailing spaces. | All the words in sentence are separated by a single space. | . Solution: . class Solution { public String toGoatLatin(String sentence) { StringBuilder sb = new StringBuilder(); StringBuilder suf = new StringBuilder(); suf.append('a'); String[] words = sentence.split(\"\\\\s+\"); for(String s : words){ if(isVowel(s.charAt(0))){ sb.append(s); }else{ sb.append(s.substring(1,s.length())); sb.append(s.charAt(0)); } sb.append(\"ma\"); sb.append(suf); sb.append(\" \"); suf.append(\"a\"); } return sb.toString().trim(); } public boolean isVowel(char c){ switch(c){ case 'a','e','i','o','u','A','E','I','O','U': return true; default: return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-131-Goat-Latin/",
    "relUrl": "/problem-131-Goat-Latin/"
  },"166": {
    "doc": "Course Schedule II",
    "title": "Course Schedule II",
    "content": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai. | For example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array. | . Example 1: . Input: numCourses = 2, prerequisites = [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]. Example 2: . Input: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] Output: [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]. Example 3: . Input: numCourses = 1, prerequisites = [] Output: [0] . Constraints: . | 1 &lt;= numCourses &lt;= 2000 | 0 &lt;= prerequisites.length &lt;= numCourses * (numCourses - 1) | prerequisites[i].length == 2 | 0 &lt;= ai, bi &lt; numCourses | ai != bi | All the pairs [ai, bi] are distinct. | . Solution: . class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); Set&lt;Integer&gt; added = new HashSet&lt;&gt;(); Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int[] arr : prerequisites){ map.computeIfAbsent(arr[0], value -&gt; new ArrayList&lt;&gt;()).add(arr[1]); } for(int k = 0; k &lt; numCourses; k++){ if(dfs(k, map, list, new HashSet&lt;&gt;(), added)) return new int[0]; } int[] ans = new int[list.size()]; int i = 0; for(int n : list) ans[i++] = n; return ans; } public boolean dfs(int start, Map&lt;Integer, List&lt;Integer&gt;&gt; map, LinkedList&lt;Integer&gt; list, Set&lt;Integer&gt; visited, Set&lt;Integer&gt; added){ if(visited.contains(start)) return true; if(!map.containsKey(start)){ if(added.add(start)) list.add(start); return false; } visited.add(start); while(!map.get(start).isEmpty()){ Integer node = map.get(start).iterator().next(); if(dfs(node, map, list, visited, added)) return true; map.get(start).remove(node); } if(added.add(start)) list.add(start); map.remove(start); visited.remove(start); return false; } } . ",
    "url": "https://1001anjan.github.io/problem-132-Course%20Schedule%20II/",
    "relUrl": "/problem-132-Course Schedule II/"
  },"167": {
    "doc": "Positions of Large Groups",
    "title": "Positions of Large Groups",
    "content": "In a string s of lowercase letters, these letters form consecutive groups of the same character. For example, a string like s = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z”, and “yy”. A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, “xxxx” has the interval [3,6]. A group is considered large if it has 3 or more characters. Return the intervals of every large group sorted in increasing order by start index. Example 1: . Input: s = \"abbxxxxzzy\" Output: [[3,6]] Explanation: \"xxxx\" is the only large group with start index 3 and end index 6. Example 2: . Input: s = \"abc\" Output: [] Explanation: We have groups \"a\", \"b\", and \"c\", none of which are large groups. Example 3: . Input: s = \"abcdddeeeeaabbbcd\" Output: [[3,5],[6,9],[12,14]] Explanation: The large groups are \"ddd\", \"eeee\", and \"bbb\". Constraints: . | 1 &lt;= s.length &lt;= 1000 | s contains lowercase English letters only. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int l = 0; int u = 0; for(int i=1; i&lt;s.length(); i++){ if(s.charAt(i-1) == s.charAt(i)){ u++; }else{ if(u - l +1 &gt;= 3){ ans.add(Arrays.asList(new Integer[]{l, u})); } l = u = i; } } if(u - l +1 &gt;= 3){ ans.add(Arrays.asList(new Integer[]{l, u})); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-132-Positions-of-Large-Groups/",
    "relUrl": "/problem-132-Positions-of-Large-Groups/"
  },"168": {
    "doc": "Design Twitter",
    "title": "Design Twitter",
    "content": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user’s news feed. Implement the Twitter class: . | Twitter() Initializes your twitter object. | void postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId. | List getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent. | void follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId. | void unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId. | . Example 1: . Input [\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"] [[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]] Output [null, null, [5], null, null, [6, 5], null, [5]] Explanation Twitter twitter = new Twitter(); twitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5). twitter.getNewsFeed(1); // User 1's news feed should return a list with 1 tweet id -&gt; [5]. return [5] twitter.follow(1, 2); // User 1 follows user 2. twitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6). twitter.getNewsFeed(1); // User 1's news feed should return a list with 2 tweet ids -&gt; [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5. twitter.unfollow(1, 2); // User 1 unfollows user 2. twitter.getNewsFeed(1); // User 1's news feed should return a list with 1 tweet id -&gt; [5], since user 1 is no longer following user 2. Constraints: . | 1 &lt;= userId, followerId, followeeId &lt;= 500 | 0 &lt;= tweetId &lt;= 104 | All the tweets have unique IDs. | At most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow. | . Solution: . class Twitter { Map&lt;Integer, Set&lt;Integer&gt;&gt; followers; Map&lt;Integer, Set&lt;Integer&gt;&gt; followees; LinkedList&lt;Integer[]&gt; tweets; public Twitter() { followers = new HashMap&lt;&gt;(); followees = new HashMap&lt;&gt;(); tweets = new LinkedList&lt;&gt;(); } public void postTweet(int userId, int tweetId) { tweets.addFirst(new Integer[]{userId, tweetId}); } public List&lt;Integer&gt; getNewsFeed(int userId) { List&lt;Integer&gt; tweet = new ArrayList&lt;&gt;(); int i = 0; for(Integer[] t : tweets){ if(t[0] == userId || (followees.get(userId) != null &amp;&amp; followees.get(userId).contains(t[0]))){ tweet.add(t[1]); i++; if(i == 10) return tweet; } } return tweet; } public void follow(int followerId, int followeeId) { followers.computeIfAbsent(followeeId, value -&gt; new HashSet&lt;&gt;()).add((Integer)followerId); followees.computeIfAbsent(followerId, value -&gt; new HashSet&lt;&gt;()).add((Integer)followeeId); } public void unfollow(int followerId, int followeeId) { if(followers.get(followeeId) != null) followers.get(followeeId).remove((Integer)followerId); if(followees.get(followerId) != null) followees.get(followerId).remove((Integer)followeeId); } } /** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * List&lt;Integer&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */ . ",
    "url": "https://1001anjan.github.io/problem-133-Design%20Twitter/",
    "relUrl": "/problem-133-Design Twitter/"
  },"169": {
    "doc": "Flipping an Image",
    "title": "Flipping an Image",
    "content": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0,1,1] results in [1,0,0]. Example 1: . Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] . Example 2: . Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] . Constraints: . | n == image.length | n == image[i].length | 1 &lt;= n &lt;= 20 | images[i][j] is either 0 or 1. | . Solution: . class Solution { public int[][] flipAndInvertImage(int[][] image) { int m = image.length; int n = image[0].length; // flip image for(int i=0; i&lt;m; i++){ int s = 0; int e = n - 1; while(s&lt;e){ int t = image[i][s]; image[i][s] = image[i][e]; image[i][e] = t; s++; e--; } } // Invert image for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++) if(image[i][j] == 1) image[i][j] = 0; else image[i][j] = 1; return image; } } . class Solution { public int[][] flipAndInvertImage(int[][] A) { int C = A[0].length; for (int[] row: A) for (int i = 0; i &lt; (C + 1) / 2; ++i) { int tmp = row[i] ^ 1; row[i] = row[C - 1 - i] ^ 1; row[C - 1 - i] = tmp; } return A; } } . ",
    "url": "https://1001anjan.github.io/problem-133-Flipping-an-Image/",
    "relUrl": "/problem-133-Flipping-an-Image/"
  },"170": {
    "doc": "Backspace String Compare",
    "title": "Backspace String Compare",
    "content": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. ‘#’ means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1: . Input: s = \"ab#c\", t = \"ad#c\" Output: true Explanation: Both s and t become \"ac\". Example 2: . Input: s = \"ab##\", t = \"c#d#\" Output: true Explanation: Both s and t become \"\". Example 3: . Input: s = \"a#c\", t = \"b\" Output: false Explanation: s becomes \"c\" while t becomes \"b\". Constraints: . | 1 &lt;= s.length, t.length &lt;= 200 | s and t only contain lowercase letters and ‘#’ characters. | . Solution: . class Solution { public boolean backspaceCompare(String s, String t) { return processBackspace(s).equals(processBackspace(t)); } public String processBackspace(String s){ StringBuilder sb = new StringBuilder(); int c = 0; for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) != '#'){ if(c&gt;0){ c--; }else{ sb.append(s.charAt(i)); } }else{ c++; } } return sb.toString(); } } . class Solution { public boolean backspaceCompare(String S, String T) { return build(S).equals(build(T)); } public String build(String S) { Stack&lt;Character&gt; ans = new Stack(); for (char c: S.toCharArray()) { if (c != '#') ans.push(c); else if (!ans.empty()) ans.pop(); } return String.valueOf(ans); } } . class Solution { public boolean backspaceCompare(String S, String T) { int i = S.length() - 1, j = T.length() - 1; int skipS = 0, skipT = 0; while (i &gt;= 0 || j &gt;= 0) { // While there may be chars in build(S) or build (T) while (i &gt;= 0) { // Find position of next possible char in build(S) if (S.charAt(i) == '#') {skipS++; i--;} else if (skipS &gt; 0) {skipS--; i--;} else break; } while (j &gt;= 0) { // Find position of next possible char in build(T) if (T.charAt(j) == '#') {skipT++; j--;} else if (skipT &gt; 0) {skipT--; j--;} else break; } // If two actual characters are different if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; S.charAt(i) != T.charAt(j)) return false; // If expecting to compare char vs nothing if ((i &gt;= 0) != (j &gt;= 0)) return false; i--; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-134-Backspace-String-Compare/",
    "relUrl": "/problem-134-Backspace-String-Compare/"
  },"171": {
    "doc": "Count Numbers with Unique Digits",
    "title": "Count Numbers with Unique Digits",
    "content": "Given an integer n, return the count of all numbers with unique digits, x, where 0 &lt;= x &lt; 10n. Example 1: . Input: n = 2 Output: 91 Explanation: The answer should be the total numbers in the range of 0 ≤ x &lt; 100, excluding 11,22,33,44,55,66,77,88,99 . Example 2: . Input: n = 0 Output: 1 . Constraints: . | 0 &lt;= n &lt;= 8 | . Solution: . class Solution { public int countNumbersWithUniqueDigits(int n) { if(n == 0) return 1; int res = 10; int uniqueDigits = 9; int availableDigits = 9; while(n&gt; 1 &amp;&amp; availableDigits &gt; 1){ uniqueDigits = uniqueDigits * availableDigits; res += uniqueDigits; n --; availableDigits --; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-134-Count%20Numbers%20with%20Unique%20Digits/",
    "relUrl": "/problem-134-Count Numbers with Unique Digits/"
  },"172": {
    "doc": "Buddy Strings",
    "title": "Buddy Strings",
    "content": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j]. For example, swapping at indices 0 and 2 in “abcd” results in “cbad”. Example 1: . Input: s = \"ab\", goal = \"ba\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal. Example 2: . Input: s = \"ab\", goal = \"ab\" Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal. Example 3: . Input: s = \"aa\", goal = \"aa\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal. Constraints: . | 1 &lt;= s.length, goal.length &lt;= 2 * 104 | s and goal consist of lowercase letters. | . Solution: . class Solution { public boolean buddyStrings(String s, String goal) { if(s.length() != goal.length()) return false; if(s.equals(goal)){ int[] arr = new int[26]; for(char c: s.toCharArray()){ arr[c-'a']++; } for(int i=0; i&lt;26;i++){ if(arr[i]&gt;1) return true; } return false; }else{ int first = -1; int second = -1; for(int i=0; i&lt;s.length(); i++){ if(s.charAt(i) != goal.charAt(i)){ if(first == -1) first = i; else if(second == -1) second = i; else return false; } } if(second == -1) return false; return s.charAt(first) == goal.charAt(second) &amp;&amp; s.charAt(second) == goal.charAt(first); } } } . ",
    "url": "https://1001anjan.github.io/problem-135-Buddy-Strings/",
    "relUrl": "/problem-135-Buddy-Strings/"
  },"173": {
    "doc": "Sum of Two Integers",
    "title": "Sum of Two Integers",
    "content": "Given two integers a and b, return the sum of the two integers without using the operators + and -. Example 1: . Input: a = 1, b = 2 Output: 3 . Example 2: . Input: a = 2, b = 3 Output: 5 . Constraints: . | -1000 &lt;= a, b &lt;= 1000 | . Solution: . class Solution { public int getSum(int a, int b) { if(b == 0) return a; int carry = (a &amp; b) &lt;&lt; 1; int sum = a ^ b; return getSum(sum, carry); } } . ",
    "url": "https://1001anjan.github.io/problem-135-Sum%20of%20Two%20Integers/",
    "relUrl": "/problem-135-Sum of Two Integers/"
  },"174": {
    "doc": "Lemonade Change",
    "title": "Lemonade Change",
    "content": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise. Example 1: . Input: bills = [5,5,5,10,20] Output: true Explanation: From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true. Example 2: . Input: bills = [5,5,10,10,20] Output: false Explanation: From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can not give the change of $15 back because we only have two $10 bills. Since not every customer received the correct change, the answer is false. Constraints: . | 1 &lt;= bills.length &lt;= 105 | bills[i] is either 5, 10, or 20. | . Solution: . class Solution { public boolean lemonadeChange(int[] bills) { int count5 = 0; int count10 = 0; int count20 = 0; for(int i=0; i&lt;bills.length; i++){ if(bills[i] == 5) { count5++; }else if(bills[i] == 10){ if(count5 == 0) return false; count5--; count10++; }else if(bills[i] == 20){ if(count5 == 0) return false; if(count10&gt;=1){ count10--; count5--; }else{ if(count5&gt;=3) count5 = count5 - 3; else return false; } } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-136-Lemonade-Change/",
    "relUrl": "/problem-136-Lemonade-Change/"
  },"175": {
    "doc": "Water and Jug Problem",
    "title": "Water and Jug Problem",
    "content": "You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs. If targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end. Operations allowed: . | Fill any of the jugs with water. | Empty any of the jugs. | Pour water from one jug into another till the other jug is completely full, or the first jug itself is empty. | . Example 1: . Input: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4 Output: true Explanation: The famous Die Hard example . Example 2: . Input: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5 Output: false . Example 3: . Input: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3 Output: true . Constraints: . | 1 &lt;= jug1Capacity, jug2Capacity, targetCapacity &lt;= 10^6 | . Solution: . every z = ax+by in range [0, x+y] is measurable. class Solution { public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) { if(jug1Capacity + jug2Capacity &lt; targetCapacity) return false; if(jug1Capacity == targetCapacity || jug2Capacity == targetCapacity || jug1Capacity + jug2Capacity == targetCapacity) return true; return targetCapacity % GCD(jug1Capacity, jug2Capacity) == 0; } public int GCD(int a, int b){ if(b == 0) return a; return GCD(b, a % b); } } . ",
    "url": "https://1001anjan.github.io/problem-136-Water%20and%20Jug%20Problem/",
    "relUrl": "/problem-136-Water and Jug Problem/"
  },"176": {
    "doc": "Largest Divisible Subset",
    "title": "Largest Divisible Subset",
    "content": "Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies: . | answer[i] % answer[j] == 0, or | answer[j] % answer[i] == 0 If there are multiple solutions, return any of them. | . Example 1: . Input: nums = [1,2,3] Output: [1,2] Explanation: [1,3] is also accepted. Example 2: . Input: nums = [1,2,4,8] Output: [1,2,4,8] . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 2 * 10^9 | All the integers in nums are unique. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-137-Largest%20Divisible%20Subset/",
    "relUrl": "/problem-137-Largest Divisible Subset/"
  },"177": {
    "doc": "Transpose Matrix",
    "title": "Transpose Matrix",
    "content": "Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix’s row and column indices. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] . Example 2: . Input: matrix = [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 1000 | 1 &lt;= m * n &lt;= 105 | -109 &lt;= matrix[i][j] &lt;= 109 | . Solution: . class Solution { public int[][] transpose(int[][] matrix) { int [][] t = new int[matrix[0].length][matrix.length]; for(int i=0; i&lt;matrix.length; i++) for(int j=0; j&lt;matrix[0].length; j++) t[j][i] = matrix[i][j]; return t; } } . ",
    "url": "https://1001anjan.github.io/problem-137-Transpose-Matrix/",
    "relUrl": "/problem-137-Transpose-Matrix/"
  },"178": {
    "doc": "Binary Gap",
    "title": "Binary Gap",
    "content": "Given a positive integer n, find and return the longest distance between any two adjacent 1’s in the binary representation of n. If there are no two adjacent 1’s, return 0. Two 1’s are adjacent if there are only 0’s separating them (possibly no 0’s). The distance between two 1’s is the absolute difference between their bit positions. For example, the two 1’s in “1001” have a distance of 3. Example 1: . Input: n = 22 Output: 2 Explanation: 22 in binary is \"10110\". The first adjacent pair of 1's is \"10110\" with a distance of 2. The second adjacent pair of 1's is \"10110\" with a distance of 1. The answer is the largest of these two distances, which is 2. Note that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined. Example 2: . Input: n = 8 Output: 0 Explanation: 8 in binary is \"1000\". There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0. Example 3: . Input: n = 5 Output: 2 Explanation: 5 in binary is \"101\". Constraints: . | 1 &lt;= n &lt;= 109 | . class Solution { public int binaryGap(int n) { int prevMax = 0; String bits = Integer.toBinaryString(n); int s = 0; int e = 0; boolean f = false; for(int i=0; i&lt;bits.length(); i++){ if(bits.charAt(i) == '1'){ if(!f){ s = i; f = true; }else{ e = i; prevMax = Math.max(prevMax, e-s); s = i; } } } return prevMax; } } . class Solution { public int binaryGap(int N) { int last = -1, ans = 0; for (int i = 0; i &lt; 32; ++i) if (((N &gt;&gt; i) &amp; 1) &gt; 0) { if (last &gt;= 0) ans = Math.max(ans, i - last); last = i; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-138-Binary-Gap/",
    "relUrl": "/problem-138-Binary-Gap/"
  },"179": {
    "doc": "Shuffle an Array",
    "title": "Shuffle an Array",
    "content": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling. Implement the Solution class: . | Solution(int[] nums) Initializes the object with the integer array nums. | int[] reset() Resets the array to its original configuration and returns it. | int[] shuffle() Returns a random shuffling of the array. | . Example 1: . Input [\"Solution\", \"shuffle\", \"reset\", \"shuffle\"] [[[1, 2, 3]], [], [], []] Output [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] Explanation Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // Shuffle the array [1,2,3] and return its result. // Any permutation of [1,2,3] must be equally likely to be returned. // Example: return [3, 1, 2] solution.reset(); // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3] solution.shuffle(); // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2] . Constraints: . | 1 &lt;= nums.length &lt;= 50 | -10^6 &lt;= nums[i] &lt;= 10^6 | All the elements of nums are unique. | At most 10^4 calls in total will be made to reset and shuffle. | . Solution: . class Solution { int [] original, copy; public Solution(int[] nums) { original = nums; copy = new int[nums.length]; copy = nums.clone(); } public int[] reset() { //copy = original.clone(); return original; } public int[] shuffle() { Random rand = new Random(); for(int i = 0; i &lt; copy.length/2; i++){ int k = rand.nextInt(copy.length); int l = rand.nextInt(copy.length); swap(copy, k, l); } return copy; } public void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } } /** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int[] param_1 = obj.reset(); * int[] param_2 = obj.shuffle(); */ . ",
    "url": "https://1001anjan.github.io/problem-138-Shuffle%20an%20Array/",
    "relUrl": "/problem-138-Shuffle an Array/"
  },"180": {
    "doc": "Leaf-Similar Trees",
    "title": "Leaf-Similar Trees",
    "content": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. Example 1: . Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output: true . Example 2: . Input: root1 = [1,2,3], root2 = [1,3,2] Output: false . Constraints: . | The number of nodes in each tree will be in the range [1, 200]. | Both of the given trees will have values in the range [0, 200]. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean leafSimilar(TreeNode root1, TreeNode root2) { List&lt;Integer&gt; l1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;&gt;(); dfs(root1,l1); dfs(root2,l2); return l1.equals(l2); } public void dfs(TreeNode head, List&lt;Integer&gt; l){ if(head == null) return; if(head.left == null &amp;&amp; head.right == null) l.add(head.val); dfs(head.left,l); dfs(head.right,l); } } . ",
    "url": "https://1001anjan.github.io/problem-139-Leaf-Similar-Trees/",
    "relUrl": "/problem-139-Leaf-Similar-Trees/"
  },"181": {
    "doc": "Linked List Random Node",
    "title": "Linked List Random Node",
    "content": "Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Implement the Solution class: . | Solution(ListNode head) Initializes the object with the head of the singly-linked list head. | int getRandom() Chooses a node randomly from the list and returns its value. All the nodes of the list should be equally likely to be chosen. | . Example 1: . Input [\"Solution\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\", \"getRandom\"] [[[1, 2, 3]], [], [], [], [], []] Output [null, 1, 3, 2, 2, 3] Explanation Solution solution = new Solution([1, 2, 3]); solution.getRandom(); // return 1 solution.getRandom(); // return 3 solution.getRandom(); // return 2 solution.getRandom(); // return 2 solution.getRandom(); // return 3 // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning. Constraints: . | The number of nodes in the linked list will be in the range [1, 10^4]. | -10^4 &lt;= Node.val &lt;= 10^4 | At most 10^4 calls will be made to getRandom. | . Follow up: . | What if the linked list is extremely large and its length is unknown to you? | Could you solve this efficiently without using extra space? | . Solution: . class Solution { private ArrayList&lt;Integer&gt; range = new ArrayList&lt;&gt;(); /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) { while (head != null) { this.range.add(head.val); head = head.next; } } /** Returns a random node's value. */ public int getRandom() { int pick = (int)(Math.random() * this.range.size()); return this.range.get(pick); } } /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ . The above solution is simple, which happens to be fast as well. But it comes with two caveats: . | It requires some space to keep the pool of elements for sampling, which does not meet the constraint asked in the follow-up question, i.e. a solution of constant space. | It cannot cope with the scenario that we have a list with ever-growing elements, i.e. we don’t have unlimited memory to hold all the elements. For example, we have a stream of numbers, and we would like to pick a random number at any given moment. With the above naive solution, we would have to keep all the numbers in the memory, which is not scalable. | . We will address the above caveats in the next approach. Reservoir Sampling . class Solution { private ListNode head; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ public Solution(ListNode head) { this.head = head; } /** Returns a random node's value. */ public int getRandom() { int scope = 1, chosenValue = 0; ListNode curr = this.head; while (curr != null) { // decide whether to include the element in reservoir if (Math.random() &lt; 1.0 / scope) chosenValue = curr.val; // move on to the next node scope += 1; curr = curr.next; } return chosenValue; } } /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ . ",
    "url": "https://1001anjan.github.io/problem-139-Linked%20List%20Random%20Node/",
    "relUrl": "/problem-139-Linked List Random Node/"
  },"182": {
    "doc": "Add Binary",
    "title": "Add Binary",
    "content": "Given two binary strings a and b, return their sum as a binary string. Example 1: . Input: a = \"11\", b = \"1\" Output: \"100\" . Example 2: . Input: a = \"1010\", b = \"1011\" Output: \"10101\" . Constraints: . | 1 &lt;= a.length, b.length &lt;= 104 | a and b consist only of ‘0’ or ‘1’ characters. | Each string does not contain leading zeros except for the zero itself. | . Solution . class Solution { public String addBinary(String a, String b) { int reminder = 0; int i = a.length() - 1; int j = b.length() - 1; int p1, p2, sum; StringBuilder sb = new StringBuilder(); while(i &gt;= 0 || j &gt;= 0 || reminder&gt;0){ p1 = i&gt;=0? a.charAt(i)-48: 0; p2 = j&gt;=0? b.charAt(j)-48: 0; sum = (p1+p2+reminder)%2; sb.append(sum); reminder = (p1+p2+reminder)/2; j--; i--; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-14-add-binary/",
    "relUrl": "/problem-14-add-binary/"
  },"183": {
    "doc": "Swap Nodes in Pairs",
    "title": "Swap Nodes in Pairs",
    "content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) . Example 1: . Input: head = [1,2,3,4] Output: [2,1,4,3] . Example 2: . Input: head = [] Output: [] . Example 3: . Input: head = [1] Output: [1] . Constraints: . | The number of nodes in the list is in the range [0, 100]. | 0 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { // corner cases if(head == null || head.next == null ) return head; // swapping head ListNode ptr, qtr; ptr = head; qtr = head.next; head = qtr; ptr.next = qtr.next; qtr.next = ptr; // swapping remaining node ptr = head.next; if(ptr.next == null) return head; ListNode mtr = ptr.next; qtr = mtr.next; while(qtr != null){ ptr.next = qtr; mtr.next = qtr.next; qtr.next = mtr; ptr = mtr; if(ptr.next == null) return head; mtr = ptr.next; if(mtr == null) return head; qtr = mtr.next; } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-14-Swap%20Nodes%20in%20Pairs/",
    "relUrl": "/problem-14-Swap Nodes in Pairs/"
  },"184": {
    "doc": "Insert Delete GetRandom O(1)",
    "title": "Insert Delete GetRandom O(1)",
    "content": "Implement the RandomizedSet class: . | RandomizedSet() Initializes the RandomizedSet object. | bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. | bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. | int getRandom() Returns a random element from the current set of elements (it’s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. | You must implement the functions of the class such that each function works in average O(1) time complexity. | . Example 1: . Input [\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2] Explanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2. Constraints: . | -2^31 &lt;= val &lt;= 2^31 - 1 | At most 2 * 105 calls will be made to insert, remove, and getRandom. | There will be at least one element in the data structure when getRandom is called. | . Solution: . class RandomizedSet { Set&lt;Integer&gt; set; public RandomizedSet() { set = new HashSet&lt;&gt;(); } public boolean insert(int val) { return set.add(val); } public boolean remove(int val) { return set.remove((Integer)val); } public int getRandom() { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(set); /* int k = 1; int result = list.get(0); for(int i = 0; i &lt; list.size(); i++){ if(Math.random() &lt; 1.0/k) result = list.get(i); k++; } return result; */ Random rand = new Random(); return list.get(rand.nextInt(list.size())); } } /** * Your RandomizedSet object will be instantiated and called as such: * RandomizedSet obj = new RandomizedSet(); * boolean param_1 = obj.insert(val); * boolean param_2 = obj.remove(val); * int param_3 = obj.getRandom(); */ . ",
    "url": "https://1001anjan.github.io/problem-140-Insert%20Delete%20GetRandom%20O(1)/",
    "relUrl": "/problem-140-Insert Delete GetRandom O(1)/"
  },"185": {
    "doc": "Middle of the Linked List",
    "title": "Middle of the Linked List",
    "content": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. Example 1: . Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: . Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: . | The number of nodes in the list is in the range [1, 100]. | 1 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode slow, fast; slow = fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow; } } . ",
    "url": "https://1001anjan.github.io/problem-140-Middle-of-the-Linked-List/",
    "relUrl": "/problem-140-Middle-of-the-Linked-List/"
  },"186": {
    "doc": "Flatten a Multilevel Doubly Linked List",
    "title": "Flatten a Multilevel Doubly Linked List",
    "content": "You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer. This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below. Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list. Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null. Example 1: . Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] Output: [1,2,3,7,8,11,12,9,10,4,5,6] Explanation: The multilevel linked list in the input is shown. After flattening the multilevel linked list it becomes: . Example 2: . Input: head = [1,2,null,3] Output: [1,3,2] Explanation: The multilevel linked list in the input is shown. After flattening the multilevel linked list it becomes: . Example 3: . Input: head = [] Output: [] Explanation: There could be empty list in the input. Constraints: . | The number of Nodes will not exceed 1000. | 1 &lt;= Node.val &lt;= 10^5 | . How the multilevel linked list is represented in test cases: . We use the multilevel linked list from Example 1 above: . 1---2---3---4---5---6--NULL | 7---8---9---10--NULL | 11--12--NULL . The serialization of each level is as follows: . [1,2,3,4,5,6,null] [7,8,9,10,null] [11,12,null] . To serialize all levels together, we will add nulls in each level to signify no node connects to the upper node of the previous level. The serialization becomes: . [1, 2, 3, 4, 5, 6, null] | [null, null, 7, 8, 9, 10, null] | [ null, 11, 12, null] . Merging the serialization of each level and removing trailing nulls we obtain: . [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12] . Solution: . /* // Definition for a Node. class Node { public int val; public Node prev; public Node next; public Node child; }; */ class Solution { public Node flatten(Node head) { Node ptr, qtr, res; ptr = qtr = res = head; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while(ptr != null){ if(ptr.next == null &amp;&amp; !stack.isEmpty() &amp;&amp; ptr.child == null){ ptr = stack.pop(); qtr.next = ptr; ptr.prev = qtr; qtr = ptr; }else if(ptr.child != null){ if(ptr.next != null) stack.push(ptr.next); ptr = ptr.child; qtr.next = ptr; ptr.prev = qtr; qtr.child = null; qtr = ptr; }else{ ptr = ptr.next; qtr = ptr; } } return res; } } . Recursion . class Solution { public Node flatten(Node head) { return helper(head, new Node()); } public Node helper(Node head, Node prevDummy) { Node cur = head; while (cur != null) { if (cur.child != null) { Node next = cur.next; cur.child.prev = cur; cur.next = helper(cur.child, prevDummy); cur.child = null; if (next != null) { Node prev = prevDummy.next; prev.next = next; next.prev = prev; } } prevDummy.next = cur; cur = cur.next; } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-141-Flatten%20a%20Multilevel%20Doubly%20Linked%20List/",
    "relUrl": "/problem-141-Flatten a Multilevel Doubly Linked List/"
  },"187": {
    "doc": "Uncommon Words from Two Sentences",
    "title": "Uncommon Words from Two Sentences",
    "content": "A sentence is a string of single-space separated words where each word consists only of lowercase letters. A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order. Example 1: . Input: s1 = \"this apple is sweet\", s2 = \"this apple is sour\" Output: [\"sweet\",\"sour\"] . Example 2: . Input: s1 = \"apple apple\", s2 = \"banana\" Output: [\"banana\"] . Constraints: . | 1 &lt;= s1.length, s2.length &lt;= 200 | s1 and s2 consist of lowercase English letters and spaces. | s1 and s2 do not have leading or trailing spaces. | All the words in s1 and s2 are separated by a single space. | . Solution: . class Solution { public String[] uncommonFromSentences(String s1, String s2) { Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); for(String w : s1.split(\"\\\\s+\")){ map.put(w,map.getOrDefault(w,0)+1); } for(String w : s2.split(\"\\\\s+\")){ map.put(w,map.getOrDefault(w,0)+1); } List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(String s: map.keySet()){ if(map.get(s) == 1) ans.add(s); } return ans.toArray(new String[ans.size()]); } } . class Solution { public String[] uncommonFromSentences(String A, String B) { Map&lt;String, Integer&gt; count = new HashMap(); for (String word: A.split(\" \")) count.put(word, count.getOrDefault(word, 0) + 1); for (String word: B.split(\" \")) count.put(word, count.getOrDefault(word, 0) + 1); List&lt;String&gt; ans = new LinkedList(); for (String word: count.keySet()) if (count.get(word) == 1) ans.add(word); return ans.toArray(new String[ans.size()]); } } . ",
    "url": "https://1001anjan.github.io/problem-141-Uncommon-Words-from-Two-Sentences/",
    "relUrl": "/problem-141-Uncommon-Words-from-Two-Sentences/"
  },"188": {
    "doc": "Longest Repeating Character Replacement",
    "title": "Longest Repeating Character Replacement",
    "content": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times. Return the length of the longest substring containing the same letter you can get after performing the above operations. Example 1: . Input: s = \"ABAB\", k = 2 Output: 4 Explanation: Replace the two 'A's with two 'B's or vice versa. Example 2: . Input: s = \"AABABBA\", k = 1 Output: 4 Explanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\". The substring \"BBBB\" has the longest repeating letters, which is 4. Constraints: . | 1 &lt;= s.length &lt;= 10^5 | s consists of only uppercase English letters. | 0 &lt;= k &lt;= s.length | . Solution: . Time Limit Exceeded O(n^2) time complexity . class Solution { public int characterReplacement(String s, int k) { int max = -1; int len = s.length(); for(int i = 0; i &lt; len; i++){ char ch = s.charAt(i); int k1 = k; int n1 = 1; int j = i + 1; // max in right side while(j &lt; len){ if(ch != s.charAt(j)) k1 --; if(k1 &lt; 0) break; n1 ++; j++; } // checking middele to left if(j == len &amp;&amp; k1 &gt; 0){ j = i - 1; while(j &gt;= 0){ if(ch != s.charAt(j)) k1 --; if(k1 &lt; 0) break; n1 ++; j--; } } // finding max in left side int n2 = 1; j = i - 1; k1 = k; while(j &gt;= 0){ if(ch != s.charAt(j)) k1 --; if(k1 &lt; 0) break; n2 ++; j--; } // checking middle to right if(j == 0 &amp;&amp; k1 &gt; 0){ j = i + 1; while(j &lt; len){ if(ch != s.charAt(j)) k1 --; if(k1 &lt; 0) break; n2 ++; j++; } } max = Math.max(max, Math.max(n1, n2)); } return max; } } . Find different approach to solve the problem here Leet Code explanation . class Solution { public int characterReplacement(String s, int k) { int start = 0; int maxFrequency = 0; int maxWindowSize = 0; int[] frequencyMap = new int[26]; for(int end = 0; end &lt; s.length(); end++){ int charIndex = s.charAt(end) - 'A'; frequencyMap[charIndex]++; maxFrequency = Math.max(maxFrequency, frequencyMap[charIndex]); // move the start pointer towards right if the current // window is invalid // validity condition windowSize - maxFrequency &lt;= k boolean isValid = (end - start + 1) - maxFrequency &lt;= k; if(!isValid){ charIndex = s.charAt(start) - 'A'; frequencyMap[charIndex]--; start ++; } maxWindowSize = end - start + 1; } return maxWindowSize; } } . ",
    "url": "https://1001anjan.github.io/problem-142-Longest%20Repeating%20Character%20Replacement/",
    "relUrl": "/problem-142-Longest Repeating Character Replacement/"
  },"189": {
    "doc": "Monotonic Array",
    "title": "Monotonic Array",
    "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. An array nums is monotone increasing if for all i &lt;= j, nums[i] &lt;= nums[j]. An array nums is monotone decreasing if for all i &lt;= j, nums[i] &gt;= nums[j]. Given an integer array nums, return true if the given array is monotonic, or false otherwise. Example 1: . Input: nums = [1,2,2,3] Output: true . Example 2: . Input: nums = [6,5,4,4] Output: true . Example 3: . Input: nums = [1,3,2] Output: false . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -105 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public boolean isMonotonic(int[] nums) { if(nums[0]&lt;=nums[nums.length-1]){ for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&gt;nums[i]) return false; } }else{ for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&lt;nums[i]) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-142-Monotonic-Array/",
    "relUrl": "/problem-142-Monotonic-Array/"
  },"190": {
    "doc": "Battleships in a Board",
    "title": "Battleships in a Board",
    "content": "Given an m x n matrix board where each cell is a battleship ‘X’ or empty ‘.’, return the number of the battleships on board. Battleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships). Example 1: . Input: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]] Output: 2 . Example 2: . Input: board = [[\".\"]] Output: 0 . Constraints: . | m == board.length | n == board[i].length | 1 &lt;= m, n &lt;= 200 | board[i][j] is either ‘.’ or ‘X’. | . Follow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the values board? . Solution: . class Solution { public int countBattleships(char[][] board) { int count = 0; for(int i = 0; i &lt; board.length; i++){ for(int j = 0; j &lt; board[0].length; j++){ // checking if the cell is 'X' and left or upper cell is not 'X' if(board[i][j] == 'X'){ if((i == 0 || board[i - 1][j] != 'X') &amp;&amp; (j == 0 || board[i][j - 1] != 'X')) count++; } } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-143-Battleships%20in%20a%20Board/",
    "relUrl": "/problem-143-Battleships in a Board/"
  },"191": {
    "doc": "Increasing Order Search Tree",
    "title": "Increasing Order Search Tree",
    "content": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Example 1: . Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] . Example 2: . Input: root = [5,1,7] Output: [1,null,5,null,7] . Constraints: . | The number of nodes in the given tree will be in the range [1, 100]. | 0 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { TreeNode t = new TreeNode(); TreeNode next; public TreeNode increasingBST(TreeNode root) { if(root == null) return null; next = t; inOrderTraversal(root); return t.right; } public void inOrderTraversal(TreeNode head){ if(head == null) return; inOrderTraversal(head.left); next.right = head; next = head; next.left = null; inOrderTraversal(head.right); } } . ",
    "url": "https://1001anjan.github.io/problem-143-Increasing-Order-Search-Tree/",
    "relUrl": "/problem-143-Increasing-Order-Search-Tree/"
  },"192": {
    "doc": "Reconstruct Original Digits from English",
    "title": "Reconstruct Original Digits from English",
    "content": "Given a string s containing an out-of-order English representation of digits 0-9, return the digits in ascending order. Example 1: . Input: s = \"owoztneoer\" Output: \"012\" . Example 2: . Input: s = \"fviefuro\" Output: \"45\" . Constraints: . | 1 &lt;= s.length &lt;= 10^5 | s[i] is one of the characters [“e”,”g”,”f”,”i”,”h”,”o”,”n”,”s”,”r”,”u”,”t”,”w”,”v”,”x”,”z”]. | s is guaranteed to be valid. | . Solution: . class Solution { public String originalDigits(String s) { // one, two, three, four, five, six seven, eight, nine, zero // 0 --&gt; if z is available // 1 --&gt; // 4/5 --&gt; f must present, // 4 --&gt; u // x --&gt; for six // 7 --&gt; if s // 8 --&gt; g must be present // 9 --&gt; for n -&gt; 9/1 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int[] dp = new int[26]; for(char ch : s.toCharArray()) dp[ch - 'a']++; // adding all zeros while(dp[25] &gt; 0){ list.add(0); dp[25]--; dp['e' - 'a']--; dp['r' - 'a']--; dp['o' - 'a']--; } // adding six while(dp['x' - 'a'] &gt; 0){ list.add(6); dp['s' - 'a']--; dp['i' - 'a']--; dp['x' - 'a']--; } // adding all seven while(dp['s' - 'a'] &gt; 0){ list.add(7); dp['s' - 'a']--; dp['e' - 'a'] -= 2; dp['v' - 'a']--; dp['n' - 'a']--; } // adding all eight while(dp['g' - 'a'] &gt; 0){ list.add(8); dp['e' - 'a']--; dp['i' - 'a']--; dp['g' - 'a']--; dp['h' - 'a']--; dp['t' - 'a']--; } // adding all four while(dp['u' - 'a'] &gt; 0){ list.add(4); dp['f' - 'a']--; dp['o' - 'a']--; dp['u' - 'a']--; dp['r' - 'a']--; } // since four's added now five can added by f only while(dp['f' - 'a'] &gt; 0){ list.add(5); dp['f' - 'a']--; dp['i' - 'a']--; dp['v' - 'a']--; dp['e' - 'a']--; } // since zero and four added so now we can add three while(dp['r' - 'a'] &gt; 0){ list.add(3); dp['t' - 'a']--; dp['h' - 'a']--; dp['r' - 'a']--; dp['e' - 'a'] -= 2; } // adding two by w while(dp['w' - 'a'] &gt; 0){ list.add(2); dp['t' - 'a']--; dp['w' - 'a']--; dp['o' - 'a']--; } // now adding nine by i while(dp['i' - 'a'] &gt; 0){ list.add(9); dp['n' - 'a']--; dp['i' - 'a']--; dp['n' - 'a']--; dp['e' - 'a']--; } // now adding one while(dp['n' - 'a'] &gt; 0){ list.add(1); dp['o' - 'a']--; dp['n' - 'a']--; dp['e' - 'a']--; } // sorting the list Collections.sort(list); StringBuilder sb = new StringBuilder(); for(int n : list) sb.append(String.valueOf(n)); return sb.toString(); } } . class Solution { public String originalDigits(String s) { // one, two, three, four, five, six seven, eight, nine, zero List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int[] dp = new int[128]; for(char ch : s.toCharArray()) dp[ch]++; // adding all zeros while(dp['z'] &gt; 0){ list.add(0); dp['z']--; dp['e']--; dp['r']--; dp['o']--; } // adding six while(dp['x'] &gt; 0){ list.add(6); dp['s']--; dp['i']--; dp['x']--; } // adding all seven while(dp['s'] &gt; 0){ list.add(7); dp['s']--; dp['e'] -= 2; dp['v']--; dp['n']--; } // adding all eight while(dp['g'] &gt; 0){ list.add(8); dp['e']--; dp['i']--; dp['g']--; dp['h']--; dp['t']--; } // adding all four while(dp['u'] &gt; 0){ list.add(4); dp['f']--; dp['o']--; dp['u']--; dp['r']--; } // since four's added now five can added by f only while(dp['f'] &gt; 0){ list.add(5); dp['f']--; dp['i']--; dp['v']--; dp['e']--; } // since zero and four added so now we can add three while(dp['r'] &gt; 0){ list.add(3); dp['t']--; dp['h']--; dp['r']--; dp['e'] -= 2; } // adding two by w while(dp['w'] &gt; 0){ list.add(2); dp['t']--; dp['w']--; dp['o']--; } // now adding nine by i while(dp['i'] &gt; 0){ list.add(9); dp['n']--; dp['i']--; dp['n']--; dp['e']--; } // now adding one while(dp['n'] &gt; 0){ list.add(1); dp['o']--; dp['n']--; dp['e']--; } // sorting the list Collections.sort(list); StringBuilder sb = new StringBuilder(); for(int n : list) sb.append(String.valueOf(n)); return sb.toString(); } } . Clean solution . | zero, two, six eight, have distinct character z, w, x, g | other characters are only shared by word with known count and only another word with unknown count, like six and seven share ‘s’, seven and five share ‘v’ | . class Solution { public String originalDigits(String s) { int[] cc = new int[256]; int[] dc = new int[10]; for (char c: s.toCharArray()) { ++cc[c]; } String[] order = {\"zero\", \"six\", \"seven\", \"five\", \"four\", \"two\", \"eight\", \"three\", \"one\", \"nine\"}; char[] flag = {'z', 'x', 's', 'v', 'f', 'w', 'g', 'r', 'o', 'i'}; int[] digits = {0, 6, 7, 5, 4, 2, 8, 3, 1, 9}; for (int i = 0; i&lt; 10; ++i) { int n = cc[flag[i]]; if (n &gt; 0) { dc[digits[i]] = n; for (char c: order[i].toCharArray()) cc[c] -= n; } } StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt;= 9; ++i) { for (int j = 0; j &lt; dc[i]; ++j) sb.append(i); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-144-Reconstruct%20Original%20Digits%20from%20English/",
    "relUrl": "/problem-144-Reconstruct Original Digits from English/"
  },"193": {
    "doc": "Sort Array By Parity",
    "title": "Sort Array By Parity",
    "content": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. Example 1: . Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Example 2: . Input: nums = [0] Output: [0] . Constraints: . | 1 &lt;= nums.length &lt;= 5000 | 0 &lt;= nums[i] &lt;= 5000 | . Solution: . class Solution { public int[] sortArrayByParity(int[] nums) { int s = 0; int e = nums.length - 1; while(s&lt;e){ // find odd number from left to right while(s&lt;e &amp;&amp; nums[s]%2 == 0) s++; // find even number from right to left while(s&lt;e &amp;&amp; nums[e]%2 != 0) e--; if(s&lt;e){ int t = nums[s]; nums[s] = nums[e]; nums[e] = t; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-144-Sort-Array-By-Parity/",
    "relUrl": "/problem-144-Sort-Array-By-Parity/"
  },"194": {
    "doc": "N-ary Tree Level Order Traversal",
    "title": "N-ary Tree Level Order Traversal",
    "content": "Given an n-ary tree, return the level order traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: . Input: root = [1,null,3,2,4,null,5,6] Output: [[1],[3,2,4],[5,6]] . Example 2: . Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] . Constraints: . | The height of the n-ary tree is less than or equal to 1000 | The total number of nodes is between [0, 10^4] | . Solution: . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) { List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); if(root == null) return list; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.offer(root); while(!q.isEmpty()){ Queue&lt;Node&gt; q1 = new LinkedList&lt;&gt;(); List&lt;Integer&gt; l = new LinkedList&lt;&gt;(); while(!q.isEmpty()){ Node n = q.poll(); l.add(n.val); for(Node ch : n.children) q1.offer(ch); } list.add(l); q = q1; } return list; } } . ",
    "url": "https://1001anjan.github.io/problem-145-N-ary%20Tree%20Level%20Order%20Traversal/",
    "relUrl": "/problem-145-N-ary Tree Level Order Traversal/"
  },"195": {
    "doc": "Reverse Only Letters",
    "title": "Reverse Only Letters",
    "content": "Given a string s, reverse the string according to the following rules: . All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed. Return s after reversing it. Example 1: . Input: s = \"ab-cd\" Output: \"dc-ba\" . Example 2: . Input: s = \"a-bC-dEf-ghIj\" Output: \"j-Ih-gfE-dCba\" . Example 3: . Input: s = \"Test1ng-Leet=code-Q!\" Output: \"Qedo1ct-eeLg=ntse-T!\" . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of characters with ASCII values in the range [33, 122]. | s does not contain ‘\"’ or ‘\\’. | . Solution: . class Solution { public String reverseOnlyLetters(String str) { char[] chars = str.toCharArray(); int s = 0; int e = chars.length - 1; while(s&lt;e){ // find letters left to right while(s&lt;e &amp;&amp; !Character.isLetter(chars[s])) s++; // find letters right to left while(s&lt;e &amp;&amp; !Character.isLetter(chars[e])) e--; if(s&lt;e){ char c = chars[s]; chars[s] = chars[e]; chars[e] = c; } s++; e--; } return new String(chars); } } . ",
    "url": "https://1001anjan.github.io/problem-145-Reverse-Only-Letters/",
    "relUrl": "/problem-145-Reverse-Only-Letters/"
  },"196": {
    "doc": "Lexicographical Numbers",
    "title": "Lexicographical Numbers",
    "content": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order. You must write an algorithm that runs in O(n) time and uses O(1) extra space. Example 1: . Input: n = 13 Output: [1,10,11,12,13,2,3,4,5,6,7,8,9] . Example 2: . Input: n = 2 Output: [1,2] . Constraints: . | 1 &lt;= n &lt;= 5 * 10^4 | . Solution: . we can imagine such a tree, out task is to traversal it with DFS, and collect numbers along the way: 1, 10, 100, … you get it. When we encounter a number larger than n, we can return back to the previous level. class Solution { public List&lt;Integer&gt; lexicalOrder(int n) { List&lt;Integer&gt; list = new LinkedList&lt;&gt;(); for(int i = 1; i &lt;= 9; i++) dfs(i, n, list); return list; } public void dfs(int value, int n, List&lt;Integer&gt; list){ if(value &gt; n) return; list.add(value); for(int i = 0; i &lt;= 9; i++){ dfs(value * 10 + i, n, list); } } } . Optimising unnecessary calls if number greater than target value . class Solution { public List&lt;Integer&gt; lexicalOrder(int n) { List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); generate(result, 1, n); return result; } private void generate(List&lt;Integer&gt; l, int cur, int n) { if (cur &gt; n) return; l.add(cur); generate(l, cur*10, n); if (cur%10 != 9) generate(l, cur+1, n); } } . ",
    "url": "https://1001anjan.github.io/problem-146-Lexicographical%20Numbers/",
    "relUrl": "/problem-146-Lexicographical Numbers/"
  },"197": {
    "doc": "Sort Array By Parity II",
    "title": "Sort Array By Parity II",
    "content": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition. Example 1: . Input: nums = [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Example 2: . Input: nums = [2,3] Output: [2,3] . Constraints: . | 2 &lt;= nums.length &lt;= 2 * 104 | nums.length is even. | Half of the integers in nums are even. | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int[] sortArrayByParityII(int[] nums) { int e = 0; int o = 1; while(e&lt;nums.length){ while(e&lt;nums.length &amp;&amp; nums[e]%2 == 0) e += 2; while(o&lt;nums.length &amp;&amp; nums[o]%2 != 0) o += 2; if(e&lt;nums.length &amp;&amp; o&lt;nums.length){ int t = nums[e]; nums[e] = nums[o]; nums[o] = t; } e += 2; o += 2; } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-146-Sort-Array-By-Parity-II/",
    "relUrl": "/problem-146-Sort-Array-By-Parity-II/"
  },"198": {
    "doc": "Long Pressed Name",
    "title": "Long Pressed Name",
    "content": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Example 1: . Input: name = \"alex\", typed = \"aaleex\" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed. Example 2: . Input: name = \"saeed\", typed = \"ssaaedd\" Output: false Explanation: 'e' must have been pressed twice, but it was not in the typed output. Constraints: . | 1 &lt;= name.length, typed.length &lt;= 1000 | name and typed consist of only lowercase English letters. | . Solution: . class Solution { public boolean isLongPressedName(String name, String typed) { int i = 0; int j = 0; while(i&lt;name.length() &amp;&amp; j&lt;typed.length()){ System.out.println(\"i\"+i+\" j: \"+j); if(name.charAt(i) == typed.charAt(j)){ i++; j++; }else{ if(j == 0) break; if(typed.charAt(j-1) != typed.charAt(j)) break; while(j&lt;typed.length() &amp;&amp; typed.charAt(j-1) == typed.charAt(j)) j++; } } while(j != 0 &amp;&amp; j&lt;typed.length() &amp;&amp; typed.charAt(j-1) == typed.charAt(j)) j++; return i == name.length() &amp;&amp; j == typed.length(); } } . ",
    "url": "https://1001anjan.github.io/problem-147-Long-Pressed-Name/",
    "relUrl": "/problem-147-Long-Pressed-Name/"
  },"199": {
    "doc": "Random Pick Index",
    "title": "Random Pick Index",
    "content": "Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Implement the Solution class: . | Solution(int[] nums) Initializes the object with the array nums. | int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i’s, then each index should have an equal probability of returning. | . Example 1: . Input [\"Solution\", \"pick\", \"pick\", \"pick\"] [[[1, 2, 3, 3, 3]], [3], [1], [3]] Output [null, 4, 0, 2] Explanation Solution solution = new Solution([1, 2, 3, 3, 3]); solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. solution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1. solution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning. Constraints: . | 1 &lt;= nums.length &lt;= 2 * 10^4 | -2^31 &lt;= nums[i] &lt;= 2^31 - 1 | target is an integer from nums. | At most 10^4 calls will be made to pick. | . Solution: . class Solution { private HashMap&lt;Integer, List&lt;Integer&gt;&gt; indices; private Random rand; public Solution(int[] nums) { this.rand = new Random(); this.indices = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); int l = nums.length; for (int i = 0; i &lt; l; ++i) { if (!this.indices.containsKey(nums[i])) { this.indices.put(nums[i], new ArrayList&lt;&gt;()); } this.indices.get(nums[i]).add(i); } } public int pick(int target) { int l = indices.get(target).size(); // pick an index at random int randomIndex = indices.get(target).get(rand.nextInt(l)); return randomIndex; } } . ",
    "url": "https://1001anjan.github.io/problem-147-Random%20Pick%20Index/",
    "relUrl": "/problem-147-Random Pick Index/"
  },"200": {
    "doc": "Partition Equal Subset Sum",
    "title": "Partition Equal Subset Sum",
    "content": "Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Example 1: . Input: nums = [1,5,11,5] Output: true Explanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2: . Input: nums = [1,2,3,5] Output: false Explanation: The array cannot be partitioned into equal sum subsets. Constraints: . | 1 &lt;= nums.length &lt;= 200 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . Time Limit Exceeded . class Solution { public boolean canPartition(int[] nums) { int sum = 0; for(int i = 0; i &lt; nums.length; i++) sum += nums[i]; if(sum % 2 != 0) return false; return dfs(nums, 0, sum / 2); } public boolean dfs(int[] nums, int from, int sum) { if(sum == 0) return true; if(sum &lt; 0) return false; for(int i = from; i &lt; nums.length; i++) if(dfs(nums, i + 1, sum - nums[i])) return true; return false; } } . Intution: So Lets start step by step and concentrate on the process: . Since we have to make two subset both having equal sum then our first condition is to check whether the sum of given array can be divided in two equal part which is if total sum is odd then partition is not possible at all and if sum is even then there is chance. For example: . 1. arr1-&gt; [1,5,11,5] and 2. arr2 -&gt; [1,5,3,11] Both arr1 and arr2 has even sum but 1st can be partitioned into ([1,5,5] &amp; [11]) and 2nd can not. Now lets try to visualize it as 0/1 Knapsack Problem: . | Since in 0/1 knapsack we have 2 choices for each object having value v whether to keep it or not in your kanpsack having certain weight W. | Same as in this case we have n elements in array and we have two choices to make whether to keep it in subset1 or subset2 (inclusion in one is direct exclusion in other) and weight of knapsack/subset will be sum/2. | So now what our target remain is we have to take care about only one subset because if one subset with weight sum/2 is possible then other subset will surely have the weight sum/2. | So now using subset sum problem code we have to just check if its possible to have a subset having sum = totalSum/2; | . Approach1: Memoization (TLE) . class Solution { public boolean canPartition(int[] nums) { int sum = 0; for(int n : nums) sum += n; if(sum % 2 != 0) return false; // dividing the sum by 2 sum /= 2; Boolean[][] dp = new Boolean[nums.length + 1][sum + 1]; return processSum(nums, 0, sum, dp); } public Boolean processSum(int[] nums, int pos, int target, Boolean[][] dp){ if(pos &gt;= nums.length) return false; if(target == 0) return true; if(target &lt; 0) return false; if(dp[pos][target] != null) return dp[pos][target]; return dp[pos][target] = processSum(nums, pos + 1, target - nums[pos], dp) || processSum(nums, pos + 1, target, dp); } } . Approach2: Dynamic Programming . class Solution { public boolean canPartition(int[] nums) { int sum = 0; int n = nums.length; for(int i : nums) sum+=i; if(sum%2!=0) return false; sum /= 2; boolean dp[][] = new boolean[n+1][sum+1]; for(int i=0;i&lt;=n;i++){ for(int j=0;j&lt;=sum;j++){ if(i==0 || j==0) dp[i][j] = false; else if(nums[i-1] &gt; j) // if curr sum value is greater than the current element value then just skip(take previous value) dp[i][j] = dp[i-1][j]; else if(nums[i-1]==j) // we got required sum dp[i][j] = true; else dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]]; } } return dp[n][sum]; } } . Approach3: Space Optimized DP . Explanation: Idea behind reverse loop for sum . | If you observe the 2d DP then dp[i][j] is the value either from dp[i-1][j] or dp[i-1][j-nums[i-1]] and when we converted 2d DP into 1d DP then the thinking was that, dp[i] will have values for one iteration and then again for next iteration we will use that stored values which will act as dp[i-1] for this iteration. | So now we need value of dp[i-num] that is value from previous index so here is the problem in left to right loop that each time when we enter into new interation we need value from previous iteration but the value will already be updated in this iteartion and we will loss the previous value. | . Thats why using reverse loop. Example: Lets in first iteration dp array is filled as [2,6,1,8,5] . | So now we started from left and upadated 2 as 4 and 6 as 7 and 1 as 5([4,7,5,8,5]) and now we reach to 8 and we need dp[1] value but we need the value from previous iteration which we have lost and hence will get the wrong answer. | So move from right to left and use the previous iteration value. (these are pure random values used in example, so dont think about them just get the example) ```java class Solution { . public boolean canPartition(int[] nums) { int sum = 0; int n = nums.length; . for(int i : nums) sum+=i; if(sum%2!=0) return false; sum /= 2; boolean[] dp = new boolean[sum+1]; dp[0] = true; for (int j : nums) { for (int i = sum; i &gt; 0; i--) { if (i &gt;= j) { dp[i] = dp[i] || dp[i-j]; } } } return dp[sum]; } } . | . ``` . ",
    "url": "https://1001anjan.github.io/problem-148-Partition%20Equal%20Subset%20Sum/",
    "relUrl": "/problem-148-Partition Equal Subset Sum/"
  },"201": {
    "doc": "Unique Email Addresses",
    "title": "Unique Email Addresses",
    "content": "Every valid email consists of a local name and a domain name, separated by the ‘@’ sign. Besides lowercase letters, the email may contain one or more ‘.’ or ‘+’. | For example, in “alice@leetcode.com”, “alice” is the local name, and “leetcode.com” is the domain name. If you add periods ‘.’ between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names. | For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address. If you add a plus ‘+’ in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names. | For example, “m.y+name@email.com” will be forwarded to “my@email.com”. It is possible to use both of these rules at the same time. | . Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails. Example 1: . Input: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"] Output: 2 Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. Example 2: . Input: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"] Output: 3 . Constraints: . | 1 &lt;= emails.length &lt;= 100 | 1 &lt;= emails[i].length &lt;= 100 | emails[i] consist of lowercase English letters, ‘+’, ‘.’ and ‘@’. | Each emails[i] contains exactly one ‘@’ character. | All local and domain names are non-empty. | Local names do not start with a ‘+’ character. | Domain names end with the “.com” suffix. | . Solution: . class Solution { public int numUniqueEmails(String[] emails) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String e : emails){ StringBuilder sb = new StringBuilder(); boolean p = true; boolean d = false; for(char c: e.toCharArray()){ if(p &amp;&amp; Character.isLetter(c)){ sb.append(c); }else if(d &amp;&amp; c == '.'){ sb.append(c); }else if(c == '+'){ p = false; }else if(c == '@') { sb.append(c); p = true; d = true; } } set.add(sb.toString()); } return set.size(); } } . simple but slow . class Solution { public int numUniqueEmails(String[] emails) { Set&lt;String&gt; set = new HashSet&lt;String&gt;(); int count=0; for(String email: emails) { String[] parts = email.split(\"\\\\@\"); String[] local = parts[0].split(\"\\\\+\"); set.add(local[0].replace(\".\",\"\")+\"@\"+(parts[1])); } return set.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-148-Unique-Email-Addresses/",
    "relUrl": "/problem-148-Unique-Email-Addresses/"
  },"202": {
    "doc": "Kth Smallest Element in a Sorted Matrix",
    "title": "Kth Smallest Element in a Sorted Matrix",
    "content": "Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. You must find a solution with a memory complexity better than O(n2). Example 1: . Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output: 13 Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 . Example 2: . Input: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8 Output: 13 Explanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13 . Constraints: . | n == matrix.length == matrix[i].length | 1 &lt;= n &lt;= 300 | -10^9 &lt;= matrix[i][j] &lt;= 10^9 | All the rows and columns of matrix are guaranteed to be sorted in non-decreasing order. | 1 &lt;= k &lt;= n^2 | . Solution: . Complexity: . | Time: O(M * N * logK), where M &lt;= 300 is the number of rows, N &lt;= 300 is the number of columns. | Space: O(K), space for heap which stores up to k elements. class Solution { public int kthSmallest(int[][] matrix, int k) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(b, a)); for(int i = 0; i &lt; matrix.length; i++){ for(int j = 0; j &lt; matrix[0].length; j++){ pq.offer(matrix[i][j]); while(pq.size() &gt; k) pq.poll(); } } return pq.poll(); } } . | . Solution 2: Min Heap to find kth smallest element from amongst N sorted list . | Since each of the rows in matrix are already sorted, we can understand the problem as finding the kth smallest element from amongst M sorted rows. | We start the pointers to point to the beginning of each rows, then we iterate k times, for each time ith, the top of the minHeap is the ith smallest element in the matrix. We pop the top from the minHeap then add the next element which has the same row with that top to the minHeap. | . Complexity: . | Time: O(K * logK) | Space: O(K) | . class Solution { public int kthSmallest(int[][] matrix, int k) { PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; Integer.compare(a[0], b[0])); for(int i = 0; i &lt; Math.min(matrix.length, k); i++) pq.offer(new int[]{matrix[i][0], i, 0}); for(int i = 1; i &lt; k; i++){ int[] top = pq.poll(); if(top[2] + 1 &lt; matrix[0].length) pq.offer(new int[]{matrix[top[1]][top[2] + 1], top[1], top[2] + 1}); } return pq.poll()[0]; } } . ✔️ Solution 3: Binary Search . Algorithm . | Start with left = minOfMatrix = matrix[0][0] and right = maxOfMatrix = matrix[n-1][n-1]. | Find the mid of the left and the right. This middle number is NOT necessarily an element in the matrix. | If countLessOrEqual(mid) &gt;= k, we keep current ans = mid and try to find smaller value by searching in the left side. Otherwise, we search in the right side. | Since ans is the smallest value which countLessOrEqual(ans) &gt;= k, so it’s the k th smallest element in the matrix. | . How to count number of elements less or equal to x efficiently? . | Since our matrix is sorted in ascending order by rows and columns. | We use two pointers, one points to the rightmost column c = n-1, and one points to the lowest row r = 0. | If matrix[r][c] &lt;= x then the number of elements in row r less or equal to x is (c+1) (Because row[r] is sorted in ascending order, so if matrix[r][c] &lt;= x then matrix[r][c-1] is also &lt;= x). Then we go to next row to continue counting. | Else if matrix[r][c] &gt; x, we decrease column c until matrix[r][c] &lt;= x (Because column is sorted in ascending order, so if matrix[r][c] &gt; x then matrix[r+1][c] is also &gt; x). | . Time complexity for counting: O(M+N). class Solution { public int kthSmallest(int[][] matrix, int k) { int left = matrix[0][0]; int right = matrix[matrix.length - 1][matrix[0].length - 1]; int ans = -1; while(left &lt;= right){ int mid = (left + right) &gt;&gt; 1; if(countLessOrEquals(matrix, mid) &gt;= k){ ans = mid; right = mid - 1; }else{ left = mid + 1; } } return ans; } public int countLessOrEquals(int[][] mat, int x){ int count = 0; int c = mat[0].length - 1; for(int r = 0; r &lt; mat.length; r++){ while(c &gt;= 0 &amp;&amp; x &lt; mat[r][c]) c --; count += c + 1; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-149-Kth%20Smallest%20Element%20in%20a%20Sorted%20Matrix/",
    "relUrl": "/problem-149-Kth Smallest Element in a Sorted Matrix/"
  },"203": {
    "doc": "Number of Recent Calls",
    "title": "Number of Recent Calls",
    "content": "You have a RecentCounter class which counts the number of recent requests within a certain time frame. Implement the RecentCounter class: . | RecentCounter() Initializes the counter with zero recent requests. | int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t]. It is guaranteed that every call to ping uses a strictly larger value of t than the previous call. | . Example 1: . Input [\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1], range is [-2999,1], return 1 recentCounter.ping(100); // requests = [1, 100], range is [-2900,100], return 2 recentCounter.ping(3001); // requests = [1, 100, 3001], range is [1,3001], return 3 recentCounter.ping(3002); // requests = [1, 100, 3001, 3002], range is [2,3002], return 3 . Constraints: . | 1 &lt;= t &lt;= 109 | Each test case will call ping with strictly increasing values of t. | At most 104 calls will be made to ping. | . Solution: . class RecentCounter { LinkedList&lt;Integer&gt; slideWindow; public RecentCounter() { this.slideWindow = new LinkedList&lt;Integer&gt;(); } public int ping(int t) { // step 1). append the current call this.slideWindow.addLast(t); // step 2). invalidate the outdated pings while (this.slideWindow.getFirst() &lt; t - 3000) this.slideWindow.removeFirst(); return this.slideWindow.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-149-Number-of-Recent-Calls/",
    "relUrl": "/problem-149-Number-of-Recent-Calls/"
  },"204": {
    "doc": "Find the Index of the First Occurrence in a String",
    "title": "Find the Index of the First Occurrence in a String",
    "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: . Input: haystack = \"sadbutsad\", needle = \"sad\" Output: 0 Explanation: \"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: . Input: haystack = \"leetcode\", needle = \"leeto\" Output: -1 Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1. Constraints: . | 1 &lt;= haystack.length, needle.length &lt;= 104 | haystack and needle consist of only lowercase English characters. | . Solution: . class Solution { public int strStr(String haystack, String needle) { return haystack.indexOf(needle); } } . class Solution { public int strStr(String haystack, String needle) { int i = 0, j = 0; int n1 = haystack.length(); int n2 = needle.length(); while(i &lt;= n1 - n2){ if(i &lt;= n1 - n2 &amp;&amp; haystack.charAt(i) != needle.charAt(0)) i++; int k = i; while(k &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; haystack.charAt(k) == needle.charAt(j)){ k ++; j ++; } if(j == n2) return i; j = 0; i++; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-15-Find%20the%20Index%20of%20the%20First%20Occurrence%20in%20a%20String/",
    "relUrl": "/problem-15-Find the Index of the First Occurrence in a String/"
  },"205": {
    "doc": "Sqrt(x)",
    "title": "Sqrt(x)",
    "content": "Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. Example 1: . Input: x = 4 Output: 2 . Example 2: . Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints: . | 0 &lt;= x &lt;= 231 - 1 | . Solution . class Solution { public int mySqrt(int x) { if(x&lt;2) return x; int start = 2; int end = x/2; int mid = (start+end)/2; long res; while(start &lt;= end){ res = (long)mid*mid; if(res == x) return mid; if(res&gt;x) end = mid - 1; else start = mid + 1; mid = (start+end)/2; } return mid; } } . ",
    "url": "https://1001anjan.github.io/problem-15-sqrt/",
    "relUrl": "/problem-15-sqrt/"
  },"206": {
    "doc": "Combination Sum IV",
    "title": "Combination Sum IV",
    "content": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target. The test cases are generated so that the answer can fit in a 32-bit integer. Example 1: . Input: nums = [1,2,3], target = 4 Output: 7 Explanation: The possible combination ways are: (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) Note that different sequences are counted as different combinations. Example 2: . Input: nums = [9], target = 3 Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 200 | 1 &lt;= nums[i] &lt;= 1000 | All the elements of nums are unique. | 1 &lt;= target &lt;= 1000 | . Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers? . Solution: . Time Limit Exceeded . class Solution { public int combinationSum4(int[] nums, int target) { if(target == 0) return 1; int res = 0; for(int i = 0; i &lt; nums.length; i++){ if(target &gt;= nums[i]) res += combinationSum4(nums, target - nums[i]); } return res; } } . Dynamic programming . class Solution { public int combinationSum4(int[] nums, int target) { int[] dp = new int[target + 1]; dp[0] = 1; for(int i = 1; i &lt; dp.length; i++){ for(int j = 0; j &lt; nums.length; j++){ if(i &gt;= nums[j]) dp[i] += dp[i - nums[j]]; } } return dp[target]; } } . ",
    "url": "https://1001anjan.github.io/problem-150-Combination%20Sum%20IV/",
    "relUrl": "/problem-150-Combination Sum IV/"
  },"207": {
    "doc": "Range Sum of BST",
    "title": "Range Sum of BST",
    "content": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. Example 1: . Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: . Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints: . | The number of nodes in the tree is in the range [1, 2 * 104]. | 1 &lt;= Node.val &lt;= 105 | 1 &lt;= low &lt;= high &lt;= 105 | All Node.val are unique. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int sum = 0; public int rangeSumBST(TreeNode root, int low, int high) { dfs(root,low,high); return this.sum; } public void dfs(TreeNode head, int low, int high){ if(head == null) return; if(head.val&gt;=low) dfs(head.left,low,high); if(head.val&lt;=high) dfs(head.right,low,high); if(head.val&gt;=low &amp;&amp; head.val&lt;=high) this.sum += head.val; } } . ",
    "url": "https://1001anjan.github.io/problem-150-Range-Sum-of-BST/",
    "relUrl": "/problem-150-Range-Sum-of-BST/"
  },"208": {
    "doc": "Remove K Digits",
    "title": "Remove K Digits",
    "content": "Given string num representing a non-negative integer num, and an integer k, return the smallest possible integer after removing k digits from num. Example 1: . Input: num = \"1432219\", k = 3 Output: \"1219\" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: . Input: num = \"10200\", k = 1 Output: \"200\" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: . Input: num = \"10\", k = 2 Output: \"0\" Explanation: Remove all the digits from the number and it is left with nothing which is 0. Constraints: . | 1 &lt;= k &lt;= num.length &lt;= 10^5 | num consists of only digits. | num does not have any leading zeros except for the zero itself. | . Solution: . class Solution { public String removeKdigits(String num, int k) { StringBuilder sb = new StringBuilder(); Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for(char ch : num.toCharArray()){ while(!stack.isEmpty() &amp;&amp; ch &lt; stack.peek() &amp;&amp; k &gt; 0){ stack.pop(); k--; } stack.push(ch); } // for 111 case while(k &gt; 0){ stack.pop(); k--; } while(!stack.isEmpty()){ sb.insert(0, stack.pop()); } // remove leading zeros while(sb.length() != 0 &amp;&amp; sb.charAt(0) == '0'){ sb.deleteCharAt(0); } if(sb.length() == 0) return \"0\"; return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-151-Remove%20K%20Digits/",
    "relUrl": "/problem-151-Remove K Digits/"
  },"209": {
    "doc": "Valid Mountain Array",
    "title": "Valid Mountain Array",
    "content": "Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if: . | arr.length &gt;= 3 | There exists some i with 0 &lt; i &lt; arr.length - 1 such that: . | arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i] | arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] | . | . Example 1: . Input: arr = [2,1] Output: false . Example 2: . Input: arr = [3,5,5] Output: false . Example 3: . Input: arr = [0,3,2,1] Output: true . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public boolean validMountainArray(int[] arr) { if(arr.length&lt;3) return false; int i = 1; while(i&lt;arr.length &amp;&amp; arr[i-1]&lt;arr[i]) i++; if(i == 1 || i == arr.length) return false; i--; while(i&lt;arr.length-1 &amp;&amp; arr[i]&gt;arr[i+1]) i++; return i == arr.length-1; } } . ",
    "url": "https://1001anjan.github.io/problem-151-Valid-Mountain-Array/",
    "relUrl": "/problem-151-Valid-Mountain-Array/"
  },"210": {
    "doc": "Delete Columns to Make Sorted",
    "title": "Delete Columns to Make Sorted",
    "content": "You are given an array of n strings strs, all of the same length. The strings can be arranged such that there is one on each line, making a grid. For example, strs = [“abc”, “bce”, “cae”] can be arranged as: . abc bce cae . You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 (‘a’, ‘b’, ‘c’) and 2 (‘c’, ‘e’, ‘e’) are sorted while column 1 (‘b’, ‘c’, ‘a’) is not, so you would delete column 1. Return the number of columns that you will delete. Example 1: . Input: strs = [\"cba\",\"daf\",\"ghi\"] Output: 1 Explanation: The grid looks as follows: cba daf ghi Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. Example 2: . Input: strs = [\"a\",\"b\"] Output: 0 Explanation: The grid looks as follows: a b Column 0 is the only column and is sorted, so you will not delete any columns. Example 3: . Input: strs = [\"zyx\",\"wvu\",\"tsr\"] Output: 3 Explanation: The grid looks as follows: zyx wvu tsr All 3 columns are not sorted, so you will delete all 3. Constraints: . | n == strs.length | 1 &lt;= n &lt;= 100 | 1 &lt;= strs[i].length &lt;= 1000 | strs[i] consists of lowercase English letters. | . Solution: . class Solution { public int minDeletionSize(String[] strs) { int c = 0; for(int i=0;i&lt;strs[0].length(); i++){ char ch = strs[0].charAt(i); for(int j = 1; j&lt;strs.length; j++){ if(ch&gt;strs[j].charAt(i)){ c++; break; } ch = strs[j].charAt(i); } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-152-Delete-Columns-to-Make-Sorted/",
    "relUrl": "/problem-152-Delete-Columns-to-Make-Sorted/"
  },"211": {
    "doc": "Interleaving String",
    "title": "Interleaving String",
    "content": "Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2. An interleaving of two strings s and t is a configuration where s and t are divided into n and m substrings respectively, such that: . | s = s1 + s2 + … + sn | t = t1 + t2 + … + tm | | n - m | &lt;= 1 | . | The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + … or t1 + s1 + t2 + s2 + t3 + s3 + … | . Note: a + b is the concatenation of strings a and b. Example 1: . Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\" Output: true Explanation: One way to obtain s3 is: Split s1 into s1 = \"aa\" + \"bc\" + \"c\", and s2 into s2 = \"dbbc\" + \"a\". Interleaving the two splits, we get \"aa\" + \"dbbc\" + \"bc\" + \"a\" + \"c\" = \"aadbbcbcac\". Since s3 can be obtained by interleaving s1 and s2, we return true. Example 2: . Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\" Output: false Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3. Example 3: . Input: s1 = \"\", s2 = \"\", s3 = \"\" Output: true . Constraints: . | 0 &lt;= s1.length, s2.length &lt;= 100 | 0 &lt;= s3.length &lt;= 200 | s1, s2, and s3 consist of lowercase English letters. | . Follow up: Could you solve it using only O(s2.length) additional memory space? . Solution: . Recursion with memoization . class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); // cheacking the length if(n1 + n2 != n3) return false; return dfsCheck(s1, s2, s3, n1, n2, n3, 0, 0, 0, new HashMap&lt;&gt;()); } public boolean dfsCheck(String s1, String s2, String s3, int n1, int n2, int n3, int p1, int p2, int p3, Map&lt;String, Boolean&gt; map){ if(p3 == n3) return true; String key = p1+\"-\"+p2+\"-\"+p3; if(map.containsKey(key)) return map.get(key); // if p1 reached to the end if(p1 == n1){ Boolean s = s2.charAt(p2) == s3.charAt(p3) ? dfsCheck(s1, s2, s3, n1, n2, n3, p1, p2 + 1, p3 + 1, map) : false; map.put(key, s); return map.get(key); } if(p2 == n2){ Boolean s = s1.charAt(p1) == s3.charAt(p3) ? dfsCheck(s1, s2, s3, n1, n2, n3, p1 + 1, p2, p3 + 1, map) : false; map.put(key, s); return map.get(key); } Boolean f1 = s2.charAt(p2) == s3.charAt(p3) ? dfsCheck(s1, s2, s3, n1, n2, n3, p1, p2 + 1, p3 + 1, map) : false; Boolean f2 = s1.charAt(p1) == s3.charAt(p3) ? dfsCheck(s1, s2, s3, n1, n2, n3, p1 + 1, p2, p3 + 1, map) : false; Boolean f = f1 || f2; map.put(key, f); return map.get(key); } } . Improvement: . //1ms class Solution { private boolean[][] invalid; private char[] c1; private char[] c2; private char[] c3; public boolean isInterleave(String s1, String s2, String s3) { c1 = s1.toCharArray(); c2 = s2.toCharArray(); c3 = s3.toCharArray(); int m = s1.length(),n=s2.length(); if(m + n != c3.length) return false; invalid = new boolean[m+1][n+1]; return dfs(0,0,0); } public boolean dfs(int i, int j, int k){ if(invalid[i][j]) return false; if(k == c3.length) return true; boolean valid = i &lt; c1.length &amp;&amp; c1[i] == c3[k] &amp;&amp; dfs(i + 1,j,k + 1) || j &lt; c2.length &amp;&amp; c2[j] == c3[k] &amp;&amp; dfs(i,j + 1,k + 1); if(!valid) invalid[i][j] = true; return valid; } } . Using 2D Dynamic Programming . class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); char[] c3 = s3.toCharArray(); if(n1 + n2 != n3) return false; boolean[][] dp = new boolean[n1 + 1][n2 + 1]; for(int i = 0; i &lt;= n1; i++){ for(int j = 0; j &lt;= n2; j++){ if(i == 0 &amp;&amp; j == 0){ dp[i][j] = true; }else if(i == 0){ dp[i][j] = dp[i][j - 1] &amp;&amp; c2[j - 1] == c3[i + j - 1]; }else if(j == 0){ dp[i][j] = dp[i - 1][j] &amp;&amp; c1[i - 1] == c3[i + j - 1]; }else{ dp[i][j] = (c1[i - 1] == c3[i + j - 1] &amp;&amp; dp[i - 1][j]) || (c2[j - 1] == c3[i + j - 1] &amp;&amp; dp[i][j - 1]); } } } return dp[n1][n2]; } } . Using 1D Dynamic Programming . class Solution { public boolean isInterleave(String s1, String s2, String s3) { int n1 = s1.length(), n2 = s2.length(), n3 = s3.length(); char[] c1 = s1.toCharArray(); char[] c2 = s2.toCharArray(); char[] c3 = s3.toCharArray(); if(n1 + n2 != n3) return false; boolean[] dp = new boolean[n2 + 1]; for(int i = 0; i &lt;= n1; i++){ for(int j = 0; j &lt;= n2; j++){ if(i == 0 &amp;&amp; j == 0){ dp[j] = true; }else if(i == 0){ dp[j] = dp[j - 1] &amp;&amp; c2[j - 1] == c3[i + j - 1]; }else if(j == 0){ dp[j] = dp[j] &amp;&amp; c1[i - 1] == c3[i + j - 1]; }else{ dp[j] = (c1[i - 1] == c3[i + j - 1] &amp;&amp; dp[j]) || (c2[j - 1] == c3[i + j - 1] &amp;&amp; dp[j - 1]); } } } return dp[n2]; } } . ",
    "url": "https://1001anjan.github.io/problem-152-Interleaving%20String/",
    "relUrl": "/problem-152-Interleaving String/"
  },"212": {
    "doc": "Maximal Square",
    "title": "Maximal Square",
    "content": "Given an m x n binary matrix filled with 0’s and 1’s, find the largest square containing only 1’s and return its area. Example 1: . Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 4 . Example 2: . Input: matrix = [[\"0\",\"1\"],[\"1\",\"0\"]] Output: 1 . Example 3: . Input: matrix = [[\"0\"]] Output: 0 . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 300 | matrix[i][j] is ‘0’ or ‘1’. | . Solution: . class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[][] dp = new int[m + 1][n + 1]; int maxLen = 0; for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;=n; j++){ if(matrix[i - 1][j - 1] == '1'){ dp[i][j] = 1 + Math.min(dp[i][j - 1], Math.min(dp[i - 1][j - 1], dp[i - 1][j])); maxLen = Math.max(maxLen, dp[i][j]); } } } return maxLen * maxLen; } } . (Better Dynamic Programming) . Algorithm . class Solution { public int maximalSquare(char[][] matrix) { int m = matrix.length, n = matrix[0].length; int[] dp = new int[n + 1]; int maxLen = 0, prev = 0; for(int i = 1; i &lt;= m; i++){ for(int j = 1; j &lt;= n; j++){ int temp = dp[j]; if(matrix[i - 1][j - 1] == '1'){ dp[j] = 1 + Math.min(dp[j - 1], Math.min(prev, dp[j])); maxLen = Math.max(maxLen, dp[j]); }else{ dp[j] = 0; } prev = temp; } } return maxLen * maxLen; } } . ",
    "url": "https://1001anjan.github.io/problem-153-Maximal%20Square/",
    "relUrl": "/problem-153-Maximal Square/"
  },"213": {
    "doc": "N-Repeated Element in Size 2N Array",
    "title": "N-Repeated Element in Size 2N Array",
    "content": "You are given an integer array nums with the following properties: . | nums.length == 2 * n. | nums contains n + 1 unique elements. | Exactly one element of nums is repeated n times. | . Return the element that is repeated n times. Example 1: . Input: nums = [1,2,3,3] Output: 3 . Example 2: . Input: nums = [2,1,2,5,3,2] Output: 2 . Example 3: . Input: nums = [5,1,5,2,5,3,5,4] Output: 5 . Constraints: . | 2 &lt;= n &lt;= 5000 | nums.length == 2 * n | 0 &lt;= nums[i] &lt;= 104 | nums contains n + 1 unique elements and one of them is repeated exactly n times. | . Solution: . class Solution { public int repeatedNTimes(int[] nums) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int n:nums) map.put(n,map.getOrDefault(n,0) + 1); for(int n: map.keySet()) // since others elemements are unique if(map.get(n)&gt;1) return n; throw null; } } . If we ever find a repeated element, it must be the answer. Let’s call this answer the major element. Consider all subarrays of length 4. There must be a major element in at least one such subarray. This is because either: . | There is a major element in a length 2 subarray, or; | Every length 2 subarray has exactly 1 major element, which means that a length 4 subarray that begins at a major element will have 2 major elements. Thus, we only have to compare elements with their neighbors that are distance 1, 2, or 3 away. class Solution { public int repeatedNTimes(int[] nums) { for(int k = 1; k&lt;=3; k++){ for(int i=0; i&lt;nums.length-k; i++) if(nums[i] == nums[i+k]) return nums[i]; } throw null; } } . | . ",
    "url": "https://1001anjan.github.io/problem-153-N-Repeated-Element-in-Size-2N-Array/",
    "relUrl": "/problem-153-N-Repeated-Element-in-Size-2N-Array/"
  },"214": {
    "doc": "Longest Consecutive Sequence",
    "title": "Longest Consecutive Sequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence. You must write an algorithm that runs in O(n) time. Example 1: . Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: . Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 . Constraints: . | 0 &lt;= nums.length &lt;= 10^5 | -10^9 &lt;= nums[i] &lt;= 10^9 | . Solution: . class Solution { public int longestConsecutive(int[] nums) { if(nums.length == 0) return 0; Arrays.sort(nums); int s = 0, e = 0, i = 1; int max = 1; while(i &lt; nums.length){ if(nums[i - 1] + 1 == nums[i]){ e++; }else if(nums[i - 1] == nums[i]){ // for duplicate numbers, not counting e++; s++; }else{ s = i; e = i; } i++; max = Math.max(max, e - s + 1); } return max; } } . NOTE: n*log(n) is better . Another way but slow . class Solution { public int longestConsecutive(int[] nums) { Set&lt;Integer&gt; num_set = new HashSet&lt;Integer&gt;(); for (int num : nums) { num_set.add(num); } int longestStreak = 0; for (int num : num_set) { if (!num_set.contains(num-1)) { int currentNum = num; int currentStreak = 1; while (num_set.contains(currentNum+1)) { currentNum += 1; currentStreak += 1; } longestStreak = Math.max(longestStreak, currentStreak); } } return longestStreak; } } . ",
    "url": "https://1001anjan.github.io/problem-154-Longest%20Consecutive%20Sequence/",
    "relUrl": "/problem-154-Longest Consecutive Sequence/"
  },"215": {
    "doc": "Univalued Binary Tree",
    "title": "Univalued Binary Tree",
    "content": "A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise. Example 1: . Input: root = [1,1,1,1,1,null,1] Output: true . Example 2: . Input: root = [2,2,2,5,2] Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 100]. | 0 &lt;= Node.val &lt; 100 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isUnivalTree(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); int val = root.val; while(!stack.isEmpty()){ TreeNode node = stack.pop(); if(val != node.val) return false; if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-154-Univalued-Binary-Tree/",
    "relUrl": "/problem-154-Univalued-Binary-Tree/"
  },"216": {
    "doc": "Largest Perimeter Triangle",
    "title": "Largest Perimeter Triangle",
    "content": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. Example 1: . Input: nums = [2,1,2] Output: 5 . Example 2: . Input: nums = [1,2,1] Output: 0 . Constraints: . | 3 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 106 | . Solution: . class Solution { public int largestPerimeter(int[] nums) { Arrays.sort(nums); for(int i=nums.length-3; i&gt;=0; i--){ if(nums[i] + nums[i+1] &gt; nums[i+2]) return nums[i] + nums[i+1] + nums[i+2]; } return 0; } } . ",
    "url": "https://1001anjan.github.io/problem-155-Largest-Perimeter-Triangle/",
    "relUrl": "/problem-155-Largest-Perimeter-Triangle/"
  },"217": {
    "doc": "Single Number II",
    "title": "Single Number II",
    "content": "Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: . Input: nums = [2,2,3,2] Output: 3 . Example 2: . Input: nums = [0,1,0,1,0,1,99] Output: 99 . Constraints: . | 1 &lt;= nums.length &lt;= 3 * 10^4 | -2^31 &lt;= nums[i] &lt;= 2^31 - 1 | Each element in nums appears exactly three times except for one element which appears once. | . Solution: . the number in 32 bits and just count how many 1s are there in each bit, and sum %= 3 will clear it once it reaches 3. After running for all the numbers for each bit, if we have a 1, then that 1 belongs to the single number, we can simply move it back to its spot by doing ans |= sum « i; . This has complexity of O(32n), which is essentially O(n) and very easy to think and implement. Plus, you get a general solution for any times of occurrence. Say all the numbers have 5 times, just do sum %= 5. class Solution { public int singleNumber(int[] nums) { int ans = 0; for(int i = 0; i &lt; 32; i++){ int sum = 0; for(int n : nums){ if(((n &gt;&gt; i) &amp; 1) == 1) sum++; } sum %= 3; ans = ans | sum &lt;&lt; i; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-155-Single%20Number%20II/",
    "relUrl": "/problem-155-Single Number II/"
  },"218": {
    "doc": "Integer Break",
    "title": "Integer Break",
    "content": "Given an integer n, break it into the sum of k positive integers, where k &gt;= 2, and maximize the product of those integers. Return the maximum product you can get. Example 1: . Input: n = 2 Output: 1 Explanation: 2 = 1 + 1, 1 × 1 = 1. Example 2: . Input: n = 10 Output: 36 Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36. Constraints: . | 2 &lt;= n &lt;= 58 | . Solution: . class Solution { public int integerBreak(int n) { int[] dp = new int[n+1]; Arrays.fill(dp,-1); return helper(n,n,dp); } private int helper(int n,int q,int[] dp){ if(n == 1)return 1; if(dp[n] != -1)return dp[n]; int ans = (n == q)? 0 : n; for(int i = 1; i &lt; n; i++){ int c = helper(i,n,dp) * helper(n-i,n,dp); ans = Math.max(c,ans); } dp[n] = ans; return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-156-Integer%20Break/",
    "relUrl": "/problem-156-Integer Break/"
  },"219": {
    "doc": "Squares of a Sorted Array",
    "title": "Squares of a Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Example 1: . Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: . Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums is sorted in non-decreasing order. | . Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach? . Solution: . class Solution { public int[] sortedSquares(int[] nums) { int[] ans = new int[nums.length]; int s = 0; int e = nums.length - 1; int i = e; while(i&gt;=0){ if(Math.abs(nums[s])&gt;Math.abs(nums[e])) ans[i--] = nums[s]*nums[s++]; else ans[i--] = nums[e]*nums[e--]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-156-Squares-of-a-Sorted%20Array/",
    "relUrl": "/problem-156-Squares-of-a-Sorted Array/"
  },"220": {
    "doc": "Add to Array-Form of Integer",
    "title": "Add to Array-Form of Integer",
    "content": "The array-form of an integer num is an array representing its digits in left to right order. | For example, for num = 1321, the array form is [1,3,2,1]. Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k. | . Example 1: . Input: num = [1,2,0,0], k = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 . Example 2: . Input: num = [2,7,4], k = 181 Output: [4,5,5] Explanation: 274 + 181 = 455 . Example 3: . Input: num = [2,1,5], k = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021 . Constraints: . | 1 &lt;= num.length &lt;= 104 | 0 &lt;= num[i] &lt;= 9 | num does not contain any leading zeros except for the zero itself. | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public List&lt;Integer&gt; addToArrayForm(int[] nums, int k) { LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); int c = 0; int i = nums.length - 1; while(k&gt;0 || i&gt;=0){ int d = k%10; if(i&gt;=0){ ans.addFirst((nums[i] + d + c)%10); c = (nums[i] + d + c)/10; i--; }else{ ans.addFirst((d+c)%10); c = (d + c)/10; } k = k/10; } if(c&gt;0) ans.addFirst(c); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-157-Add-to-Array-Form-of-Integer/",
    "relUrl": "/problem-157-Add-to-Array-Form-of-Integer/"
  },"221": {
    "doc": "Minimum Rounds to Complete All Tasks",
    "title": "Minimum Rounds to Complete All Tasks",
    "content": "You are given a 0-indexed integer array tasks, where tasks[i] represents the difficulty level of a task. In each round, you can complete either 2 or 3 tasks of the same difficulty level. Return the minimum rounds required to complete all the tasks, or -1 if it is not possible to complete all the tasks. Example 1: . Input: tasks = [2,2,3,3,2,4,4,4,4,4] Output: 4 Explanation: To complete all the tasks, a possible plan is: - In the first round, you complete 3 tasks of difficulty level 2. - In the second round, you complete 2 tasks of difficulty level 3. - In the third round, you complete 3 tasks of difficulty level 4. - In the fourth round, you complete 2 tasks of difficulty level 4. It can be shown that all the tasks cannot be completed in fewer than 4 rounds, so the answer is 4. Example 2: . Input: tasks = [2,3,3] Output: -1 Explanation: There is only 1 task of difficulty level 2, but in each round, you can only complete either 2 or 3 tasks of the same difficulty level. Hence, you cannot complete all the tasks, and the answer is -1. Constraints: . | 1 &lt;= tasks.length &lt;= 10^5 | 1 &lt;= tasks[i] &lt;= 10^9 | . Solution: . class Solution { public int minimumRounds(int[] tasks) { Map&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); for(int n : tasks) mp.put(n, mp.getOrDefault(n, 0) + 1); int count = 0; for(int n : mp.values()){ int c = process(n); if(c == -1) return -1; count += c; } return count; } public int process(int n){ if(n % 3 == 0) return n / 3; int c3 = n / 3, c2 = 1; while(c2 * 2 &lt;= n){ int value = c3 * 3 + c2 * 2; if(value == n) return c3 &gt; 0 ? c3 + c2 : c2; if(value &gt; n){ c3 --; c2 ++; } } return -1; } } . class Solution { public int minimumRounds(int[] tasks) { Map&lt;Integer, Integer&gt; freq = new HashMap(); // Store the frequencies in the map. for (int task : tasks) { freq.put(task, freq.getOrDefault(task, 0) + 1); } int minimumRounds = 0; // Iterate over the task's frequencies. for (int count : freq.values()) { // If the frequency is 1, it's not possible to complete tasks. if (count == 1) { return - 1; } if (count % 3 == 0) { // Group all the task in triplets. minimumRounds += count / 3; } else { // If count % 3 = 1; (count / 3 - 1) groups of triplets and 2 pairs. // If count % 3 = 2; (count / 3) groups of triplets and 1 pair. minimumRounds += count / 3 + 1; } } return minimumRounds; } } . ",
    "url": "https://1001anjan.github.io/problem-157-Minimum%20Rounds%20to%20Complete%20All%20Tasks/",
    "relUrl": "/problem-157-Minimum Rounds to Complete All Tasks/"
  },"222": {
    "doc": "Cousins in Binary Tree",
    "title": "Cousins in Binary Tree",
    "content": "Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. Two nodes of a binary tree are cousins if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1. Example 1: . Input: root = [1,2,3,4], x = 4, y = 3 Output: false . Example 2: . Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true . Example 3: . Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false . Constraints: . | The number of nodes in the tree is in the range [2, 100]. | 1 &lt;= Node.val &lt;= 100 | Each node has a unique value. | x != y | x and y are exist in the tree. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isCousins(TreeNode root, int x, int y) { if(root == null || root.val == x || root.val == y) return false; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ int size = q.size(); int x1 = -1; int y1 = -1; TreeNode p1, p2; p1 = p2 = null; Queue&lt;TreeNode&gt; q1 = new LinkedList&lt;&gt;(); for(int i = 1; i&lt;=size; i++){ TreeNode t = q.poll(); if(t.left != null &amp;&amp; t.left.val == x){ x1= x; p1 = t; }else if(t.left != null &amp;&amp; t.left.val == y){ y1= y; p2 = t; } if(t.right != null &amp;&amp; t.right.val == x){ x1 = x; p1 = t; } else if(t.right != null &amp;&amp; t.right.val == y){ y1 = y; p2 = t; } if(x1 == x &amp;&amp; y1== y &amp;&amp; p1 != p2) return true; if(t.left != null) q1.add(t.left); if(t.right != null) q1.add(t.right); } q = q1; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-158-Cousins-in-Binary-Tree/",
    "relUrl": "/problem-158-Cousins-in-Binary-Tree/"
  },"223": {
    "doc": "Minimum Number of Arrows to Burst Balloons",
    "title": "Minimum Number of Arrows to Burst Balloons",
    "content": "There are some spherical balloons taped onto a flat wall that represents the XY-plane. The balloons are represented as a 2D integer array points where points[i] = [xstart, xend] denotes a balloon whose horizontal diameter stretches between xstart and xend. You do not know the exact y-coordinates of the balloons. Arrows can be shot up directly vertically (in the positive y-direction) from different points along the x-axis. A balloon with xstart and xend is burst by an arrow shot at x if xstart &lt;= x &lt;= xend. There is no limit to the number of arrows that can be shot. A shot arrow keeps traveling up infinitely, bursting any balloons in its path. Given the array points, return the minimum number of arrows that must be shot to burst all balloons. Example 1: . Input: points = [[10,16],[2,8],[1,6],[7,12]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 6, bursting the balloons [2,8] and [1,6]. - Shoot an arrow at x = 11, bursting the balloons [10,16] and [7,12]. Example 2: . Input: points = [[1,2],[3,4],[5,6],[7,8]] Output: 4 Explanation: One arrow needs to be shot for each balloon for a total of 4 arrows. Example 3: . Input: points = [[1,2],[2,3],[3,4],[4,5]] Output: 2 Explanation: The balloons can be burst by 2 arrows: - Shoot an arrow at x = 2, bursting the balloons [1,2] and [2,3]. - Shoot an arrow at x = 4, bursting the balloons [3,4] and [4,5]. Constraints: . | 1 &lt;= points.length &lt;= 10^5 | points[i].length == 2 | -2^31 &lt;= xstart &lt; xend &lt;= 2^31 - 1 | . Solution: . class Solution { public int findMinArrowShots(int[][] points) { Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0])); int count = 1; int end = points[0][1]; for(int i = 1; i &lt; points.length; i++){ if(points[i][0] &lt;= end){ end = Math.min(end, points[i][1]); }else{ count ++; end = points[i][1]; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-158-Minimum%20Number%20of%20Arrows%20to%20Burst%20Balloons/",
    "relUrl": "/problem-158-Minimum Number of Arrows to Burst Balloons/"
  },"224": {
    "doc": "Cousins in Binary Tree",
    "title": "Find the Town Judge",
    "content": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: . | The town judge trusts nobody. | Everybody (except for the town judge) trusts the town judge. | There is exactly one person that satisfies properties 1 and 2. | . You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. Example 1: . Input: n = 2, trust = [[1,2]] Output: 2 . Example 2: . Input: n = 3, trust = [[1,3],[2,3]] Output: 3 . Example 3: . Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 . Constraints: . | 1 &lt;= n &lt;= 1000 | 0 &lt;= trust.length &lt;= 104 | trust[i].length == 2 | All the pairs of trust are unique. | ai != bi | 1 &lt;= ai, bi &lt;= n | . Solution: . class Solution { public int findJudge(int n, int[][] trust) { boolean[] s = new boolean[n]; int[] c = new int[n]; for(int i=0; i&lt;trust.length; i++){ s[trust[i][0]-1] = true; c[trust[i][1]-1]++; } for(int i=0; i&lt;n; i++) if(!s[i] &amp;&amp; c[i] == n-1) return i+1; return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-159-Cousins-in-Binary-Tree/#find-the-town-judge",
    "relUrl": "/problem-159-Cousins-in-Binary-Tree/#find-the-town-judge"
  },"225": {
    "doc": "Cousins in Binary Tree",
    "title": "Cousins in Binary Tree",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-159-Cousins-in-Binary-Tree/",
    "relUrl": "/problem-159-Cousins-in-Binary-Tree/"
  },"226": {
    "doc": "Maximum Ice Cream Bars",
    "title": "Maximum Ice Cream Bars",
    "content": "It is a sweltering summer day, and a boy wants to buy some ice cream bars. At the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. Return the maximum number of ice cream bars the boy can buy with coins coins. Note: The boy can buy the ice cream bars in any order. Example 1: . Input: costs = [1,3,2,4,1], coins = 7 Output: 4 Explanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7. Example 2: . Input: costs = [10,6,8,7,7,8], coins = 5 Output: 0 Explanation: The boy cannot afford any of the ice cream bars. Example 3: . Input: costs = [1,6,3,1,2,5], coins = 20 Output: 6 Explanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18. Constraints: . | costs.length == n | 1 &lt;= n &lt;= 10^5 | 1 &lt;= costs[i] &lt;= 10^5 | 1 &lt;= coins &lt;= 10^8 | . Solution: . class Solution { public int maxIceCream(int[] costs, int coins) { Arrays.sort(costs); int count = 0; for(int n : costs){ if(coins &gt;= n){ coins -= n; count++; }else break; } return count; } } . Using counting sort . class Solution { public int maxIceCream(int[] costs, int coins) { int m = costs[0]; for (int cost : costs) m = Math.max(m, cost); int[] freq_arr = new int[m + 1]; for(int c : costs) freq_arr[c] ++; int count = 0; for(int i = 1; i &lt; freq_arr.length; i++){ if(freq_arr[i] == 0) continue; if(freq_arr[i] &gt; coins) break; // Count how many icecreams of 'cost' we can pick with our 'coins'. // Either we can pick all ice creams of 'cost' or we will be limited by remaining 'coins'. int max = Math.min(freq_arr[i], coins/i); count += max; coins -= i * max; System.out.println(max+\" \"+coins+\" \"+count); } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-159-Maximum%20Ice%20Cream%20Bars/",
    "relUrl": "/problem-159-Maximum Ice Cream Bars/"
  },"227": {
    "doc": "Climbing Stairs",
    "title": "Climbing Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? . Example 1: . Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps . Example 2: . Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step . Constraints: . | 1 &lt;= n &lt;= 45 | . Solution . class Solution { public int climbStairs(int n) { if(n &lt;= 2) return n; int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; for(int i = 3; i &lt;= n; i++) dp[i] = dp[i-1] + dp[i-2]; return dp[n]; } } . Recursion . class Solution { HashMap&lt;Integer, Integer&gt; map = new HashMap(); public int climbStairs(int n) { if(map.containsKey(n)) return map.get(n); if(n == 1){ map.put(1, 1); return 1; } if(n == 2) { map.put(2, 2); return 2; } int x = climbStairs(n-1) + climbStairs(n-2); map.put(n,x); return map.get(n); } } . ",
    "url": "https://1001anjan.github.io/problem-16-climbing-stairs/",
    "relUrl": "/problem-16-climbing-stairs/"
  },"228": {
    "doc": "Divide Two Integers",
    "title": "Divide Two Integers",
    "content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. Example 1: . Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = 3.33333.. which is truncated to 3. Example 2: . Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = -2.33333.. which is truncated to -2. Constraints: . | -2^31 &lt;= dividend, divisor &lt;= 2^31 - 1 | divisor != 0 | . Solution: . class Solution { public int divide(int dividend, int divisor) { //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE){ //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; } else { ans = (int) (sign * lans); } return ans; } private long ldivide(long ldividend, long ldivisor) { // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) { sum += sum; multiple += multiple; } //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor); } } . ",
    "url": "https://1001anjan.github.io/problem-16-Divide%20Two%20Integers/",
    "relUrl": "/problem-16-Divide Two Integers/"
  },"229": {
    "doc": "Find Common Characters",
    "title": "Find Common Characters",
    "content": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order. Example 1: . Input: words = [\"bella\",\"label\",\"roller\"] Output: [\"e\",\"l\",\"l\"] . Example 2: . Input: words = [\"cool\",\"lock\",\"cook\"] Output: [\"c\",\"o\"] . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); Map&lt;Character, Integer&gt; m1 = new HashMap&lt;&gt;(); // constracting first word for(char c : words[0].toCharArray()) m1.put(c,m1.getOrDefault(c,0)+1); for(int i = 1; i &lt; words.length; i++){ Map&lt;Character, Integer&gt; m2 = new HashMap&lt;&gt;(); for(char c : words[i].toCharArray()) m2.put(c,m2.getOrDefault(c,0)+1); // find common char and store min value or remove uncommon Map&lt;Character, Integer&gt; m3 = new HashMap&lt;&gt;(); for(char c : m2.keySet()){ if(m1.containsKey(c)) m3.put(c,Math.min(m1.get(c),m2.get(c))); } m1 = m3; } // constract ans for(char c : m1.keySet()){ for(int i = 1; i&lt;= m1.get(c); i++) ans.add(String.valueOf(c)); } return ans; } } . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); for(char ch = 'a'; ch &lt;= 'z'; ch++) { int minCountOfCh = Integer.MAX_VALUE; for(String word : words) { int currChCount = 0; for(char currCh : word.toCharArray()) { if(currCh == ch) { currChCount++; } } minCountOfCh = Math.min(minCountOfCh, currChCount); } for(int i = 0; i &lt; minCountOfCh; i++) { res.add(String.valueOf(ch)); } } return res; } } . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] freq = new int[26]; Arrays.fill(freq, Integer.MAX_VALUE); for (String s : words) { int[] temp = new int[26]; for (int i = 0; i &lt; s.length(); i++) { int index = (int) s.charAt(i) - 'a'; temp[index]++; } for (int i = 0; i &lt; 26; i++) { freq[i] = Math.min(temp[i], freq[i]); } } for (int i = 0; i &lt; 26; i++) { while (freq[i]-- &gt; 0) { System.out.print(i + \" \"); char c = (char) (i + 97); ans.add(\"\" + c); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-160-Find-Common-Characters/",
    "relUrl": "/problem-160-Find-Common-Characters/"
  },"230": {
    "doc": "Gas Station",
    "title": "Gas Station",
    "content": "There are n gas stations along a circular route, where the amount of gas at the ith station is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the ith station to its next (i + 1)th station. You begin the journey with an empty tank at one of the gas stations. Given two integer arrays gas and cost, return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique . Example 1: . Input: gas = [1,2,3,4,5], cost = [3,4,5,1,2] Output: 3 Explanation: Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 4. Your tank = 4 - 1 + 5 = 8 Travel to station 0. Your tank = 8 - 2 + 1 = 7 Travel to station 1. Your tank = 7 - 3 + 2 = 6 Travel to station 2. Your tank = 6 - 4 + 3 = 5 Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3. Therefore, return 3 as the starting index. Example 2: . Input: gas = [2,3,4], cost = [3,4,3] Output: -1 Explanation: You can't start at station 0 or 1, as there is not enough gas to travel to the next station. Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4 Travel to station 0. Your tank = 4 - 3 + 2 = 3 Travel to station 1. Your tank = 3 - 3 + 3 = 3 You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3. Therefore, you can't travel around the circuit once no matter where you start. Constraints: . | n == gas.length == cost.length | 1 &lt;= n &lt;= 10^5 | 0 &lt;= gas[i], cost[i] &lt;= 10^4 | . Solution: . Time Limit Exceeded. Complexity O(n^2) . class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { for(int i = 0; i &lt; gas.length; i++){ if(processForStation(gas, i, cost)) return i; } return -1; } private boolean processForStation(int[] gas, int start, int[] cost){ int i = start; int store = gas[i]; int next = i; do{ i = next; if(cost[i] &gt; store) return false; next = (i + 1) % cost.length; store = store - cost[i] + gas[next]; }while(next != start); return true; } } . Complexity: O(n) . class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { int totalGas = 0; int totalCost = 0; for(int i = 0; i &lt; gas.length; i++){ totalGas += gas[i]; totalCost += cost[i]; } if(totalGas &lt; totalCost) return -1; // Initialize remainsGas and start to 0 int remainsGas = 0, start = 0; // Iterate through all the gas stations for(int i = 0 ; i &lt; gas.length; i++){ // Add the difference between gas and cost at each station to remainsGas remainsGas = remainsGas +(gas[i] - cost[i]); // If remainsGas becomes negative, set start to the next station and reset remainsGas to 0 if(remainsGas &lt; 0 ){ start = i+1; remainsGas = 0; } } // Return the starting station return start; } } . ",
    "url": "https://1001anjan.github.io/problem-160-Gas%20Station/",
    "relUrl": "/problem-160-Gas Station/"
  },"231": {
    "doc": "Maximize Sum Of Array After K Negations",
    "title": "Maximize Sum Of Array After K Negations",
    "content": "Given an integer array nums and an integer k, modify the array in the following way: . | choose an index i and replace nums[i] with -nums[i]. You should apply this process exactly k times. You may choose the same index i multiple times. | . Return the largest possible sum of the array after modifying it in this way. Example 1: . Input: nums = [4,2,3], k = 1 Output: 5 Explanation: Choose index 1 and nums becomes [4,-2,3]. Example 2: . Input: nums = [3,-1,0,2], k = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2]. Example 3: . Input: nums = [2,-3,-1,5,-4], k = 2 Output: 13 Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4]. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -100 &lt;= nums[i] &lt;= 100 | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // checking for negetive elements while(i&lt;k &amp;&amp; i&lt;nums.length &amp;&amp; nums[i]&lt;0){ nums[i] *=-1; i++; } if(i == nums.length){ if(k%2 == 0) nums[nums.length-1] *=-1; }else{ k = k - i; // checking if positive element if(i&lt;nums.length &amp;&amp; nums[i] &gt; 0){ // check if we have previous postive element if(i&gt;0 &amp;&amp; nums[i-1]&gt;0 &amp;&amp; nums[i-1]&lt;nums[i] &amp;&amp; k%2 == 1) nums[i-1] *= -1; else if(k%2 == 1) nums[i] *= -1; } } int sum = 0; for(int n : nums) sum +=n; return sum; } } . Using mean heap but slower than previous . class Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue&lt;Integer&gt;pq=new PriorityQueue&lt;&gt;((a,b)-&gt;a-b); int sum=0; for(int i:nums){ pq.add(i); } while(k&gt;0){ int x=pq.poll(); pq.add(-x); k--; } while(pq.size()&gt;0){ sum+=pq.poll(); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Maximize-Sum-Of-Array-After-K-Negations/",
    "relUrl": "/problem-161-Maximize-Sum-Of-Array-After-K-Negations/"
  },"232": {
    "doc": "Surrounded Regions",
    "title": "Surrounded Regions",
    "content": "Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. Example 1: . Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Notice that an 'O' should not be flipped if: - It is on the border, or - It is adjacent to an 'O' that should not be flipped. The bottom 'O' is on the border, so it is not flipped. The other three 'O' form a surrounded region, so they are flipped. Example 2: . Input: board = [[\"X\"]] Output: [[\"X\"]] . Constraints: . | m == board.length | n == board[i].length | 1 &lt;= m, n &lt;= 200 | board[i][j] is ‘X’ or ‘O’. | . Solution: . Time Complexity: O(n^3) . class Solution { boolean ss; public void solve(char[][] board) { List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); Set&lt;String&gt; visited = new HashSet&lt;&gt;(); for(int i = 1; i &lt; board.length - 1; i++){ for(int j = 1; j &lt; board[0].length - 1; j++){ if(board[i][j] == 'O'){ ss = true; process(board, i, j, list, visited); if(ss) for(int[] arr : list) board[arr[0]][arr[1]] = 'X'; } list.clear(); visited.clear(); } } } public void process(char[][] board, int i , int j, List&lt;int[]&gt; list, Set&lt;String&gt; visited){ if(i &lt; 0 || i &gt; board.length || j &lt; 0 || j &gt; board[0].length){ ss = ss &amp;&amp; false; return; } if(i == 0 &amp;&amp; board[i][j] == 'O') { ss = ss &amp;&amp; false; return; } if(j == 0 &amp;&amp; board[i][j] == 'O') { ss = ss &amp;&amp; false; return; } if(i == board.length - 1 &amp;&amp; board[i][j] == 'O') { ss = ss &amp;&amp; false; return; } if(j == board[0].length - 1 &amp;&amp; board[i][j] == 'O') { ss = ss &amp;&amp; false; return; } visited.add(i+\"-\"+j); list.add(new int[]{i, j}); if(i - 1 &gt;= 0 &amp;&amp; board[i - 1][j] == 'O' &amp;&amp; !visited.contains((i - 1)+\"-\"+j)) process(board, i - 1, j, list, visited); if(j - 1 &gt;= 0 &amp;&amp; board[i][j - 1] == 'O' &amp;&amp; !visited.contains(i+\"-\"+(j - 1))) process(board, i, j - 1, list, visited); if(i + 1 &lt; board.length &amp;&amp; board[i + 1][j] == 'O' &amp;&amp; !visited.contains((i + 1)+\"-\"+j)) process(board, i + 1, j, list, visited); if(j + 1 &lt; board[0].length &amp;&amp; board[i][j + 1] == 'O' &amp;&amp; !visited.contains(i+\"-\"+(j + 1))){ process(board, i, j + 1, list, visited); } ss = ss &amp;&amp; true; } } . Improvement: O(n^2) . Basically, all the boundary ‘O’s need not to be changed. Use DFS to visit the boundary ‘O’, turn it into ‘V’ and explore the node. In this way, we change the remaining ‘O’s to ‘X’s. Convert the ‘V’s to ‘O’s. class Solution { public void solve(char[][] board) { int rows = board.length; int cols = board[0].length; for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; cols; j++){ if(i * j == 0 || i == rows-1 || j == cols-1){ //We check for Boundary 'O's and turn them into 'V'. //These are valid 'O's and need not to be changed to 'X's. if(board[i][j] == 'O'){ dfs(board, i, j); } } } } //Iterate over the whole grid, change remaining 'O's to 'X's. //Change 'V's to 'O's for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; cols; j++){ if(board[i][j] == 'O'){ board[i][j] = 'X'; } else if(board[i][j] == 'V'){ board[i][j] = 'O'; } } } } //Main DFS Function to convert all the boundary 'O's to 'V's private void dfs(char[][] board, int i, int j){ if(i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length || board[i][j] != 'O'){ return; } board[i][j] = 'V'; dfs(board, i + 1, j); dfs(board, i - 1, j); dfs(board, i, j + 1); dfs(board, i, j - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-161-Surrounded%20Regions/",
    "relUrl": "/problem-161-Surrounded Regions/"
  },"233": {
    "doc": "Complement of Base 10 Integer",
    "title": "Complement of Base 10 Integer",
    "content": "The complement of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation. | For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2. Given an integer n, return its complement. | . Example 1: . Input: n = 5 Output: 2 Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10. Example 2: . Input: n = 7 Output: 0 Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10. Example 3: . Input: n = 10 Output: 5 Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10. Constraints: . | 0 &lt;= n &lt; 109 | . Solution: . class Solution { public int bitwiseComplement(int num) { if(num == 0) return 1; int mask = 0; while(mask &lt; num) mask = mask &lt;&lt; 1 | 1; return (~ num) &amp; mask ; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Complement-of-Base-10-Integer/",
    "relUrl": "/problem-161-Complement-of-Base-10-Integer/"
  },"234": {
    "doc": "Find K Pairs with Smallest Sums",
    "title": "Find K Pairs with Smallest Sums",
    "content": "You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u, v) which consists of one element from the first array and one element from the second array. Return the k pairs (u1, v1), (u2, v2), …, (uk, vk) with the smallest sums. Example 1: . Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3 Output: [[1,2],[1,4],[1,6]] Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6] . Example 2: . Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2 Output: [[1,1],[1,1]] Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3] . Example 3: . Input: nums1 = [1,2], nums2 = [3], k = 3 Output: [[1,3],[2,3]] Explanation: All possible pairs are returned from the sequence: [1,3],[2,3] . Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 10^5 | -10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9 | nums1 and nums2 both are sorted in ascending order. | 1 &lt;= k &lt;= 10^4 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); // the check is not required as per Constraints for the problem if(nums1.length == 0 || nums2.length == 0 || k == 0) return ans; PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; (a[0] + a[1] - b[0] - b[1])); for(int i = 0; i &lt; Math.min(nums1.length , k); i++){ // storing combination nums1[i], nums2[0], 0 -&gt; first index of nums2 pq.offer(new int[]{nums1[i], nums2[0], 0}); } while(k-- &gt; 0 &amp;&amp; !pq.isEmpty()){ int curr[] = pq.poll(); ans.add(Arrays.asList(curr[0], curr[1])); if(curr[2] &lt; nums2.length - 1) pq.offer(new int[]{curr[0], nums2[curr[2] + 1], curr[2] + 1}); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-162-Find%20K%20Pairs%20with%20Smallest%20Sums/",
    "relUrl": "/problem-162-Find K Pairs with Smallest Sums/"
  },"235": {
    "doc": "Minimum Time to Collect All Apples in a Tree",
    "title": "Minimum Time to Collect All Apples in a Tree",
    "content": "Given an undirected tree consisting of n vertices numbered from 0 to n-1, which has some apples in their vertices. You spend 1 second to walk over one edge of the tree. Return the minimum time in seconds you have to spend to collect all apples in the tree, starting at vertex 0 and coming back to this vertex. The edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi. Additionally, there is a boolean array hasApple, where hasApple[i] = true means that vertex i has an apple; otherwise, it does not have any apple. Example 1: . Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false] Output: 8 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 2: . Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false] Output: 6 Explanation: The figure above represents the given tree where red vertices have an apple. One optimal path to collect all apples is shown by the green arrows. Example 3: . Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false] Output: 0 . Constraints: . | 1 &lt;= n &lt;= 10^5 | edges.length == n - 1 | edges[i].length == 2 | 0 &lt;= ai &lt; bi &lt;= n - 1 | from_i &lt; to_i | hasApple.length == n | . Solution: . class Solution { public int minTime(int n, int[][] edges, List&lt;Boolean&gt; hasApple) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); // create adjacency map for(int[] arr : edges){ adj.computeIfAbsent(arr[0], data -&gt; new ArrayList&lt;&gt;()).add(arr[1]); adj.computeIfAbsent(arr[1], data -&gt; new ArrayList&lt;&gt;()).add(arr[0]); } return dfsComputeMinTime(0, -1, adj, hasApple); } private int dfsComputeMinTime(int node, int parent, Map&lt;Integer, List&lt;Integer&gt;&gt; map, List&lt;Boolean&gt; hasApple){ if(!map.containsKey(node)) return 0; int totalCost = 0, childCost = 0; for(int child : map.get(node)){ if(child == parent) continue; childCost = dfsComputeMinTime(child, node, map, hasApple); if(childCost &gt; 0 || hasApple.get(child)){ totalCost += childCost + 2; } } return totalCost; } } . ",
    "url": "https://1001anjan.github.io/problem-163-Minimum%20Time%20to%20Collect%20All%20Apples%20in%20a%20Tree/",
    "relUrl": "/problem-163-Minimum Time to Collect All Apples in a Tree/"
  },"236": {
    "doc": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "title": "Partition Array Into Three Parts With Equal Sum",
    "content": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 &lt; j with (arr[0] + arr[1] + … + arr[i] == arr[i + 1] + arr[i + 2] + … + arr[j - 1] == arr[j] + arr[j + 1] + … + arr[arr.length - 1]) . Example 1: . Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 . Example 2: . Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false . Example 3: . Input: arr = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 . Constraints: . | 3 &lt;= arr.length &lt;= 5 * 104 | -104 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public boolean canThreePartsEqualSum(int[] arr) { int sum = 0; for(int n : arr) sum += n; if(sum % 3 != 0) return false; int parts = sum/3; int count = 0; sum = 0; for(int i=0; i&lt;arr.length; i++){ sum += arr[i]; if(sum == parts){ count ++; sum = 0; } } return count &gt;= 3; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/#partition-array-into-three-parts-with-equal-sum",
    "relUrl": "/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/#partition-array-into-three-parts-with-equal-sum"
  },"237": {
    "doc": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "title": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/",
    "relUrl": "/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/"
  },"238": {
    "doc": "Binary Prefix Divisible By 5",
    "title": "Binary Prefix Divisible By 5",
    "content": "You are given a binary array nums (0-indexed). We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit). | For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5. Return an array of booleans answer where answer[i] is true if xi is divisible by 5. | . Example 1: . Input: nums = [0,1,1] Output: [true,false,false] Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10. Only the first number is divisible by 5, so answer[0] is true. Example 2: . Input: nums = [1,1,1] Output: [false,false,false] . Constraints: . | 1 &lt;= nums.length &lt;= 105 | nums[i] is either 0 or 1. | . Solution: . class Solution { public List&lt;Boolean&gt; prefixesDivBy5(int[] nums) { List&lt;Boolean&gt; ans = new LinkedList&lt;&gt;(); long n = 0; for(int i=0; i&lt;nums.length; i++) ans.add((n = (n &lt;&lt; 1 | nums[i]) % 5) == 0); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-164-Binary-Prefix-Divisible-By-5/",
    "relUrl": "/problem-164-Binary-Prefix-Divisible-By-5/"
  },"239": {
    "doc": "Number of Nodes in the Sub-Tree With the Same Label",
    "title": "Number of Nodes in the Sub-Tree With the Same Label",
    "content": "You are given a tree (i.e. a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. The root of the tree is the node 0, and each node of the tree has a label which is a lower-case character given in the string labels (i.e. The node with the number i has the label labels[i]). The edges array is given on the form edges[i] = [ai, bi], which means there is an edge between nodes ai and bi in the tree. Return an array of size n where ans[i] is the number of nodes in the subtree of the ith node which have the same label as node i. A subtree of a tree T is the tree consisting of a node in T and all of its descendant nodes. Example 1: . Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = \"abaedcd\" Output: [2,1,1,1,1,1,1] Explanation: Node 0 has label 'a' and its sub-tree has node 2 with label 'a' as well, thus the answer is 2. Notice that any node is part of its sub-tree. Node 1 has a label 'b'. The sub-tree of node 1 contains nodes 1,4 and 5, as nodes 4 and 5 have different labels than node 1, the answer is just 1 (the node itself). Example 2: . Input: n = 4, edges = [[0,1],[1,2],[0,3]], labels = \"bbbb\" Output: [4,2,1,1] Explanation: The sub-tree of node 2 contains only node 2, so the answer is 1. The sub-tree of node 3 contains only node 3, so the answer is 1. The sub-tree of node 1 contains nodes 1 and 2, both have label 'b', thus the answer is 2. The sub-tree of node 0 contains nodes 0, 1, 2 and 3, all with label 'b', thus the answer is 4. Example 3: . Input: n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = \"aabab\" Output: [3,2,1,1,1] . Constraints: . | 1 &lt;= n &lt;= 10^5 | edges.length == n - 1 | edges[i].length == 2 | 0 &lt;= ai, bi &lt; n | ai != bi | labels.length == n | labels is consisting of only of lowercase English letters. | . Solution: . class Solution { public int[] countSubTrees(int n, int[][] edges, String labels) { int[] result = new int[n]; Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); for(int[] arr : edges){ map.computeIfAbsent(arr[0], value -&gt; new ArrayList&lt;&gt;()).add(arr[1]); map.computeIfAbsent(arr[1], value -&gt; new ArrayList&lt;&gt;()).add(arr[0]); } dfsCountSubTrees(0, -1, map, labels.toCharArray(), result); return result; } private int[] dfsCountSubTrees(int node, int parent, Map&lt;Integer, List&lt;Integer&gt;&gt; map, char[] labels, int[] result){ int[] dp = new int[26]; dp[labels[node] - 'a'] = 1; if(!map.containsKey(node)) return dp; // checking leave node for(int child : map.get(node)){ if(child == parent) continue; int[] childsDp = dfsCountSubTrees(child, node, map, labels, result); for(int i = 0; i &lt; 26; i++){ dp[i] += childsDp[i]; } } result[node] = dp[labels[node] - 'a']; return dp; } } . ",
    "url": "https://1001anjan.github.io/problem-164-Number%20of%20Nodes%20in%20the%20Sub-Tree%20With%20the%20Same%20Label/",
    "relUrl": "/problem-164-Number of Nodes in the Sub-Tree With the Same Label/"
  },"240": {
    "doc": "Longest Path With Different Adjacent Characters",
    "title": "Longest Path With Different Adjacent Characters",
    "content": "You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to node i. Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them. Example 1: . ![](../../assets/images/ds/160_example_1_1.png) Input: parent = [-1,0,0,1,1,2], s = \"abacbe\" Output: 3 Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -&gt; 1 -&gt; 3. The length of this path is 3, so 3 is returned. It can be proven that there is no longer path that satisfies the conditions. Example 2: . ![](../../assets/images/ds/160_example_1_1.png) Input: parent = [-1,0,0,0], s = \"aabc\" Output: 3 Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -&gt; 0 -&gt; 3. The length of this path is 3, so 3 is returned. Constraints: . | n == parent.length == s.length | 1 &lt;= n &lt;= 10^5 | 0 &lt;= parent[i] &lt;= n - 1 for all i &gt;= 1 | parent[0] == -1 | parent represents a valid tree. | s consists of only lowercase English letters. | . Solution: . class Solution { int longestPath = 1; public int longestPath(int[] parent, String s) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); for(int i = 1; i &lt; parent.length; i++){ adj.computeIfAbsent(parent[i], value -&gt; new ArrayList&lt;&gt;()).add(i); } dfsComputeLongestPath(0, adj, s.toCharArray()); return longestPath; } private int dfsComputeLongestPath(int node, Map&lt;Integer, List&lt;Integer&gt;&gt; childs, char[] s){ // If the node is the only child, return 1 for the currentNode itself. if(!childs.containsKey(node)) return 1; int longestChain = 0, secondLongestChain = 0; for(int child : childs.get(node)){ int longestChainStartingFromChild = dfsComputeLongestPath(child, childs, s); if(s[child] == s[node]) continue; if(longestChainStartingFromChild &gt; longestChain){ secondLongestChain = longestChain; longestChain = longestChainStartingFromChild; }else if(longestChainStartingFromChild &gt; secondLongestChain){ secondLongestChain = longestChainStartingFromChild; } } // Add \"1\" for the node itself. longestPath = Math.max(longestPath, longestChain + secondLongestChain + 1); return longestChain + 1; } } . ",
    "url": "https://1001anjan.github.io/problem-165-Longest%20Path%20With%20Different%20Adjacent%20Characters/",
    "relUrl": "/problem-165-Longest Path With Different Adjacent Characters/"
  },"241": {
    "doc": "Sum of Root To Leaf Binary Numbers",
    "title": "Sum of Root To Leaf Binary Numbers",
    "content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer. Example 1: . Input: root = [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 . Example 2: . Input: root = [0] Output: 0 . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | Node.val is 0 or 1. | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int leafSum; public int sumRootToLeaf(TreeNode root) { this.leafSum = 0; inorderTraverse(root,0); return this.leafSum; } public void inorderTraverse(TreeNode head, int currSum){ if(head != null){ if(head.left == null &amp;&amp; head.right == null){ leafSum += currSum &lt;&lt; 1 | head.val; } currSum = currSum &lt;&lt; 1 | head.val; inorderTraverse(head.left,currSum); inorderTraverse(head.right,currSum); } } } . Morris Preorder Traversal. The idea of Morris preorder traversal is simple: to use no space but to traverse the tree. Must check: https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/ . ",
    "url": "https://1001anjan.github.io/problem-165-Sum-of-Root-To-Leaf-Binary-Numbers/",
    "relUrl": "/problem-165-Sum-of-Root-To-Leaf-Binary-Numbers/"
  },"242": {
    "doc": "Divisor Game",
    "title": "Divisor Game",
    "content": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player’s turn, that player makes a move consisting of: . | Choosing any x with 0 &lt; x &lt; n and n % x == 0. | Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. | . Return true if and only if Alice wins the game, assuming both players play optimally. Example 1: . Input: n = 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves. Example 2: . Input: n = 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves. Constraints: . | 1 &lt;= n &lt;= 1000 | . Solution: . class Solution { public boolean divisorGame(int n) { return n%2 == 0; } } . ",
    "url": "https://1001anjan.github.io/problem-166-Divisor-Game/",
    "relUrl": "/problem-166-Divisor-Game/"
  },"243": {
    "doc": "Path Sum III",
    "title": "Path Sum III",
    "content": "Given the root of a binary tree and an integer targetSum, return the number of paths where the sum of the values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes). Example 1: . Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8 Output: 3 Explanation: The paths that sum to 8 are shown. Example 2: . Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: 3 . Constraints: . | The number of nodes in the tree is in the range [0, 1000]. | -10^9 &lt;= Node.val &lt;= 10^9 | -1000 &lt;= targetSum &lt;= 1000 | . Solution: . Complexity: . | Space: O(n) due to recursion. | Time: O(n^2) ```java /** | Definition for a binary tree node. | public class TreeNode { | int val; | TreeNode left; | TreeNode right; | TreeNode() {} | TreeNode(int val) { this.val = val; } | TreeNode(int val, TreeNode left, TreeNode right) { | this.val = val; | this.left = left; | this.right = right; | } | } */ class Solution { public int pathSum(TreeNode root, int targetSum) { if(root == null) return 0; return dfsSum(root, targetSum) + pathSum(root.left, targetSum) + pathSum(root.right, targetSum); } . private int dfsSum(TreeNode node, long sum){ if(node == null) return 0; return (node.val == sum ? 1 : 0) + dfsSum(node.left, sum - node.val) + dfsSum(node.right, sum - node.val); } } . ```java class Solution { int count; public int pathSum(TreeNode root, int targetSum) { count= 0; List&lt;Integer&gt; l1= new ArrayList&lt;&gt;(); preorder(root, targetSum, 0, l1); return count; } public void preorder(TreeNode root, int targetSum, long temp, List&lt;Integer&gt; l1){ if(root == null){ return; } // temp+= root.val; l1.add(root.val); preorder(root.left, targetSum, temp, l1); preorder(root.right, targetSum, temp, l1); for(int i= l1.size()-1; i&gt;=0; i--){ temp+= l1.get(i); if(temp == targetSum){ count++; } } // Backtracking (restoring the previous condition) l1.remove(l1.size()-1); } } . | . ",
    "url": "https://1001anjan.github.io/problem-166-Path%20Sum%20III/",
    "relUrl": "/problem-166-Path Sum III/"
  },"244": {
    "doc": "Find All Duplicates in an Array",
    "title": "Find All Duplicates in an Array",
    "content": "Given an integer array nums of length n where all the integers of nums are in the range [1, n] and each integer appears once or twice, return an array of all the integers that appears twice. You must write an algorithm that runs in O(n) time and uses only constant extra space. Example 1: . Input: nums = [4,3,2,7,8,2,3,1] Output: [2,3] . Example 2: . Input: nums = [1,1,2] Output: [1] . Example 3: . Input: nums = [1] Output: [] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 10^5 | 1 &lt;= nums[i] &lt;= n | Each element in nums appears once or twice. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-167-Find%20All%20Duplicates%20in%20an%20Array/",
    "relUrl": "/problem-167-Find All Duplicates in an Array/"
  },"245": {
    "doc": "Valid Boomerang",
    "title": "Valid Boomerang",
    "content": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang. A boomerang is a set of three points that are all distinct and not in a straight line. Example 1: . Input: points = [[1,1],[2,3],[3,2]] Output: true . Example 2: . Input: points = [[1,1],[2,2],[3,3]] Output: false . Constraints: . | points.length == 3 | points[i].length == 2 | 0 &lt;= xi, yi &lt;= 100 | . Solution: Area of a triangle . class Solution { public boolean isBoomerang(int[][] points) { double a, b, c, d, area; a=points[0][0]-points[1][0]; b=points[1][0]-points[2][0]; c=points[0][1]-points[1][1]; d=points[1][1]-points[2][1]; area=0.5*((a*d)-(b*c)); return area!=0; } } . ",
    "url": "https://1001anjan.github.io/problem-167-Valid-Boomerang/",
    "relUrl": "/problem-167-Valid-Boomerang/"
  },"246": {
    "doc": "Last Stone Weight",
    "title": "Last Stone Weight",
    "content": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: . | If x == y, both stones are destroyed, and | If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. | . Return the weight of the last remaining stone. If there are no stones left, return 0. Example 1: . Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. Example 2: . Input: stones = [1] Output: 1 . Constraints: . | 1 &lt;= stones.length &lt;= 30 | 1 &lt;= stones[i] &lt;= 1000 | . Solution: . class Solution { public int lastStoneWeight(int[] stones) { Queue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for(int n : stones) q.add(n); while(q.size() &gt; 1){ int x = q.poll(); int y = q.poll(); if(x != y) q.add(Math.abs(x - y)); } if(q.size() == 0) return 0; return q.poll(); } } . ",
    "url": "https://1001anjan.github.io/problem-168-Last-Stone-Weight/",
    "relUrl": "/problem-168-Last-Stone-Weight/"
  },"247": {
    "doc": "Subarray Sums Divisible by K",
    "title": "Subarray Sums Divisible by K",
    "content": "Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k. A subarray is a contiguous part of an array. Example 1: . Input: nums = [4,5,0,-2,-3,1], k = 5 Output: 7 Explanation: There are 7 subarrays with a sum divisible by k = 5: [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] . Example 2: . Input: nums = [5], k = 9 Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 3 * 10^4 | -10^4 &lt;= nums[i] &lt;= 10^4 | 2 &lt;= k &lt;= 10^4 | . Solution: . Time Limit Exceeded. Time Complexity O(n^2), Space Complexity: O(n) . class Solution { public int subarraysDivByK(int[] nums, int k) { int[] dp = new int[nums.length + 1]; int sum = 0; dp[0] = 0; for(int i = 0; i &lt; nums.length; i++){ sum += nums[i]; dp[i + 1] = sum; } // int count = 0; for(int i = 0; i &lt; dp.length; i++){ for(int j = i + 1; j &lt; dp.length; j++){ if((dp[j] - dp[i]) % k == 0) count++; } } return count; } } . Improvement . when (dp[j] - dp[i]) % k = 0 means dp[j] % k = dp[i] % k here dp[i] means prefix sum 0 to i. class Solution { public int subarraysDivByK(int[] nums, int k) { // There are k mod groups 0...k-1. int[] reminder = new int[k]; int prefixSum = 0; reminder[0] = 1; int count = 0; for(int n : nums){ prefixSum += n; // Take modulo twice to avoid negative remainders. int r = (prefixSum % k + k) % k; count += reminder[r]; reminder[r] ++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-168-Subarray%20Sums%20Divisible%20by%20K/",
    "relUrl": "/problem-168-Subarray Sums Divisible by K/"
  },"248": {
    "doc": "Non-decreasing Subsequences",
    "title": "Non-decreasing Subsequences",
    "content": "Given an integer array nums, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order. Example 1: . Input: nums = [4,6,7,7] Output: [[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]] . Example 2: . Input: nums = [4,4,3,2,1] Output: [[4,4]] . Constraints: . | 1 &lt;= nums.length &lt;= 15 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; ans = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length - 1; i++){ processSubsequences(i, nums, ans, new ArrayList&lt;&gt;()); } return new ArrayList&lt;&gt;(ans); } private void processSubsequences(int start, int[] nums, Set&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ list.add(nums[start]); if(list.size() &gt; 1){ ans.add(new ArrayList&lt;&gt;(list)); } for(int i = start + 1; i &lt; nums.length; i++){ if(nums[start] &lt;= nums[i]){ processSubsequences(i, nums, ans, list); list.remove(list.size() - 1); } } } } . Complexity Analysis: . The total number of subsequences (including the empty one) of an array numsnumsnums is 2^n. In the worst case, we may check all of them. | Time Complexity: O(2^n * n) | Space Complexity: O(2^n) | . ",
    "url": "https://1001anjan.github.io/problem-169-Non-decreasing%20Subsequences/",
    "relUrl": "/problem-169-Non-decreasing Subsequences/"
  },"249": {
    "doc": "Remove All Adjacent Duplicates In String",
    "title": "Remove All Adjacent Duplicates In String",
    "content": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. Example 1: . Input: s = \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Example 2: . Input: s = \"azxxzy\" Output: \"ay\" . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of lowercase English letters. | . Solution: . class Solution { public String removeDuplicates(String s) { StringBuilder sb = new StringBuilder(); sb.append(s.charAt(0)); for(int i=1; i&lt;s.length(); i++){ if(sb.length()&gt;0 &amp;&amp; sb.charAt(sb.length()-1) == s.charAt(i)){ // sb.delete(sb.length()-1, sb.length()); sb.deleteCharAt(sb.length()-1); }else{ sb.append(s.charAt(i)); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-169-Remove-All-Adjacent-Duplicates-In-String/",
    "relUrl": "/problem-169-Remove-All-Adjacent-Duplicates-In-String/"
  },"250": {
    "doc": "Next Permutation",
    "title": "Next Permutation",
    "content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order. | For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). | For example, the next permutation of arr = [1,2,3] is [1,3,2]. | Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. | While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. | Given an array of integers nums, find the next permutation of nums. | . The replacement must be in place and use only constant extra memory. Example 1: . Input: nums = [1,2,3] Output: [1,3,2] . Example 2: . Input: nums = [3,2,1] Output: [1,2,3] . Example 3: . Input: nums = [1,1,5] Output: [1,5,1] . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public void nextPermutation(int[] nums) { int i = nums.length - 2; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1] ) i --; if(i &gt;= 0){ int j = nums.length - 1; while(j &gt;=0 &amp;&amp; nums[i] &gt;= nums[j]) j--; swap(nums, i, j); } reverse(nums, i + 1); } public void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } public void reverse(int[] nums, int i){ int j = nums.length - 1; while(i &lt; j)swap(nums, i ++, j --); } } . ",
    "url": "https://1001anjan.github.io/problem-17-Next%20Permutation/",
    "relUrl": "/problem-17-Next Permutation/"
  },"251": {
    "doc": "Remove Duplicates from Sorted Linked List",
    "title": "Remove Duplicates from Sorted List",
    "content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. Example 1 . Input: head = [1,1,2] Output: [1,2] . Example 2 . Input: head = [1,1,2,3,3] Output: [1,2,3] . Constraints: . | The number of nodes in the list is in the range [0, 300]. | -100 &lt;= Node.val &lt;= 100 | The list is guaranteed to be sorted in ascending order. | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null ) return head; ListNode res, ptr, rem; // create first node res = ptr = head; int currVal = head.val; head = head.next; res.next = null; while(head != null){ if(head.val == currVal){ rem = head; head = head.next; rem.next = null; }else{ ptr.next = head; ptr = ptr.next; head = head.next; ptr.next = null; currVal = ptr.val; } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-17-remove-duplicates-from-sorted-list/#remove-duplicates-from-sorted-list",
    "relUrl": "/problem-17-remove-duplicates-from-sorted-list/#remove-duplicates-from-sorted-list"
  },"252": {
    "doc": "Remove Duplicates from Sorted Linked List",
    "title": "Remove Duplicates from Sorted Linked List",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-17-remove-duplicates-from-sorted-list/",
    "relUrl": "/problem-17-remove-duplicates-from-sorted-list/"
  },"253": {
    "doc": "Height Checker",
    "title": "Height Checker",
    "content": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. Example 1: . Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2: . Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3: . Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints: . | 1 &lt;= heights.length &lt;= 100 | 1 &lt;= heights[i] &lt;= 100 | . Solution: . class Solution { public int heightChecker(int[] heights) { Queue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;(); for(int n : heights) q.add(n); int count = 0; for(int n : heights) if(q.poll() != n) count++; return count; } } . ",
    "url": "https://1001anjan.github.io/problem-170-Height-Checker/",
    "relUrl": "/problem-170-Height-Checker/"
  },"254": {
    "doc": "Network Delay Time",
    "title": "Network Delay Time",
    "content": "You are given a network of n nodes, labeled from 1 to n. You are also given times, a list of travel times as directed edges times[i] = (ui, vi, wi), where ui is the source node, vi is the target node, and wi is the time it takes for a signal to travel from source to target. We will send a signal from a given node k. Return the minimum time it takes for all the n nodes to receive the signal. If it is impossible for all the n nodes to receive the signal, return -1. Example 1: . Input: times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2 Output: 2 . Example 2: . Input: times = [[1,2,1]], n = 2, k = 1 Output: 1 . Example 3: . Input: times = [[1,2,1]], n = 2, k = 2 Output: -1 . Constraints: . | 1 &lt;= k &lt;= n &lt;= 100 | 1 &lt;= times.length &lt;= 6000 | times[i].length == 3 | 1 &lt;= ui, vi &lt;= n | ui != vi | 0 &lt;= wi &lt;= 100 | All the pairs (ui, vi) are unique. (i.e., no multiple edges.) | . Solution: . class Solution { public int networkDelayTime(int[][] times, int n, int k) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; weight = new HashMap&lt;&gt;(); int[] dp = new int[n + 1]; Arrays.fill(dp, 1000); for(int[] arr : times){ adj.computeIfAbsent(arr[0], value -&gt; new ArrayList&lt;&gt;()).add(arr[1]); weight.put(arr[0]+\"*\"+arr[1], arr[2]); } Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.offer(k); dp[k] = 0; while(!q.isEmpty()){ int node = q.poll(); if(!adj.containsKey(node)) continue; for(int child : adj.get(node)){ String path = node+\"*\"+child; int arrTime = dp[node] + weight.get(path); if(dp[child] &gt; arrTime){ dp[child] = arrTime; q.offer(child); } } } int max = -1; for(int i = 1; i &lt; dp.length; i++){ max = Math.max(max, dp[i]); } return max == 1000? -1: max; } } . Same BFS approach but improved in the String operation . class Solution { // Adjacency list Map&lt;Integer, List&lt;Pair&lt;Integer, Integer&gt;&gt;&gt; adj = new HashMap&lt;&gt;(); private void BFS(int[] signalReceivedAt, int sourceNode) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); q.add(sourceNode); // Time for starting node is 0 signalReceivedAt[sourceNode] = 0; while (!q.isEmpty()) { int currNode = q.remove(); if (!adj.containsKey(currNode)) { continue; } // Broadcast the signal to adjacent nodes for (Pair&lt;Integer, Integer&gt; edge : adj.get(currNode)) { int time = edge.getKey(); int neighborNode = edge.getValue(); // Fastest signal time for neighborNode so far // signalReceivedAt[currNode] + time : // time when signal reaches neighborNode int arrivalTime = signalReceivedAt[currNode] + time; if (signalReceivedAt[neighborNode] &gt; arrivalTime) { signalReceivedAt[neighborNode] = arrivalTime; q.add(neighborNode); } } } } public int networkDelayTime(int[][] times, int n, int k) { // Build the adjacency list for (int[] time : times) { int source = time[0]; int dest = time[1]; int travelTime = time[2]; adj.putIfAbsent(source, new ArrayList&lt;&gt;()); adj.get(source).add(new Pair(travelTime, dest)); } int[] signalReceivedAt = new int[n + 1]; Arrays.fill(signalReceivedAt, Integer.MAX_VALUE); BFS(signalReceivedAt, k); int answer = Integer.MIN_VALUE; for (int i = 1; i &lt;= n; i++) { answer = Math.max(answer, signalReceivedAt[i]); } // INT_MAX signifies atleat one node is unreachable return answer == Integer.MAX_VALUE ? -1 : answer; } } . ",
    "url": "https://1001anjan.github.io/problem-170-Network%20Delay%20Time/",
    "relUrl": "/problem-170-Network Delay Time/"
  },"255": {
    "doc": "Unique Number of Occurrences",
    "title": "Unique Number of Occurrences",
    "content": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise. Example 1: . Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: . Input: arr = [1,2] Output: false . Example 3: . Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true . Constraints: . | 1 &lt;= arr.length &lt;= 1000 | -1000 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean uniqueOccurrences(int[] arr) { Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr){ m.put(n,m.getOrDefault(n,0) + 1); } int prev = Integer.MAX_VALUE; for(int n : m.values().stream().sorted().collect(Collectors.toList())){ if(prev == n) return false; prev = n; } return true; } } . Extra Memory but Time Complexity O(n) . class Solution { public boolean uniqueOccurrences(int[] arr) { Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr){ m.put(n,m.getOrDefault(n,0) + 1); } Set&lt;Integer&gt; s = new HashSet(); for(int n : m.values()) s.add(n); return s.size() == m.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-171-Unique-Number-of-Occurrences/",
    "relUrl": "/problem-171-Unique-Number-of-Occurrences/"
  },"256": {
    "doc": "Minimum Absolute Difference",
    "title": "Minimum Absolute Difference",
    "content": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows . | a, b are from arr | a &lt; b | b - a equals to the minimum absolute difference of any two elements in arr | . Example 1: . Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2: . Input: arr = [1,3,6,10,15] Output: [[1,3]] . Example 3: . Input: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]] . Constraints: . | 2 &lt;= arr.length &lt;= 105 | -106 &lt;= arr[i] &lt;= 106 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(int[] arr) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; for(int i = 1; i&lt;arr.length; i++) if(arr[i] - arr[i-1] &lt; diff) diff = arr[i] - arr[i-1]; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; arr.length; i++){ for(int j = i + 1; j &lt; arr.length; j++){ if(arr[j] - arr[i] == diff){ ans.add((Arrays.asList(new Integer[]{arr[i],arr[j]}))); }else if(arr[j] - arr[i] &gt; diff) break; } } return ans; } } . https://leetcode.com/problems/minimum-absolute-difference/solution/ . ",
    "url": "https://1001anjan.github.io/problem-172-Minimum-Absolute-Difference/",
    "relUrl": "/problem-172-Minimum-Absolute-Difference/"
  },"257": {
    "doc": "Maximum Number of Balloons",
    "title": "Maximum Number of Balloons",
    "content": "Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. Example 1: . Input: text = \"nlaebolko\" Output: 1 . Example 2: . Input: text = \"loonbalxballpoon\" Output: 2 . Example 3: . Input: text = \"leetcode\" Output: 0 . Constraints: . | 1 &lt;= text.length &lt;= 104 | text consists of lower case English letters only. | . Solution: . class Solution { public int maxNumberOfBalloons(String text) { Map&lt;Character,Integer&gt; m = new HashMap&lt;&gt;(); for(char c : text.toCharArray()) if(c == 'b' || c == 'a' || c == 'n' || c == 'l' || c == 'o') m.put(c,m.getOrDefault(c,0)+1); if(m.size() != 5) return 0; int max = m.get('b'); for(char c : m.keySet()){ if(c == 'l' || c == 'o') max = Math.min(max, m.get(c)/2); else max = Math.min(max, m.get(c)); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-173-Maximum-Number-of-Balloons/",
    "relUrl": "/problem-173-Maximum-Number-of-Balloons/"
  },"258": {
    "doc": "Distance Between Bus Stops",
    "title": "Distance Between Bus Stops",
    "content": "A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n. The bus goes along both directions i.e. clockwise and counterclockwise. Return the shortest distance between the given start and destination stops. Example 1: . Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1. Example 2: . Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3. Example 3: . Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4. Constraints: . | 1 &lt;= n &lt;= 10^4 | distance.length == n | 0 &lt;= start, destination &lt; n | 0 &lt;= distance[i] &lt;= 10^4 | . Solution: . class Solution { public int distanceBetweenBusStops(int[] distance, int start, int destination) { int dist = 0; int sum = 0; if(start &gt; destination){ int t = destination; destination = start; start = t; } for(int i = 0; i&lt;distance.length; i++){ sum += distance[i]; if(i &gt;= start &amp;&amp; i &lt; destination) dist += distance[i]; } System.out.println(dist); return Math.min(dist,sum-dist); } } . ",
    "url": "https://1001anjan.github.io/problem-174-Distance-Between-Bus-Stops/",
    "relUrl": "/problem-174-Distance-Between-Bus-Stops/"
  },"259": {
    "doc": "Find Words That Can Be Formed by Characters",
    "title": "Find Words That Can Be Formed by Characters",
    "content": "You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words. Example 1: . Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" Output: 6 Explanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6. Example 2: . Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" Output: 10 Explanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10. Constraints: . | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length, chars.length &lt;= 100 | words[i] and chars consist of lowercase English letters. | . Solution: . class Solution { public int countCharacters(String[] words, String chars) { int total = 0; int[] count = new int[26]; for(char c : chars.toCharArray()) count[c-'a']++; for(String str : words){ int[] temp = new int[26]; for(char c : str.toCharArray()) temp[c-'a']++; int i = 0; for(; i &lt; 26; i++) if(count[i]&lt;temp[i]) break; if(i == 26) total += str.length(); } return total; } } . ",
    "url": "https://1001anjan.github.io/problem-175-Distance-Between-Bus-Stops/",
    "relUrl": "/problem-175-Distance-Between-Bus-Stops/"
  },"260": {
    "doc": "N-th Tribonacci Number",
    "title": "N-th Tribonacci Number",
    "content": "The Tribonacci sequence Tn is defined as follows: . T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn. Example 1: . Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 . Example 2: . Input: n = 25 Output: 1389537 . Constraints: . | 0 &lt;= n &lt;= 37 | The answer is guaranteed to fit within a 32-bit integer, ie. answer &lt;= 2^31 - 1. | . Solution: . class Solution { public int tribonacci(int n) { int[] m = new int[38]; return tribonacci(n,m); } public int tribonacci(int n, int[] m) { if(n == 0) return 0; if(n == 1) return 1; if(n == 2) return 1; int t1, t2, t3; if(m[n-1] == 0) t1 = tribonacci(n-1, m); else t1 = m[n-1]; if(m[n-2] == 0) t2 = tribonacci(n-2, m); else t2 = m[n-2]; if(m[n-3] == 0) t3 = tribonacci(n-3, m); else t3 = m[n-3]; m[n] = t1 + t2 + t3; return m[n]; } } . ",
    "url": "https://1001anjan.github.io/problem-176-N-th-Tribonacci-Number/",
    "relUrl": "/problem-176-N-th-Tribonacci-Number/"
  },"261": {
    "doc": "Number of Equivalent Domino Pairs",
    "title": "Number of Equivalent Domino Pairs",
    "content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j]. Example 1: . Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1 . Example 2: . Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]] Output: 3 . Constraints: . | 1 &lt;= dominoes.length &lt;= 4 * 104 | dominoes[i].length == 2 | 1 &lt;= dominoes[i][j] &lt;= 9 | . Solution: . class Solution { public int numEquivDominoPairs(int[][] dominoes) { int count = 0; Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int i = 0; i &lt; dominoes.length ; i++){ int max = Math.max(dominoes[i][0],dominoes[i][1]); int min = Math.min(dominoes[i][0],dominoes[i][1]); int key = max*10 + min; count += m.getOrDefault(key,0); m.put(key, m.getOrDefault(key,0)+1); } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-177-Number-of-Equivalent-Domino-Pairs/",
    "relUrl": "/problem-177-Number-of-Equivalent-Domino-Pairs/"
  },"262": {
    "doc": "Relative Sort Array",
    "title": "Relative Sort Array",
    "content": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order. Example 1: . Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] . Example 2: . Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] . Constraints: . | 1 &lt;= arr1.length, arr2.length &lt;= 1000 | 0 &lt;= arr1[i], arr2[i] &lt;= 1000 | All the elements of arr2 are distinct. | Each arr2[i] is in arr1. | . Solution: . class Solution { public int[] relativeSortArray(int[] arr1, int[] arr2) { Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;(); int[] ans = new int[arr1.length]; Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr1) m.put(n,m.getOrDefault(n,0)+1); int i = 0; for(int n : arr2){ s.add(n); for(int j = 1; j&lt;= m.get(n); j++) ans[i++] = n; } Arrays.sort(arr1); for(int n : arr1){ if(!s.contains(n)) ans[i++] = n; } return ans; } } . Time-complexity O(n) . class Solution{ public int[] relativeSortArray(int[] arr1, int[] arr2) { int j=0; int[] freq=new int[100000]; int[] ans=new int[arr1.length]; for(int i:arr1){ freq[i]++; } for(int i:arr2){ while(freq[i]!=0){ ans[j++]=i; freq[i]--; } } for(int i=0;i&lt;freq.length;i++){ while(freq[i]!=0){ ans[j++]=i; freq[i]--; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-178-Relative-Sort-Array/",
    "relUrl": "/problem-178-Relative-Sort-Array/"
  },"263": {
    "doc": "Print in Order",
    "title": "Print in Order",
    "content": "Suppose we have a class: . public class Foo { public void first() { print(\"first\"); } public void second() { print(\"second\"); } public void third() { print(\"third\"); } } . The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second(). Note: . We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests’ comprehensiveness. Example 1: . Input: nums = [1,2,3] Output: \"firstsecondthird\" Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output. Example 2: . Input: nums = [1,3,2] Output: \"firstsecondthird\" Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output. Constraints: . | nums is a permutation of [1, 2, 3]. | . Solution: . class Foo { private boolean first = false; private boolean second = false; private boolean third = false; public Foo(){ } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs \"first\". Do not change or remove this line. printFirst.run(); first = true; } public void second(Runnable printSecond) throws InterruptedException { while (!this.first) { try { Thread.sleep(1); } catch (InterruptedException e) { } } // printSecond.run() outputs \"second\". Do not change or remove this line. printSecond.run(); this.second = true; } public void third(Runnable printThird) throws InterruptedException { while (!this.second) { try { Thread.sleep(1); } catch (InterruptedException e) { } } // printThird.run() outputs \"third\". Do not change or remove this line. printThird.run(); } } . ",
    "url": "https://1001anjan.github.io/problem-179-Print-in-Order/",
    "relUrl": "/problem-179-Print-in-Order/"
  },"264": {
    "doc": "Merge Sorted Array",
    "title": "Merge Sorted Array",
    "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: . Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: . Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: . Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: . | nums1.length == m + n | nums2.length == n | 0 &lt;= m, n &lt;= 200 | 1 &lt;= m + n &lt;= 200 | -109 &lt;= nums1[i], nums2[j] &lt;= 109 | . Solution . class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { if(n == 0) return; int i = m + n - 1; n --; m --; while(n &gt;= 0){ if(m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]){ nums1[i] = nums1[m]; m--; }else{ nums1[i] = nums2[n]; n --; } i --; } } } . ",
    "url": "https://1001anjan.github.io/problem-18-merge-sorted-array/",
    "relUrl": "/problem-18-merge-sorted-array/"
  },"265": {
    "doc": "Valid Sudoku",
    "title": "Valid Sudoku",
    "content": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: . Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: . | A Sudoku board (partially filled) could be valid but is not necessarily solvable. | Only the filled cells need to be validated according to the mentioned rules. | . Example 1: . Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true . Example 2: . Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: . | board.length == 9 | board[i].length == 9 | board[i][j] is a digit 1-9 or ‘.’. | . Solution: . class Solution { public boolean isValidSudoku(char[][] board) { Set&lt;Character&gt; row = new HashSet&lt;&gt;(); Set&lt;Character&gt; col = new HashSet&lt;&gt;(); Set&lt;Character&gt; cube = new HashSet&lt;&gt;(); for(int i = 0; i &lt; 9; i++){ row.clear(); col.clear(); cube.clear(); for(int j = 0; j &lt; 9; j++){ if(board[i][j] != '.' &amp;&amp; !row.add(board[i][j])) return false; if(board[j][i] != '.' &amp;&amp; !col.add(board[j][i])) return false; int ci = 3*(i/3) + (j/3); int cj = 3*(i%3) + (j%3); if(board[ci][cj] != '.' &amp;&amp; !cube.add(board[ci][cj])) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-18-Valid%20Sudoku/",
    "relUrl": "/problem-18-Valid Sudoku/"
  },"266": {
    "doc": "Defanging an IP Address",
    "title": "Defanging an IP Address",
    "content": "Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period “.” with “[.]”. Example 1: . Input: address = \"1.1.1.1\" Output: \"1[.]1[.]1[.]1\" . Example 2: . Input: address = \"255.100.50.0\" Output: \"255[.]100[.]50[.]0\" . Constraints: . | The given address is a valid IPv4 address. | . Solution: . class Solution { public String defangIPaddr(String address) { StringBuilder sb = new StringBuilder(); for(char c : address.toCharArray()){ if(c == '.') sb.append(\"[.]\"); else sb.append(String.valueOf(c)); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-180-Defanging-an-IP-Address/",
    "relUrl": "/problem-180-Defanging-an-IP-Address/"
  },"267": {
    "doc": "Distribute Candies to People",
    "title": "Distribute Candies to People",
    "content": "We distribute some number of candies, to a row of n = num_people people in the following way: . We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies. Example 1: . Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. Example 2: . Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. Constraints: . | 1 &lt;= candies &lt;= 10^9 | 1 &lt;= num_people &lt;= 1000 | . Solution: . class Solution { public int[] distributeCandies(int candies, int num_people) { int[] ans = new int[num_people]; int i = 0; int d = 1; while(candies &gt; 0){ ans[i%num_people] += d; i++; candies -= d; d++; if(d&gt;candies){ d=candies; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-181-Distribute-Candies-to-People/",
    "relUrl": "/problem-181-Distribute-Candies-to-People/"
  },"268": {
    "doc": "Duplicate Zeros",
    "title": "Duplicate Zeros",
    "content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: . Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] . Example 2: . Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 9 | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-182-Duplicate-Zeros/",
    "relUrl": "/problem-182-Duplicate-Zeros/"
  },"269": {
    "doc": "Occurrences After Bigram",
    "title": "Occurrences After Bigram",
    "content": "Given two strings first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second. Return an array of all the words third for each occurrence of “first second third”. Example 1: . Input: text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" Output: [\"girl\",\"student\"] . Example 2: . Input: text = \"we will we will rock you\", first = \"we\", second = \"will\" Output: [\"we\",\"rock\"] . Constraints: . | 1 &lt;= text.length &lt;= 1000 | text consists of lowercase English letters and spaces. | All the words in text a separated by a single space. | 1 &lt;= first.length, second.length &lt;= 10 | first and second consist of lowercase English letters. | . Solution: . class Solution { public String[] findOcurrences(String text, String first, String second) { String[] words = text.split(\" \"); ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;(); for( int i = 0; i &lt; words.length - 2; i++){ if(words[i].equals(first) &amp;&amp; words[i+1].equals(second)) ans.add(words[i+2]); } String[] res = new String[ans.size()]; return ans.toArray(res); } } . ",
    "url": "https://1001anjan.github.io/problem-183-Occurrences-After-Bigram/",
    "relUrl": "/problem-183-Occurrences-After-Bigram/"
  },"270": {
    "doc": "Split a String in Balanced Strings",
    "title": "Split a String in Balanced Strings",
    "content": "Balanced strings are those that have an equal quantity of ‘L’ and ‘R’ characters. Given a balanced string s, split it into some number of substrings such that: . Each substring is balanced. Return the maximum number of balanced strings you can obtain. Example 1: . Input: s = \"RLRRLLRLRL\" Output: 4 Explanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'. Example 2: . Input: s = \"RLRRRLLRLL\" Output: 2 Explanation: s can be split into \"RL\", \"RRRLLRLL\", each substring contains same number of 'L' and 'R'. Note that s cannot be split into \"RL\", \"RR\", \"RL\", \"LR\", \"LL\", because the 2nd and 5th substrings are not balanced. Example 3: . Input: s = \"LLLLRRRR\" Output: 1 Explanation: s can be split into \"LLLLRRRR\". Constraints: . | 2 &lt;= s.length &lt;= 1000 | s[i] is either ‘L’ or ‘R’. | s is a balanced string. | . Solution: . class Solution { public int balancedStringSplit(String s) { int count = 0; int c = 0; for(char ch : s.toCharArray()){ if( ch == 'L') count++; else count--; if(count == 0){ c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-184-Split-a-String-in-Balanced-Strings/",
    "relUrl": "/problem-184-Split-a-String-in-Balanced-Strings/"
  },"271": {
    "doc": "String Matching in an Array",
    "title": "String Matching in an Array",
    "content": "Given an array of string words. Return all strings in words which is substring of another word in any order. String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j]. Example 1: . Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"] Output: [\"as\",\"hero\"] Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\". [\"hero\",\"as\"] is also a valid answer. Example 2: . Input: words = [\"leetcode\",\"et\",\"code\"] Output: [\"et\",\"code\"] Explanation: \"et\", \"code\" are substring of \"leetcode\". Example 3: . Input: words = [\"blue\",\"green\",\"bu\"] Output: [] . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 30 | words[i] contains only lowercase English letters. | It’s guaranteed that words[i] will be unique. | . Solution: . class Solution { public List&lt;String&gt; stringMatching(String[] words) { List&lt;String&gt;ans = new ArrayList&lt;&gt;(); for(int i=0; i&lt;words.length; i++){ String s = words[i]; for(int j=0; j&lt;words.length; j++){ if(i == j){ continue; } if(words[j].contains(s)){ ans.add(s); break; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-185-String-Matching-in-an-Array/",
    "relUrl": "/problem-185-String-Matching-in-an-Array/"
  },"272": {
    "doc": "Find Lucky Integer in an Array",
    "title": "Find Lucky Integer in an Array",
    "content": "Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1. Example 1: . Input: arr = [2,2,3,4] Output: 2 Explanation: The only lucky number in the array is 2 because frequency[2] == 2. Example 2: . Input: arr = [1,2,2,3,3,3] Output: 3 Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them. Example 3: . Input: arr = [2,2,2,3,3] Output: -1 Explanation: There are no lucky numbers in the array. Constraints: . | 1 &lt;= arr.length &lt;= 500 | 1 &lt;= arr[i] &lt;= 500 | . Solution: . class Solution { public int findLucky(int[] arr) { int [] count = new int[501]; for(int n : arr) count[n]++; for(int i = 500; i&gt;=1; i--){ if(i == count[i]) return i; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-186-Find-Lucky-Integer-in-an-Array/",
    "relUrl": "/problem-186-Find-Lucky-Integer-in-an-Array/"
  },"273": {
    "doc": "Find the Distance Value Between Two Arrays",
    "title": "Find the Distance Value Between Two Arrays",
    "content": "Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays. | The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where | arr1[i]-arr2[j] | &lt;= d. | . Example 1: . Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 &gt; d=2 |4-9|=5 &gt; d=2 |4-1|=3 &gt; d=2 |4-8|=4 &gt; d=2 For arr1[1]=5 we have: |5-10|=5 &gt; d=2 |5-9|=4 &gt; d=2 |5-1|=4 &gt; d=2 |5-8|=3 &gt; d=2 For arr1[2]=8 we have: |8-10|=2 &lt;= d=2 |8-9|=1 &lt;= d=2 |8-1|=7 &gt; d=2 |8-8|=0 &lt;= d=2 . Example 2: . Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3 Output: 2 . Example 3: . Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6 Output: 1 . Constraints: . | 1 &lt;= arr1.length, arr2.length &lt;= 500 | -1000 &lt;= arr1[i], arr2[j] &lt;= 1000 | 0 &lt;= d &lt;= 100 | . Solution: . class Solution { public int findTheDistanceValue(int[] arr1, int[] arr2, int d) { Arrays.sort(arr2); int count = 0; for(int i=0;i&lt;arr1.length;i++) if(distance(arr2, arr1[i], d)) count++; return count; } public boolean distance(int [] arr, int k, int d) { int start = 0, last = arr.length-1; while(start&lt;=last) { int mid = start + (last - start)/2; int diff = Math.abs(arr[mid] - k); if(diff &lt;= d) return false; else if(arr[mid] &gt; k) last = mid - 1; else start = mid + 1; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-187-Find-the-Distance-Value-Between-Two-Arrays/",
    "relUrl": "/problem-187-Find-the-Distance-Value-Between-Two-Arrays/"
  },"274": {
    "doc": "Shift 2D Grid",
    "title": "Shift 2D Grid",
    "content": "Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: . | Element at grid[i][j] moves to grid[i][j + 1]. | Element at grid[i][n - 1] moves to grid[i + 1][0]. | Element at grid[m - 1][n - 1] moves to grid[0][0]. | Return the 2D grid after applying shift operation k times. | . Example 1: . Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] . Example 2: . Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] . Example 3: . Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m &lt;= 50 | 1 &lt;= n &lt;= 50 | -1000 &lt;= grid[i][j] &lt;= 1000 | 0 &lt;= k &lt;= 100 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) { int[][] ans = new int[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { int newCol = (j + k) % grid[0].length; int newRow = (i + (j + k) / grid[0].length) % grid.length; ans[newRow][newCol] = grid[i][j]; } } return (List) Arrays.asList(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-188-Shift-2D-Grid/",
    "relUrl": "/problem-188-Shift-2D-Grid/"
  },"275": {
    "doc": "Subtract the Product and Sum of Digits of an Integer",
    "title": "Subtract the Product and Sum of Digits of an Integer",
    "content": "Given an integer number n, return the difference between the product of its digits and the sum of its digits. Example 1: . Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 . Example 2: . Input: n = 4421 Output: 21 Explanation: Product of digits = 4 * 4 * 2 * 1 = 32 Sum of digits = 4 + 4 + 2 + 1 = 11 Result = 32 - 11 = 21 . Constraints: . | 1 &lt;= n &lt;= 10^5 | . Solution: . class Solution { public int subtractProductAndSum(int n) { int p = 1; int s = 0; while(n&gt;0){ int d = n%10; p *= d; s += d; n = n/10; } return p - s; } } . ",
    "url": "https://1001anjan.github.io/problem-189-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/",
    "relUrl": "/problem-189-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/"
  },"276": {
    "doc": "Binary Tree Inorder Traversal",
    "title": "Binary Tree Inorder Traversal",
    "content": "Given the root of a binary tree, return the inorder traversal of its nodes’ values. Example 1: . Input: root = [1,null,2,3] Output: [1,3,2] . Example 2: . Input: root = [] Output: [] . Example 3: . Input: root = [1] Output: [1] . Constraints: . | The number of nodes in the tree is in the range [0, 100]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { List&lt;Integer&gt; val = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if(root == null) return new ArrayList&lt;Integer&gt;(); inorderTraversal(root.left); val.add(root.val); inorderTraversal(root.right); return val; } } . ",
    "url": "https://1001anjan.github.io/problem-19-Binary-Tree-Inorder-Traversal/",
    "relUrl": "/problem-19-Binary-Tree-Inorder-Traversal/"
  },"277": {
    "doc": "Count and Say",
    "title": "Count and Say",
    "content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: . | countAndSay(1) = “1” | countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string. | To determine how you “say” a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit. | . For example, the saying and conversion for digit string “3322251”: Given a positive integer n, return the nth term of the count-and-say sequence. Example 1: . Input: n = 1 Output: \"1\" Explanation: This is the base case. Example 2: . Input: n = 4 Output: \"1211\" Explanation: countAndSay(1) = \"1\" countAndSay(2) = say \"1\" = one 1 = \"11\" countAndSay(3) = say \"11\" = two 1's = \"21\" countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" . Constraints: . | 1 &lt;= n &lt;= 30 | . Solution: . class Solution { public String countAndSay(int n) { if(n == 1) return \"1\"; String dp = \"1\"; for(int i = 2; i &lt;= n; i++){ dp = process(n, dp); } return dp; } public String process(int n, String s){ int len = s.length(); StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; len; ){ int c = 0; int j = i; char ch = s.charAt(i); while(j &lt; len){ if(ch == s.charAt(j)){ j++; c++; }else break; } i = j; sb.append(c).append(ch); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-19-Count%20and%20Say/",
    "relUrl": "/problem-19-Count and Say/"
  },"278": {
    "doc": "Element Appearing More Than 25% In Sorted Array",
    "title": "Element Appearing More Than 25% In Sorted Array",
    "content": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. Example 1: . Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 . Example 2: . Input: arr = [1,1] Output: 1 . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public int findSpecialInteger(int[] arr) { int currSum = 1; for(int i = 1; i &lt; arr.length; i++){ if(arr[i-1] == arr[i]) currSum ++; else{ if(currSum &gt; arr.length/4) return arr[i-1]; currSum = 1; } } if(currSum &gt; arr.length/4) return arr[arr.length-1]; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-190-Element-Appearing-More-Than-25%25-In-Sorted-Array/",
    "relUrl": "/problem-190-Element-Appearing-More-Than-25%-In-Sorted-Array/"
  },"279": {
    "doc": "Convert Binary Number in a Linked List to Integer",
    "title": "Convert Binary Number in a Linked List to Integer",
    "content": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list. Example 1: . Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 . Example 2: . Input: head = [0] Output: 0 . Constraints: . | The Linked List is not empty. | Number of nodes will not exceed 30. | Each node’s value is either 0 or 1. | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public int getDecimalValue(ListNode head) { int sum = 0; while(head != null){ sum = sum*2 + head.val; head = head.next; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-191-Convert-Binary-Number-in-a-Linked-List-to-Integer/",
    "relUrl": "/problem-191-Convert-Binary-Number-in-a-Linked-List-to-Integer/"
  },"280": {
    "doc": "Find Numbers with Even Number of Digits",
    "title": "Find Numbers with Even Number of Digits",
    "content": "Given an array nums of integers, return how many of them contain an even number of digits. Example 1: . Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits. Example 2: . Input: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. Constraints: . | 1 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public int findNumbers(int[] nums) { int count = 0; for(int n : nums){ String s = String.valueOf(n); if(s.length()%2 == 0) count++; } return count; } } . Faster execution . class Solution { public int findNumbers(int[] nums) { int result=0; for(int i=0; i &lt; nums.length;i++){ if (CalculateDigitsOfNumber(nums[i])%2 == 0){ result++; } } return result; } public static int CalculateDigitsOfNumber(int Number){ return (int)(Math.log10(Number))+1; } } . ",
    "url": "https://1001anjan.github.io/problem-192-Find-Numbers-with-Even-Number-of-Digits/",
    "relUrl": "/problem-192-Find-Numbers-with-Even-Number-of-Digits/"
  },"281": {
    "doc": "Replace Elements with Greatest Element on Right Side",
    "title": "Replace Elements with The Greatest Element on Right Side",
    "content": "Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array. Example 1: . Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Explanation: - index 0 --&gt; the greatest element to the right of index 0 is index 1 (18). - index 1 --&gt; the greatest element to the right of index 1 is index 4 (6). - index 2 --&gt; the greatest element to the right of index 2 is index 4 (6). - index 3 --&gt; the greatest element to the right of index 3 is index 4 (6). - index 4 --&gt; the greatest element to the right of index 4 is index 5 (1). - index 5 --&gt; there are no elements to the right of index 5, so we put -1. Example 2: . Input: arr = [400] Output: [-1] Explanation: There are no elements to the right of index 0. Constraints: . | 1 &lt;= arr.length &lt;= 104 | 1 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public int[] replaceElements(int[] arr) { int currMax = -1; for(int i = arr.length-1; i&gt;=0; i--){ int t = arr[i]; arr[i] = currMax; if(t&gt;currMax) currMax = t; } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/#replace-elements-with-the-greatest-element-on-right-side",
    "relUrl": "/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/#replace-elements-with-the-greatest-element-on-right-side"
  },"282": {
    "doc": "Replace Elements with Greatest Element on Right Side",
    "title": "Replace Elements with Greatest Element on Right Side",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/",
    "relUrl": "/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/"
  },"283": {
    "doc": "Find N Unique Integers Sum up to Zero",
    "title": "Find N Unique Integers Sum up to Zero",
    "content": "Given an integer n, return any array containing n unique integers such that they add up to 0. Example 1: . Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: . Input: n = 3 Output: [-1,0,1] . Example 3: . Input: n = 1 Output: [0] . Constraints: . | 1 &lt;= n &lt;= 1000 | . Solution: . class Solution { public int[] sumZero(int n) { int[] ans = new int[n]; int k = 1; if(n%2 == 0){ for(int i = 0; i&lt;n; i++){ if(i%2 == 0) ans[i] = k; else{ ans[i] = k*-1; k++; } } }else{ ans[0] = 0; for(int i = 1; i&lt;n; i++){ if(i%2 == 0){ ans[i] = k*-1; k++; } else{ ans[i] = k; } } } return ans; } } . Other . class Solution { public int[] sumZero(int n) { int[] result = new int[n]; int start = (n/2)*-1, end = n/2, i = 0; while (start &lt; end) { result[i] = start; result[n - i - 1] = end; ++start; --end; ++i; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-194-Find-N-Unique-Integers-Sum-up-to-Zero/",
    "relUrl": "/problem-194-Find-N-Unique-Integers-Sum-up-to-Zero/"
  },"284": {
    "doc": "Decrypt String from Alphabet to Integer Mapping",
    "title": "Decrypt String from Alphabet to Integer Mapping",
    "content": "You are given a string s formed by digits and ‘#’. We want to map s to English lowercase characters as follows: . | Characters (‘a’ to ‘i’) are represented by (‘1’ to ‘9’) respectively. | Characters (‘j’ to ‘z’) are represented by (‘10#’ to ‘26#’) respectively. Return the string formed after mapping. | . The test cases are generated so that a unique mapping will always exist. Example 1: . Input: s = \"10#11#12\" Output: \"jkab\" Explanation: \"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\". Example 2: . Input: s = \"1326#\" Output: \"acz\" . Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of digits and the ‘#’ letter. | s will be a valid string such that mapping is always possible. | . Solution: . class Solution { public String freqAlphabets(String s) { StringBuilder sb = new StringBuilder(); for(int i = s.length()-1; i &gt;= 0; i--){ if(s.charAt(i) != '#'){ sb.append(Character.toString(s.charAt(i) + 48 )); }else{ sb.append(Character.toString(Integer.parseInt(s.substring(i-2,i)) + 96)); i -= 2; } } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-195-Decrypt-String-from-Alphabet-to-Integer-Mapping/",
    "relUrl": "/problem-195-Decrypt-String-from-Alphabet-to-Integer-Mapping/"
  },"285": {
    "doc": "Decompress Run-Length Encoded List",
    "title": "Decompress Run-Length Encoded List",
    "content": "We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2i], nums[2i+1]] (with i &gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. Example 1: . Input: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. Example 2: . Input: nums = [1,1,2,3] Output: [1,3,3] . Constraints: . | 2 &lt;= nums.length &lt;= 100 | nums.length % 2 == 0 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] decompressRLElist(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt;= nums.length-2; i = i+2){ while(nums[i] &gt; 0){ ans.add(nums[i+1]); nums[i]--; } } int[] res = new int[ans.size()]; int i = 0; for(int n : ans) res[i++] = n; return res; } } . Faster approach . class Solution { public int[] decompressRLElist(int[] nums) { int size=0; for(int i=0;i&lt;nums.length;i+=2) size+=nums[i]; int arr[] = new int[size]; int j=0; for(int i=0; i&lt;nums.length; i+=2){ while(nums[i]&gt;0){ arr[j] = nums[i+1]; j++; nums[i]--; } } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-196-Decompress-Run-Length-Encoded-List/",
    "relUrl": "/problem-196-Decompress-Run-Length-Encoded-List/"
  },"286": {
    "doc": "Convert Integer to the Sum of Two No-Zero Integers",
    "title": "Convert Integer to the Sum of Two No-Zero Integers",
    "content": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation. Given an integer n, return a list of two integers [A, B] where: . A and B are No-Zero integers. A + B = n The test cases are generated so that there is at least one valid solution. If there are many valid solutions you can return any of them. Example 1: . Input: n = 2 Output: [1,1] Explanation: A = 1, B = 1. A + B = n and both A and B do not contain any 0 in their decimal representation. Example 2: . Input: n = 11 Output: [2,9] . Constraints: . | 2 &lt;= n &lt;= 104 | . Solution: . class Solution { public int[] getNoZeroIntegers(int n) { int s = 1; int e = n-1; while(s&lt;=e){ if(checkNoZeroInteger(s) &amp;&amp; checkNoZeroInteger(e)) return new int[]{s,e}; s++; e--; } throw null; } public boolean checkNoZeroInteger(int n){ while(n&gt;0){ if(n%10 == 0) return false; n = n/10; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-197-Convert-Integer-to-the-Sum-of-Two-No-Zero%20Integers/",
    "relUrl": "/problem-197-Convert-Integer-to-the-Sum-of-Two-No-Zero Integers/"
  },"287": {
    "doc": "Maximum 69 Number",
    "title": "Maximum 69 Number",
    "content": "You are given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). Example 1: . Input: num = 9669 Output: 9969 Explanation: Changing the first digit results in 6669. Changing the second digit results in 9969. Changing the third digit results in 9699. Changing the fourth digit results in 9666. The maximum number is 9969. Example 2: . Input: num = 9996 Output: 9999 Explanation: Changing the last digit 6 to 9 results in the maximum number. Example 3: . Input: num = 9999 Output: 9999 Explanation: It is better not to apply any change. Constraints: . | 1 &lt;= num &lt;= 104 | num consists of only 6 and 9 digits. | . Solution: . class Solution { public int maximum69Number (int num) { String s = String.valueOf(num); StringBuilder sb = new StringBuilder(); boolean f = true; for(char c : s.toCharArray()){ if(c == '6' &amp;&amp; f){ sb.append(\"9\"); f = false; } else sb.append(String.valueOf(c)); } return Integer.parseInt(sb.toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-198-Maximum-69-Number/",
    "relUrl": "/problem-198-Maximum-69-Number/"
  },"288": {
    "doc": "Rank Transform of an Array",
    "title": "Rank Transform of an Array",
    "content": "Given an array of integers arr, replace each element with its rank. The rank represents how large the element is. The rank has the following rules: . Rank is an integer starting from 1. The larger the element, the larger the rank. If two elements are equal, their rank must be the same. Rank should be as small as possible. Example 1: . Input: arr = [40,10,20,30] Output: [4,1,2,3] Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest. Example 2: . Input: arr = [100,100,100] Output: [1,1,1] Explanation: Same elements share the same rank. Example 3: . Input: arr = [37,12,28,9,100,56,80,5,12] Output: [5,3,4,2,8,6,7,1,3] . Constraints: . | 0 &lt;= arr.length &lt;= 105 | -109 &lt;= arr[i] &lt;= 109 | . Solution: . class Solution { public int[] arrayRankTransform(int[] arr) { Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int n : arr) s.add(n); Integer[] temp = new Integer[s.size()]; s.toArray(temp); Arrays.sort(temp); for(int j = 0; j&lt;arr.length; j++){ arr[j] = binarySearch(temp,arr[j]) + 1; } return arr; } public int binarySearch(Integer[] arr, int v){ int s = 0; int e = arr.length - 1; while(s&lt;=e){ int mid = (e+s)/2; if(arr[mid] == v) return mid; if(arr[mid]&gt;v) e = mid - 1; else s = mid + 1; } return -1; } } . Same Time Complexity but faster . class Solution { public int[] arrayRankTransform(int[] arr) { int[]res=new int[arr.length]; for(int i=0;i&lt;arr.length;i++){ res[i]=arr[i]; } Arrays.sort(arr); HashMap&lt;Integer,Integer&gt;h1=new HashMap(); int x=0; for(int i=0;i&lt;arr.length;i++){ if(!h1.containsKey(arr[i])){ x++; h1.put(arr[i],x); } } int ans[]=new int[arr.length]; for(int i=0;i&lt;arr.length;i++){ ans[i]=h1.get(res[i]); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-199-Rank-Transform-of-an-Array/",
    "relUrl": "/problem-199-Rank-Transform-of-an-Array/"
  },"289": {
    "doc": "Add Two Numbers",
    "title": "Add Two Numbers",
    "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: . Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: . Input: l1 = [0], l2 = [0] Output: [0] . Example 3: . Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] . Constraints: . | The number of nodes in each linked list is in the range [1, 100]. | 0 &lt;= Node.val &lt;= 9 | It is guaranteed that the list represents a number that does not have leading zeros. | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode resultList, ptr; int c = 0; // creating first node ListNode newNode = new ListNode((l1.val + l2.val)%10); c = (l1.val + l2.val) / 10; resultList = ptr = newNode; l1 = l1.next; l2 = l2.next; while(l1 != null &amp;&amp; l2 != null){ newNode = new ListNode((l1.val + l2.val + c)%10); c = (l1.val + l2.val + c) / 10; ptr.next = newNode; ptr = newNode; l1 = l1.next; l2 = l2.next; } while(l1 != null){ newNode = new ListNode((l1.val + c)%10); c = (l1.val + c) / 10; ptr.next = newNode; ptr = newNode; l1 = l1.next; } while(l2 != null){ newNode = new ListNode((l2.val + c)%10); c = (l2.val + c) / 10; ptr.next = newNode; ptr = newNode; l2 = l2.next; } if(c &gt; 0){ newNode = new ListNode(c); ptr.next = newNode; } return resultList; } } . ",
    "url": "https://1001anjan.github.io/problem-2-Add%20Two%20Numbers/",
    "relUrl": "/problem-2-Add Two Numbers/"
  },"290": {
    "doc": "Number of Good Paths",
    "title": "Number of Good Paths",
    "content": "There is a tree (i.e. a connected, undirected graph with no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node. You are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi. A good path is a simple path that satisfies the following conditions: . The starting node and the ending node have the same value. All nodes between the starting node and the ending node have values less than or equal to the starting node (i.e. the starting node’s value should be the maximum value along the path). Return the number of distinct good paths. Note that a path and its reverse are counted as the same path. For example, 0 -&gt; 1 is considered to be the same as 1 -&gt; 0. A single node is also considered as a valid path. Example 1: . Input: vals = [1,3,2,1,3], edges = [[0,1],[0,2],[2,3],[2,4]] Output: 6 Explanation: There are 5 good paths consisting of a single node. There is 1 additional good path: 1 -&gt; 0 -&gt; 2 -&gt; 4. (The reverse path 4 -&gt; 2 -&gt; 0 -&gt; 1 is treated as the same as 1 -&gt; 0 -&gt; 2 -&gt; 4.) Note that 0 -&gt; 2 -&gt; 3 is not a good path because vals[2] &gt; vals[0]. Example 2: . Input: vals = [1,1,2,2,3], edges = [[0,1],[1,2],[2,3],[2,4]] Output: 7 Explanation: There are 5 good paths consisting of a single node. There are 2 additional good paths: 0 -&gt; 1 and 2 -&gt; 3. Example 3: . Input: vals = [1], edges = [] Output: 1 Explanation: The tree consists of only one node, so there is one good path. Constraints: . | n == vals.length | 1 &lt;= n &lt;= 3 * 10^4 | 0 &lt;= vals[i] &lt;= 10^5 | edges.length == n - 1 | edges[i].length == 2 | 0 &lt;= ai, bi &lt; n | ai != bi | edges represents a valid tree. | . Solution: . Time Limit Exceeded Time Complexity O(n^2) . class Solution { int count = 0; public int numberOfGoodPaths(int[] vals, int[][] edges) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); for (int[] edge : edges) { adj.computeIfAbsent(edge[0], value -&gt; new ArrayList&lt;Integer&gt;()).add(edge[1]); adj.computeIfAbsent(edge[1], value -&gt; new ArrayList&lt;Integer&gt;()).add(edge[0]); } for(int i = 0; i &lt; vals.length; i++){ dfsCount(i, i, -1, adj, vals); } int ex = (count - vals.length)/2; return vals.length + ex; } private void dfsCount(int start, int node, int parent, Map&lt;Integer, List&lt;Integer&gt;&gt; adj, int[] vals){ if(vals[start] == vals[node]) count ++; if(!adj.containsKey(node)) return; for(int child : adj.get(node)){ if(child == parent) continue; if(vals[start] &gt;= vals[child]) dfsCount(start, child, node, adj, vals); } } } . Leetcode official solution: . link Time Complexity O(nLogN) Space Complexity O(N) . class UnionFind { int[] parent; int[] rank; public UnionFind(int size) { parent = new int[size]; for (int i = 0; i &lt; size; i++) parent[i] = i; rank = new int[size]; } public int find(int x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; } public void union_set(int x, int y) { int xset = find(x), yset = find(y); if (xset == yset) { return; } else if (rank[xset] &lt; rank[yset]) { parent[xset] = yset; } else if (rank[xset] &gt; rank[yset]) { parent[yset] = xset; } else { parent[yset] = xset; rank[xset]++; } } } class Solution { public int numberOfGoodPaths(int[] vals, int[][] edges) { Map&lt;Integer, List&lt;Integer&gt;&gt; adj = new HashMap&lt;&gt;(); for (int[] edge : edges) { int a = edge[0], b = edge[1]; adj.computeIfAbsent(a, value -&gt; new ArrayList&lt;Integer&gt;()).add(b); adj.computeIfAbsent(b, value -&gt; new ArrayList&lt;Integer&gt;()).add(a); } int n = vals.length; // Mapping from value to all the nodes having the same value in sorted order of // values. TreeMap&lt;Integer, List&lt;Integer&gt;&gt; valuesToNodes = new TreeMap&lt;&gt;(); for (int i = 0; i &lt; n; i++) { valuesToNodes.computeIfAbsent(vals[i], value -&gt; new ArrayList&lt;Integer&gt;()).add(i); } UnionFind dsu = new UnionFind(n); int goodPaths = 0; // Iterate over all the nodes with the same value in sorted order, starting from // the lowest value. for (int value : valuesToNodes.keySet()) { // For every node in nodes, combine the sets of the node and its neighbors into // one set. for (int node : valuesToNodes.get(value)) { if (!adj.containsKey(node)) continue; for (int neighbor : adj.get(node)) { // Only choose neighbors with a smaller value, as there is no point in // traversing to other neighbors. if (vals[node] &gt;= vals[neighbor]) { dsu.union_set(node, neighbor); } } } // Map to compute the number of nodes under observation (with the same values) // in each of the sets. Map&lt;Integer, Integer&gt; group = new HashMap&lt;&gt;(); // Iterate over all the nodes. Get the set of each node and increase the count // of the set by 1. for (int u : valuesToNodes.get(value)) { group.put(dsu.find(u), group.getOrDefault(dsu.find(u), 0) + 1); } // For each set of \"size\", add size * (size + 1) / 2 to the number of goodPaths. for (int key : group.keySet()) { int size = group.get(key); goodPaths += size * (size + 1) / 2; } } return goodPaths; } } . ",
    "url": "https://1001anjan.github.io/problem-2-Number%20of%20Good%20Paths/",
    "relUrl": "/problem-2-Number of Good Paths/"
  },"291": {
    "doc": "Palindrome Number",
    "title": "2. Palindrome Number",
    "content": "Given an integer x, return true if x is palindrome integer. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not. Example 1: . Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2: . Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: . Input: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Constraints: . -231 &lt;= x &lt;= 231 - 1 . Solution . class Solution { public boolean isPalindrome(int x) { if(x &lt; 0) return false; int rev = 0; int original = x; while(x &gt; 0){ rev = rev*10 + x%10; x = x/10; } return rev == original? true : false; } } . Complexity Analysis: . | Time complexity : O(log10(n)). We divided the input by 10 for every iteration, so the time complexity is O(log10(n)) . | Space complexity : O(1)O(1). | . ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-2-Palindrome-Number/#2-palindrome-number",
    "relUrl": "/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-2-Palindrome-Number/#2-palindrome-number"
  },"292": {
    "doc": "Palindrome Number",
    "title": "Palindrome Number",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-2-Palindrome-Number/",
    "relUrl": "/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-2-Palindrome-Number/"
  },"293": {
    "doc": "Combination Sum",
    "title": "Combination Sum",
    "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: . Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: . Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] . Example 3: . Input: candidates = [2], target = 1 Output: [] . Constraints: . | 1 &lt;= candidates.length &lt;= 30 | 2 &lt;= candidates[i] &lt;= 40 | All elements of candidates are distinct. | 1 &lt;= target &lt;= 40 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(candidates); for(int i = 0; i &lt; candidates.length; i++){ process(candidates, i, candidates.length - 1, target - candidates[i], ans, new ArrayList&lt;Integer&gt;(Arrays.asList(candidates[i]))); } return ans; } public void process(int[] arr, int currentIndex, int searchIndex, int target, List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; elist){ if(searchIndex &lt; 0) return; if(target == 0){ list.add(elist); } for(int i = searchIndex; i &gt;= currentIndex; i--){ if(target == arr[i]){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(elist); l.add(arr[i]); list.add(l); } if(target &gt; arr[i]){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(elist); l.add(arr[i]); process(arr,currentIndex, i,target - arr[i], list,l); } } } } . public class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { //special case List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(candidates == null || candidates.length == 0) return res; Arrays.sort(candidates); help(res, new ArrayList&lt;Integer&gt;(), target, 0, candidates); return res; } public void help(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp, int target, int start, int [] candidates) { if(target == 0) { res.add(new ArrayList&lt;Integer&gt; (tmp)); return; } else { for(int i = start;i&lt;candidates.length;i++) { if(i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) continue; if(target &gt;= candidates[i]) { tmp.add(new Integer(candidates[i])); help(res, tmp, target - candidates[i],i,candidates); tmp.remove(tmp.size()-1); } } } } } . ",
    "url": "https://1001anjan.github.io/problem-20-Combination%20Sum/",
    "relUrl": "/problem-20-Combination Sum/"
  },"294": {
    "doc": "Same Tree",
    "title": "Same Tree",
    "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1: . Input: p = [1,2,3], q = [1,2,3] Output: true . Example 2 . Input: p = [1,2], q = [1,null,2] Output: false . Example 3: . Input: p = [1,2,1], q = [1,1,2] Output: false . Constraints: . | The number of nodes in both trees is in the range [0, 100]. | -104 &lt;= Node.val &lt;= 104 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q == null) return true; if(p != null &amp;&amp; q == null) return false; if(p == null &amp;&amp; q != null) return false; if(p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); } } . ",
    "url": "https://1001anjan.github.io/problem-20-Same-Tree/",
    "relUrl": "/problem-20-Same-Tree/"
  },"295": {
    "doc": "Remove Palindromic Subsequences",
    "title": "Remove Palindromic Subsequences",
    "content": "You are given a string s consisting only of letters ‘a’ and ‘b’. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward. Example 1: . Input: s = \"ababa\" Output: 1 Explanation: s is already a palindrome, so its entirety can be removed in a single step. Example 2: . Input: s = \"abb\" Output: 2 Explanation: \"abb\" -&gt; \"bb\" -&gt; \"\". Remove palindromic subsequence \"a\" then \"bb\". Example 3: . Input: s = \"baabb\" Output: 2 Explanation: \"baabb\" -&gt; \"b\" -&gt; \"\". Remove palindromic subsequence \"baab\" then \"b\". Constraints: . | 1 &lt;= s.length &lt;= 1000 | s[i] is either ‘a’ or ‘b’. | . Solution: . class Solution { public int removePalindromeSub(String s) { StringBuilder sb = new StringBuilder(); sb.append(s); sb.reverse(); return sb.toString().equals(s) ? 1 : 2; } } . ",
    "url": "https://1001anjan.github.io/problem-200-Remove-Palindromic-Subsequences/",
    "relUrl": "/problem-200-Remove-Palindromic-Subsequences/"
  },"296": {
    "doc": "The K Weakest Rows in a Matrix",
    "title": "The K Weakest Rows in a Matrix",
    "content": "You are given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row. A row i is weaker than a row j if one of the following is true: . | The number of soldiers in row i is less than the number of soldiers in row j. | Both rows have the same number of soldiers and i &lt; j. | Return the indices of the k weakest rows in the matrix ordered from weakest to strongest. | . Example 1: . Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 Output: [2,0,3] Explanation: The number of soldiers in each row is: - Row 0: 2 - Row 1: 4 - Row 2: 1 - Row 3: 2 - Row 4: 5 The rows ordered from weakest to strongest are [2,0,3,1,4]. Example 2: . Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 Output: [0,2] Explanation: The number of soldiers in each row is: - Row 0: 1 - Row 1: 4 - Row 2: 1 - Row 3: 1 The rows ordered from weakest to strongest are [0,2,3,1]. Constraints: . | m == mat.length | n == mat[i].length | 2 &lt;= n, m &lt;= 100 | 1 &lt;= k &lt;= m | matrix[i][j] is either 0 or 1. | . Solution: . class Solution { public int[] kWeakestRows(int[][] mat, int k) { int[] ans = new int[k]; int[][] count = new int[mat.length][2]; for(int i=0; i&lt;mat.length; i++){ count[i][1] = countValueOne(mat[i]); count[i][0] = i; } Arrays.sort(count, (a,b)-&gt;(a[1]-b[1])); for(int i=0; i&lt;k; i++) ans[i] = count[i][0]; return ans; } public int countValueOne(int[] arr){ int count = 0; for(int n: arr){ if(n == 1) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-201-The-K-Weakest-Rows-in-a-Matrix/",
    "relUrl": "/problem-201-The-K-Weakest-Rows-in-a-Matrix/"
  },"297": {
    "doc": "Number of Steps to Reduce a Number to Zero",
    "title": "Number of Steps to Reduce a Number to Zero",
    "content": "Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Example 1: . Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3. Step 4) 3 is odd; subtract 1 and obtain 2. Step 5) 2 is even; divide by 2 and obtain 1. Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: . Input: num = 8 Output: 4 Explanation: Step 1) 8 is even; divide by 2 and obtain 4. Step 2) 4 is even; divide by 2 and obtain 2. Step 3) 2 is even; divide by 2 and obtain 1. Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: . Input: num = 123 Output: 12 . Constraints: . | 0 &lt;= num &lt;= 106 | . Solution: . class Solution { public int numberOfSteps(int n) { int step = 0; while(n&gt;0){ if(n%2 == 0) n = n/2; else n = n -1; step++; } return step; } } . ",
    "url": "https://1001anjan.github.io/problem-202-Number-of-Steps-to-Reduce-a-Number-to-Zero/",
    "relUrl": "/problem-202-Number-of-Steps-to-Reduce-a-Number-to-Zero/"
  },"298": {
    "doc": "Check If N and Its Double Exist",
    "title": "Check If N and Its Double Exist",
    "content": "Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M). More formally check if there exists two indices i and j such that : . | i != j | 0 &lt;= i, j &lt; arr.length | arr[i] == 2 * arr[j] | . Example 1: . Input: arr = [10,2,5,3] Output: true Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5. Example 2: . Input: arr = [7,1,14,11] Output: true Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7. Example 3: . Input: arr = [3,1,7,11] Output: false Explanation: In this case does not exist N and M, such that N = 2 * M. Constraints: . | 2 &lt;= arr.length &lt;= 500 | -10^3 &lt;= arr[i] &lt;= 10^3 | . Solution: . Time Complexity O(nLogN) Space: O(1); . class Solution { public boolean checkIfExist(int[] arr) { Arrays.sort(arr); for(int i = 0; i&lt;arr.length; i++){ if(binarySearch(arr, arr[i]*2, i)) return true; } return false; } public boolean binarySearch(int[] arr, int val, int index){ int s = 0; int e = arr.length - 1; while(s &lt;= e){ int mid = (s + e)/2; if(arr[mid] == val &amp;&amp; index != mid) return true; if(arr[mid] &gt; val) e = mid - 1; else s = mid + 1; } return false; } } . time Complexity: O(n) Space: O(n) . class Solution { public boolean checkIfExist(int[] arr) { HashMap&lt;Double,Integer&gt; map = new HashMap&lt;&gt;(); for(int i:arr) { double temp = i; if(map.containsKey(temp*2)) return true; else if(map.containsKey(temp/2)) return true; map.put(temp,1); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-203-Check-If-N-and-Its-Double-Exist/",
    "relUrl": "/problem-203-Check-If-N-and-Its-Double-Exist/"
  },"299": {
    "doc": "Count Negative Numbers in a Sorted Matrix",
    "title": "Count Negative Numbers in a Sorted Matrix",
    "content": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid. Example 1: . Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] Output: 8 Explanation: There are 8 negatives number in the matrix. Example 2: . Input: grid = [[3,2],[1,0]] Output: 0 . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m, n &lt;= 100 | -100 &lt;= grid[i][j] &lt;= 100 | . Follow up: Could you find an O(n + m) solution? . Solution: . Time Complexity O(m*n) . class Solution { public int countNegatives(int[][] grid) { int count = 0; for(int i = 0; i &lt;grid.length; i++){ for(int j = grid[i].length - 1; j&gt;=0; j--){ if(grid[i][j] &lt; 0) count++; else break; } } return count; } } . Time Complexity O(m*logN) but actually consumed more time than first approach . class Solution { public int countNegatives(int[][] grid) { int count = 0; for(int i = 0; i &lt;grid.length; i++){ if(grid[i][grid[i].length - 1] &lt; 0) count += grid[i].length - binarySearch(grid[i]); System.out.println(count); } return count; } public int binarySearch(int[] arr){ int s = 0; int e = arr.length - 1; while(s &lt;= e){ int mid = (s+e)/2; if(mid == 0 &amp;&amp; arr[mid] &lt; 0) return mid; if(mid == arr.length - 1) return mid; if(mid == 0 &amp;&amp; arr[mid] &gt;= 0) s = mid + 1; else if(arr[mid - 1]&gt;=0 &amp;&amp; arr[mid] &lt; 0) return mid; else if(arr[mid - 1] &lt; 0) e = mid - 1; else s = mid + 1; } throw null; } } . Time Complexity: O(m+n) and much faster . class Solution { public int countNegatives(int[][] grid) { int m = grid.length; int n = grid[0].length; int i = 0; int j = n-1; int count = 0; while(i&lt;=m-1 &amp;&amp; j&gt;=0) { if(grid[i][j] &lt; 0) { count += m-i; j--; }else{ i++; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-204-Count-Negative-Numbers-in-a-Sorted-Matrix/",
    "relUrl": "/problem-204-Count-Negative-Numbers-in-a-Sorted-Matrix/"
  },"300": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "Sort Integers by The Number of 1 Bits",
    "content": "You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order. Return the array after sorting it. Example 1: . Input: arr = [0,1,2,3,4,5,6,7,8] Output: [0,1,2,4,8,3,5,6,7] Explantion: [0] is the only integer with 0 bits. [1,2,4,8] all have 1 bit. [3,5,6] have 2 bits. [7] has 3 bits. The sorted array by bits is [0,1,2,4,8,3,5,6,7] . Example 2: . Input: arr = [1024,512,256,128,64,32,16,8,4,2,1] Output: [1,2,4,8,16,32,64,128,256,512,1024] Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order. Constraints: . | 1 &lt;= arr.length &lt;= 500 | 0 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public int[] sortByBits(int[] arr) { int[][] map = new int[arr.length][2]; for(int i = 0; i &lt; arr.length; i++){ map[i][0] = arr[i]; map[i][1] = countBinaryOne(arr[i]); } Arrays.sort(map, (a,b) -&gt; { if(a[1] == b[1]) return a[0] - b[0]; return a[1] - b[1]; }); for(int i = 0; i &lt; arr.length; i++){ arr[i] = map[i][0]; } return arr; } public int countBinaryOne(int n){ int count = 0; while(n&gt;0){ if((n &amp; 1) == 1) count++; n = n &gt;&gt; 1; } return count; } } . Same time complexity but constant memory and faster execution time . class Solution { public int[] sortByBits(int[] arr) { for ( int i =0 ;i&lt; arr.length ;i++){ arr[i] += Integer.bitCount(arr[i])*10001; } Arrays.sort(arr); for ( int i =0 ;i&lt; arr.length ;i++){ arr[i] = arr[i] %10001; } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-205-Sort-Integers-by-The-Number-of-1-Bits/",
    "relUrl": "/problem-205-Sort-Integers-by-The-Number-of-1-Bits/"
  },"301": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "How Many Numbers Are Smaller Than the Current Number",
    "content": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j’s such that j != i and nums[j] &lt; nums[i]. Return the answer in an array. Example 1: . Input: nums = [8,1,2,2,3] Output: [4,0,1,1,3] Explanation: For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). Example 2: . Input: nums = [6,5,4,8] Output: [2,1,0,3] . Example 3: . Input: nums = [7,7,7,7] Output: [0,0,0,0] . Constraints: . | 2 &lt;= nums.length &lt;= 500 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] smallerNumbersThanCurrent(int[] nums) { int[] temp = Arrays.copyOf(nums,nums.length); Arrays.sort(nums); Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); m.put(nums[0],0); int count = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i-1] != nums[i]){ m.put(nums[i],count); } count++; } for(int i = 0; i &lt; temp.length; i++) nums[i] = m.get(temp[i]); return nums; } } . class Solution { public int[] smallerNumbersThanCurrent(int[] nums) { //initiate an array to keep count of all elements in nums int[] arr = new int[101]; for(int num: nums){ arr[num]++; } //update array by cumulating sum for(int i = 1; i &lt; arr.length; i++){ arr[i] = arr[i] + arr[i-1]; } //change the nums array to number of smaller elements than the current number //the array arr keep count of elements smaller/equals to each index (element), so to find element smaller than current, look at previous index for(int i = 0; i &lt; nums.length; i++){ try{ nums[i] = arr[nums[i]-1]; } catch (ArrayIndexOutOfBoundsException e){ nums[i] = 0; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-206-How%20Many%20Numbers%20Are%20Smaller%20Than%20the%20Current%20Number/#how-many-numbers-are-smaller-than-the-current-number",
    "relUrl": "/problem-206-How Many Numbers Are Smaller Than the Current Number/#how-many-numbers-are-smaller-than-the-current-number"
  },"302": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "Sort Integers by The Number of 1 Bits",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-206-How%20Many%20Numbers%20Are%20Smaller%20Than%20the%20Current%20Number/",
    "relUrl": "/problem-206-How Many Numbers Are Smaller Than the Current Number/"
  },"303": {
    "doc": "Increasing Decreasing String",
    "title": "Increasing Decreasing String",
    "content": "You are given a string s. Reorder the string using the following algorithm: . | Pick the smallest character from s and append it to the result. | Pick the smallest character from s which is greater than the last appended character to the result and append it. | Repeat step 2 until you cannot pick more characters. | Pick the largest character from s and append it to the result. | Pick the largest character from s which is smaller than the last appended character to the result and append it. | Repeat step 5 until you cannot pick more characters. | Repeat the steps from 1 to 6 until you pick all characters from s. | . In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result. Return the result string after sorting s with this algorithm. Example 1: . Input: s = \"aaaabbbbcccc\" Output: \"abccbaabccba\" Explanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\" After steps 4, 5 and 6 of the first iteration, result = \"abccba\" First iteration is done. Now s = \"aabbcc\" and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\" After steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\" . Example 2: . Input: s = \"rat\" Output: \"art\" Explanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters. | . Solution: . class Solution { public String sortString(String s) { int[] map = new int[26]; for(char c : s.toCharArray()) { map[c - 'a']++; } StringBuilder sb = new StringBuilder(); while(sb.length() != s.length()){ for(int i = 0; i &lt; 26; i++){ if(map[i] &gt; 0){ sb.append((char)('a' + i)); map[i]--; } } for(int i = 25; i &gt;= 0; i--){ if(map[i] &gt; 0){ sb.append((char)('a' + i)); map[i]--; } } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-207-Increasing-Decreasing-String/",
    "relUrl": "/problem-207-Increasing-Decreasing-String/"
  },"304": {
    "doc": "Lucky Numbers in a Matrix",
    "title": "Lucky Numbers in a Matrix",
    "content": "Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order. A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column. Example 1: . Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2: . Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3: . Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= n, m &lt;= 50 | 1 &lt;= matrix[i][j] &lt;= 105. | All elements in the matrix are distinct. | . Solution: . class Solution { public List&lt;Integer&gt; luckyNumbers (int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; matrix.length; i++){ // find min value int min = matrix[i][0]; int index = 0; for(int j = 1; j &lt; matrix[i].length; j++){ if(min &gt; matrix[i][j]){ min = matrix[i][j]; index = j; } } // check if (min) is the max value boolean f = true; for(int j = 0; j &lt; matrix.length; j++){ if(min &lt; matrix[j][index]){ f = false; break; } } // add element to the list if(f) ans.add(min); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-208-Lucky-Numbers-in-a-Matrix/",
    "relUrl": "/problem-208-Lucky-Numbers-in-a-Matrix/"
  },"305": {
    "doc": "Minimum Value to Get Positive Step by Step Sum",
    "title": "Minimum Value to Get Positive Step by Step Sum",
    "content": "Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1. Example 1: . Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 . Example 2: . Input: nums = [1,2] Output: 1 Explanation: Minimum start value should be positive. Example 3: . Input: nums = [1,-2,-3] Output: 5 . Constraints: . | 1 &lt;= nums.length &lt;= 100 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int minStartValue(int[] nums) { int start = nums[0]; if(start &lt; 0) start = (start*-1) + 1; else start = 1; int i = 0; while(i != nums.length){ int temp = start; for(i = 0; i &lt; nums.length; i++){ temp = temp + nums[i]; if(temp &lt; 1){ start++; break; } } } return start; } } . Faster Solution . class Solution { public int minStartValue(int[] nums) { int preSum=0; int minSum=Integer.MAX_VALUE; for(int i : nums){ preSum+=i; minSum=Math.min(minSum,preSum); } return minSum &gt; 0 ? 1 : Math.abs(minSum) + 1; } } . ",
    "url": "https://1001anjan.github.io/problem-209-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/",
    "relUrl": "/problem-209-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/"
  },"306": {
    "doc": "Combination Sum II",
    "title": "Combination Sum II",
    "content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. Example 1: . Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] . Example 2: . Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ] . Constraints: . | 1 &lt;= candidates.length &lt;= 100 | 1 &lt;= candidates[i] &lt;= 50 | 1 &lt;= target &lt;= 30 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(candidates); process(0, candidates, target, ans, new ArrayList&lt;Integer&gt;()); return ans; } public void process(int start, int[] arr, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(target == 0) { ans.add(new ArrayList&lt;&gt;(list)); return; } for(int i = start; i &lt; arr.length; i++){ if(i &gt; start &amp;&amp; arr[i] == arr[i - 1]){ continue; } if(target &gt;= arr[i]){ list.add(arr[i]); process(i + 1,arr,target - arr[i],ans,list); list.remove(list.size() - 1); } } } } . ",
    "url": "https://1001anjan.github.io/problem-21-Combination%20Sum%20II/",
    "relUrl": "/problem-21-Combination Sum II/"
  },"307": {
    "doc": "Symmetric Tree",
    "title": "Symmetric Tree",
    "content": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: . Input: root = [1,2,2,3,4,4,3] Output: true . Example 2: . Input: root = [1,2,2,null,3,null,3] Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) return true; return checkMiror(root.left, root.right); } public boolean checkMiror(TreeNode t1, TreeNode t2){ if(t1 == null || t2 == null) return t1 == t2; if(t1.val == t2.val) return checkMiror(t1.left, t2.right) &amp;&amp; checkMiror(t1.right, t2.left); return false; } } . ",
    "url": "https://1001anjan.github.io/problem-21-Symmetric-Tree/",
    "relUrl": "/problem-21-Symmetric-Tree/"
  },"308": {
    "doc": "Reformat The String",
    "title": "Reformat The String",
    "content": "You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return the reformatted string or return an empty string if it is impossible to reformat the string. Example 1: . Input: s = \"a0b1c2\" Output: \"0a1b2c\" Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations. Example 2: . Input: s = \"leetcode\" Output: \"\" Explanation: \"leetcode\" has only characters so we cannot separate them by digits. Example 3: . Input: s = \"1229857369\" Output: \"\" Explanation: \"1229857369\" has only digits so we cannot separate them by characters. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters and/or digits. | . class Solution { public String reformat(String s) { int letters = 0, numbers = 0; for(char c : s.toCharArray()){ if(Character.isDigit(c)) numbers++; else letters++; } if(Math.abs(letters - numbers) &gt; 1) return \"\"; return letters &gt; numbers ? makeResult(s,0,1) : makeResult(s,1,0); } private String makeResult(String s, int i, int j){ char[] c = s.toCharArray(); char[] res = new char[s.length()]; for(char ch: c){ if(Character.isLetter(ch)){ res[i] = ch; i+=2; }else{ res[j] = ch; j+=2; } } return String.valueOf(res); } } . ",
    "url": "https://1001anjan.github.io/problem-210-Reformat-The-String/",
    "relUrl": "/problem-210-Reformat-The-String/"
  },"309": {
    "doc": "Maximum Score After Splitting a String",
    "title": "Maximum Score After Splitting a String",
    "content": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring. Example 1: . Input: s = \"011101\" Output: 5 Explanation: All possible ways of splitting s into two non-empty substrings are: left = \"0\" and right = \"11101\", score = 1 + 4 = 5 left = \"01\" and right = \"1101\", score = 1 + 3 = 4 left = \"011\" and right = \"101\", score = 1 + 2 = 3 left = \"0111\" and right = \"01\", score = 1 + 1 = 2 left = \"01110\" and right = \"1\", score = 2 + 1 = 3 . Example 2: . Input: s = \"00111\" Output: 5 Explanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5 . Example 3: . Input: s = \"1111\" Output: 3 . Constraints: . | 2 &lt;= s.length &lt;= 500 | The string s consists of characters ‘0’ and ‘1’ only. | . Solution: . class Solution { public int maxScore(String s) { int one = 0; for(int i = 0; i &lt; s.length(); i++) { one += s.charAt(i) == '1' ? 1 : 0; } int zero = 0; if(s.charAt(0) == '0') zero++; else one--; int ans = zero + one; for(int i = 1; i &lt; s.length() - 1; i++) { if(s.charAt(i) == '0') { zero++; } else { one--; } ans = Math.max(ans, zero + one); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-211-Maximum-Score-After-Splitting-a-String/",
    "relUrl": "/problem-211-Maximum-Score-After-Splitting-a-String/"
  },"310": {
    "doc": "Kids With the Greatest Number of Candies",
    "title": "Kids With the Greatest Number of Candies",
    "content": "There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. Example 1: . Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Example 2: . Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. Example 3: . Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] . Constraints: . | n == candies.length | 2 &lt;= n &lt;= 100 | 1 &lt;= candies[i] &lt;= 100 | 1 &lt;= extraCandies &lt;= 50 | . Solution: . class Solution { public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) { LinkedList&lt;Boolean&gt; ans = new LinkedList&lt;Boolean&gt;(); int max = -1; for(int n : candies){ if(n &gt; max) max = n; } for(int n : candies){ if(n + extraCandies &gt;= max) ans.addLast(true); else ans.addLast(false); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-212-Kids-With-the-Greatest-Number-of-Candies/",
    "relUrl": "/problem-212-Kids-With-the-Greatest-Number-of-Candies/"
  },"311": {
    "doc": "Destination City",
    "title": "Destination City",
    "content": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city. Example 1: . Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] Output: \"Sao Paulo\" Explanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\". Example 2: . Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] Output: \"A\" Explanation: All possible trips are: \"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\". \"B\" -&gt; \"C\" -&gt; \"A\". \"C\" -&gt; \"A\". \"A\". Clearly the destination city is \"A\". Example 3: . Input: paths = [[\"A\",\"Z\"]] Output: \"Z\" . Constraints: . | 1 &lt;= paths.length &lt;= 100 | paths[i].length == 2 | 1 &lt;= cityAi.length, cityBi.length &lt;= 10 | cityAi != cityBi | All strings consist of lowercase and uppercase English letters and the space character. | . Solution: . class Solution { public String destCity(List&lt;List&lt;String&gt;&gt; paths) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); for(List&lt;String&gt; l : paths){ s.add(l.get(0)); } for(List&lt;String&gt; l : paths){ if(!s.contains(l.get(1))) return l.get(1); } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-213-Destination-City/",
    "relUrl": "/problem-213-Destination-City/"
  },"312": {
    "doc": "Check If All 1's Are at Least Length K Places Away",
    "title": "Check If All 1’s Are at Least Length K Places Away",
    "content": "Given an binary array nums and an integer k, return true if all 1’s are at least k places away from each other, otherwise return false. #####Example 1: . Input: nums = [1,0,0,0,1,0,0,1], k = 2 Output: true Explanation: Each of the 1s are at least 2 places away from each other. Example 2: . Input: nums = [1,0,0,1,0,1], k = 2 Output: false Explanation: The second 1 and third 1 are only one apart from each other. Constraints: . | 1 &lt;= nums.length &lt;= 105 | 0 &lt;= k &lt;= nums.length | nums[i] is 0 or 1 | . Solution: . class Solution { public boolean kLengthApart(int[] nums, int k) { // initialize the counter of zeros to k // to pass the first 1 in nums int count = k; for (int num : nums) { // if the current integer is 1 if (num == 1) { // check that number of zeros in-between 1s // is greater than or equal to k if (count &lt; k) { return false; } // reinitialize counter count = 0; // if the current integer is 0 } else { // increase the counter ++count; } } return true; } } . Bit manipulation . https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/solution/ . class Solution { public boolean kLengthApart(int[] nums, int k) { // convert binary array into int int x = 0; for (int num : nums) { x = (x &lt;&lt; 1) | num; } // base case if (x == 0 || k == 0) { return true; } // remove trailing zeros while ((x &amp; 1) == 0) { x = x &gt;&gt; 1; } while (x != 1) { // remove trailing 1-bit x = x &gt;&gt; 1; // count trailing zeros int count = 0; while ((x &amp; 1) == 0) { x = x &gt;&gt; 1; ++count; } // number of zeros in-between 1-bits // should be greater than or equal to k if (count &lt; k) { return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/#check-if-all-1s-are-at-least-length-k-places-away",
    "relUrl": "/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/#check-if-all-1s-are-at-least-length-k-places-away"
  },"313": {
    "doc": "Check If All 1's Are at Least Length K Places Away",
    "title": "Check If All 1's Are at Least Length K Places Away",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/",
    "relUrl": "/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/"
  },"314": {
    "doc": "Build an Array With Stack Operations",
    "title": "Build an Array With Stack Operations",
    "content": "You are given an array target and an integer n. In each iteration, you will read a number from list = [1, 2, 3, …, n]. Build the target array using the following operations: . | “Push”: Reads a new element from the beginning list, and pushes it in the array. | “Pop”: Deletes the last element of the array. | If the target array is already built, stop reading more elements. Return a list of the operations needed to build target. The test cases are generated so that the answer is unique. | . Example 1: . Input: target = [1,3], n = 3 Output: [\"Push\",\"Push\",\"Pop\",\"Push\"] Explanation: Read number 1 and automatically push in the array -&gt; [1] Read number 2 and automatically push in the array then Pop it -&gt; [1] Read number 3 and automatically push in the array -&gt; [1,3] . Example 2: . Input: target = [1,2,3], n = 3 Output: [\"Push\",\"Push\",\"Push\"] . Example 3: . Input: target = [1,2], n = 4 Output: [\"Push\",\"Push\"] Explanation: You only need to read the first 2 numbers and stop. Constraints: . | 1 &lt;= target.length &lt;= 100 | 1 &lt;= n &lt;= 100 | 1 &lt;= target[i] &lt;= n | target is strictly increasing. | . Solution: . class Solution { public List&lt;String&gt; buildArray(int[] target, int n) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int i = 0; for(int k = 1; i &lt; target.length &amp;&amp; k &lt;= n; k++){ ans.add(\"Push\"); if(target[i] == k){ i++; }else{ ans.add(\"Pop\"); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-215-Build-an-Array-With-Stack-Operations/",
    "relUrl": "/problem-215-Build-an-Array-With-Stack-Operations/"
  },"315": {
    "doc": "Consecutive Characters",
    "title": "Consecutive Characters",
    "content": "The power of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string s, return the power of s. Example 1: . Input: s = \"leetcode\" Output: 2 Explanation: The substring \"ee\" is of length 2 with the character 'e' only. Example 2: . Input: s = \"abbcccddddeeeeedcba\" Output: 5 Explanation: The substring \"eeeee\" is of length 5 with the character 'e' only. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters. | . Solution: . class Solution { public int maxPower(String s) { int max = -1; int currMax = 1; for(int i = 1; i &lt; s.length(); i++){ if(s.charAt(i - 1) == s.charAt(i)){ currMax++; }else{ max = Math.max(max, currMax); currMax = 1; } } return Math.max(max, currMax); } } . Faster in execution: . class Solution { public int maxPower(String s) { int max = -1; int currMax = 1; char prev = s.charAt(0); for(int i = 1; i &lt; s.length(); i++){ char now = s.charAt(i); if(prev == now){ currMax++; }else{ max = Math.max(max, currMax); currMax = 1; } prev = now; } return Math.max(max, currMax); } } . ",
    "url": "https://1001anjan.github.io/problem-216-Consecutive-Characters/",
    "relUrl": "/problem-216-Consecutive-Characters/"
  },"316": {
    "doc": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
    "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
    "content": "Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s. Example 1: . Input: sentence = \"i love eating burger\", searchWord = \"burg\" Output: 4 Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence. Example 2: . Input: sentence = \"this problem is an easy problem\", searchWord = \"pro\" Output: 2 Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3: . Input: sentence = \"i am tired\", searchWord = \"you\" Output: -1 Explanation: \"you\" is not a prefix of any word in the sentence. Constraints: . | 1 &lt;= sentence.length &lt;= 100 | 1 &lt;= searchWord.length &lt;= 10 | sentence consists of lowercase English letters and spaces. | searchWord consists of lowercase English letters. | . Solution: . class Solution { public int isPrefixOfWord(String sentence, String searchWord) { String[] words = sentence.split(\" \"); char first = searchWord.charAt(0); for(int i = 0; i &lt; words.length; i++){ if(words[i].charAt(0) == first){ int m = 1; while(m &lt; words[i].length() &amp;&amp; m &lt; searchWord.length()){ if(searchWord.charAt(m) != words[i].charAt(m)) break; m++; } if(m == searchWord.length()) return i+1; } } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-217-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/",
    "relUrl": "/problem-217-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/"
  },"317": {
    "doc": "Make Two Arrays Equal by Reversing Sub-arrays",
    "title": "Make Two Arrays Equal by Reversing Sub-arrays",
    "content": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps. Return true if you can make arr equal to target or false otherwise. Example 1: . Input: target = [1,2,3,4], arr = [2,4,1,3] Output: true Explanation: You can follow the next steps to convert arr to target: 1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3] 2- Reverse sub-array [4,2], arr becomes [1,2,4,3] 3- Reverse sub-array [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. Example 2: . Input: target = [7], arr = [7] Output: true Explanation: arr is equal to target without any reverses. Example 3: . Input: target = [3,7,9], arr = [3,7,11] Output: false Explanation: arr does not have value 9 and it can never be converted to target. Constraints: . | target.length == arr.length | 1 &lt;= target.length &lt;= 1000 | 1 &lt;= target[i] &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean canBeEqual(int[] target, int[] arr) { int[] count = new int[1001]; for(int n : target) count[n]++; for(int n : arr) count[n]--; for(int i = 0; i &lt; count.length; i++){ if(count[i] != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-218-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/",
    "relUrl": "/problem-218-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/"
  },"318": {
    "doc": "Maximum Product of Two Elements in an Array",
    "title": "Maximum Product of Two Elements in an Array",
    "content": "Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). Example 1: . Input: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. Example 2: . Input: nums = [1,5,4,5] Output: 16 Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3: . Input: nums = [3,7] Output: 12 . Constraints: . | 2 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 10^3 | . Solution: . class Solution { public int maxProduct(int[] nums) { int max1, max2; if(nums[0] &gt; nums[1]){ max1 = nums[0]; max2 = nums[1]; }else{ max1 = nums[1]; max2 = nums[0]; } for(int i = 2; i &lt; nums.length; i++){ if(max1 &lt; nums[i]){ max2 = max1; max1 = nums[i]; }else if(max2 &lt; nums[i]){ max2 = nums[i]; } } return (max1 - 1)*(max2 - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-219-Maximum-Product-of-Two-Elements-in-an-Array/",
    "relUrl": "/problem-219-Maximum-Product-of-Two-Elements-in-an-Array/"
  },"319": {
    "doc": "Jump Game II",
    "title": "Jump Game II",
    "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: . | 0 &lt;= j &lt;= nums[i] and | i + j &lt; n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. | . Example 1: . Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: . Input: nums = [2,3,0,1,4] Output: 2 . Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int jump(int[] nums) { int jump = 0, currEnd = 0, maxEnd = 0; for(int i = 0; i &lt; nums.length - 1; i++){ maxEnd = Math.max(maxEnd, i + nums[i]); if(i == currEnd){ jump++; currEnd = maxEnd; } } return jump; } } . ",
    "url": "https://1001anjan.github.io/problem-22-Jump%20Game%20II/",
    "relUrl": "/problem-22-Jump Game II/"
  },"320": {
    "doc": "Maximum Depth of Binary Tree",
    "title": "Maximum Depth of Binary Tree",
    "content": "Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 3 . Example 2: . Input: root = [1,null,2] Output: 2 . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { if(root == null ) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } } . ",
    "url": "https://1001anjan.github.io/problem-22-Maximum-Depth-of-Binary-Tree/",
    "relUrl": "/problem-22-Maximum-Depth-of-Binary-Tree/"
  },"321": {
    "doc": "Shuffle the Array",
    "title": "Shuffle the Array",
    "content": "Given the array nums consisting of 2n elements in the form [x1,x2,…,xn,y1,y2,…,yn]. Return the array in the form [x1,y1,x2,y2,…,xn,yn]. Example 1: . Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: . Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] . Example 3: . Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] . Constraints: . | 1 &lt;= n &lt;= 500 | nums.length == 2n | 1 &lt;= nums[i] &lt;= 10^3 | . Solution: . class Solution { public int[] shuffle(int[] nums, int n) { int[] ans = new int[nums.length]; int j = 0; int k = n; for(int i = 0; i &lt; nums.length; i++){ if(i%2 == 0){ ans[i] = nums[j++]; }else{ ans[i] = nums[k++]; } } return ans; } } . SAME execution time . class Solution { public int[] shuffle(int[] nums, int n) { int ans[] = new int[nums.length]; for(int i = 0; i &lt; nums.length/2; i++){ ans[i * 2] = nums[i]; ans[2 * i + 1] = nums[n + i]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-220-Shuffle-the-Array/",
    "relUrl": "/problem-220-Shuffle-the-Array/"
  },"322": {
    "doc": "Final Prices With a Special Discount in a Shop",
    "title": "Final Prices With a Special Discount in a Shop",
    "content": "Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j &gt; i and prices[j] &lt;= prices[i], otherwise, you will not receive any discount at all. Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount. Example 1: . Input: prices = [8,4,6,2,3] Output: [4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. Example 2: . Input: prices = [1,2,3,4,5] Output: [1,2,3,4,5] Explanation: In this case, for all items, you will not receive any discount at all. Example 3: . Input: prices = [10,1,1,6] Output: [9,0,1,6] . Constraints: . | 1 &lt;= prices.length &lt;= 500 | 1 &lt;= prices[i] &lt;= 10^3 | . Solution: . class Solution { public int[] finalPrices(int[] prices) { for(int i = 0; i&lt;prices.length - 1; i++){ for(int j = i + 1; j &lt; prices.length; j++){ if(prices[i] &gt;= prices[j]){ prices[i] -= prices[j]; break; } } } return prices; } } . ",
    "url": "https://1001anjan.github.io/problem-221-Final-Prices-With-a-Special-Discount-in-a-Shop/",
    "relUrl": "/problem-221-Final-Prices-With-a-Special-Discount-in-a-Shop/"
  },"323": {
    "doc": "Running Sum of 1d Array",
    "title": "Running Sum of 1d Array",
    "content": "Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. Example 1: . Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: . Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: . Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17] . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -10^6 &lt;= nums[i] &lt;= 10^6 | . Solution: . class Solution { public int[] runningSum(int[] nums) { for(int i = 1; i&lt;nums.length; i++){ nums[i] += nums[i-1]; } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-222-Running-Sum-of-1d-Array/",
    "relUrl": "/problem-222-Running-Sum-of-1d-Array/"
  },"324": {
    "doc": "XOR Operation in an Array",
    "title": "XOR Operation in an Array",
    "content": "You are given an integer n and an integer start. Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length. Return the bitwise XOR of all elements of nums. Example 1: . Input: n = 5, start = 0 Output: 8 Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8. Where \"^\" corresponds to bitwise XOR operator. Example 2: . Input: n = 4, start = 3 Output: 8 Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8. Constraints: . | 1 &lt;= n &lt;= 1000 | 0 &lt;= start &lt;= 1000 | n == nums.length | . Solution: . class Solution { public int xorOperation(int n, int start) { int ans = start; for(int i = 1; i &lt; n; i++) ans = ans ^ (start + 2*i); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-223-XOR-Operation-in-an-Array/",
    "relUrl": "/problem-223-XOR-Operation-in-an-Array/"
  },"325": {
    "doc": "Average Salary Excluding the Minimum and Maximum Salary",
    "title": "Average Salary Excluding the Minimum and Maximum Salary",
    "content": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 . Example 2: . Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 . Constraints: . | 3 &lt;= salary.length &lt;= 100 | 1000 &lt;= salary[i] &lt;= 106 | All the integers of salary are unique. | . Solution: . class Solution { public double average(int[] salary) { int max = Math.max(salary[0],salary[1]); int min = Math.min(salary[0],salary[1]); double sum = max + min; for(int i = 2; i &lt; salary.length; i++){ if(max &lt; salary[i]){ max = salary[i]; }else if(min &gt; salary[i]){ min = salary[i]; } sum += salary[i]; } sum = sum - max - min; return sum/(salary.length - 2); } } . ",
    "url": "https://1001anjan.github.io/problem-224-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/",
    "relUrl": "/problem-224-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/"
  },"326": {
    "doc": "Path Crossing",
    "title": "Path Crossing",
    "content": "Given a string path, where path[i] = ‘N’, ‘S’, ‘E’ or ‘W’, each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path. Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise. Example 1: . Input: path = \"NES\" Output: false Explanation: Notice that the path doesn't cross any point more than once. Example 2: . Input: path = \"NESWW\" Output: true Explanation: Notice that the path visits the origin twice. Constraints: . | 1 &lt;= path.length &lt;= 104 | path[i] is either ‘N’, ‘S’, ‘E’, or ‘W’. | . Solution: . class Solution { public boolean isPathCrossing(String path) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); s.add(\"0,0\"); int x = 0, y = 0; for(char c : path.toCharArray()){ if(c == 'N') y++; else if(c == 'E') x++; else if(c == 'S') y--; else x--; String str = \"\"+x+\",\"+y; if(s.contains(str)) return true; s.add(str); } return false; } } . Faster using string Builder . class Solution { public boolean isPathCrossing(String path) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); s.add(\"0,0\"); int x = 0, y = 0; StringBuilder sb = new StringBuilder(); for(char c : path.toCharArray()){ sb.setLength(0); if(c == 'N') y++; else if(c == 'E') x++; else if(c == 'S') y--; else x--; if(!s.add(sb.append(x).append(\",\").append(y).toString())) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-225-Path-Crossing/",
    "relUrl": "/problem-225-Path-Crossing/"
  },"327": {
    "doc": "Can Make Arithmetic Progression From Sequence",
    "title": "Can Make Arithmetic Progression From Sequence",
    "content": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false. Example 1: . Input: arr = [3,5,1] Output: true Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. Example 2: . Input: arr = [1,2,4] Output: false Explanation: There is no way to reorder the elements to obtain an arithmetic progression. Constraints: . | 2 &lt;= arr.length &lt;= 1000 | -106 &lt;= arr[i] &lt;= 106 | . Solution: . Time Complexity: O(nLogN) . class Solution { public boolean canMakeArithmeticProgression(int[] arr) { Arrays.sort(arr); int diff = arr[0] - arr[1]; for(int i = 1; i &lt; arr.length - 1; i++){ if(diff != arr[i] - arr[i + 1]) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-226-Can-Make-Arithmetic-Progression-From-Sequence/",
    "relUrl": "/problem-226-Can-Make-Arithmetic-Progression-From-Sequence/"
  },"328": {
    "doc": "Reformat Date",
    "title": "Reformat Date",
    "content": "Given a date string in the form Day Month Year, where: . | Day is in the set {“1st”, “2nd”, “3rd”, “4th”, …, “30th”, “31st”}. | Month is in the set {“Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec”}. | Year is in the range [1900, 2100]. | . Convert the date string to the format YYYY-MM-DD, where: . | YYYY denotes the 4 digit year. | MM denotes the 2 digit month. | DD denotes the 2 digit day. | . Example 1: . Input: date = \"20th Oct 2052\" Output: \"2052-10-20\" . Example 2: . Input: date = \"6th Jun 1933\" Output: \"1933-06-06\" . Example 3: . Input: date = \"26th May 1960\" Output: \"1960-05-26\" . Constraints: . | The given dates are guaranteed to be valid, so no error handling is necessary. | . Solution: . class Solution { public String reformatDate(String date) { String[] strs = date.split(\" \"); StringBuilder sb = new StringBuilder(); return sb.append(strs[2]).append(\"-\").append(getFormatedMonth(strs[1])).append(\"-\") .append(getFormatedDate(strs[0].substring(0,strs[0].length() - 2))).toString(); } public String getFormatedMonth(String str){ switch(str){ case \"Jan\": return \"01\"; case \"Feb\": return \"02\"; case \"Mar\": return \"03\"; case \"Apr\": return \"04\"; case \"May\": return \"05\"; case \"Jun\": return \"06\"; case \"Jul\": return \"07\"; case \"Aug\": return \"08\"; case \"Sep\": return \"09\"; case \"Oct\": return \"10\"; case \"Nov\": return \"11\"; case \"Dec\": return \"12\"; case default: return \"-1\"; } } public String getFormatedDate(String str){ if(str.length() == 1) return \"0\".concat(str); return str; } } . ",
    "url": "https://1001anjan.github.io/problem-227-Reformat-Date/",
    "relUrl": "/problem-227-Reformat-Date/"
  },"329": {
    "doc": "Number of Good Pairs",
    "title": "Number of Good Pairs",
    "content": "Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i &lt; j. Example 1: . Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2: . Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good. Example 3: . Input: nums = [1,2,3] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int numIdenticalPairs(int[] nums) { int[] count = new int[101]; for(int n : nums) count[n]++; int sum = 0; for(int i = 1; i &lt;= 100; i++){ if(count[i] &gt;= 2){ sum += (count[i]*(count[i]-1))/2; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-228-Number-of-Good-Pairs/",
    "relUrl": "/problem-228-Number-of-Good-Pairs/"
  },"330": {
    "doc": "Count Odd Numbers in an Interval Range",
    "title": "Count Odd Numbers in an Interval Range",
    "content": "Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive). Example 1: . Input: low = 3, high = 7 Output: 3 Explanation: The odd numbers between 3 and 7 are [3,5,7]. Example 2: . Input: low = 8, high = 10 Output: 1 Explanation: The odd numbers between 8 and 10 are [9]. Constraints: . | 0 &lt;= low &lt;= high &lt;= 10^9 | . Solution: . class Solution { public int countOdds(int low, int high) { int ans = (high - low)/2; if(low % 2 ==0 &amp;&amp; high % 2 == 0 ) return ans; return ans + 1; } } . ",
    "url": "https://1001anjan.github.io/problem-229-Count-Odd-Numbers-in-an-Interval-Range/",
    "relUrl": "/problem-229-Count-Odd-Numbers-in-an-Interval-Range/"
  },"331": {
    "doc": "Convert Sorted Array to Binary Search Tree",
    "title": "Convert Sorted Array to Binary Search Tree",
    "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Example 1: . Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: . Example 2: . Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums is sorted in a strictly increasing order. | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { return convertBalancedTree(null, nums, 0, nums.length-1); } public TreeNode convertBalancedTree(TreeNode head, int[] nums, int s, int e){ if(s&gt;e) return head; int mid = (s+e)/2; head = new TreeNode(nums[mid]); head.left = convertBalancedTree(head.left, nums, s, mid-1); head.right = convertBalancedTree(head.right, nums, mid+1, e); return head; } } . ",
    "url": "https://1001anjan.github.io/problem-23-Convert-Sorted-Array-to-Binary-Search-Tree/",
    "relUrl": "/problem-23-Convert-Sorted-Array-to-Binary-Search-Tree/"
  },"332": {
    "doc": "Permutations",
    "title": "Permutations",
    "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: . Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] . Example 2: . Input: nums = [0,1] Output: [[0,1],[1,0]] . Example 3: . Input: nums = [1] Output: [[1]] . Constraints: . | 1 &lt;= nums.length &lt;= 6 | -10 &lt;= nums[i] &lt;= 10 | All the integers of nums are unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processPermute(nums,0,ans); return ans; } public void processPermute(int[] arr, int level, List&lt;List&lt;Integer&gt;&gt; ans){ if(level == arr.length){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); for(int n : arr) l.add(n); ans.add(l); return; } for(int i = level; i &lt; arr.length; i++){ swap(arr,i,level); processPermute(arr, level + 1, ans); swap(arr,i,level); } } public void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } . ",
    "url": "https://1001anjan.github.io/problem-23-Permutations/",
    "relUrl": "/problem-23-Permutations/"
  },"333": {
    "doc": "Shuffle String",
    "title": "Shuffle String",
    "content": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string. Return the shuffled string. Example 1: . Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3] Output: \"leetcode\" Explanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling. Example 2: . Input: s = \"abc\", indices = [0,1,2] Output: \"abc\" Explanation: After shuffling, each character remains in its position. Constraints: . | s.length == indices.length == n | 1 &lt;= n &lt;= 100 | s consists of only lowercase English letters. | 0 &lt;= indices[i] &lt; n | All values of indices are unique. | . Solution: . class Solution { public String restoreString(String s, int[] indices) { char[] ans = new char[indices.length]; for(int i = 0; i &lt; indices.length; i++){ ans[indices[i]] = s.charAt(i); } return new String(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-230-Shuffle-String/",
    "relUrl": "/problem-230-Shuffle-String/"
  },"334": {
    "doc": "Count Good Triplets",
    "title": "Count Good Triplets",
    "content": "Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets. A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true: . | 0 &lt;= i &lt; j &lt; k &lt; arr.length | | arr[i] - arr[j] | &lt;= a | . | | arr[j] - arr[k] | &lt;= b | . | | arr[i] - arr[k] | &lt;= c | . | . | Where | x | denotes the absolute value of x. | . Return the number of good triplets. Example 1: . Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3 Output: 4 Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]. Example 2: . Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1 Output: 0 Explanation: No triplet satisfies all conditions. Constraints: . | 3 &lt;= arr.length &lt;= 100 | 0 &lt;= arr[i] &lt;= 1000 | 0 &lt;= a, b, c &lt;= 1000 | . Solution: . class Solution { public int countGoodTriplets(int[] arr, int a, int b, int c) { int count = 0; for(int i = 0; i &lt; arr.length - 2; i++) for(int j = i + 1; j &lt; arr.length - 1; j++) for(int k = j + 1; k &lt; arr.length; k++){ if(Math.abs(arr[i] - arr[j]) &lt;= a &amp;&amp; Math.abs(arr[j] - arr[k]) &lt;= b &amp;&amp; Math.abs(arr[i] - arr[k]) &lt;= c) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-231-Count-Good-Triplets/",
    "relUrl": "/problem-231-Count-Good-Triplets/"
  },"335": {
    "doc": "Kth Missing Positive Number",
    "title": "Kth Missing Positive Number",
    "content": "Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array. Example 1: . Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Example 2: . Input: arr = [1,2,3,4], k = 2 Output: 6 Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6. Constraints: . | 1 &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | 1 &lt;= k &lt;= 1000 | arr[i] &lt; arr[j] for 1 &lt;= i &lt; j &lt;= arr.length | . Follow up: . Could you solve this problem in less than O(n) complexity? . Solution . class Solution { public int findKthPositive(int[] arr, int k) { int count = 0; int i = 1; int j = 0; while(count != k){ if(j &lt; arr.length &amp;&amp; arr[j] == i){ j++; }else{ count++; } i++; } return i-1; } } . ",
    "url": "https://1001anjan.github.io/problem-232-Kth-Missing-Positive-Number/",
    "relUrl": "/problem-232-Kth-Missing-Positive-Number/"
  },"336": {
    "doc": "Make The String Great",
    "title": "Make The String Great",
    "content": "Given a string s of lower and upper case English letters. A good string is a string which doesn’t have two adjacent characters s[i] and s[i + 1] where: . | 0 &lt;= i &lt;= s.length - 2 | s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa. | . To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return the string after making it good. The answer is guaranteed to be unique under the given constraints. Notice that an empty string is also good. Example 1: . Input: s = \"leEeetcode\" Output: \"leetcode\" Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\". Example 2: . Input: s = \"abBAcC\" Output: \"\" Explanation: We have many possible scenarios, and all lead to the same answer. For example: \"abBAcC\" --&gt; \"aAcC\" --&gt; \"cC\" --&gt; \"\" \"abBAcC\" --&gt; \"abBA\" --&gt; \"aA\" --&gt; \"\" . Example 3: . Input: s = \"s\" Output: \"s\" . Constraints: . | 1 &lt;= s.length &lt;= 100 | s contains only lower and upper case English letters. | . Solution: . class Solution { public String makeGood(String s) { StringBuilder sb = new StringBuilder(); boolean status = false; sb.append(s); while(!status ){ char[] chs = sb.toString().toCharArray(); sb.setLength(0); status = true; for(int i = 0; i &lt; chs.length; i++){ if(i &lt; chs.length - 1 &amp;&amp; chs[i] != chs[i+1] &amp;&amp; Character.toUpperCase(chs[i]) == Character.toUpperCase(chs[i+1])){ i++; status = false; }else{ sb.append(chs[i]); } } } return sb.toString(); } } . Using recursion . class Solution { public String makeGood(String s) { for(int i=0;i&lt;s.length() - 1;i++){ if(Math.abs(s.charAt(i) - s.charAt(i+1)) ==32) return makeGood(s.substring(0, i)+ s.substring(i+2)); } return s; } } . using Stack but slow approach . class Solution { public String makeGood(String s) { Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); for(int i=0; i&lt;s.length(); i++){ char c = s.charAt(i); if(!stk.isEmpty() &amp;&amp; Math.abs(stk.peek()-c) == 32) stk.pop(); else stk.push(c); } StringBuilder res = new StringBuilder(); while(!stk.isEmpty()) res.append(stk.pop()); return res.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-233-Make-The-String-Great/",
    "relUrl": "/problem-233-Make-The-String-Great/"
  },"337": {
    "doc": "Three Consecutive Odds",
    "title": "Three Consecutive Odds",
    "content": "Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false. Example 1: . Input: arr = [2,6,4,1] Output: false Explanation: There are no three consecutive odds. Example 2: . Input: arr = [1,2,34,3,4,5,7,23,12] Output: true Explanation: [5,7,23] are three consecutive odds. Constraints: . | 1 &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean threeConsecutiveOdds(int[] arr) { int count = 0; for(int n : arr){ if(n % 2 == 0){ count = 0; }else{ count ++; } if(count == 3) return true; } return false; } } . class Solution { public boolean threeConsecutiveOdds(int[] arr) { if(arr.length &lt; 3) return false; for(int i=0;i&lt;arr.length-2;i++) { if(arr[i] % 2 != 0 &amp;&amp; arr[i+1] % 2 != 0 &amp;&amp; arr[i+2] % 2 != 0) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-234-Three-Consecutive-Odds/",
    "relUrl": "/problem-234-Three-Consecutive-Odds/"
  },"338": {
    "doc": "Thousand Separator",
    "title": "Thousand Separator",
    "content": "Given an integer n, add a dot (“.”) as the thousands separator and return it in string format. Example 1: . Input: n = 987 Output: \"987\" . Example 2: . Input: n = 1234 Output: \"1.234\" . Constraints: . | 0 &lt;= n &lt;= 231 - 1 | . Solution: . class Solution { public String thousandSeparator(int n) { if(n == 0) return \"0\"; StringBuilder sb = new StringBuilder(); int count = 0; while(n &gt; 0){ if(count == 3){ count = 0; sb.append(\".\"); } sb.append(n % 10); n = n/10; count++; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-235-Thousand-Separator/",
    "relUrl": "/problem-235-Thousand-Separator/"
  },"339": {
    "doc": "Detect Pattern of Length M Repeated K or More Times",
    "title": "Detect Pattern of Length M Repeated K or More Times",
    "content": "Given an array of positive integers arr, find a pattern of length m that is repeated k or more times. A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions. Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false. Example 1: . Input: arr = [1,2,4,4,4,4], m = 1, k = 3 Output: true Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less. Example 2: . Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 Output: true Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times. Example 3: . Input: arr = [1,2,1,2,1,3], m = 2, k = 3 Output: false Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times. Constraints: . | 2 &lt;= arr.length &lt;= 100 | 1 &lt;= arr[i] &lt;= 100 | 1 &lt;= m &lt;= 100 | 2 &lt;= k &lt;= 100 | . Solution: . class Solution { public boolean containsPattern(int[] arr, int m, int k) { int count = 0; for (int i = 0; i &lt; arr.length - m; i++) { if (arr[i] == arr[i + m]) { count++; } else { count = 0; } if (count == m * (k-1)) { return true; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-236-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times/",
    "relUrl": "/problem-236-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times/"
  },"340": {
    "doc": "Matrix Diagonal Sum",
    "title": "Matrix Diagonal Sum",
    "content": "Given a square matrix mat, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. Example 1: . Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. Example 2: . Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 . Example 3: . Input: mat = [[5]] Output: 5 . Constraints: . | n == mat.length == mat[i].length | 1 &lt;= n &lt;= 100 | 1 &lt;= mat[i][j] &lt;= 100 | . Solution: . class Solution { public int diagonalSum(int[][] mat) { int sum = 0; int i = 0; int j = 0; while(i &lt; mat.length){ sum += mat[i++][j++]; } i = 0; j = mat[0].length - 1; while(i &lt; mat.length){ sum += mat[i++][j--]; } if(mat.length % 2 != 0) sum -= mat[mat.length / 2][mat.length / 2]; return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-237-Matrix-Diagonal-Sum/",
    "relUrl": "/problem-237-Matrix-Diagonal-Sum/"
  },"341": {
    "doc": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "title": "Replace All ?’s to Avoid Consecutive Repeating Characters",
    "content": "Given a string s containing only lowercase English letters and the ‘?’ character, convert all the ‘?’ characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non ‘?’ characters. It is guaranteed that there are no consecutive repeating characters in the given string except for ‘?’. Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints. Example 1: . Input: s = \"?zs\" Output: \"azs\" Explanation: There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\". Example 2: . Input: s = \"ubv?w\" Output: \"ubvaw\" Explanation: There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consist of lowercase English letters and ‘?’. | . Solution: . class Solution { public String modifyString(String s) { char[] chars = s.toCharArray(); char prev = '1'; for(int i = 0; i &lt; chars.length; i++){ if(chars[i] == '?'){ chars[i] = getNewChar(prev,chars[(i + 1)%chars.length]); } prev = chars[i]; } return new String(chars); } public char getNewChar(char prev, char next){ int i = 0; int p = prev - 'a'; int n = next - 'a'; while(i &lt; 26){ if(i != p &amp;&amp; i != n) break; i++; } return (char)('a' + i); } } . ",
    "url": "https://1001anjan.github.io/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/#replace-all-s-to-avoid-consecutive-repeating-characters",
    "relUrl": "/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/#replace-all-s-to-avoid-consecutive-repeating-characters"
  },"342": {
    "doc": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/",
    "relUrl": "/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/"
  },"343": {
    "doc": "Special Positions in a Binary Matrix",
    "title": "Special Positions in a Binary Matrix",
    "content": "Given an m x n binary matrix mat, return the number of special positions in mat. A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed). Example 1: . Input: mat = [[1,0,0],[0,0,1],[1,0,0]] Output: 1 Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0. Example 2: . Input: mat = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 Explanation: (0, 0), (1, 1) and (2, 2) are special positions. Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= m, n &lt;= 100 | mat[i][j] is either 0 or 1. | . Solution: . class Solution { public int numSpecial(int[][] mat) { int m = mat.length, n = mat[0].length; int[] row = new int[m], col = new int[n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] == 1) { row[i]++; col[j]++; } } } int res = 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] == 1 &amp;&amp; row[i] == 1 &amp;&amp; col[j] == 1) { res++; } } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-239-Special-Positions-in-a-Binary-Matrix/",
    "relUrl": "/problem-239-Special-Positions-in-a-Binary-Matrix/"
  },"344": {
    "doc": "Balanced Binary Tree",
    "title": "Balanced Binary Tree",
    "content": "Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: . a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: true . Example 2: . Input: root = [1,2,2,3,3,null,null,4,4] Output: false . Example 3: . Input: root = [] Output: true . Constraints: . | The number of nodes in the tree is in the range [0, 5000]. | -104 &lt;= Node.val &lt;= 104 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private boolean isBalanced = true; public boolean isBalanced(TreeNode root) { if(root == null) return true; if(root.left == null &amp;&amp; root.right == null) return true; getMaxDepth(root); return isBalanced; } public int getMaxDepth(TreeNode head){ if(head == null) return 0; if(head.left == null &amp;&amp; head.right == null) return 1; int left = getMaxDepth(head.left); int right = getMaxDepth(head.right); if(Math.abs(left - right) &gt; 1){ isBalanced = false; } return 1+ Math.max(left,right); } } . ",
    "url": "https://1001anjan.github.io/problem-24-Balanced-Binary-Tree/",
    "relUrl": "/problem-24-Balanced-Binary-Tree/"
  },"345": {
    "doc": "Permutations II",
    "title": "Permutations II",
    "content": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: . Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] . Example 2: . Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] . Constraints: . | 1 &lt;= nums.length &lt;= 8 | -10 &lt;= nums[i] &lt;= 10 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(nums); processPermute(nums,0,ans); return ans; } public void processPermute(int[] arr, int level, List&lt;List&lt;Integer&gt;&gt; ans){ if(level == arr.length){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); for(int n : arr) l.add(n); ans.add(l); return; } HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = level; i &lt; arr.length; i++){ if(set.add(arr[i])){ swap(arr,i,level); processPermute(arr, level + 1, ans); swap(arr, i, level); } } } public void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } . ",
    "url": "https://1001anjan.github.io/problem-24-Permutations%20II/",
    "relUrl": "/problem-24-Permutations II/"
  },"346": {
    "doc": "Sum of All Odd Length Subarrays",
    "title": "Sum of All Odd Length Subarrays",
    "content": "Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr. A subarray is a contiguous subsequence of the array. Example 1: . Input: arr = [1,4,2,5,3] Output: 58 Explanation: The odd-length subarrays of arr and their sums are: [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 . Example 2: . Input: arr = [1,2] Output: 3 Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3. Example 3: . Input: arr = [10,11,12] Output: 66 . Constraints: . | 1 &lt;= arr.length &lt;= 100 | 1 &lt;= arr[i] &lt;= 1000 | . Follow up: . Could you solve this problem in O(n) time complexity? . Solution: . class Solution { public int sumOddLengthSubarrays(int[] arr) { int sum = 0; for(int i = 0; i &lt; arr.length; i++){ // calculating no of times index will be present in all subarrays int allCount = (arr.length - i)*(i + 1); // calculate no of times index will be present in odd length subarrays int oddCount = allCount % 2 == 0 ? allCount/2 : allCount/2 + 1; sum += oddCount*arr[i]; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-240-Sum-of-All-Odd-Length-Subarrays/",
    "relUrl": "/problem-240-Sum-of-All-Odd-Length-Subarrays/"
  },"347": {
    "doc": "Rearrange Spaces Between Words",
    "title": "Rearrange Spaces Between Words",
    "content": "You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It’s guaranteed that text contains at least one word. Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text. Return the string after rearranging the spaces. Example 1: . Input: text = \" this is a sentence \" Output: \"this is a sentence\" Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces. Example 2: . Input: text = \" practice makes perfect\" Output: \"practice makes perfect \" Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string. Constraints: . | 1 &lt;= text.length &lt;= 100 | text consists of lowercase English letters and ‘ ‘. | text contains at least one word. | . Solution: . class Solution { public String reorderSpaces(String text) { int totalLen = text.length(); if(totalLen == 1) return text; String[] words = text.trim().split(\"\\\\s+\"); int len = 0; for(String s : words) len += s.length(); int space = totalLen - len; boolean isOne = false; int extra = 0; if(words.length == 1){ isOne = true; }else{ extra = space - (space / (words.length - 1))*(words.length - 1); space = space / (words.length - 1); } StringBuilder sb = new StringBuilder(); for(String s : words){ sb.append(s); for(int i = 1; i &lt;= space; i++) sb.append(\" \"); } if(!isOne){ sb.setLength(sb.length() - space); } for(int i = 1; i &lt;= extra; i++) sb.append(\" \"); return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-241-Rearrange-Spaces-Between-Words/",
    "relUrl": "/problem-241-Rearrange-Spaces-Between-Words/"
  },"348": {
    "doc": "Crawler Log Folder",
    "title": "Crawler Log Folder",
    "content": "The Leetcode file system keeps a log each time some user performs a change folder operation. The operations are described below: . | ”../” : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). | ”./” : Remain in the same folder. | “x/” : Move to the child folder named x (This folder is guaranteed to always exist). | . You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed. Return the minimum number of operations needed to go back to the main folder after the change folder operations. Example 1: . Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"] Output: 2 Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder. Example 2: . Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"] Output: 3 . Example 3: . Input: logs = [\"d1/\",\"../\",\"../\",\"../\"] Output: 0 . Constraints: . | 1 &lt;= logs.length &lt;= 103 | 2 &lt;= logs[i].length &lt;= 10 | logs[i] contains lowercase English letters, digits, ‘.’, and ‘/’. | logs[i] follows the format described in the statement. | Folder names consist of lowercase English letters and digits. | . Solution: . class Solution { public int minOperations(String[] logs) { int level = 0; for(String s : logs){ if(s.length() == 3 &amp;&amp; s.charAt(0) == '.' &amp;&amp; s.charAt(1) == '.') { if(level &gt; 0) level--; }else if(s.charAt(0) != '.') level++; } return level; } } . ",
    "url": "https://1001anjan.github.io/problem-242-Crawler-Log-Folder/",
    "relUrl": "/problem-242-Crawler-Log-Folder/"
  },"349": {
    "doc": "Design Parking System",
    "title": "Design Parking System",
    "content": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the ParkingSystem class: . | ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor. | bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true. | . Example 1: . Input [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"] [[1, 1, 0], [1], [2], [3], [1]] Output [null, true, true, false, false] Explanation ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied. Constraints: . | 0 &lt;= big, medium, small &lt;= 1000 | carType is 1, 2, or 3 | At most 1000 calls will be made to addCar | . Solution: . class ParkingSystem { private int b; private int m; private int s; public ParkingSystem(int big, int medium, int small) { b = big; m = medium; s = small; } public boolean addCar(int carType) { if(carType == 1 &amp;&amp; b &gt; 0){ b--; return true; }else if(carType == 2 &amp;&amp; m &gt; 0){ m--; return true; }else if(carType == 3 &amp;&amp; s &gt; 0){ s--; return true; }else return false; } } /** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem obj = new ParkingSystem(big, medium, small); * boolean param_1 = obj.addCar(carType); */ . class ParkingSystem { int[] space = new int[4]; public ParkingSystem(int big, int medium, int small) { space[1] = big; space[2] = medium; space[3] = small; } public boolean addCar(int carType) { if (space[carType] &gt; 0) { space[carType]--; return true; } else { return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-243-Design-Parking-System/",
    "relUrl": "/problem-243-Design-Parking-System/"
  },"350": {
    "doc": "Maximum Nesting Depth of the Parentheses",
    "title": "Maximum Nesting Depth of the Parentheses",
    "content": "A string is a valid parentheses string (denoted VPS) if it meets one of the following: . | It is an empty string “”, or a single character not equal to “(“ or “)”, | It can be written as AB (A concatenated with B), where A and B are VPS’s, or | It can be written as (A), where A is a VPS. | . We can similarly define the nesting depth depth(S) of any VPS S as follows: . | depth(“”) = 0 | depth(C) = 0, where C is a string with a single character not equal to “(“ or “)”. | depth(A + B) = max(depth(A), depth(B)), where A and B are VPS’s. | depth(“(“ + A + “)”) = 1 + depth(A), where A is a VPS. | For example, “”, “()()”, and “()(()())” are VPS’s (with nesting depths 0, 1, and 2), and “)(“ and “(()” are not VPS’s. | . Given a VPS represented as string s, return the nesting depth of s. Example 1: . Input: s = \"(1+(2*3)+((8)/4))+1\" Output: 3 Explanation: Digit 8 is inside of 3 nested parentheses in the string. Example 2: . Input: s = \"(1)+((2))+(((3)))\" Output: 3 . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of digits 0-9 and characters ‘+’, ‘-‘, ‘*’, ‘/’, ‘(‘, and ‘)’. | It is guaranteed that parentheses expression s is a VPS. | . Solution: . class Solution { public int maxDepth(String str) { Stack&lt;Character&gt; s = new Stack&lt;&gt;(); int depth = 0; for(char c : str.toCharArray()){ if(c == '(') s.push('('); else if(c == ')'){ depth = Math.max(depth, s.size()); s.pop(); } } return depth; } } . class Solution { public int maxDepth(String s) { int max = 0, count = 0; for(char c : s.toCharArray()){ if(c == '('){ count++; }else if(c == ')'){ count--; } max = Math.max(max,count); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-244-Maximum-Nesting-Depth-of-the-Parentheses/",
    "relUrl": "/problem-244-Maximum-Nesting-Depth-of-the-Parentheses/"
  },"351": {
    "doc": "Mean of Array After Removing Some Elements",
    "title": "Mean of Array After Removing Some Elements",
    "content": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements. Answers within 10-5 of the actual answer will be considered accepted. Example 1: . Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] Output: 2.00000 Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2. Example 2: . Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] Output: 4.00000 . Example 3: . Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] Output: 4.77778 . Constraints: . | 20 &lt;= arr.length &lt;= 1000 | arr.length is a multiple of 20. | 0 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public double trimMean(int[] arr) { Arrays.sort(arr); int d = arr.length / 20; double sum = 0.0; for(int i = d; i &lt; arr.length - d; i++){ sum += arr[i]; } return sum / (arr.length - 2*d); } } . ",
    "url": "https://1001anjan.github.io/problem-245-Mean-of-Array-After-Removing-Some-Elements/",
    "relUrl": "/problem-245-Mean-of-Array-After-Removing-Some-Elements/"
  },"352": {
    "doc": "Largest Substring Between Two Equal Characters",
    "title": "Largest Substring Between Two Equal Characters",
    "content": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1. A substring is a contiguous sequence of characters within a string. Example 1: . Input: s = \"aa\" Output: 0 Explanation: The optimal substring here is an empty substring between the two 'a's. Example 2: . Input: s = \"abca\" Output: 2 Explanation: The optimal substring here is \"bc\". Example 3: . Input: s = \"cbzxy\" Output: -1 Explanation: There are no characters that appear twice in s. Constraints: . | 1 &lt;= s.length &lt;= 300 | s contains only lowercase English letters. | . Solution: . class Solution { public int maxLengthBetweenEqualCharacters(String s) { int[][] index = new int[26][2]; for(int i = 0; i &lt; s.length(); i++){ char c = s.charAt(i); if(index[c - 'a'][0] == 0) index[c - 'a'][0] = i + 1; else index[c - 'a'][1] = i + 1; } int max = index[0][1] - index[0][0] - 1; for(int i = 1; i &lt; 26; i++){ max = Math.max(max, index[i][1] - index[i][0] - 1); } return max; } } . O(n*n) Time complexity . class Solution { public int maxLengthBetweenEqualCharacters(String s) { int res = -1; for(int i=0; i&lt;s.length(); i++){ char c = s.charAt(i); res = Math.max(res, s.lastIndexOf(c) - s.indexOf(c)-1); } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-246-Largest-Substring-Between-Two-Equal-Characters/",
    "relUrl": "/problem-246-Largest-Substring-Between-Two-Equal-Characters/"
  },"353": {
    "doc": "Sort Array by Increasing Frequency",
    "title": "Sort Array by Increasing Frequency",
    "content": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. Return the sorted array. Example 1: . Input: nums = [1,1,2,2,2,3] Output: [3,1,1,2,2,2] Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3. Example 2: . Input: nums = [2,3,1,3,2] Output: [1,3,3,2,2] Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order. Example 3: . Input: nums = [-1,1,-6,4,5,-6,1,4,1] Output: [5,-1,4,4,-6,-6,1,1,1] . Constraints: . | 1 &lt;= nums.length &lt;= 100 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] frequencySort(int[] nums) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int n : nums){ map.put(n,map.getOrDefault(n,0) + 1); } List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list = new LinkedList&lt;Map.Entry&lt;Integer,Integer&gt;&gt;(map.entrySet()); Collections.sort(list,(i1,i2) -&gt; { if(i1.getValue() == i2.getValue()) return i2.getKey().compareTo(i1.getKey()); else return i1.getValue().compareTo(i2.getValue()); }); int i = 0; for(Map.Entry&lt;Integer,Integer&gt; m : list){ for(int j = 1; j &lt;= m.getValue(); j++) nums[i++] = m.getKey(); } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-247-Sort-Array-by-Increasing-Frequency/",
    "relUrl": "/problem-247-Sort-Array-by-Increasing-Frequency/"
  },"354": {
    "doc": "Get Maximum in Generated Array",
    "title": "Get Maximum in Generated Array",
    "content": "You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way: . | nums[0] = 0 | nums[1] = 1 | nums[2 * i] = nums[i] when 2 &lt;= 2 * i &lt;= n | nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &lt;= 2 * i + 1 &lt;= n Return the maximum integer in the array nums​​​. | . Example 1: . Input: n = 7 Output: 3 Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. Example 2: . Input: n = 2 Output: 1 Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1. Example 3: . Input: n = 3 Output: 2 Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2. Constraints: . | 0 &lt;= n &lt;= 100 | . Solution: . class Solution { public int getMaximumGenerated(int n) { if(n == 0) return 0; if(n == 1) return 1; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; int max = 1; for(int i = 2; i &lt; n + 1; i++){ if(i % 2 == 0) dp[i] = dp[i / 2]; else dp[i] = dp[i / 2] + dp[(i / 2) + 1]; max = Math.max(max, dp[i]); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-248-Sort-Array-by-Increasing-Frequency/",
    "relUrl": "/problem-248-Sort-Array-by-Increasing-Frequency/"
  },"355": {
    "doc": "Defuse the Bomb",
    "title": "Defuse the Bomb",
    "content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k. To decrypt the code, you must replace every number. All the numbers are replaced simultaneously. | If k &gt; 0, replace the ith number with the sum of the next k numbers. | If k &lt; 0, replace the ith number with the sum of the previous k numbers. | If k == 0, replace the ith number with 0. As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1]. | . Given the circular array code and an integer key k, return the decrypted code to defuse the bomb! . Example 1: . Input: code = [5,7,1,4], k = 3 Output: [12,10,16,13] Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around. Example 2: . Input: code = [1,2,3,4], k = 0 Output: [0,0,0,0] Explanation: When k is zero, the numbers are replaced by 0. Example 3: . Input: code = [2,4,9,3], k = -2 Output: [12,5,6,13] Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers. Constraints: . | n == code.length | 1 &lt;= n &lt;= 100 | 1 &lt;= code[i] &lt;= 100 | -(n - 1) &lt;= k &lt;= n - 1 | . Solution: O(n*k) . class Solution { public int[] decrypt(int[] code, int k) { int[] ans = new int[code.length]; if(k == 0) return ans; if(k &gt; 0){ for(int i = 0; i &lt; code.length; i++){ int sum = 0; for(int j = 1; j &lt;= k; j++){ sum += code[(i + j) % code.length]; } ans[i] = sum; } }else{ for(int i = 0; i &lt; code.length; i++){ int sum = 0; for(int j = 0; j &lt; Math.abs(k); j++){ sum += code[(code.length + k + i + j) % code.length]; } ans[i] = sum; } } return ans; } } . Faster O(n) . class Solution { public int[] decrypt(int[] code, int k) { if(k==0) return new int[code.length]; int n = code.length; int[] result = new int[code.length]; int start, end; start = k &gt; 0? 1: code.length + k; end = k &gt; 0? k : n-1; int sum = 0; for(int i = start; i &lt;= end; i++) sum += code[i]; for(int i=0;i&lt;code.length;i++){ result[i] = sum; sum -= code[start]; start = (start+1)%n; end = (end+1)%n; sum += code[end]; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-249-Defuse-the-Bomb/",
    "relUrl": "/problem-249-Defuse-the-Bomb/"
  },"356": {
    "doc": "Minimum Depth of Binary Tree",
    "title": "Minimum Depth of Binary Tree",
    "content": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 2 . Example 2: . Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 . Constraints: . | The number of nodes in the tree is in the range [0, 105]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; int left = Integer.MAX_VALUE; int right = Integer.MAX_VALUE; if(root.left != null) { left = minDepth(root.left); } if(root.right != null){ right = minDepth(root.right); } return 1 + Math.min(left,right ); } } . Non-recursive . class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); int depth = 1; while (true){ int level = queue.size(); for (int i = 0; i &lt; level; i++){ TreeNode data = queue.poll(); if (data.left == null &amp;&amp; data.right == null) return depth; if (data.left != null) queue.offer(data.left); if (data.right != null) queue.offer(data.right); } depth++; } } } . ",
    "url": "https://1001anjan.github.io/problem-25-Minimum-Depth-of-Binary-Tree/",
    "relUrl": "/problem-25-Minimum-Depth-of-Binary-Tree/"
  },"357": {
    "doc": "Rotate Image",
    "title": "Rotate Image",
    "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] . Example 2: . Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] . Constraints: . | n == matrix.length == matrix[i].length | 1 &lt;= n &lt;= 20 | -1000 &lt;= matrix[i][j] &lt;= 1000 | . Solution: . class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for(int i = 0; i &lt; n/2; i++){ for(int j = i; j &lt; n - i - 1; j++){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } } } . ",
    "url": "https://1001anjan.github.io/problem-25-Rotate%20Image/",
    "relUrl": "/problem-25-Rotate Image/"
  },"358": {
    "doc": "Check If Two String Arrays are Equivalent",
    "title": "Check If Two String Arrays are Equivalent",
    "content": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string. Example 1: . Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] Output: true Explanation: word1 represents string \"ab\" + \"c\" -&gt; \"abc\" word2 represents string \"a\" + \"bc\" -&gt; \"abc\" The strings are the same, so return true. Example 2: . Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] Output: false . Example 3: . Input: word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] Output: true . Constraints: . | 1 &lt;= word1.length, word2.length &lt;= 103 | 1 &lt;= word1[i].length, word2[i].length &lt;= 103 | 1 &lt;= sum(word1[i].length), sum(word2[i].length) &lt;= 103 | word1[i] and word2[i] consist of lowercase letters. | . Solution: . class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder(); for(String s : word1) sb1.append(s); for(String s : word2) sb2.append(s); return sb1.toString().equals(sb2.toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-250-Check-If-Two-String-Arrays-are-Equivalent/",
    "relUrl": "/problem-250-Check-If-Two-String-Arrays-are-Equivalent/"
  },"359": {
    "doc": "Maximum Repeating Substring",
    "title": "Check If Two String Arrays are Equivalent",
    "content": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word’s maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word’s maximum k-repeating value is 0. Given strings sequence and word, return the maximum k-repeating value of word in sequence. Example 1: . Input: sequence = \"ababc\", word = \"ab\" Output: 2 Explanation: \"abab\" is a substring in \"ababc\". Example 2: . Input: sequence = \"ababc\", word = \"ba\" Output: 1 Explanation: \"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\". Example 3: . Input: sequence = \"ababc\", word = \"ac\" Output: 0 Explanation: \"ac\" is not a substring in \"ababc\". Constraints: . | 1 &lt;= sequence.length &lt;= 100 | 1 &lt;= word.length &lt;= 100 | sequence and word contains only lowercase English letters. | . Solution: . class Solution { public int maxRepeating(String sequence, String word) { StringBuilder umang = new StringBuilder(word); int count =0; while(true){ if(sequence.contains(umang)){ count+=1; umang.append(word); } else{ return count; } } } } // The main concept here is , we have to form a possible longest substring using concatenated 'word' in 'sequence' and keep increasing our count of repeating ' word'. ",
    "url": "https://1001anjan.github.io/problem-251-Maximum-Repeating-Substring/#check-if-two-string-arrays-are-equivalent",
    "relUrl": "/problem-251-Maximum-Repeating-Substring/#check-if-two-string-arrays-are-equivalent"
  },"360": {
    "doc": "Maximum Repeating Substring",
    "title": "Maximum Repeating Substring",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-251-Maximum-Repeating-Substring/",
    "relUrl": "/problem-251-Maximum-Repeating-Substring/"
  },"361": {
    "doc": "Richest Customer Wealth",
    "title": "Richest Customer Wealth",
    "content": "You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has. A customer’s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth. Example 1: . Input: accounts = [[1,2,3],[3,2,1]] Output: 6 Explanation: 1st customer has wealth = 1 + 2 + 3 = 6 2nd customer has wealth = 3 + 2 + 1 = 6 Both customers are considered the richest with a wealth of 6 each, so return 6. Example 2: . Input: accounts = [[1,5],[7,3],[3,5]] Output: 10 Explanation: 1st customer has wealth = 6 2nd customer has wealth = 10 3rd customer has wealth = 8 The 2nd customer is the richest with a wealth of 10. Example 3: . Input: accounts = [[2,8,7],[7,1,3],[1,9,5]] Output: 17 . Constraints: . | m == accounts.length | n == accounts[i].length | 1 &lt;= m, n &lt;= 50 | 1 &lt;= accounts[i][j] &lt;= 100 | . Solution: . class Solution { public int maximumWealth(int[][] accounts) { int tempWealth; int maxWealth = sumArray(accounts[0]); for(int i = 1; i &lt; accounts.length; i++){ tempWealth = sumArray(accounts[i]); if(tempWealth &gt; maxWealth) maxWealth = tempWealth; } return maxWealth; } public int sumArray(int arr[]){ int sum = 0; for(int i=0; i &lt; arr.length; i++){ sum += arr[i]; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-252-Richest-Customer-Wealth/",
    "relUrl": "/problem-252-Richest-Customer-Wealth/"
  },"362": {
    "doc": "Goal Parser Interpretation",
    "title": "Goal Parser Interpretation",
    "content": "You own a Goal Parser that can interpret a string command. The command consists of an alphabet of “G”, “()” and/or “(al)” in some order. The Goal Parser will interpret “G” as the string “G”, “()” as the string “o”, and “(al)” as the string “al”. The interpreted strings are then concatenated in the original order. Given the string command, return the Goal Parser’s interpretation of command. Example 1: . Input: command = \"G()(al)\" Output: \"Goal\" Explanation: The Goal Parser interprets the command as follows: G -&gt; G () -&gt; o (al) -&gt; al The final concatenated result is \"Goal\". Example 2: . Input: command = \"G()()()()(al)\" Output: \"Gooooal\" . Example 3: . Input: command = \"(al)G(al)()()G\" Output: \"alGalooG\" . Constraints: . | 1 &lt;= command.length &lt;= 100 | command consists of “G”, “()”, and/or “(al)” in some order. | . Solution: . class Solution { public String interpret(String command) { StringBuilder sb = new StringBuilder(); char[] s = command.toCharArray(); int i = 0; while(i &lt; s.length){ if(s[i] == 'G'){ sb.append(\"G\"); i++; }else if(s[i] == '('){ if(s[i + 1] == ')'){ sb.append(\"o\"); i = i+ 2; }else{ i++; while(s[i] != ')') sb.append(s[i++]); i++; } } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-253-Goal-Parser%20Interpretation/",
    "relUrl": "/problem-253-Goal-Parser Interpretation/"
  },"363": {
    "doc": "Count the Number of Consistent Strings",
    "title": "Count the Number of Consistent Strings",
    "content": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed. Return the number of consistent strings in the array words. Example 1: . Input: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"] Output: 2 Explanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'. Example 2: . Input: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"] Output: 7 Explanation: All strings are consistent. Example 3: . Input: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"] Output: 4 Explanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent. Constraints: . | 1 &lt;= words.length &lt;= 104 | 1 &lt;= allowed.length &lt;= 26 | 1 &lt;= words[i].length &lt;= 10 | The characters in allowed are distinct. | words[i] and allowed contain only lowercase English letters. | . Solution: . class Solution { public int countConsistentStrings(String allowed, String[] words) { boolean[] a = new boolean[26]; for(char c : allowed.toCharArray()) a[c - 'a'] = true; int count = 0; for(String str : words){ boolean f = true; for(char c : str.toCharArray()){ if(!a[c - 'a']){ f = false; break; } } if(f) count++; } return count; } } . class Solution { public int countConsistentStrings(String allowed, String[] words) { int mask =0; for (int i =0; i&lt;allowed.length(); i++) { mask |= 1 &lt;&lt; (allowed.charAt(i) - 'a'); } int count = 0; outer: for (int i =0; i&lt; words.length; i++) { for (int j = 0; j&lt;words[i].length(); j++) { if ((mask &amp; (1 &lt;&lt; words[i].charAt(j) - 'a')) == 0) continue outer; } count ++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-254-Count-the-Number-of-Consistent-Strings/",
    "relUrl": "/problem-254-Count-the-Number-of-Consistent-Strings/"
  },"364": {
    "doc": "Count of Matches in Tournament",
    "title": "Count of Matches in Tournament",
    "content": "You are given an integer n, the number of teams in a tournament that has strange rules: . | If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round. | If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round. Return the number of matches played in the tournament until a winner is decided. | . Example 1: . Input: n = 7 Output: 6 Explanation: Details of the tournament: - 1st Round: Teams = 7, Matches = 3, and 4 teams advance. - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. Example 2: . Input: n = 14 Output: 13 Explanation: Details of the tournament: - 1st Round: Teams = 14, Matches = 7, and 7 teams advance. - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. Constraints: . | 1 &lt;= n &lt;= 200 | . Solution: . class Solution { public int numberOfMatches(int n) { int count = 0; while(n != 1){ if(n % 2 == 0){ count += n / 2; n = n / 2; }else{ count += (n - 1)/2; n = (n - 1)/2 + 1; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-255-Count-of-Matches-in-Tournament/",
    "relUrl": "/problem-255-Count-of-Matches-in-Tournament/"
  },"365": {
    "doc": "Reformat Phone Number",
    "title": "Reformat Phone Number",
    "content": "You are given a phone number as a string number. number consists of digits, spaces ‘ ‘, and/or dashes ‘-‘. You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows: . | 2 digits: A single block of length 2. | 3 digits: A single block of length 3. | 4 digits: Two blocks of length 2 each. The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2. | . Return the phone number after formatting. Example 1: . Input: number = \"1-23-45 6\" Output: \"123-456\" Explanation: The digits are \"123456\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\". Joining the blocks gives \"123-456\". Example 2: . Input: number = \"123 4-567\" Output: \"123-45-67\" Explanation: The digits are \"1234567\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\". Joining the blocks gives \"123-45-67\". Example 3: . Input: number = \"123 4-5678\" Output: \"123-456-78\" Explanation: The digits are \"12345678\". Step 1: The 1st block is \"123\". Step 2: The 2nd block is \"456\". Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\". Joining the blocks gives \"123-456-78\". Constraints: . | 2 &lt;= number.length &lt;= 100 | number consists of digits and the characters ‘-‘ and ‘ ‘. | There are at least two digits in number. | . Solution: . class Solution { public String reformatNumber(String number) { StringBuilder sb = new StringBuilder(); for(char c : number.toCharArray()){ if(c != '-' &amp;&amp; c != ' ') sb.append(c); } char[] chs = sb.toString().toCharArray(); sb.setLength(0); int i = 0; int d = 3; while(i &lt; chs.length){ if(i == chs.length - 4 || i == chs.length - 2){ d = 2; }else{ d = 3; } int k = i; while(i &lt; k + d &amp;&amp; i &lt; chs.length){ sb.append(chs[i]); i++; } if(i != chs.length) sb.append(\"-\"); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-256-Reformat%20Phone%20Number/",
    "relUrl": "/problem-256-Reformat Phone Number/"
  },"366": {
    "doc": "Number of Students Unable to Eat Lunch",
    "title": "Number of Students Unable to Eat Lunch",
    "content": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: . | If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue. | Otherwise, they will leave it and go to the queue’s end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. | . You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat. Example 1: . Input: students = [1,1,0,0], sandwiches = [0,1,0,1] Output: 0 Explanation: - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1]. - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0]. - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,1]. - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1]. - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = []. Hence all students are able to eat. Example 2: . Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] Output: 3 . Constraints: . | 1 &lt;= students.length, sandwiches.length &lt;= 100 | students.length == sandwiches.length | sandwiches[i] is 0 or 1. | students[i] is 0 or 1. | . Solution: . class Solution { public int countStudents(int[] students, int[] sandwiches) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for(int n : students) q.add(n); int c = q.size(); int i = 0; while(c &gt; 0){ int n = q.poll(); if(n == sandwiches[i]){ i++; c = q.size(); }else{ q.add(n); c--; } } return q.size(); } } . Array Implementation and faster . class Solution { public int countStudents(int[] students, int[] sandwiches) { int c0, c1; c0 = c1 = 0; for(int n : students){ if(n == 0) c0++; else c1++; } for(int n : sandwiches){ if(n == 0){ if(c0 == 0) break; c0--; }else{ if(c1 == 0) break; c1--; } } return c1 + c0; } } . ",
    "url": "https://1001anjan.github.io/problem-256-Number-of-Students-Unable-to-Eat-Lunch/",
    "relUrl": "/problem-256-Number-of-Students-Unable-to-Eat-Lunch/"
  },"367": {
    "doc": "Determine if String Halves Are Alike",
    "title": "Determine if String Halves Are Alike",
    "content": "You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels (‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘A’, ‘E’, ‘I’, ‘O’, ‘U’). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. Example 1: . Input: s = \"book\" Output: true Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. Example 2: . Input: s = \"textbook\" Output: false Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. Constraints: . | 2 &lt;= s.length &lt;= 1000 | s.length is even. | s consists of uppercase and lowercase letters. | . Solution . class Solution { public boolean halvesAreAlike(String s) { int c = 0; for(int i = 0; i &lt; s.length() / 2; i++){ if(isVowel(s.charAt(i))) c++; } for(int i = s.length() / 2; i &lt; s.length(); i++){ if(isVowel(s.charAt(i))) c--; } return c == 0; } public boolean isVowel(char c){ if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') return true; return false; } } . Faster execution approach . class Solution { public boolean halvesAreAlike(String s) { String s1 = s.substring(0, s.length() / 2); String s2 = s.substring(s.length() / 2); return helper(s1) == helper(s2); } private static int helper(String s) { int count = 0; for (char c : s.toCharArray()){ if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-257-Determine-if-String-Halves-Are-Alike/",
    "relUrl": "/problem-257-Determine-if-String-Halves-Are-Alike/"
  },"368": {
    "doc": "Calculate Money in Leetcode Bank",
    "title": "Calculate Money in Leetcode Bank",
    "content": "Hercy wants to save money for his first car. He puts money in the Leetcode bank every day. He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day. Example 1: . Input: n = 4 Output: 10 Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10. Example 2: . Input: n = 10 Output: 37 Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2. Example 3: . Input: n = 20 Output: 96 Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96. Constraints: . | 1 &lt;= n &lt;= 1000 | . https://leetcode.com/problems/calculate-money-in-leetcode-bank/ . Solution: . ",
    "url": "https://1001anjan.github.io/problem-258-Calculate-Money-in-Leetcode-Bank/",
    "relUrl": "/problem-258-Calculate-Money-in-Leetcode-Bank/"
  },"369": {
    "doc": "Group Anagrams",
    "title": "Group Anagrams",
    "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: . Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] . Example 2: . Input: strs = [\"\"] Output: [[\"\"]] . Example 3: . Input: strs = [\"a\"] Output: [[\"a\"]] . Constraints: . | 1 &lt;= strs.length &lt;= 104 | 0 &lt;= strs[i].length &lt;= 100 | strs[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { int[][] dp = new int[strs.length][26]; for(int i = 0; i &lt; strs.length; i++){ for(char ch : strs[i].toCharArray()){ dp[i][ch - 'a']++; } } List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); Set&lt;String&gt; used = new HashSet&lt;&gt;(); for(int i = 0; i &lt; strs.length; i++){ if(!used.add(strs[i])) continue; List&lt;String&gt; group = new ArrayList&lt;&gt;(); group.add(strs[i]); for(int j = i + 1; j &lt; dp.length; j++){ if(i == j) continue; int k = 0; while(k &lt; 26){ if(dp[i][k] != dp[j][k]) break; k++; } if(k == 26){ used.add(strs[j]); group.add(strs[j]); } } ans.add(group); } return ans; } } . class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if (strs == null || strs.length == 0) return new ArrayList&lt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String s : strs) { char[] ca = new char[26]; for (char c : s.toCharArray()) ca[c - 'a']++; String keyStr = String.valueOf(ca); if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;&gt;()); map.get(keyStr).add(s); } return new ArrayList&lt;&gt;(map.values()); } } . ",
    "url": "https://1001anjan.github.io/problem-26-Group%20Anagrams/",
    "relUrl": "/problem-26-Group Anagrams/"
  },"370": {
    "doc": "Path Sum",
    "title": "Path Sum",
    "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: . Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: . Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --&gt; 2): The sum is 3. (1 --&gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: . Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: . | The number of nodes in the tree is in the range [0, 5000]. | -1000 &lt;= Node.val &lt;= 1000 | -1000 &lt;= targetSum &lt;= 1000 | . Solution . Non-Recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if(root == null) return false; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); Map&lt;TreeNode, Relation&gt; map = new HashMap&lt;TreeNode, Relation&gt;(); stack.push(root); map.put(root, new Relation(null, root.val)); TreeNode ptr; int sum = 0; Relation rl; while(!stack.isEmpty()){ ptr = stack.pop(); rl = map.get(ptr); if(rl.parent != null){ sum = map.get(rl.parent).sumVal + ptr.val; }else{ sum = ptr.val; } if(ptr.left == null &amp;&amp; ptr.right == null &amp;&amp; sum == targetSum) return true; if(ptr.right != null) { stack.push(ptr.right); map.put(ptr.right,new Relation(ptr, sum+ptr.right.val)); } if(ptr.left != null) { stack.push(ptr.left); map.put(ptr.left,new Relation(ptr, sum+ptr.left.val)); } } return false; } } class Relation{ public TreeNode parent; public int sumVal; public Relation(TreeNode node, int val){ parent = node; sumVal = val; } } . Recursive . class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; return solve(root, targetSum); } public boolean solve(TreeNode root, int targetSum) { if (root == null) return false; if (root != null &amp;&amp; root.left == null &amp;&amp; root.right == null) { return (targetSum-root.val) == 0; } boolean a = solve(root.left, targetSum-root.val); boolean b = solve(root.right, targetSum-root.val); return a || b; } } . ",
    "url": "https://1001anjan.github.io/problem-26-Path-Sum/",
    "relUrl": "/problem-26-Path-Sum/"
  },"371": {
    "doc": "Decode XORed Array",
    "title": "Decode XORed Array",
    "content": "There is a hidden integer array arr that consists of n non-negative integers. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3]. You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0]. Return the original array arr. It can be proved that the answer exists and is unique. Example 1: . Input: encoded = [1,2,3], first = 1 Output: [1,0,2,1] Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] . Example 2: . Input: encoded = [6,2,7,3], first = 4 Output: [4,2,0,7,4] . Constraints: . | 2 &lt;= n &lt;= 104 | encoded.length == n - 1 | 0 &lt;= encoded[i] &lt;= 105 | 0 &lt;= first &lt;= 105 | . Solution: . class Solution { public int[] decode(int[] encoded, int first) { int[] ans = new int[encoded.length + 1]; ans[0] = first; for(int i = 1; i &lt; encoded.length + 1; i++){ ans[i] = ans[i - 1] ^ encoded[i - 1]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-259-Decode-XORed-Array/",
    "relUrl": "/problem-259-Decode-XORed-Array/"
  },"372": {
    "doc": "Find the Highest Altitude",
    "title": "Find the Highest Altitude",
    "content": "There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0. You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 &lt;= i &lt; n). Return the highest altitude of a point. Example 1: . Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. Example 2: . Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. Constraints: . | n == gain.length | 1 &lt;= n &lt;= 100 | -100 &lt;= gain[i] &lt;= 100 | . Solution: . class Solution { public int largestAltitude(int[] gain) { int max = 0; int curr = 0; for(int n : gain){ curr = curr + n; max = Math.max(max,curr); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-260-Find-the-Highest-Altitude/",
    "relUrl": "/problem-260-Find-the-Highest-Altitude/"
  },"373": {
    "doc": "Latest Time by Replacing Hidden Digits",
    "title": "Latest Time by Replacing Hidden Digits",
    "content": "You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?). The valid times are those inclusively between 00:00 and 23:59. Return the latest valid time you can get from time by replacing the hidden digits. Example 1: . Input: time = \"2?:?0\" Output: \"23:50\" Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50. Example 2: . Input: time = \"0?:3?\" Output: \"09:39\" . Example 3: . Input: time = \"1?:22\" Output: \"19:22\" . Constraints: . | time is in the format hh:mm. | It is guaranteed that you can produce a valid time from the given string. | . Solution: . class Solution { public String maximumTime(String t) { char[] time = t.toCharArray(); if(time[4]=='?'){ time[4]='9'; } if(time[3]=='?'){ time[3]='5'; } if(time[0]=='?'){ if(time[1]=='1'||time[1]=='2'||time[1]=='3'||time[1]=='0'){ time[0]='2'; } else if(time[1]=='?'){ time[0]='2'; }else{ time[0]='1'; } } if(time[1]=='?'){ if(time[0]=='0'){ time[1]='9'; } else if(time[0]=='1'){ time[1]='9'; }else if(time[0]=='2'){ time[1]='3'; } } return new String(time); } } . ",
    "url": "https://1001anjan.github.io/problem-262-Latest-Time-by-Replacing-Hidden-Digits/",
    "relUrl": "/problem-262-Latest-Time-by-Replacing-Hidden-Digits/"
  },"374": {
    "doc": "Maximum Number of Balls in a Box",
    "title": "Maximum Number of Balls in a Box",
    "content": "You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball’s number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1. Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls. Example 1: . Input: lowLimit = 1, highLimit = 10 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 2 1 1 1 1 1 1 1 1 0 0 ... Box 1 has the most number of balls with 2 balls. Example 2: . Input: lowLimit = 5, highLimit = 15 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 1 1 1 1 2 2 1 1 1 0 0 ... Boxes 5 and 6 have the most number of balls with 2 balls in each. Example 3: . Input: lowLimit = 19, highLimit = 28 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 12 ... Ball Count: 0 1 1 1 1 1 1 1 1 2 0 0 ... Box 10 has the most number of balls with 2 balls. Constraints: . | 1 &lt;= lowLimit &lt;= highLimit &lt;= 10^5 | . Solution: . class Solution { public int countBalls(int lowLimit, int highLimit) { Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); int max = 0; int key = getKey(lowLimit); m.put(key, 1); max = Math.max(max,m.get(key)); for(int i = lowLimit + 1; i &lt;= highLimit; i++){ if(i % 10 == 0){ key = getKey(i); }else{ key++; } m.put(key, m.getOrDefault(key,0) + 1); max = Math.max(max,m.get(key)); } return max; } public int getKey(int n){ int sum = 0; while(n &gt; 0){ sum += n%10; n = n / 10; } return sum; } } . Faster . /** INPUT :- 1 &lt;= lowLimit &lt;= highLimit &lt;= 10^5 so the max number of boxes that can be there are 99999 = 45. **/ class Solution { public int countBalls(int lowLimit, int highLimit) { int[] boxes = new int[46]; int max = 0; int key = getKey(lowLimit); boxes[key]++; max = Math.max(max,boxes[key]); for(int i = lowLimit + 1; i &lt;= highLimit; i++){ if(i % 10 == 0){ key = getKey(i); }else{ key++; } boxes[key]++; max = Math.max(max,boxes[key]); } return max; } public int getKey(int n){ int sum = 0; while(n &gt; 0){ sum += n%10; n = n / 10; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-263-Maximum-Number-of-Balls-in-a-Box/",
    "relUrl": "/problem-263-Maximum-Number-of-Balls-in-a-Box/"
  },"375": {
    "doc": "Sum of Unique Elements",
    "title": "Sum of Unique Elements",
    "content": "You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array. Return the sum of all the unique elements of nums. Example 1: . Input: nums = [1,2,3,2] Output: 4 Explanation: The unique elements are [1,3], and the sum is 4. Example 2: . Input: nums = [1,1,1,1,1] Output: 0 Explanation: There are no unique elements, and the sum is 0. Example 3: . Input: nums = [1,2,3,4,5] Output: 15 Explanation: The unique elements are [1,2,3,4,5], and the sum is 15. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int sumOfUnique(int[] nums) { int[] dp = new int[101]; for(int n : nums) dp[n]++; int sum = 0; int i = 0; for(int n : dp){ if(n == 1) sum += i; i++; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-264-Sum-of-Unique-Elements/",
    "relUrl": "/problem-264-Sum-of-Unique-Elements/"
  },"376": {
    "doc": "Check if Array Is Sorted and Rotated",
    "title": "Check if Array Is Sorted and Rotated",
    "content": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation. Example 1: . Input: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]. Example 2: . Input: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums. Example 3: . Input: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution . class Solution { public boolean check(int[] nums) { int i = 0; while(i &lt; nums.length - 1 &amp;&amp; nums[i] &lt;= nums[i + 1]) i++; if(i == nums.length - 1) return true; // may have rotated array if(nums[0] &lt; nums[nums.length - 1]) return false; i++; while(i &lt; nums.length - 1 &amp;&amp; nums[i] &lt;= nums[i + 1]) i++; if(i == nums.length - 1) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-265-Check-if-Array-Is-Sorted-and-Rotated/",
    "relUrl": "/problem-265-Check-if-Array-Is-Sorted-and-Rotated/"
  },"377": {
    "doc": "Minimum Changes To Make Alternating Binary String",
    "title": "Minimum Changes To Make Alternating Binary String",
    "content": "You are given a string s consisting only of the characters ‘0’ and ‘1’. In one operation, you can change any ‘0’ to ‘1’ or vice versa. The string is called alternating if no two adjacent characters are equal. For example, the string “010” is alternating, while the string “0100” is not. Return the minimum number of operations needed to make s alternating. Example 1: . Input: s = \"0100\" Output: 1 Explanation: If you change the last character to '1', s will be \"0101\", which is alternating. Example 2: . Input: s = \"10\" Output: 0 Explanation: s is already alternating. Example 3: . Input: s = \"1111\" Output: 2 Explanation: You need two operations to reach \"0101\" or \"1010\". Constraints: . | 1 &lt;= s.length &lt;= 10^4 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public int minOperations(String s) { int c1, c2; c1 = c2 = 0; boolean stc = true; for(char c : s.toCharArray()){ if(stc){ if(c == '0') c2++; else c1++; }else{ if(c == '0') c1++; else c2++; } stc = !stc; } return Math.min(c1,c2); } } . ",
    "url": "https://1001anjan.github.io/problem-266-Minimum-Changes-To-Make-Alternating-Binary-String/",
    "relUrl": "/problem-266-Minimum-Changes-To-Make-Alternating-Binary-String/"
  },"378": {
    "doc": "Merge Strings Alternately",
    "title": "Merge Strings Alternately",
    "content": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string. Example 1: . Input: word1 = \"abc\", word2 = \"pqr\" Output: \"apbqcr\" Explanation: The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r . Example 2: . Input: word1 = \"ab\", word2 = \"pqrs\" Output: \"apbqrs\" Explanation: Notice that as word2 is longer, \"rs\" is appended to the end. word1: a b word2: p q r s merged: a p b q r s . Example 3: . Input: word1 = \"abcd\", word2 = \"pq\" Output: \"apbqcd\" Explanation: Notice that as word1 is longer, \"cd\" is appended to the end. word1: a b c d word2: p q merged: a p b q c d . Constraints: . | 1 &lt;= word1.length, word2.length &lt;= 100 | word1 and word2 consist of lowercase English letters. | . Solution: . class Solution { public String mergeAlternately(String word1, String word2) { StringBuilder sb = new StringBuilder(); int i = 0, j = 0; boolean stc = true; while(i &lt; word1.length() &amp;&amp; j &lt; word2.length()){ if(stc){ sb.append(word1.charAt(i)); i++; }else{ sb.append(word2.charAt(j)); j++; } stc = !stc; } while(i &lt; word1.length()){ sb.append(word1.charAt(i)); i++; } while(j &lt; word2.length()){ sb.append(word2.charAt(j)); j++; } return sb.toString(); } } . Another way . class Solution { public String mergeAlternately(String word1, String word2) { int n=Math.max(word1.length(),word2.length()); StringBuilder res=new StringBuilder(); for(int i=0;i&lt;n;i++){ if(i&lt;word1.length())res.append(word1.charAt(i)); if(i&lt;word2.length())res.append(word2.charAt(i)); } return res.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-267-Merge-Strings-Alternately/",
    "relUrl": "/problem-267-Merge-Strings-Alternately/"
  },"379": {
    "doc": "Count Items Matching a Rule",
    "title": "Count Items Matching a Rule",
    "content": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue. The ith item is said to match the rule if one of the following is true: . | ruleKey == “type” and ruleValue == typei. | ruleKey == “color” and ruleValue == colori. | ruleKey == “name” and ruleValue == namei. Return the number of items that match the given rule. | . Example 1: . Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\" Output: 1 Explanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"]. Example 2: . Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\" Output: 2 Explanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match. Constraints: . | 1 &lt;= items.length &lt;= 10^4 | 1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10 | ruleKey is equal to either “type”, “color”, or “name”. | All strings consist only of lowercase letters. | . Solution: . class Solution { public int countMatches(List&lt;List&lt;String&gt;&gt; items, String ruleKey, String ruleValue) { int count = 0; for(List&lt;String&gt; list : items){ if(ruleKey.equals(\"type\")){ if(list.get(0).equals(ruleValue)) count++; }else if(ruleKey.equals(\"color\")){ if(list.get(1).equals(ruleValue)) count++; }else{ if(list.get(2).equals(ruleValue)) count++; } } return count; } } . class Solution { public int countMatches(List &lt; List &lt; String &gt;&gt; items, String ruleKey, String ruleValue) { int count = 0; int index = 0; switch (ruleKey) { case \"color\": { index = 1; break; } case \"type\": { index = 0; break; } case \"name\": { index = 2; break; } } for (List &lt; String &gt; item: items) { if (item.get(index).equals(ruleValue)) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-268-Count-Items-Matching-a-Rule/",
    "relUrl": "/problem-268-Count-Items-Matching-a-Rule/"
  },"380": {
    "doc": "Count Items Matching a Rule",
    "title": "Find Nearest Point That Has the Same X or Y Coordinate",
    "content": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location. Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1. The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2). Example 1: . Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] Output: 2 Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2. Example 2: . Input: x = 3, y = 4, points = [[3,4]] Output: 0 Explanation: The answer is allowed to be on the same location as your current location. Example 3: . Input: x = 3, y = 4, points = [[2,3]] Output: -1 Explanation: There are no valid points. Constraints: . | 1 &lt;= points.length &lt;= 104 | points[i].length == 2 | 1 &lt;= x, y, ai, bi &lt;= 104 | . Solution: . class Solution { public int nearestValidPoint(int x, int y, int[][] points) { int md = Integer.MAX_VALUE; int index = -1; int i = 0; for(int[] p : points){ if(p[0] == x || p[1] == y){ int d = Math.abs(x - p[0]) + Math.abs(y - p[1]); if(md &gt; d){ md = d; index = i; } } i++; } return index; } } . Faster by nature . class Solution { public int nearestValidPoint(int x, int y, int[][] points) { int md = Integer.MAX_VALUE; int index = -1; for(int i = 0; i &lt; points.length; i++){ if(points[i][0] == x || points[i][1] == y){ int d = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); if(md &gt; d){ md = d; index = i; } } } return index; } } . ",
    "url": "https://1001anjan.github.io/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/#find-nearest-point-that-has-the-same-x-or-y-coordinate",
    "relUrl": "/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/#find-nearest-point-that-has-the-same-x-or-y-coordinate"
  },"381": {
    "doc": "Count Items Matching a Rule",
    "title": "Count Items Matching a Rule",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/",
    "relUrl": "/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/"
  },"382": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle",
    "content": "Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] . Example 2: . Input: numRows = 1 Output: [[1]] . Constraints: . 1 &lt;= numRows &lt;= 30 . ",
    "url": "https://1001anjan.github.io/problem-27-Pascal-Triangle/#pascals-triangle",
    "relUrl": "/problem-27-Pascal-Triangle/#pascals-triangle"
  },"383": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-27-Pascal-Triangle/",
    "relUrl": "/problem-27-Pascal-Triangle/"
  },"384": {
    "doc": "Pow(x, n)",
    "title": "Pow(x, n)",
    "content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: . Input: x = 2.00000, n = 10 Output: 1024.00000 . Example 2: . Input: x = 2.10000, n = 3 Output: 9.26100 . Example 3: . Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 . Constraints: . | -100.0 &lt; x &lt; 100.0 | -2^31 &lt;= n &lt;= 2^31-1 | n is an integer. | -10^4 &lt;= x^n &lt;= 10^4 | . Solution: . class Solution { public double myPow(double x, int n) { if(n &lt; 0){ n = -n; x = 1/x; } if(n == 0) return 1; double pow = 1; while(n &gt; 0){ if((n &amp; 1) != 0){ pow *= x; } x *= x; n &gt;&gt;&gt;= 1; } return pow; } } . Logic: . n order to improve efficiency we will opt for Binary Exponentiation using which we can calculate xn using O log2(N) multiplications. Basic Idea is to divide the work using binary representation of exponents i.e. is to keep multiplying pow with x, if the bit is odd, and multiplying x with itself until we get 0 We will use very 1st example of 1st Approach i.e. x = 7, n = 11 and pow = 1 Here, we have to calculate 711 Binary of n i.e. (11)10 is (1011)2 1 0 1 1 23 22 21 20 &lt;– Corresponding place values of each bit . OR we can also write this as 1 0 1 1 8 4 2 1 &lt;– Corresponding place values of each bit . Now, 78 × 72 × 71 == 711 as 7(8 + 2 + 1) == 711 NOTE: We have not considered 74 in this case as the 4th place bit is OFF . So, 78 × 72 × 71 == 5764801 × 49 × 7 == 1977326743 &lt;– Desired Output Now, applying logic keeping this concept in mind . double pow = 1; while(n != 0){ if((n &amp; 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd pow *= x; x *= x; n &gt;&gt;&gt;= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2 } . PROCESS . Iteration 1 pow = 1 × 7 = 7 x = 7 × 7 = 49 n = 11 »&gt; 1 = 5 . Iteration 2 pow = 7 × 49 = 343 x = 49 × 49 = 2401 n = 5 »&gt; 1 = 2 . Iteration 3 x = 2401 × 2401 = 5764801 n = 2 »&gt; 1 = 1 . Iteration 4 pow = 343 × 5764801 = 1977326743 x = 5764801 × 5764801 = 3.323293057 × 10¹³ n = 1 »&gt; 1 = 0 . We exit the loop as the number has become 0 and we got pow as 1977326743 which is the desired output In this binary exponentiation approach, the loop iterated for only 4 times which is nothing but (O log2(N) + 1) ~ (O log2(N)) . And for 2nd example of 1st Approach where x = 1 and n = 2147483647 This loop executed for only 31 times (O log2(N)) which is far far less than 2147483647 times(in case of O(N) approach) . ",
    "url": "https://1001anjan.github.io/problem-27-Pow(x,%20n)/",
    "relUrl": "/problem-27-Pow(x, n)/"
  },"385": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if Binary String Has at Most One Segment of Ones",
    "content": "Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false. Example 1: . Input: s = \"1001\" Output: false Explanation: The ones do not form a contiguous segment. Example 2: . Input: s = \"110\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘0’ or ‘1’. | s[0] is ‘1’ | . Solution: . Just increase the count when 0 comes, and when we get 1, check the value of count, if is not 0, return false . class Solution { public boolean checkOnesSegment(String s) { boolean consecOne = true; int count = 0; for(char c: s.toCharArray()){ if(c == '0') count++; else { if(count != 0) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-270-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/",
    "relUrl": "/problem-270-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"
  },"386": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if One String Swap Can Make Strings Equal",
    "content": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false. Example 1: . Input: s1 = \"bank\", s2 = \"kanb\" Output: true Explanation: For example, swap the first character with the last character of s2 to make \"bank\". Example 2: . Input: s1 = \"attack\", s2 = \"defend\" Output: false Explanation: It is impossible to make them equal with one string swap. Example 3: . Input: s1 = \"kelb\", s2 = \"kelb\" Output: true Explanation: The two strings are already equal, so no string swap operation is required. Constraints: . | 1 &lt;= s1.length, s2.length &lt;= 100 | s1.length == s2.length | s1 and s2 consist of only lowercase English letters. | . Solution: . class Solution { public boolean areAlmostEqual(String s1, String s2) { List&lt;Integer&gt; indexs = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; s1.length(); i++){ if(s1.charAt(i) != s2.charAt(i)){ indexs.add(i); } if(indexs.size() &gt; 2) return false; } if(indexs.size() == 0) return true; if(indexs.size() == 1) return false; return s1.charAt(indexs.get(0)) == s2.charAt(indexs.get(1)) &amp;&amp; s1.charAt(indexs.get(1)) == s2.charAt(indexs.get(0)); } } . ####### Another way . class Solution { public boolean areAlmostEqual(String s1, String s2) { if(s1.equals(s2)) return true; List&lt;Integer&gt; indexs = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; s1.length(); i++){ if(s1.charAt(i) != s2.charAt(i)){ indexs.add(i); } if(indexs.size() &gt; 2) return false; } if(indexs.size() == 2){ return s1.charAt(indexs.get(0)) == s2.charAt(indexs.get(1)) &amp;&amp; s1.charAt(indexs.get(1)) == s2.charAt(indexs.get(0)); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/#check-if-one-string-swap-can-make-strings-equal",
    "relUrl": "/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/#check-if-one-string-swap-can-make-strings-equal"
  },"387": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if Binary String Has at Most One Segment of Ones",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/",
    "relUrl": "/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/"
  },"388": {
    "doc": "Find Center of Star Graph",
    "title": "Find Center of Star Graph",
    "content": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node. You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph. Example 1: . Input: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. Example 2: . Input: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 . Constraints: . | 3 &lt;= n &lt;= 10^5 | edges.length == n - 1 | edges[i].length == 2 | 1 &lt;= ui, vi &lt;= n | ui != vi | The given edges represent a valid star graph. | . Solution: . class Solution { public int findCenter(int[][] edges) { if(edges[0][0] == edges[1][0]) return edges[0][0]; if(edges[0][0] == edges[1][1]) return edges[0][0]; if(edges[0][1] == edges[1][0]) return edges[0][1]; if(edges[0][1] == edges[1][1]) return edges[0][1]; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-272-Find-Center-of-Star-Graph/",
    "relUrl": "/problem-272-Find-Center-of-Star-Graph/"
  },"389": {
    "doc": "Second Largest Digit in a String",
    "title": "Second Largest Digit in a String",
    "content": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist. An alphanumeric string is a string consisting of lowercase English letters and digits. Example 1: . Input: s = \"dfa12321afd\" Output: 2 Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2. Example 2: . Input: s = \"abc1111\" Output: -1 Explanation: The digits that appear in s are [1]. There is no second largest digit. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters and/or digits. | . Solution: . class Solution { public int secondHighest(String s) { boolean[] d = new boolean[10]; for(char c : s.toCharArray()){ if(!Character.isLetter(c)){ d[c - '0'] = true; } } int i = 9; while(i &gt;= 0 &amp;&amp; !d[i]) i--; if(i == 0 || i == -1) return -1; i--; while(i &gt;= 0 &amp;&amp; !d[i]) i--; return i; } } . naturally faster approach . class Solution { public int secondHighest(String s) { int first = -1; int second = -1; for(char c : s.toCharArray()) { if(c &gt;= '0' &amp;&amp; c &lt;= '9') { int num = c - '0'; if(num &gt; first) { second = first; first = num; } else if(num &gt; second &amp;&amp; num &lt; first) { second = num; } } } return second; } } . ",
    "url": "https://1001anjan.github.io/problem-273-Second-Largest-Digit-in-a-String/",
    "relUrl": "/problem-273-Second-Largest-Digit-in-a-String/"
  },"390": {
    "doc": "Maximum Ascending Subarray Sum",
    "title": "Maximum Ascending Subarray Sum",
    "content": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, …, numsr-1, numsr] is ascending if for all i where l &lt;= i &lt; r, numsi &lt; numsi+1. Note that a subarray of size 1 is ascending. Example 1: . Input: nums = [10,20,30,5,10,50] Output: 65 Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. Example 2: . Input: nums = [10,20,30,40,50] Output: 150 Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150. Example 3: . Input: nums = [12,17,15,13,10,11,12] Output: 33 Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int maxAscendingSum(int[] nums) { int max = -1; int curr = nums[0]; for(int i = 1; i &lt;nums.length; i++){ if(nums[i - 1] &lt; nums[i]){ curr += nums[i]; }else{ max = Math.max(max,curr); curr = nums[i]; } } return Math.max(max,curr); } } . ",
    "url": "https://1001anjan.github.io/problem-274-Maximum-Ascending-Subarray-Sum/",
    "relUrl": "/problem-274-Maximum-Ascending-Subarray-Sum/"
  },"391": {
    "doc": "Number of Different Integers in a String",
    "title": "Number of Different Integers in a String",
    "content": "You are given a string word that consists of digits and lowercase English letters. You will replace every non-digit character with a space. For example, “a123bc34d8ef34” will become “ 123 34 8 34”. Notice that you are left with some integers that are separated by at least one space: “123”, “34”, “8”, and “34”. Return the number of different integers after performing the replacement operations on word. Two integers are considered different if their decimal representations without any leading zeros are different. Example 1: . Input: word = \"a123bc34d8ef34\" Output: 3 Explanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once. Example 2: . Input: word = \"leet1234code234\" Output: 2 . Example 3: . Input: word = \"a1b01c001\" Output: 1 Explanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because the leading zeros are ignored when comparing their decimal values. Constraints: . | 1 &lt;= word.length &lt;= 1000 | word consists of digits and lowercase English letters. | . Solution: . class Solution { public int numDifferentIntegers(String word) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; word.length(); i++){ char c = word.charAt(i); if(!Character.isLetter(c)){ sb.append(c); }else{ if(sb.length() != 0) s.add(filterString(sb)); sb.setLength(0); } } if(sb.length() != 0) s.add(filterString(sb)); return s.size(); } public String filterString(StringBuilder str){ if(str.charAt(0) != '0') return str.toString(); int i = 0; int n = str.length(); while(i &lt; n &amp;&amp; str.charAt(i) == '0') i++; if(i == n) return \"0\"; return str.substring(i,n).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-275-Number-of-Different-Integers-in-a-String/",
    "relUrl": "/problem-275-Number-of-Different-Integers-in-a-String/"
  },"392": {
    "doc": "Determine Color of a Chessboard Square",
    "title": "Determine Color of a Chessboard Square",
    "content": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return true if the square is white, and false if the square is black. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. Example 1: . Input: coordinates = \"a1\" Output: false Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false. Example 2: . Input: coordinates = \"h3\" Output: true Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true. Example 3: . Input: coordinates = \"c7\" Output: false . Constraints: . | coordinates.length == 2 | ‘a’ &lt;= coordinates[0] &lt;= ‘h’ | ‘1’ &lt;= coordinates[1] &lt;= ‘8’ | . Solution: . class Solution { public boolean squareIsWhite(String coordinates) { return (getRefvalue(coordinates.charAt(0)) ^ ((coordinates.charAt(1) - '0')%2)) == 1; } public int getRefvalue(char c){ switch(c){ case 'a','c','e','g': return 1; default: return 0; } } } . Another way . class Solution { public boolean squareIsWhite(String coordinates) { int coord = coordinates.charAt(0) - 97 + coordinates.charAt(1) - 48; return coord % 2 == 0 ? true : false; } } . ",
    "url": "https://1001anjan.github.io/problem-276-Determine-Color-of-a-Chessboard-Square/",
    "relUrl": "/problem-276-Determine-Color-of-a-Chessboard-Square/"
  },"393": {
    "doc": "Truncate Sentence",
    "title": "Truncate Sentence",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation). For example, “Hello World”, “HELLO”, and “hello world hello world” are all sentences. You are given a sentence s and an integer k. You want to truncate s such that it contains only the first k words. Return s after truncating it. Example 1: . Input: s = \"Hello how are you Contestant\", k = 4 Output: \"Hello how are you\" Explanation: The words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]. The first 4 words are [\"Hello\", \"how\", \"are\", \"you\"]. Hence, you should return \"Hello how are you\". Example 2: . Input: s = \"What is the solution to this problem\", k = 4 Output: \"What is the solution\" Explanation: The words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]. The first 4 words are [\"What\", \"is\", \"the\", \"solution\"]. Hence, you should return \"What is the solution\". Example 3: . Input: s = \"chopper is not a tanuki\", k = 5 Output: \"chopper is not a tanuki\" . Constraints: . | 1 &lt;= s.length &lt;= 500 | k is in the range [1, the number of words in s]. | s consist of only lowercase and uppercase English letters and spaces. | The words in s are separated by a single space. | There are no leading or trailing spaces. | . Solution: . class Solution { public String truncateSentence(String s, int k) { String[] wrd = s.split(\" \"); int i = 0; StringBuilder sb = new StringBuilder(); do{ sb.append(wrd[i]).append(\" \"); i++; }while(i &lt; k &amp;&amp; i &lt; wrd.length); return sb.substring(0,sb.length() - 1).toString(); } } . ####### Naturally faster . class Solution { public String truncateSentence(String s, int k) { StringBuilder sb = new StringBuilder(); int countSpaces = 0; for(char curr : s.toCharArray()) { if(curr == ' ') { countSpaces++; } if(countSpaces == k) break; sb.append(curr); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-277-Truncate-Sentence/",
    "relUrl": "/problem-277-Truncate-Sentence/"
  },"394": {
    "doc": "Sign of the Product of an Array",
    "title": "Sign of the Product of an Array",
    "content": "There is a function signFunc(x) that returns: . | 1 if x is positive. | -1 if x is negative. | 0 if x is equal to 0. You are given an integer array nums. Let product be the product of all values in the array nums. | . Return signFunc(product). Example 1: . Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 . Example 2: . Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 . Example 3: . Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int arraySign(int[] nums) { boolean sign = true; for(int n : nums){ if(n == 0) return 0; else if(n &lt; 0) sign = !sign; } return sign == true? 1 : -1; } } . ",
    "url": "https://1001anjan.github.io/problem-278-Sign-of-the-Product-of-an-Array/",
    "relUrl": "/problem-278-Sign-of-the-Product-of-an-Array/"
  },"395": {
    "doc": "Minimum Operations to Make the Array Increasing",
    "title": "Minimum Operations to Make the Array Increasing",
    "content": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1. For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3]. Return the minimum number of operations needed to make nums strictly increasing. An array nums is strictly increasing if nums[i] &lt; nums[i+1] for all 0 &lt;= i &lt; nums.length - 1. An array of length 1 is trivially strictly increasing. Example 1: . Input: nums = [1,1,1] Output: 3 Explanation: You can do the following operations: 1) Increment nums[2], so nums becomes [1,1,2]. 2) Increment nums[1], so nums becomes [1,2,2]. 3) Increment nums[2], so nums becomes [1,2,3]. Example 2: . Input: nums = [1,5,2,4,1] Output: 14 . Example 3: . Input: nums = [8] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 5000 | 1 &lt;= nums[i] &lt;= 10^4 | . Solution: . class Solution { public int minOperations(int[] nums) { int opt = 0; for(int i = 1; i &lt; nums.length; i++){ if(nums[i - 1] &gt;= nums[i]){ opt += nums[i - 1] - nums[i] + 1; nums[i] = nums[i - 1] + 1; } } return opt; } } . ",
    "url": "https://1001anjan.github.io/problem-279-Minimum-Operations-to-Make-the-Array-Increasing/",
    "relUrl": "/problem-279-Minimum-Operations-to-Make-the-Array-Increasing/"
  },"396": {
    "doc": "Maximum Subarray",
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the subarray which has the largest sum and return its sum. Example 1: . Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: . Input: nums = [1] Output: 1 . Example 3: . Input: nums = [5,4,-1,7,8] Output: 23 . Constraints: . | 1 &lt;= nums.length &lt;= 10^5 | -10^4 &lt;= nums[i] &lt;= 10^4 | . Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Solution: . class Solution { public int maxSubArray(int[] nums) { int maxSum = nums[0]; int currSum = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if(currSum + nums[i] &lt; nums[i]){ currSum = nums[i]; }else{ currSum += nums[i]; } maxSum = Math.max(maxSum,currSum); } return Math.max(maxSum,currSum); } } . class Solution { public int maxSubArray(int[] nums) { return divideAndConquer(nums, 0, nums.length - 1); } public int divideAndConquer(int[] arr, int l, int u){ if( l &gt; u) return Integer.MIN_VALUE; if(l == u) return arr[l]; int m = (l + u)/2; /* Return maximum of following three possible cases: a) Maximum subarray sum in left half b) Maximum subarray sum in right half c) Maximum subarray sum such that the subarray crosses the midpoint */ return Math.max(Math.max(divideAndConquer(arr, l, m - 1), divideAndConquer(arr, m + 1, u)), maximumCrossing(arr, l, m, u)); } public int maximumCrossing(int[] arr, int l, int m, int u){ int sum = 0; int leftSum = Integer.MIN_VALUE; for(int i = m; i &gt;= l; i--){ sum += arr[i]; if(sum &gt; leftSum) leftSum = sum; } sum = 0; int rightSum = Integer.MIN_VALUE; for(int i = m; i &lt;= u; i++){ sum += arr[i]; if(sum &gt; rightSum) rightSum = sum; } return Math.max(leftSum + rightSum - arr[m], Math.max(leftSum, rightSum)); } } . ",
    "url": "https://1001anjan.github.io/problem-28-Maximum%20Subarray/",
    "relUrl": "/problem-28-Maximum Subarray/"
  },"397": {
    "doc": "Valid Palindrome",
    "title": "Valid Palindrome",
    "content": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: . Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: . Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: . Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: . | 1 &lt;= s.length &lt;= 2 * 105 | s consists only of printable ASCII characters. | . Solution . class Solution { public boolean isPalindrome(String s) { StringBuffer sb = new StringBuffer(); s = s.toLowerCase().trim(); for(int i=0; i&lt;s.length(); i++){ if(Character.isLetter(s.charAt(i)) || Character.isDigit(s.charAt(i))) sb.append(s.charAt(i)); } String str = sb.toString(); if(str.equals(\" \")) return true; return str.equals(sb.reverse().toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-27-Valid-Palindrome/",
    "relUrl": "/problem-27-Valid-Palindrome/"
  },"398": {
    "doc": "Check if the Sentence Is Pangram",
    "title": "Check if the Sentence Is Pangram",
    "content": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise. Example 1: . Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\" Output: true Explanation: sentence contains at least one of every letter of the English alphabet. Example 2: . Input: sentence = \"leetcode\" Output: false . Constraints: . | 1 &lt;= sentence.length &lt;= 1000 | sentence consists of lowercase English letters. | . Solution: . class Solution { public boolean checkIfPangram(String sentence) { Set&lt;Character&gt; s = new HashSet(); for(char c : sentence.toCharArray()){ s.add(c); } return s.size() == 26; } } . Execution wise faster . class Solution { public boolean checkIfPangram(String sentence) { boolean[] dp = new boolean[26]; for(char c : sentence.toCharArray()){ dp[c - 'a'] = true; } for(boolean d : dp){ if(!d) return false; } return true; } } . Even faster execution . class Solution { public boolean checkIfPangram(String sentence) { if(sentence.length() &lt; 26){ return false; } else{ String str = \"abcdefghijklmnopqrstuvwxyz\"; for(int i=0;i &lt; str.length();i++){ if(sentence.indexOf(str.charAt(i)) == -1){ return false; } } return true; } } } . ",
    "url": "https://1001anjan.github.io/problem-280-Check-if-the-Sentence-Is-Pangram/",
    "relUrl": "/problem-280-Check-if-the-Sentence-Is-Pangram/"
  },"399": {
    "doc": "Sum of Digits in Base K",
    "title": "Sum of Digits in Base K",
    "content": "Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k. After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10. Example 1: . Input: n = 34, k = 6 Output: 9 Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9. Example 2: . Input: n = 10, k = 10 Output: 1 Explanation: n is already in base 10. 1 + 0 = 1. Constraints: . | 1 &lt;= n &lt;= 100 | 2 &lt;= k &lt;= 10 | . Solution: . class Solution { public int sumBase(int n, int k) { int sum = 0; while(n &gt; 0){ sum += n % k; n = n / k; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-281-Sum-of-Digits-in-Base-K/",
    "relUrl": "/problem-281-Sum-of-Digits-in-Base-K/"
  },"400": {
    "doc": "Replace All Digits with Characters",
    "title": "Replace All Digits with Characters",
    "content": "You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices. There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c. For example, shift(‘a’, 5) = ‘f’ and shift(‘x’, 0) = ‘x’. For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]). Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed ‘z’. Example 1: . Input: s = \"a1c1e1\" Output: \"abcdef\" Explanation: The digits are replaced as follows: - s[1] -&gt; shift('a',1) = 'b' - s[3] -&gt; shift('c',1) = 'd' - s[5] -&gt; shift('e',1) = 'f' . Example 2: . Input: s = \"a1b2c3d4e\" Output: \"abbdcfdhe\" Explanation: The digits are replaced as follows: - s[1] -&gt; shift('a',1) = 'b' - s[3] -&gt; shift('b',2) = 'd' - s[5] -&gt; shift('c',3) = 'f' - s[7] -&gt; shift('d',4) = 'h' . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists only of lowercase English letters and digits. | shift(s[i-1], s[i]) &lt;= ‘z’ for all odd indices i. | . Solution . class Solution { public String replaceDigits(String s) { StringBuilder sb = new StringBuilder(); sb.append(s); for(int i = 1; i &lt; sb.length(); i = i + 2){ sb.setCharAt(i,(char)(sb.charAt(i - 1) + (sb.charAt(i) - '0'))); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-281-Replace-All-Digits-with-Characters/",
    "relUrl": "/problem-281-Replace-All-Digits-with-Characters/"
  },"401": {
    "doc": "Minimum Distance to the Target Element",
    "title": "Minimum Distance to the Target Element",
    "content": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x. Return abs(i - start). It is guaranteed that target exists in nums. Example 1: . Input: nums = [1,2,3,4,5], target = 5, start = 3 Output: 1 Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1. Example 2: . Input: nums = [1], target = 1, start = 0 Output: 0 Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0. Example 3: . Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0 Output: 0 Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 104 | 0 &lt;= start &lt; nums.length | target is in nums. | . Solution: . class Solution { public int getMinDistance(int[] nums, int target, int start) { int i, j; i = j = start; while(i &gt;= 0 &amp;&amp; j &lt; nums.length){ if(nums[j] == target) return j - start; if(nums[i] == target) return start - i; j++; i--; } while(i &gt;= 0){ if(nums[i] == target) return start - i; i--; } while(j &lt; nums.length){ if(nums[j] == target) return j - start; j++; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-283-Minimum-Distance-to-the-Target-Element/",
    "relUrl": "/problem-283-Minimum-Distance-to-the-Target-Element/"
  },"402": {
    "doc": "Maximum-Population-Year",
    "title": "Maximum Population Year",
    "content": "You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person. The population of some year x is the number of people alive during that year. The ith person is counted in year x’s population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die. Return the earliest year with the maximum population. Example 1: . Input: logs = [[1993,1999],[2000,2010]] Output: 1993 Explanation: The maximum population is 1, and 1993 is the earliest year with this population. Example 2: . Input: logs = [[1950,1961],[1960,1971],[1970,1981]] Output: 1960 Explanation: The maximum population is 2, and it had happened in years 1960 and 1970. The earlier year between them is 1960. Constraints: . | 1 &lt;= logs.length &lt;= 100 | 1950 &lt;= birthi &lt; deathi &lt;= 2050 | . Solution . class Solution { public int maximumPopulation(int[][] logs) { int[] years = new int[101]; for(int[] p : logs){ years[p[0] - 1950]++; years[p[1] - 1950]--; } int max = Integer.MIN_VALUE; int y = 0; int curr = 0; for(int i = 0; i &lt; 101; i++) { curr += years[i]; if(curr &gt; max) { max = curr; y = i + 1950; } } return y; } } . ",
    "url": "https://1001anjan.github.io/problem-284-Maximum-Population-Year/#maximum-population-year",
    "relUrl": "/problem-284-Maximum-Population-Year/#maximum-population-year"
  },"403": {
    "doc": "Maximum-Population-Year",
    "title": "Maximum-Population-Year",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-284-Maximum-Population-Year/",
    "relUrl": "/problem-284-Maximum-Population-Year/"
  },"404": {
    "doc": "Sorting the Sentence",
    "title": "Sorting the Sentence",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters. A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence. | For example, the sentence “This is a sentence” can be shuffled as “sentence4 a3 is2 This1” or “is2 sentence4 This1 a3”. Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence. | . Example 1: . Input: s = \"is2 sentence4 This1 a3\" Output: \"This is a sentence\" Explanation: Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers. Example 2: . Input: s = \"Myself2 Me1 I4 and3\" Output: \"Me Myself and I\" Explanation: Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers. Constraints: . | 2 &lt;= s.length &lt;= 200 | s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9. | The number of words in s is between 1 and 9. | The words in s are separated by a single space. | s contains no leading or trailing spaces. | . Solution: . class Solution { public String sortSentence(String s) { // Since we have only 10 words String[] words = new String[10]; String[] w = s.split(\" \"); for(String str : w){ int n = str.length() - 1; int i = str.charAt(n) - '0'; words[i] = str.substring(0,n); } StringBuilder sb = new StringBuilder(); for(String str : words){ if(str != null) sb.append(str).append(\" \"); } return sb.substring(0,sb.length() - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-285-Sorting-the-Sentence/",
    "relUrl": "/problem-285-Sorting-the-Sentence/"
  },"405": {
    "doc": "Longer Contiguous Segments of Ones than Zeros",
    "title": "Longer Contiguous Segments of Ones than Zeros",
    "content": "Given a binary string s, return true if the longest contiguous segment of 1’s is strictly longer than the longest contiguous segment of 0’s in s, or return false otherwise. | For example, in s = “110100010” the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3. Note that if there are no 0’s, then the longest continuous segment of 0’s is considered to have a length 0. The same applies if there is no 1’s. | . Example 1: . Input: s = \"1101\" Output: true Explanation: The longest contiguous segment of 1s has length 2: \"1101\" The longest contiguous segment of 0s has length 1: \"1101\" The segment of 1s is longer, so return true. Example 2: . Input: s = \"111000\" Output: false Explanation: The longest contiguous segment of 1s has length 3: \"111000\" The longest contiguous segment of 0s has length 3: \"111000\" The segment of 1s is not longer, so return false. Example 3: . Input: s = \"110100010\" Output: false Explanation: The longest contiguous segment of 1s has length 2: \"110100010\" The longest contiguous segment of 0s has length 3: \"110100010\" The segment of 1s is not longer, so return false. Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public boolean checkZeroOnes(String s) { int n = s.length(); if(n == 1) return s.charAt(0) == '1'; return longestSegmentLen(s,'1') &gt; longestSegmentLen(s,'0'); } public int longestSegmentLen(String s, char ch){ int max = 0; char prev = s.charAt(0); int crr = prev == ch? 1 : 0; for(int i = 1; i &lt; s.length(); i++){ char now = s.charAt(i); if(prev == ch &amp;&amp; prev == now) crr++; else{ max = Math.max(max,crr); crr = 1; } prev = now; } return Math.max(max,crr); } } . Single pass . class Solution { public boolean checkZeroOnes(String s) { int n = s.length(); if(n == 1) return s.charAt(0) == '1'; int zeros = 0, ones = 0, zMax = -1, oMax = -1; for (int i = 0; i &lt; n - 1; i++) { if (s.charAt(i) == s.charAt(i+1)) { if (s.charAt(i) == '0') zeros++; else ones++; } else { zMax = Integer.max(zeros, zMax); oMax = Integer.max(ones, oMax); zeros = 0; ones = 0; } } zMax = Integer.max(zeros, zMax); oMax = Integer.max(ones, oMax); return oMax &gt; zMax; } } . ",
    "url": "https://1001anjan.github.io/problem-286-Longer-Contiguous-Segments-of-Ones-than-Zeros/",
    "relUrl": "/problem-286-Longer-Contiguous-Segments-of-Ones-than-Zeros/"
  },"406": {
    "doc": "Substrings of Size Three with Distinct Characters",
    "title": "Substrings of Size Three with Distinct Characters",
    "content": "A string is good if there are no repeated characters. Given a string s, return the number of good substrings of length three in s. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A substring is a contiguous sequence of characters in a string. Example 1: . Input: s = \"xyzzaz\" Output: 1 Explanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". The only good substring of length 3 is \"xyz\". Example 2: . Input: s = \"aababcabc\" Output: 4 Explanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\". The good substrings are \"abc\", \"bca\", \"cab\", and \"abc\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | . Solution . class Solution { public int countGoodSubstrings(String s) { if(s.length() &lt; 3) return 0; char prev, now, next; prev = s.charAt(0); now = s.charAt(1); int c = 0; for(int i = 1; i &lt; s.length() - 1; i++){ next = s.charAt(i + 1); if(prev != now &amp;&amp; prev != next &amp;&amp; now != next) c++; prev = now; now = next; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-287-Substrings-of-Size-Three-with-Distinct-Characters/",
    "relUrl": "/problem-287-Substrings-of-Size-Three-with-Distinct-Characters/"
  },"407": {
    "doc": "Check if All the Integers in a Range Are Covered",
    "title": "Check if All the Integers in a Range Are Covered",
    "content": "You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi. Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise. An integer x is covered by an interval ranges[i] = [starti, endi] if starti &lt;= x &lt;= endi. Example 1: . Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5 Output: true Explanation: Every integer between 2 and 5 is covered: - 2 is covered by the first range. - 3 and 4 are covered by the second range. - 5 is covered by the third range. Example 2: . Input: ranges = [[1,10],[10,20]], left = 21, right = 21 Output: false Explanation: 21 is not covered by any range. Constraints: . | 1 &lt;= ranges.length &lt;= 50 | 1 &lt;= starti &lt;= endi &lt;= 50 | 1 &lt;= left &lt;= right &lt;= 50 | . Solution: . class Solution { public boolean isCovered(int[][] ranges, int left, int right) { boolean[] all = new boolean[51]; for(int[] arr : ranges){ for(int i = arr[0]; i &lt;= arr[1]; i++) all[i] = true; } while(left &lt;= right){ if(!all[left]) return false; left++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-288-Check-if-All-the-Integers-in-a-Range-Are-Covered/",
    "relUrl": "/problem-288-Check-if-All-the-Integers-in-a-Range-Are-Covered/"
  },"408": {
    "doc": "Check if Word Equals Summation of Two Words",
    "title": "Check if Word Equals Summation of Two Words",
    "content": "The letter value of a letter is its position in the alphabet starting from 0 (i.e. ‘a’ -&gt; 0, ‘b’ -&gt; 1, ‘c’ -&gt; 2, etc.). The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer. | For example, if s = “acb”, we concatenate each letter’s letter value, resulting in “021”. After converting it, we get 21. You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters ‘a’ through ‘j’ inclusive. | . Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise. Example 1: . Input: firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\" Output: true Explanation: The numerical value of firstWord is \"acb\" -&gt; \"021\" -&gt; 21. The numerical value of secondWord is \"cba\" -&gt; \"210\" -&gt; 210. The numerical value of targetWord is \"cdb\" -&gt; \"231\" -&gt; 231. We return true because 21 + 210 == 231. Example 2: . Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\" Output: false Explanation: The numerical value of firstWord is \"aaa\" -&gt; \"000\" -&gt; 0. The numerical value of secondWord is \"a\" -&gt; \"0\" -&gt; 0. The numerical value of targetWord is \"aab\" -&gt; \"001\" -&gt; 1. We return false because 0 + 0 != 1. Example 3: . Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\" Output: true Explanation: The numerical value of firstWord is \"aaa\" -&gt; \"000\" -&gt; 0. The numerical value of secondWord is \"a\" -&gt; \"0\" -&gt; 0. The numerical value of targetWord is \"aaaa\" -&gt; \"0000\" -&gt; 0. We return true because 0 + 0 == 0. Constraints: . | 1 &lt;= firstWord.length, secondWord.length, targetWord.length &lt;= 8 | firstWord, secondWord, and targetWord consist of lowercase English letters from ‘a’ to ‘j’ inclusive. | . Solution . class Solution { public boolean isSumEqual(String firstWord, String secondWord, String targetWord) { return parseString(firstWord) + parseString(secondWord) == parseString(targetWord); } public int parseString(String s){ int value = 0; int i = 0; int n = s.length(); // ignoring 'a' s while(i &lt; n &amp;&amp; s.charAt(i) == 'a') i++; while(i &lt; n){ value = value * 10 + (s.charAt(i) - 'a'); i++; } return value; } } . ",
    "url": "https://1001anjan.github.io/problem-289-Check-if-Word-Equals-Summation-of-Two-Words/",
    "relUrl": "/problem-289-Check-if-Word-Equals-Summation-of-Two-Words/"
  },"409": {
    "doc": "Single Number",
    "title": "Single Number",
    "content": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: . Input: nums = [2,2,1] Output: 1 . Example 2: . Input: nums = [4,1,2,1,2] Output: 4 . Example 3: . Input: nums = [1] Output: 1 . Constraints: . | 1 &lt;= nums.length &lt;= 3 * 104 | -3 * 104 &lt;= nums[i] &lt;= 3 * 104 | Each element in the array appears twice except for one element which appears only once. | . Solution . XOR . class Solution { public int singleNumber(int[] nums) { int x = nums[0]; for(int i=1; i&lt;nums.length; i++){ x = x^nums[i]; } return x; } } . ",
    "url": "https://1001anjan.github.io/problem-29-Single-Number/",
    "relUrl": "/problem-29-Single-Number/"
  },"410": {
    "doc": "Spiral Matrix",
    "title": "Spiral Matrix",
    "content": "Given an m x n matrix, return all elements of the matrix in spiral order. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] . Example 2: . Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 10 | -100 &lt;= matrix[i][j] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int m = matrix.length; int n = matrix[0].length; int total = m * n, count = 0; int i = 0, j = 0; int yRight = 0, yLeft = 0, xUp = 1, xDown = 0; while(count &lt; total){ while(count &lt; total &amp;&amp; j &lt; n - yRight){ ans.add(matrix[i][j]); j++; count++; } yRight++; i++; j--; while(count &lt; total &amp;&amp; i &lt; m - xDown){ ans.add(matrix[i][j]); count++; i++; } xDown++; i--; j--; while(count &lt; total &amp;&amp; j &gt;= yLeft){ ans.add(matrix[i][j]); count++; j--; } yLeft++; j++; i--; while(count &lt; total &amp;&amp; i &gt;= xUp){ ans.add(matrix[i][j]); i--; count++; } i++; j++; xUp++; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-29-Spiral%20Matrix/",
    "relUrl": "/problem-29-Spiral Matrix/"
  },"411": {
    "doc": "Redistribute Characters to Make All Strings Equal",
    "title": "Redistribute Characters to Make All Strings Equal",
    "content": "You are given an array of strings words (0-indexed). In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j]. Return true if you can make every string in words equal using any number of operations, and false otherwise. Example 1: . Input: words = [\"abc\",\"aabc\",\"bc\"] Output: true Explanation: Move the first 'a' in words[1] to the front of words[2], to make words[1] = \"abc\" and words[2] = \"abc\". All the strings are now equal to \"abc\", so return true. Example 2: . Input: words = [\"ab\",\"a\"] Output: false Explanation: It is impossible to make all the strings equal using the operation. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of lowercase English letters. | . Solution . class Solution { public boolean makeEqual(String[] words) { int[] count = new int[26]; for(String w : words){ for(char c : w.toCharArray()){ count[c - 'a']++; } } for(int i : count){ if(i % words.length != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-290-Redistribute-Characters-to-Make-All-Strings-Equal/",
    "relUrl": "/problem-290-Redistribute-Characters-to-Make-All-Strings-Equal/"
  },"412": {
    "doc": "Largest Odd Number in String",
    "title": "Largest Odd Number in String",
    "content": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string “” if no odd integer exists. A substring is a contiguous sequence of characters within a string. Example 1: . Input: num = \"52\" Output: \"5\" Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number. Example 2: . Input: num = \"4206\" Output: \"\" Explanation: There are no odd numbers in \"4206\". Example 3: . Input: num = \"35427\" Output: \"35427\" Explanation: \"35427\" is already an odd number. Constraints: . | 1 &lt;= num.length &lt;= 105 | num only consists of digits and does not contain any leading zeros. | . Solution: . class Solution { public String largestOddNumber(String num) { for(int i = num.length() - 1; i&gt;=0; i--){ if((num.charAt(i) - '0')%2 != 0) return num.substring(0,i+1); } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-291-Largest-Odd-Number-in-String/",
    "relUrl": "/problem-291-Largest-Odd-Number-in-String/"
  },"413": {
    "doc": "Remove One Element to Make the Array Strictly Increasing",
    "title": "Remove One Element to Make the Array Strictly Increasing",
    "content": "Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true. The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length). Example 1: . Input: nums = [1,2,10,5,7] Output: true Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7]. [1,2,5,7] is strictly increasing, so return true. Example 2: . Input: nums = [2,3,1,2] Output: false Explanation: [3,1,2] is the result of removing the element at index 0. [2,1,2] is the result of removing the element at index 1. [2,3,2] is the result of removing the element at index 2. [2,3,1] is the result of removing the element at index 3. No resulting array is strictly increasing, so return false. Example 3: . Input: nums = [1,1,1] Output: false Explanation: The result of removing any element is [1,1]. [1,1] is not strictly increasing, so return false. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution . class Solution { public boolean canBeIncreasing(int[] nums) { // corner cases if(nums.length == 1) return true; int c = 0; for(int i = 1; i &lt; nums.length; i++){ if(nums[i - 1] &gt;= nums[i]){ c++; if(c &gt; 1) return false; if(i &gt;= 2 &amp;&amp; nums[i-2] &gt;= nums[i]) nums[i] = nums[i - 1]; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-292-Remove-One-Element-to-Make-the-Array-Strictly-Increasing/",
    "relUrl": "/problem-292-Remove-One-Element-to-Make-the-Array-Strictly-Increasing/"
  },"414": {
    "doc": "Maximum Product Difference Between Two Pairs",
    "title": "Maximum Product Difference Between Two Pairs",
    "content": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d). | For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16. Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized. | . Return the maximum such product difference. Example 1: . Input: nums = [5,6,2,7,4] Output: 34 Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4). The product difference is (6 * 7) - (2 * 4) = 34. Example 2: . Input: nums = [4,2,5,9,7,4,8] Output: 64 Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4). The product difference is (9 * 8) - (2 * 4) = 64. Constraints: . | 4 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int maxProductDifference(int[] nums) { int max1, max2, min1, min2; max1 = max2 = -1; min1 = min2 = Integer.MAX_VALUE; for(int n : nums){ if(n &gt; max1){ max2 = max1; max1 = n; }else if(n &gt; max2){ max2 = n; } if(n &lt; min1){ min2 = min1; min1 = n; }else if(n &lt; min2){ min2 = n; } } return (max1*max2) - (min1*min2); } } . ",
    "url": "https://1001anjan.github.io/problem-293-Maximum-Product-Difference-Between-Two-Pairs/",
    "relUrl": "/problem-293-Maximum-Product-Difference-Between-Two-Pairs/"
  },"415": {
    "doc": "Build Array from Permutation",
    "title": "Build Array from Permutation",
    "content": "Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 &lt;= i &lt; nums.length and return it. A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive). Example 1: . Input: nums = [0,2,1,5,3,4] Output: [0,1,2,4,5,3] Explanation: The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3] . Example 2: . Input: nums = [5,0,1,2,3,4] Output: [4,5,0,1,2,3] Explanation: The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3] . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 0 &lt;= nums[i] &lt; nums.length | The elements in nums are distinct. | Follow-up: Can you solve it without using an extra space (i.e., O(1) memory)? | . Solution: . class Solution { public int[] buildArray(int[] nums) { int[] ans = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++) ans[i] = nums[nums[i]]; return ans; } } . Using constant memory . class Solution { public int[] buildArray(int[] nums) { for(int i = 0; i &lt; nums.length; i++){ nums[i] = nums.length*(nums[nums[i]]%nums.length) + nums[i]; } for(int i = 0; i &lt; nums.length; i++) nums[i] = nums[i]/nums.length; return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-294-Build-Array-from-Permutation/",
    "relUrl": "/problem-294-Build-Array-from-Permutation/"
  },"416": {
    "doc": "Count Square Sum Triples",
    "title": "Count Square Sum Triples",
    "content": "A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2. Given an integer n, return the number of square triples such that 1 &lt;= a, b, c &lt;= n. Example 1: . Input: n = 5 Output: 2 Explanation: The square triples are (3,4,5) and (4,3,5). Example 2: . Input: n = 10 Output: 4 Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10). Constraints: . | 1 &lt;= n &lt;= 250 | . Solution: . class Solution { public int countTriples(int n) { int c = 0; for(int i = 1; i &lt;= n; i++){ for(int j = i + 1; j &lt;= n; j++){ double s = Math.sqrt(i*i + j*j); if(s &lt;= n &amp;&amp; s % 1 == 0) c++; } } return 2*c; } } . ",
    "url": "https://1001anjan.github.io/problem-295-Count-Square-Sum-Triples/",
    "relUrl": "/problem-295-Count-Square-Sum-Triples/"
  },"417": {
    "doc": "Concatenation of Array",
    "title": "Concatenation of Array",
    "content": "Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 &lt;= i &lt; n (0-indexed). Specifically, ans is the concatenation of two nums arrays. Return the array ans. Example 1: . Input: nums = [1,2,1] Output: [1,2,1,1,2,1] Explanation: The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] . Example 2: . Input: nums = [1,3,2,1] Output: [1,3,2,1,1,3,2,1] Explanation: The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution . class Solution { public int[] getConcatenation(int[] nums) { int[] ans = new int[nums.length*2]; for(int i = 0; i &lt; nums.length; i++){ ans[i] = nums[i]; ans[nums.length + i] = nums[i]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-296-Concatenation-of-Array/",
    "relUrl": "/problem-296-Concatenation-of-Array/"
  },"418": {
    "doc": "Maximum Number of Words You Can Type",
    "title": "Maximum Number of Words You Can Type",
    "content": "There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly. Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard. Example 1: . Input: text = \"hello world\", brokenLetters = \"ad\" Output: 1 Explanation: We cannot type \"world\" because the 'd' key is broken. Example 2: . Input: text = \"leet code\", brokenLetters = \"lt\" Output: 1 Explanation: We cannot type \"leet\" because the 'l' and 't' keys are broken. Example 3: . Input: text = \"leet code\", brokenLetters = \"e\" Output: 0 Explanation: We cannot type either word because the 'e' key is broken. Constraints: . | 1 &lt;= text.length &lt;= 104 | 0 &lt;= brokenLetters.length &lt;= 26 | text consists of words separated by a single space without any leading or trailing spaces. | Each word only consists of lowercase English letters. | brokenLetters consists of distinct lowercase English letters. | . Solution: . class Solution { public int canBeTypedWords(String text, String brokenLetters) { boolean[] dp = new boolean[26]; for(char c : brokenLetters.toCharArray()) dp[c - 'a'] = true; int wc = 1; int df = 0; boolean finished = true; for(char c : text.toCharArray()){ if(c == ' '){ wc++; finished = true; }else if(finished &amp;&amp; dp[c - 'a']){ finished = false; df++; } } return wc - df; } } . ",
    "url": "https://1001anjan.github.io/problem-297-Maximum-Number-of-Words-You-Can-Type/",
    "relUrl": "/problem-297-Maximum-Number-of-Words-You-Can-Type/"
  },"419": {
    "doc": "Check if All Characters Have Equal Number of Occurrences",
    "title": "Check if All Characters Have Equal Number of Occurrences",
    "content": "Given a string s, return true if s is a good string, or false otherwise. A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency). Example 1: . Input: s = \"abacbc\" Output: true Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s. Example 2: . Input: s = \"aaabb\" Output: false Explanation: The characters that appear in s are 'a' and 'b'. 'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of lowercase English letters. | . Solution: . class Solution { public boolean areOccurrencesEqual(String s) { int[] dp = new int[26]; for(char c : s.toCharArray()) dp[c - 'a']++; int i = 0; while(i &lt; 26 &amp;&amp; dp[i] == 0) i++; // since we have atleast one char int p = dp[i]; while(i &lt; 26){ if(dp[i] != 0 &amp;&amp; dp[i] != p) return false; i++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-298-Check%20if%20All%20Characters%20Have%20Equal%20Number%20of%20Occurrences/",
    "relUrl": "/problem-298-Check if All Characters Have Equal Number of Occurrences/"
  },"420": {
    "doc": "Sum of Digits of String After Convert",
    "title": "Sum of Digits of String After",
    "content": "You are given a string s consisting of lowercase English letters, and an integer k. First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace ‘a’ with 1, ‘b’ with 2, …, ‘z’ with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total. For example, if s = “zbax” and k = 2, then the resulting integer would be 8 by the following operations: . | Convert: “zbax” ➝ “(26)(2)(1)(24)” ➝ “262124” ➝ 262124 | Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17 | Transform #2: 17 ➝ 1 + 7 ➝ 8 | Return the resulting integer after performing the operations described above. | . Example 1: . Input: s = \"iiii\", k = 1 Output: 36 Explanation: The operations are as follows: - Convert: \"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36 Thus the resulting integer is 36. Example 2: . Input: s = \"leetcode\", k = 2 Output: 6 Explanation: The operations are as follows: - Convert: \"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 - Transform #2: 33 ➝ 3 + 3 ➝ 6 Thus the resulting integer is 6. Example 3: Input: s = \"zbax\", k = 2 Output: 8 . Constraints: . | 1 &lt;= s.length &lt;= 100 | 1 &lt;= k &lt;= 10 | s consists of lowercase English letters. | . Solution: . class Solution { public int getLucky(String s, int k) { StringBuilder sb1 = new StringBuilder(); for(char c : s.toCharArray()) sb1.append(c - 96); int sum = 0; while(k &gt;= 1){ sum = 0; for(char c : sb1.toString().toCharArray()) sum += c - 48; sb1.setLength(0); sb1.append(sum); k--; } return sum; } } . Improvement–&gt; . class Solution { public static int getLucky(String s, int k) { int totalAddedValue = toInteger(s); for(int roundCounter = 1; roundCounter &lt; k; roundCounter++){ totalAddedValue = addDigitsOfNumbers(totalAddedValue); } return totalAddedValue; } public static int toInteger(String s) { int integerValueOfString = 0; int valueAdde; for(int index = 0; index &lt; s.length(); index++){ integerValueOfString = (integerValueOfString + addDigitsOfNumbers((int)(s.charAt(index) - 96))); } return integerValueOfString; } public static int addDigitsOfNumbers(int number) { int addedValue = 0; while (number != 0){ addedValue = addedValue + (number % 10); number = number / 10; } return addedValue; } } . ",
    "url": "https://1001anjan.github.io/problem-299-Sum%20of%20Digits%20of%20String%20After%20Convert/#sum-of-digits-of-string-after",
    "relUrl": "/problem-299-Sum of Digits of String After Convert/#sum-of-digits-of-string-after"
  },"421": {
    "doc": "Sum of Digits of String After Convert",
    "title": "Sum of Digits of String After Convert",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-299-Sum%20of%20Digits%20of%20String%20After%20Convert/",
    "relUrl": "/problem-299-Sum of Digits of String After Convert/"
  },"422": {
    "doc": "Longest Substring Without Repeating Characters",
    "title": "Longest Substring Without Repeating Characters",
    "content": "Given a string s, find the length of the longest substring without repeating characters. Example 1: . Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: . Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: . Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Constraints: . | 0 &lt;= s.length &lt;= 5 * 104 | s consists of English letters, digits, symbols and spaces. | . Solution: . class Solution { public int lengthOfLongestSubstring(String str) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int s = 0, e = 0, max = 0, curr = 0; while(e &lt; str.length()){ char ch = str.charAt(e); if(set.add(ch)){ curr++; e++; }else{ while(str.charAt(s) != ch) { set.remove(str.charAt(s)); s++; } s++; curr = e - s + 1; e++; } max = Math.max(max, curr); } return max; } } . class Solution { public int lengthOfLongestSubstring(String s) { int max = 0; int tmax; for(int i=0; i&lt;s.length(); i++){ tmax= 1; HashSet&lt;Character&gt; set = new HashSet(); set.add(s.charAt(i)); for(int j= i+1; j&lt;s.length(); j++){ if(set.contains(s.charAt(j))) break; tmax++; set.add(s.charAt(j)); } if(tmax&gt;max) max = tmax; } return max; } } . class Solution { public int lengthOfLongestSubstring(String s) { int count = 0; int temp = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); if(s.length() == 0 ) return 0; if(s.length() == 1) return 1; for(int i = 0 ; i&lt;s.length(); i++){ if(temp&gt;count){ count = temp; } temp = 0; set.clear(); for(int j=i ; j&lt;s.length(); j++){ if(set.contains(s.charAt(j))){ break; } temp++; set.add(s.charAt(j)); } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-3-Longest%20Substring%20Without%20Repeating%20Characters/",
    "relUrl": "/problem-3-Longest Substring Without Repeating Characters/"
  },"423": {
    "doc": "Roman to Integer",
    "title": "3.  Roman to Integer",
    "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 . For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: . | I can be placed before V (5) and X (10) to make 4 and 9. | X can be placed before L (50) and C (100) to make 40 and 90. | C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. | . Example 1: . Input: s = \"III\" Output: 3 Explanation: III = 3. Example 2: . Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3: . Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: . | 1 &lt;= s.length &lt;= 15 | s contains only the characters (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’). | It is guaranteed that s is a valid roman numeral in the range [1, 3999]. | . Solution: . class Solution { public int romanToInt(String s) { int sum = 0; char ch; for(int i = 0; i&lt;s.length(); i++){ ch = s.charAt(i); if(ch == 'I'){ if( i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'V'){ sum = sum + 4; i++; }else if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'X'){ sum = sum + 9; i++; }else{ sum = sum + 1; } }else if(ch == 'V'){ sum = sum + 5; }else if(ch == 'X'){ if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'L'){ sum = sum + 40; i++; }else if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'C'){ sum = sum + 90; i++; }else{ sum = sum + 10; } }else if(ch == 'L'){ sum = sum + 50; }else if(ch == 'C'){ if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'D'){ sum = sum + 400; i++; }else if(i+1&lt;s.length() &amp;&amp; s.charAt(i+1) == 'M'){ sum = sum + 900; i++; }else{ sum = sum + 100; } }else if(ch == 'D'){ sum = sum + 500; }else if(ch == 'M'){ sum = sum + 1000; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-3-Roman-to-Integer/#3--roman-to-integer",
    "relUrl": "/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-3-Roman-to-Integer/#3--roman-to-integer"
  },"424": {
    "doc": "Roman to Integer",
    "title": "Roman to Integer",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-3-Roman-to-Integer/",
    "relUrl": "/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-3-Roman-to-Integer/"
  },"425": {
    "doc": "Jump Game",
    "title": "Jump Game",
    "content": "You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example 1: . Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: . Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public boolean canJump(int[] nums) { boolean[] dp = new boolean[nums.length]; return testJump(nums,0, dp); } public boolean testJump(int[] arr, int start, boolean[] dp){ if(start &gt;= arr.length - 1) return true; if(arr[start] == 0) return false; boolean status = false; for(int i = start + 1; i &lt;= start + arr[start]; i++){ if(i &gt;= arr.length - 1) return true; if(!dp[i]){ dp[i] = true; status = status | testJump(arr, i, dp); } } return status; } } . class Solution { //we can use dynamic programming. //for a given position i //OPT[i] represent whether it is possible to reach the last index or not. //OPT[i] = true if (i == last Index) //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]] //OPT[i] = false if (nums[i] == 0) //The result is opt[0]; public boolean canJump(int[] nums) { boolean[] dp = new boolean[nums.length]; Arrays.fill(dp, false); dp[nums.length-1] = true; for(int i = nums.length - 2; i &gt;= 0; i--){ if(nums[i] == 0) dp[i] = false; else{ if(nums[i] + i &gt;= nums.length) dp[i] = true; else{ for(int j = 1; j &lt;= nums[i]; j++){ dp[i] = dp[i] || dp[i + j]; //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them. j += nums[i + j]; } } } } return dp[0]; } } . Assume that we can move step = nums[0] steps at the beginning, then move to num[1] and step–, always take the max of num[1] and step as remaining steps, and repeat until arriving at the last element. If step == 0 during the iteration, it means we could neither move forward nor reach the end, so return false. class Solution { public boolean canJump(int[] nums) { int step = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (step == 0) return false; step = Math.max(--step, nums[i]); } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-30-Jump%20Game/",
    "relUrl": "/problem-30-Jump Game/"
  },"426": {
    "doc": "Linked List Cycle",
    "title": "Linked List Cycle",
    "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: . Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Constraints: . | The number of the nodes in the list is in the range [0, 104]. | -105 &lt;= Node.val &lt;= 105 | pos is -1 or a valid index in the linked-list. | . Solution: . Using extra memory . /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; Set&lt;ListNode&gt; set = new HashSet&lt;ListNode&gt;(); while(head != null){ if(set.contains(head)) { return true; } set.add(head); head = head.next; } return false; } } . Using constant memory . public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode last = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; last = last.next; if(fast == last){ return true; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-30-Linked-List-Cycle/",
    "relUrl": "/problem-30-Linked-List-Cycle/"
  },"427": {
    "doc": "Three Divisors",
    "title": "Three Divisors",
    "content": "Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false. An integer m is a divisor of n if there exists an integer k such that n = k * m. Example 1: . Input: n = 2 Output: false Explantion: 2 has only two divisors: 1 and 2. Example 2: . Input: n = 4 Output: true Explantion: 4 has three divisors: 1, 2, and 4. Constraints: . | 1 &lt;= n &lt;= 10^4 | . Solution: . class Solution { public boolean isThree(int n) { int c = 0; for(int i = 2; i &lt;= n / 2; i++){ if(n % i == 0){ c++; if(c &gt; 1) return false; } } return c == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-300-Three-Divisors/",
    "relUrl": "/problem-300-Three-Divisors/"
  },"428": {
    "doc": "Delete Characters to Make Fancy String",
    "title": "Delete Characters to Make Fancy String",
    "content": "A fancy string is a string where no three consecutive characters are equal. Given a string s, delete the minimum possible number of characters from s to make it fancy. Return the final string after the deletion. It can be shown that the answer will always be unique. Example 1: . Input: s = \"leeetcode\" Output: \"leetcode\" Explanation: Remove an 'e' from the first group of 'e's to create \"leetcode\". No three consecutive characters are equal, so return \"leetcode\". Example 2: . Input: s = \"aaabaaaa\" Output: \"aabaa\" Explanation: Remove an 'a' from the first group of 'a's to create \"aabaaaa\". Remove two 'a's from the second group of 'a's to create \"aabaa\". No three consecutive characters are equal, so return \"aabaa\". Example 3: . Input: s = \"aab\" Output: \"aab\" Explanation: No three consecutive characters are equal, so return \"aab\". Constraints: . | 1 &lt;= s.length &lt;= 10^5 | s consists only of lowercase English letters. | . Solution: . class Solution { public String makeFancyString(String s) { StringBuilder sb = new StringBuilder(); char[] chr = s.toCharArray(); sb.append(chr[0]); int c = 1; for(int i = 1; i &lt; chr.length; i++){ if(chr[i - 1] == chr[i]){ c++; if(c &lt; 3){ sb.append(chr[i]); } }else{ c = 1; sb.append(chr[i]); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-301-Delete%20Characters%20to%20Make%20Fancy%20String/",
    "relUrl": "/problem-301-Delete Characters to Make Fancy String/"
  },"429": {
    "doc": "Check If String Is a Prefix of Array",
    "title": "Check If String Is a Prefix of Array",
    "content": "Given a string s and an array of strings words, determine whether s is a prefix string of words. A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length. Return true if s is a prefix string of words, or false otherwise. Example 1: . Input: s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"] Output: true Explanation: s can be made by concatenating \"i\", \"love\", and \"leetcode\" together. Example 2: . Input: s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"] Output: false Explanation: It is impossible to make s using a prefix of arr. Constraints: . *1 &lt;= words.length &lt;= 100 . | 1 &lt;= words[i].length &lt;= 20 | 1 &lt;= s.length &lt;= 1000 | words[i] and s consist of only lowercase English letters. | . class Solution { public boolean isPrefixString(String s, String[] words) { StringBuilder sb = new StringBuilder(); for(String str : words){ sb.append(str); if(s.equals(sb.toString())) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-302-Check%20If%20String%20Is%20a%20Prefix%20of%20Array/",
    "relUrl": "/problem-302-Check If String Is a Prefix of Array/"
  },"430": {
    "doc": "Number of Strings That Appear as Substrings in Word",
    "title": "Number of Strings That Appear as Substrings in Word",
    "content": "Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word. A substring is a contiguous sequence of characters within a string. Example 1: . Input: patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\" Output: 3 Explanation: - \"a\" appears as a substring in \"abc\". - \"abc\" appears as a substring in \"abc\". - \"bc\" appears as a substring in \"abc\". - \"d\" does not appear as a substring in \"abc\". 3 of the strings in patterns appear as a substring in word. Example 2: . Input: patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\" Output: 2 Explanation: - \"a\" appears as a substring in \"aaaaabbbbb\". - \"b\" appears as a substring in \"aaaaabbbbb\". - \"c\" does not appear as a substring in \"aaaaabbbbb\". 2 of the strings in patterns appear as a substring in word. Example 3: . Input: patterns = [\"a\",\"a\",\"a\"], word = \"ab\" Output: 3 Explanation: Each of the patterns appears as a substring in word \"ab\". Constraints: . | 1 &lt;= patterns.length &lt;= 100 | 1 &lt;= patterns[i].length &lt;= 100 | 1 &lt;= word.length &lt;= 100 | patterns[i] and word consist of lowercase English letters. | . Solution: . class Solution { public int numOfStrings(String[] patterns, String word) { int c = 0; for(String s : patterns){ if(word.contains(s)) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-303-Number%20of%20Strings%20That%20Appear%20as%20Substrings%20in%20Word/",
    "relUrl": "/problem-303-Number of Strings That Appear as Substrings in Word/"
  },"431": {
    "doc": "Minimum Time to Type Word Using Special Typewriter",
    "title": "Minimum Time to Type Word Using Special Typewriter",
    "content": "There is a special typewriter with lowercase English letters ‘a’ to ‘z’ arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character ‘a’. Each second, you may perform one of the following operations: . | Move the pointer one character counterclockwise or clockwise. | Type the character the pointer is currently on. | . Given a string word, return the minimum number of seconds to type out the characters in word. Example 1: . Input: word = \"abc\" Output: 5 Explanation: The characters are printed as follows: - Type the character 'a' in 1 second since the pointer is initially on 'a'. - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer clockwise to 'c' in 1 second. - Type the character 'c' in 1 second. Example 2: . Input: word = \"bza\" Output: 7 Explanation: The characters are printed as follows: - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer counterclockwise to 'z' in 2 seconds. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'a' in 1 second. - Type the character 'a' in 1 second. Example 3: . Input: word = \"zjpc\" Output: 34 Explanation: The characters are printed as follows: - Move the pointer counterclockwise to 'z' in 1 second. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'j' in 10 seconds. - Type the character 'j' in 1 second. - Move the pointer clockwise to 'p' in 6 seconds. - Type the character 'p' in 1 second. - Move the pointer counterclockwise to 'c' in 13 seconds. - Type the character 'c' in 1 second. Constraints: . | 1 &lt;= word.length &lt;= 100 | word consists of lowercase English letters. | . Solution: . class Solution { public int minTimeToType(String word) { int t = 0; char prev = 'a'; for(int i = 0; i &lt; word.length(); i++){ char curr = word.charAt(i); int d = Math.abs(prev - curr); int v = Math.min(d, 26 - d); t += v + 1; prev = curr; } return t; } } . ",
    "url": "https://1001anjan.github.io/problem-304-Minimum%20Time%20to%20Type%20Word%20Using%20Special%20Typewriter/",
    "relUrl": "/problem-304-Minimum Time to Type Word Using Special Typewriter/"
  },"432": {
    "doc": "Find Greatest Common Divisor of Array",
    "title": "Find Greatest Common Divisor of Array",
    "content": "Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums. The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers. Example 1: . Input: nums = [2,5,6,9,10] Output: 2 Explanation: The smallest number in nums is 2. The largest number in nums is 10. The greatest common divisor of 2 and 10 is 2. Example 2: . Input: nums = [7,5,6,8,3] Output: 1 Explanation: The smallest number in nums is 3. The largest number in nums is 8. The greatest common divisor of 3 and 8 is 1. Example 3: . Input: nums = [3,3] Output: 3 Explanation: The smallest number in nums is 3. The largest number in nums is 3. The greatest common divisor of 3 and 3 is 3. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int findGCD(int[] nums) { int mx, mn; mx = mn = nums[0]; for(int n : nums){ if(n &gt; mx) mx = n; if(n &lt; mn) mn = n; } for(int i = mn; i &gt;= 1; i--){ if(mx % i == 0 &amp;&amp; mn % i == 0) return i; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-305-Find%20Greatest%20Common%20Divisor%20of%20Array/",
    "relUrl": "/problem-305-Find Greatest Common Divisor of Array/"
  },"433": {
    "doc": "Minimum Difference Between Highest and Lowest of K Scores",
    "title": "Minimum Difference Between Highest and Lowest of K Scores",
    "content": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k. Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized. Return the minimum possible difference. Example 1: . Input: nums = [90], k = 1 Output: 0 Explanation: There is one way to pick score(s) of one student: - [90]. The difference between the highest and lowest score is 90 - 90 = 0. The minimum possible difference is 0. Example 2: . Input: nums = [9,4,1,7], k = 2 Output: 2 Explanation: There are six ways to pick score(s) of two students: - [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5. - [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8. - [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2. - [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3. - [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3. - [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6. The minimum possible difference is 2. Constraints: . | 1 &lt;= k &lt;= nums.length &lt;= 1000 | 0 &lt;= nums[i] &lt;= 105 | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-306-Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/",
    "relUrl": "/problem-306-Minimum Difference Between Highest and Lowest of K Scores/"
  },"434": {
    "doc": "Count Special Quadruplets",
    "title": "Count Special Quadruplets",
    "content": "Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that: . | nums[a] + nums[b] + nums[c] == nums[d], and | a &lt; b &lt; c &lt; d | . Example 1: . Input: nums = [1,2,3,6] Output: 1 Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6. Example 2: . Input: nums = [3,3,6,4,5] Output: 0 Explanation: There are no such quadruplets in [3,3,6,4,5]. Example 3: . Input: nums = [1,1,1,3,5] Output: 4 Explanation: The 4 quadruplets that satisfy the requirement are: - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 . Constraints: . | 4 &lt;= nums.length &lt;= 50 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int countQuadruplets(int[] nums) { int c = 0; for(int i = 0; i &lt; nums.length - 3; i++){ for(int j = i + 1; j &lt; nums.length - 2; j++){ for(int k = j + 1; k &lt; nums.length - 1; k++){ int v = nums[i] + nums[j] + nums[k]; for(int l = k + 1; l &lt; nums.length; l++) if(v == nums[l]) c++; } } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-307-Count%20Special%20Quadruplets/",
    "relUrl": "/problem-307-Count Special Quadruplets/"
  },"435": {
    "doc": "Reverse Prefix of Word",
    "title": "Reverse Prefix of Word",
    "content": "Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing. For example, if word = “abcdefd” and ch = “d”, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be “dcbaefd”. Return the resulting string. Example 1: . Input: word = \"abcdefd\", ch = \"d\" Output: \"dcbaefd\" Explanation: The first occurrence of \"d\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\". Example 2: . Input: word = \"xyxzxe\", ch = \"z\" Output: \"zxyxxe\" Explanation: The first and only occurrence of \"z\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\". Example 3: . Input: word = \"abcd\", ch = \"z\" Output: \"abcd\" Explanation: \"z\" does not exist in word. You should not do any reverse operation, the resulting string is \"abcd\". Constraints: . | 1 &lt;= word.length &lt;= 250 | word consists of lowercase English letters. | ch is a lowercase English letter. | . Solution: . class Solution { public String reversePrefix(String word, char ch) { StringBuffer sb = new StringBuffer(); int n = word.length(); int i = 0; for(; i &lt; n; i++){ char c = word.charAt(i); sb.append(c); if(c == ch) break; } if(i == n) return sb.toString(); return sb.reverse().append(word.substring(i + 1,n)).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-308-Reverse-Prefix-of-Word/",
    "relUrl": "/problem-308-Reverse-Prefix-of-Word/"
  },"436": {
    "doc": "Count Number of Pairs With Absolute Difference K",
    "title": "Count Number of Pairs With Absolute Difference K",
    "content": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i &lt; j such that |nums[i] - nums[j]| == k. | The value of | x | is defined as: | . | x if x &gt;= 0. | -x if x &lt; 0. | . Example 1: . Input: nums = [1,2,2,1], k = 1 Output: 4 Explanation: The pairs with an absolute difference of 1 are: - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] . Example 2: . Input: nums = [1,3], k = 3 Output: 0 Explanation: There are no pairs with an absolute difference of 3. Example 3: . Input: nums = [3,2,1,5,4], k = 2 Output: 3 Explanation: The pairs with an absolute difference of 2 are: - [3,2,1,5,4] - [3,2,1,5,4] - [3,2,1,5,4] . Constraints: . | 1 &lt;= nums.length &lt;= 200 | 1 &lt;= nums[i] &lt;= 100 | 1 &lt;= k &lt;= 99 | . Solution: O(n) complexity with constant space . class Solution { public int countKDifference(int[] nums, int k) { int i , j , max = 0 , pairs = 0 ; int[] count = new int[101] ; for( i = 0 ; i &lt; nums.length ; i++ ){ count[nums[i]]++ ; if( nums[i] &gt; max ){ max = nums[i] ; } } for( i = 1 , j = i + k ; j &lt;= max ; i++ , j++ ){ if( count[i] &gt; 0 &amp;&amp; count[j] &gt; 0 ){ pairs += count[i] * count[j] ; } } return pairs ; } } . O(n^2 complexity) . class Solution { public int countKDifference(int[] nums, int k) { int c = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ int d = nums[j] - nums[i]; if(d == k) c++; else if(d &gt; k) break; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-309-Count-Number-of-Pairs-With-Absolute-Difference-K/",
    "relUrl": "/problem-309-Count-Number-of-Pairs-With-Absolute-Difference-K/"
  },"437": {
    "doc": "Binary Tree Preorder Traversal",
    "title": "Binary Tree Preorder Traversal",
    "content": "Given the root of a binary tree, return the preorder traversal of its nodes’ values. Example 1: . Input: root = [1,null,2,3] Output: [1,2,3] . Example 2: . Input: root = [] Output: [] . Example 3: . Input: root = [1] Output: [1] . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); return preorderTraversal(root, list); } public List&lt;Integer&gt; preorderTraversal(TreeNode head, List&lt;Integer&gt; list){ if(head == null) return list; list.add(head.val); preorderTraversal(head.left,list); preorderTraversal(head.right,list); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-31-Binary-Tree-Preorder-Traversal/",
    "relUrl": "/problem-31-Binary-Tree-Preorder-Traversal/"
  },"438": {
    "doc": "Binary Tree Preorder Traversal",
    "title": "Binary Tree Postorder Traversal",
    "content": "Example 1: . Input: root = [1,null,2,3] Output: [3,2,1] . Example 2: . Input: root = [] Output: [] . Solution . class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); return postorderTraversal(root, list); } public List&lt;Integer&gt; postorderTraversal(TreeNode head, List&lt;Integer&gt; list){ if(head == null) return list; postorderTraversal(head.left,list); postorderTraversal(head.right,list); list.add(head.val); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-31-Binary-Tree-Preorder-Traversal/#binary-tree-postorder-traversal",
    "relUrl": "/problem-31-Binary-Tree-Preorder-Traversal/#binary-tree-postorder-traversal"
  },"439": {
    "doc": "Merge Intervals",
    "title": "Merge Intervals",
    "content": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: . Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2: . Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: . | 1 &lt;= intervals.length &lt;= 10^4 | intervals[i].length == 2 | 0 &lt;= starti &lt;= endi &lt;= 10^4 | . Solution: . class Solution { public int[][] merge(int[][] intervals) { List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); Arrays.sort(intervals, (a,b) -&gt;{ if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; }); int i1 = intervals[0][0]; int i2 = intervals[0][1]; int i = 1; while(i &lt; intervals.length){ if(i2 &gt;= intervals[i][0]){ i2 = Math.max(i2, intervals[i][1]); }else{ List&lt;Integer&gt; l = new LinkedList&lt;&gt;(); l.add(i1); l.add(i2); list.add(l); i1 = intervals[i][0]; i2 = intervals[i][1]; } i++; } List&lt;Integer&gt; l = new LinkedList&lt;&gt;(); l.add(i1); l.add(i2); list.add(l); int[][] ans = new int[list.size()][2]; i = 0; for(List&lt;Integer&gt; l1 : list){ ans[i][0] = l1.get(0); ans[i][1] = l1.get(1); i++; } return ans; } } . class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[0], b[0])); LinkedList&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); for (int[] interval : intervals) { // if the list of merged intervals is empty or if the current // interval does not overlap with the previous, simply append it. if (merged.isEmpty() || merged.getLast()[1] &lt; interval[0]) { merged.add(interval); } // otherwise, there is overlap, so we merge the current and previous // intervals. else { merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]); } } return merged.toArray(new int[merged.size()][]); } } . ",
    "url": "https://1001anjan.github.io/problem-31-Merge%20Intervals/",
    "relUrl": "/problem-31-Merge Intervals/"
  },"440": {
    "doc": "Final Value of Variable After Performing Operations",
    "title": "Final Value of Variable After Performing Operations",
    "content": "There is a programming language with only four operations and one variable X: . ++X and X++ increments the value of the variable X by 1. –X and X– decrements the value of the variable X by 1. Initially, the value of X is 0. Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations. Example 1: . Input: operations = [\"--X\",\"X++\",\"X++\"] Output: 1 Explanation: The operations are performed as follows: Initially, X = 0. --X: X is decremented by 1, X = 0 - 1 = -1. X++: X is incremented by 1, X = -1 + 1 = 0. X++: X is incremented by 1, X = 0 + 1 = 1. Example 2: . Input: operations = [\"++X\",\"++X\",\"X++\"] Output: 3 Explanation: The operations are performed as follows: Initially, X = 0. ++X: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. X++: X is incremented by 1, X = 2 + 1 = 3. Example 3: . Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"] Output: 0 Explanation: The operations are performed as follows: Initially, X = 0. X++: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. --X: X is decremented by 1, X = 2 - 1 = 1. X--: X is decremented by 1, X = 1 - 1 = 0. Constraints: . | 1 &lt;= operations.length &lt;= 100 | operations[i] will be either “++X”, “X++”, “–X”, or “X–”. | . Solution: . class Solution { public int finalValueAfterOperations(String[] operations) { int x = 0; for(String str : operations){ char c = str.charAt(0); if(Character.isLetter(c)){ if(str.charAt(2) == '+'){ x++; }else{ x--; } }else{ if(c == '+'){ x++; }else{ x--; } } } return x; } } . Improved . class Solution { public int finalValueAfterOperations(String[] operations) { int x = 0; for(String str : operations){ if(str.charAt(1) == '+'){ x++; }else{ x--; } } return x; } } . ",
    "url": "https://1001anjan.github.io/problem-310-Final%20Value%20of%20Variable%20After%20Performing%20Operations/",
    "relUrl": "/problem-310-Final Value of Variable After Performing Operations/"
  },"441": {
    "doc": "Maximum Difference Between Increasing Elements",
    "title": "Maximum Difference Between Increasing Elements",
    "content": "Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 &lt;= i &lt; j &lt; n and nums[i] &lt; nums[j]. Return the maximum difference. If no such i and j exists, return -1. Example 1: . Input: nums = [7,1,5,4] Output: 4 Explanation: The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4. Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i &gt; j, so it is not valid. Example 2: . Input: nums = [9,4,3,2] Output: -1 Explanation: There is no i and j such that i &lt; j and nums[i] &lt; nums[j]. Example 3: . Input: nums = [1,5,2,10] Output: 9 Explanation: The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9. Constraints: . | n == nums.length | 2 &lt;= n &lt;= 1000 | 1 &lt;= nums[i] &lt;= 10^9 | . Solution: O(n^2) complexity . class Solution { public int maximumDifference(int[] nums) { int max = 0; for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ max = Math.max(max,nums[j] - nums[i]); } } return max == 0? -1 : max; } } . O(n) time Complexity . class Solution { public int maximumDifference(int[] nums) { int min = nums[0]; int maxDiff = -1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] &lt; min){ min = nums[i]; }else if(nums[i] - min &gt; maxDiff){ maxDiff = nums[i] - min; } } return maxDiff == 0? -1 : maxDiff; } } . ",
    "url": "https://1001anjan.github.io/problem-311-Maximum%20Difference%20Between%20Increasing%20Elements/",
    "relUrl": "/problem-311-Maximum Difference Between Increasing Elements/"
  },"442": {
    "doc": "Convert 1D Array Into 2D Array",
    "title": "Convert 1D Array Into 2D Array",
    "content": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible. Example 1: . Input: original = [1,2,3,4], m = 2, n = 2 Output: [[1,2],[3,4]] Explanation: The constructed 2D array should contain 2 rows and 2 columns. The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array. The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array. Example 2: . Input: original = [1,2,3], m = 1, n = 3 Output: [[1,2,3]] Explanation: The constructed 2D array should contain 1 row and 3 columns. Put all three elements in original into the first row of the constructed 2D array. Example 3: . Input: original = [1,2], m = 1, n = 1 Output: [] Explanation: There are 2 elements in original. It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array. Constraints: . | 1 &lt;= original.length &lt;= 5 * 10^4 | 1 &lt;= original[i] &lt;= 10^5 | 1 &lt;= m, n &lt;= 4 * 10^4 | . Solution: . class Solution { public int[][] construct2DArray(int[] original, int m, int n) { if(m * n != original.length) return new int[0][0]; int[][] ans = new int[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ ans[i][j] = original[n*i + j]; } } return ans; } } . ##### . ",
    "url": "https://1001anjan.github.io/problem-312-Convert%201D%20Array%20Into%202D%20Array/",
    "relUrl": "/problem-312-Convert 1D Array Into 2D Array/"
  },"443": {
    "doc": "Minimum Moves to Convert String",
    "title": "Minimum Moves to Convert String",
    "content": "You are given a string s consisting of n characters which are either ‘X’ or ‘O’. A move is defined as selecting three consecutive characters of s and converting them to ‘O’. Note that if a move is applied to the character ‘O’, it will stay the same. Return the minimum number of moves required so that all the characters of s are converted to ‘O’. Example 1: . Input: s = \"XXX\" Output: 1 Explanation: XXX -&gt; OOO We select all the 3 characters and convert them in one move. Example 2: . Input: s = \"XXOX\" Output: 2 Explanation: XXOX -&gt; OOOX -&gt; OOOO We select the first 3 characters in the first move, and convert them to 'O'. Then we select the last 3 characters and convert them so that the final string contains all 'O's. Example 3: . Input: s = \"OOOO\" Output: 0 Explanation: There are no 'X's in s to convert. Constraints: . | 3 &lt;= s.length &lt;= 1000 | s[i] is either ‘X’ or ‘O’. | . Solution: . class Solution { public int minimumMoves(String s) { int count = 0; int idx = 0; while(idx &lt; s.length()){ if(s.charAt(idx) == 'O'){ // if we hit a 'O' we can skip it idx++; }else{ count++; // we find a 'X' idx += 3; // we will flip the substing from(idx, idx+3); } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-313-Minimum%20Moves%20to%20Convert%20String/",
    "relUrl": "/problem-313-Minimum Moves to Convert String/"
  },"444": {
    "doc": "Two Out of Three",
    "title": "Two Out of Three",
    "content": "Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order. Example 1: . Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] Output: [3,2] Explanation: The values that are present in at least two arrays are: - 3, in all three arrays. - 2, in nums1 and nums2. Example 2: . Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] Output: [2,3,1] Explanation: The values that are present in at least two arrays are: - 2, in nums2 and nums3. - 3, in nums1 and nums2. - 1, in nums1 and nums3. Example 3: . Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5] Output: [] Explanation: No value is present in at least two arrays. Constraints: . | 1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100 | 1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) { Set&lt;Integer&gt; s1 = new HashSet(); Set&lt;Integer&gt; s2 = new HashSet(); Set&lt;Integer&gt; s3 = new HashSet(); for(int n : nums1) s1.add(n); for(int n : nums2) s2.add(n); for(int n : nums3) s3.add(n); Set&lt;Integer&gt; ans = new HashSet&lt;&gt;(); for(int n : s1){ if(s2.contains(n) || s2.contains(n)) ans.add(n); } for(int n : s2){ if(s1.contains(n) || s3.contains(n)) ans.add(n); } for(int n : s3){ if(s1.contains(n) || s2.contains(n)) ans.add(n); } return new ArrayList(ans); } } . Improvement . class Solution { public List&lt;Integer&gt; twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) { //as the max value of a number is limited to 100.. we can use an arrya of size 100. int[] present = new int[100]; for(int n : nums1) if(present[n - 1] == 0) present[n - 1] += 1; for(int n : nums2) if(present[n-1] &lt; 2) present[n - 1] += 2; for(int n : nums3) if(present[n - 1] != 0) present[n - 1] += 3; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 100; ++i){ if(present[i] &gt;= 3) result.add(i + 1); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-314-Two%20Out%20of%20Three/",
    "relUrl": "/problem-314-Two Out of Three/"
  },"445": {
    "doc": "Check if Numbers Are Ascending in a Sentence",
    "title": "Check if Numbers Are Ascending in a Sentence",
    "content": "A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters. | For example, “a puppy has 2 eyes 4 legs” is a sentence with seven tokens: “2” and “4” are numbers and the other tokens such as “puppy” are words. Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s). | . Return true if so, or false otherwise. Example 1: . Input: s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\" Output: true Explanation: The numbers in s are: 1, 3, 4, 6, 12. They are strictly increasing from left to right: 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12. Example 2: . Input: s = \"hello world 5 x 5\" Output: false Explanation: The numbers in s are: 5, 5. They are not strictly increasing. Example 3: . Input: s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\" Output: false Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing. Constraints: . | 3 &lt;= s.length &lt;= 200 | s consists of lowercase English letters, spaces, and digits from 0 to 9, inclusive. | The number of tokens in s is between 2 and 100, inclusive. | The tokens in s are separated by a single space. | There are at least two numbers in s. | Each number in s is a positive number less than 100, with no leading zeros. | s contains no leading or trailing spaces. | . Solution: . class Solution { public boolean areNumbersAscending(String s) { int curr = 0; int i = 0; int n = s.length(); while(i &lt; n){ char ch = s.charAt(i); if(Character.isDigit(ch)){ int v = 0; while(ch != ' '){ v = v * 10 + ch - '0'; i++; if(i == n) break; ch = s.charAt(i); } if(v &lt;= curr) return false; curr = v; } i++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-315-Check%20if%20Numbers%20Are%20Ascending%20in%20a%20Sentence/",
    "relUrl": "/problem-315-Check if Numbers Are Ascending in a Sentence/"
  },"446": {
    "doc": "Number of Valid Words in a Sentence",
    "title": "Number of Valid Words in a Sentence",
    "content": "A sentence consists of lowercase letters (‘a’ to ‘z’), digits (‘0’ to ‘9’), hyphens (‘-‘), punctuation marks (‘!’, ‘.’, and ‘,’), and spaces (‘ ‘) only. Each sentence can be broken down into one or more tokens separated by one or more spaces ‘ ‘. A token is a valid word if all three of the following are true: . | It only contains lowercase letters, hyphens, and/or punctuation (no digits). | There is at most one hyphen ‘-‘. If present, it must be surrounded by lowercase characters (“a-b” is valid, but “-ab” and “ab-“ are not valid). | There is at most one punctuation mark. If present, it must be at the end of the token (“ab,”, “cd!”, and “.” are valid, but “a!b” and “c.,” are not valid). | . Examples of valid words include “a-b.”, “afad”, “ba-c”, “a!”, and “!”. Given a string sentence, return the number of valid words in sentence. Example 1: . Input: sentence = \"cat and dog\" Output: 3 Explanation: The valid words in the sentence are \"cat\", \"and\", and \"dog\". Example 2: . Input: sentence = \"!this 1-s b8d!\" Output: 0 Explanation: There are no valid words in the sentence. \"!this\" is invalid because it starts with a punctuation mark. \"1-s\" and \"b8d\" are invalid because they contain digits. Example 3: . Input: sentence = \"alice and bob are playing stone-game10\" Output: 5 Explanation: The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\". \"stone-game10\" is invalid because it contains digits. Constraints: . | 1 &lt;= sentence.length &lt;= 1000 | sentence only contains lowercase English letters, digits, ‘ ‘, ‘-‘, ‘!’, ‘.’, and ‘,’. | There will be at least 1 token. | . Solution: . class Solution { public int countValidWords(String sentence) { int count = 0; String[] words = sentence.trim().split(\"\\\\s+\"); for(String str : words){ int hypens = 0; int n = str.length(); int i = 0; while(i &lt; n){ char ch = str.charAt(i); if(Character.isDigit(ch)){ break; } if(ch == '-'){ if(i == 0 || i == n - 1) break; if(!Character.isLetter(str.charAt(i-1)) || !Character.isLetter(str.charAt(i+1))) break; hypens++; }else if(ch == '!' || ch == '.' || ch == ','){ if(i != n - 1) break; } i++; } if(hypens &lt;= 1 &amp;&amp; i == n) count++; } return count; } } . Improvement . class Solution { public int countValidWords(String sentence) { int count = 0; String[] words = sentence.split(\" \"); for(String str : words){ int n = str.length(); if(n == 0) continue; int hypens = 0; int i = 0; while(i &lt; n){ char ch = str.charAt(i); if(Character.isDigit(ch)){ break; } if(ch == '-'){ hypens++; if(i == 0 || i == n - 1 || hypens &gt; 1) break; if(!Character.isLetter(str.charAt(i-1)) || !Character.isLetter(str.charAt(i+1))) break; }else if(ch == '!' || ch == '.' || ch == ','){ if(i != n - 1) break; } i++; } if(i == n) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-316-Number%20of%20Valid%20Words%20in%20a%20Sentence/",
    "relUrl": "/problem-316-Number of Valid Words in a Sentence/"
  },"447": {
    "doc": "Kth Distinct String in an Array",
    "title": "Kth Distinct String in an Array",
    "content": "A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string “”. Note that the strings are considered in the order in which they appear in the array. Example 1: . Input: arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2 Output: \"a\" Explanation: The only distinct strings in arr are \"d\" and \"a\". \"d\" appears 1st, so it is the 1st distinct string. \"a\" appears 2nd, so it is the 2nd distinct string. Since k == 2, \"a\" is returned. Example 2: . Input: arr = [\"aaa\",\"aa\",\"a\"], k = 1 Output: \"aaa\" Explanation: All strings in arr are distinct, so the 1st string \"aaa\" is returned. Example 3: . Input: arr = [\"a\",\"b\",\"a\"], k = 3 Output: \"\" Explanation: The only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\". Constraints: . | 1 &lt;= k &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i].length &lt;= 5 | arr[i] consists of lowercase English letters. | . Solution: . class Solution { public String kthDistinct(String[] arr, int k) { Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); Set&lt;String&gt; dupSet = new HashSet&lt;&gt;(); for(String s : arr){ if(set.contains(s)){ dupSet.add(s); }else{ set.add(s); } } for(String s : dupSet){ set.remove(s); } if(k &gt; set.size()) return \"\"; int i = 1; for(String str : set){ if(i == k) return str; i++; } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-317-Kth%20Distinct%20String%20in%20an%20Array/",
    "relUrl": "/problem-317-Kth Distinct String in an Array/"
  },"448": {
    "doc": "Smallest Index With Equal Value",
    "title": "Smallest Index With Equal Value",
    "content": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist. x mod y denotes the remainder when x is divided by y. Example 1: . Input: nums = [0,1,2] Output: 0 Explanation: i=0: 0 mod 10 = 0 == nums[0]. i=1: 1 mod 10 = 1 == nums[1]. i=2: 2 mod 10 = 2 == nums[2]. All indices have i mod 10 == nums[i], so we return the smallest index 0. Example 2: . Input: nums = [4,3,2,1] Output: 2 Explanation: i=0: 0 mod 10 = 0 != nums[0]. i=1: 1 mod 10 = 1 != nums[1]. i=2: 2 mod 10 = 2 == nums[2]. i=3: 3 mod 10 = 3 != nums[3]. 2 is the only index which has i mod 10 == nums[i]. Example 3: . Input: nums = [1,2,3,4,5,6,7,8,9,0] Output: -1 Explanation: No index satisfies i mod 10 == nums[i]. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 9 | . Solution: . class Solution { public int smallestEqual(int[] nums) { for(int i = 0; i &lt; nums.length; i++){ if(i % 10 == nums[i]) return i; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-318-Smallest%20Index%20With%20Equal%20Value/",
    "relUrl": "/problem-318-Smallest Index With Equal Value/"
  },"449": {
    "doc": "Check Whether Two Strings are Almost Equivalent",
    "title": "Check Whether Two Strings are Almost Equivalent",
    "content": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from ‘a’ to ‘z’ between word1 and word2 is at most 3. Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise. The frequency of a letter x is the number of times it occurs in the string. Example 1: . Input: word1 = \"aaaa\", word2 = \"bccb\" Output: false Explanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\". The difference is 4, which is more than the allowed 3. Example 2: . Input: word1 = \"abcdeef\", word2 = \"abaaacc\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3. - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0. - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1. - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1. - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2. - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1. Example 3: . Input: word1 = \"cccddabba\", word2 = \"babababab\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2. - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3. - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3. - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2. Constraints: . | n == word1.length == word2.length | 1 &lt;= n &lt;= 100 | word1 and word2 consist only of lowercase English letters. | . Solution: . class Solution { public boolean checkAlmostEquivalent(String word1, String word2) { int[] dp1 = getFrequency(word1); int[] dp2 = getFrequency(word2); for(int i = 0; i &lt; 26; i++){ if(Math.abs(dp1[i] - dp2[i]) &gt; 3) return false; } return true; } public int[] getFrequency(String str){ int[] dp = new int[26]; for(char c : str.toCharArray()) dp[c - 'a']++; return dp; } } . ",
    "url": "https://1001anjan.github.io/problem-319-Check%20Whether%20Two%20Strings%20are%20Almost%20Equivalent/",
    "relUrl": "/problem-319-Check Whether Two Strings are Almost Equivalent/"
  },"450": {
    "doc": "Insert Interval",
    "title": "Insert Interval",
    "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: . Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] . Example 2: . Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: . | 0 &lt;= intervals.length &lt;= 10^4 | intervals[i].length == 2 | 0 &lt;= starti &lt;= endi &lt;= 10^5 | intervals is sorted by starti in ascending order. | newInterval.length == 2 | 0 &lt;= start &lt;= end &lt;= 10^5 | . Solution: . class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); // adding new item to sorted position boolean added = false; for(int[] arr : intervals){ if(!added){ if(newInterval[0] == arr[0]){ if(newInterval[1] &lt; arr[1]){ list.add(newInterval); list.add(arr); }else{ list.add(arr); list.add(newInterval); } added = true; }else if(newInterval[0] &lt; arr[0]){ list.add(newInterval); list.add(arr); added = true; } } list.add(arr); } if(!added){ list.add(newInterval); } // merging intervals LinkedList&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); for(int[] interval : list){ if(merged.isEmpty() || merged.getLast()[1] &lt; interval[0]){ merged.add(interval); }else{ merged.getLast()[1] = Math.max(merged.getLast()[1] , interval[1]); } } return merged.toArray(new int[merged.size()][]); } } . ",
    "url": "https://1001anjan.github.io/problem-32-Insert%20Interval/",
    "relUrl": "/problem-32-Insert Interval/"
  },"451": {
    "doc": "Min Stack",
    "title": "Min Stack",
    "content": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: . | MinStack() initializes the stack object. | void push(int val) pushes the element val onto the stack. | void pop() removes the element on the top of the stack. | int top() gets the top element of the stack. | int getMin() retrieves the minimum element in the stack. | . Example 1: . Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 . Constraints: . | -231 &lt;= val &lt;= 231 - 1 | Methods pop, top and getMin operations will always be called on non-empty stacks. | At most 3 * 104 calls will be made to push, pop, top, and getMin. | . Solution . class MinStack { Stack&lt;Integer[]&gt; stack; public MinStack() { stack = new Stack&lt;&gt;(); } public void push(int val) { if(stack.isEmpty()){ stack.push(new Integer[]{val, val}); }else{ stack.push(new Integer[]{val, Math.min(val, getMin())}); } } public void pop() { stack.pop(); } public int top() { return stack.peek()[0]; } public int getMin() { return stack.peek()[1]; } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ . ",
    "url": "https://1001anjan.github.io/problem-32-Min-Stack/",
    "relUrl": "/problem-32-Min-Stack/"
  },"452": {
    "doc": "Time Needed to Buy Tickets",
    "title": "Time Needed to Buy Tickets",
    "content": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line. Return the time taken for the person at position k (0-indexed) to finish buying tickets. Example 1: . Input: tickets = [2,3,2], k = 2 Output: 6 Explanation: - In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1]. - In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0]. The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds. Example 2: . Input: tickets = [5,1,1,1], k = 0 Output: 8 Explanation: - In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0]. - In the next 4 passes, only the person in position 0 is buying tickets. The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds. Constraints: . | n == tickets.length | 1 &lt;= n &lt;= 100 | 1 &lt;= tickets[i] &lt;= 100 | 0 &lt;= k &lt; n | . Solution: . class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int c = 0; int i = 0; while(tickets[k] != 0){ i = i % tickets.length; if(tickets[i] != 0){ c++; tickets[i]--; } i++; } return c; } } . O(n) time complexity . class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int count = 0; for(int i = 0; i &lt;= k; i++){ count += Math.min(tickets[i],tickets[k]); } for(int i = k + 1; i &lt; tickets.length; i++){ if(tickets[i] &gt;= tickets[k]){ count += tickets[k] - 1; }else{ count += tickets[i]; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-320-Time%20Needed%20to%20Buy%20Tickets/",
    "relUrl": "/problem-320-Time Needed to Buy Tickets/"
  },"453": {
    "doc": "Two Furthest Houses With Different Colors",
    "title": "Two Furthest Houses With Different Colors",
    "content": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house. Return the maximum distance between two houses with different colors. The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x. Example 1: . Input: colors = [1,1,1,6,1,1,1] Output: 3 Explanation: In the above image, color 1 is blue, and color 6 is red. The furthest two houses with different colors are house 0 and house 3. House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3. Note that houses 3 and 6 can also produce the optimal answer. Example 2: . Input: colors = [1,8,3,8,3] Output: 4 Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green. The furthest two houses with different colors are house 0 and house 4. House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4. Example 3: . Input: colors = [0,1] Output: 1 Explanation: The furthest two houses with different colors are house 0 and house 1. House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1. Constraints: . | n == colors.length | 2 &lt;= n &lt;= 100 | 0 &lt;= colors[i] &lt;= 100 | Test data are generated such that at least two houses have different colors. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-321-Two%20Furthest%20Houses%20With%20Different%20Colors/",
    "relUrl": "/problem-321-Two Furthest Houses With Different Colors/"
  },"454": {
    "doc": "Count Common Words With One Occurrence",
    "title": "Count Common Words With One Occurrence",
    "content": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays. Example 1: . Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"] Output: 2 Explanation: - \"leetcode\" appears exactly once in each of the two arrays. We count this string. - \"amazing\" appears exactly once in each of the two arrays. We count this string. - \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string. - \"as\" appears once in words1, but does not appear in words2. We do not count this string. Thus, there are 2 strings that appear exactly once in each of the two arrays. Example 2: . Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"] Output: 0 Explanation: There are no strings that appear in each of the two arrays. Example 3: . Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"] Output: 1 Explanation: The only string that appears exactly once in each of the two arrays is \"ab\". Constraints: . | 1 &lt;= words1.length, words2.length &lt;= 1000 | 1 &lt;= words1[i].length, words2[j].length &lt;= 30 | words1[i] and words2[j] consists only of lowercase English letters. | . Solution: . class Solution { public int countWords(String[] words1, String[] words2) { Map&lt;String,Integer&gt; m1 = new HashMap&lt;&gt;(); Map&lt;String,Integer&gt; m2 = new HashMap&lt;&gt;(); for(String s : words1){ m1.put(s,m1.getOrDefault(s,0) + 1); } for(String s : words2){ m2.put(s,m2.getOrDefault(s,0) + 1); } int c = 0; for(String k : m1.keySet()){ if(m1.get(k) == 1 &amp;&amp; m2.getOrDefault(k,0) == 1) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-322-Count%20Common%20Words%20With%20One%20Occurrence/",
    "relUrl": "/problem-322-Count Common Words With One Occurrence/"
  },"455": {
    "doc": "Find Target Indices After Sorting Array",
    "title": "Find Target Indices After Sorting Array",
    "content": "You are given a 0-indexed integer array nums and a target element target. A target index is an index i such that nums[i] == target. Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order. Example 1: . Input: nums = [1,2,5,2,3], target = 2 Output: [1,2] Explanation: After sorting, nums is [1,2,2,3,5]. The indices where nums[i] == 2 are 1 and 2. Example 2: . Input: nums = [1,2,5,2,3], target = 3 Output: [3] Explanation: After sorting, nums is [1,2,2,3,5]. The index where nums[i] == 3 is 3. Example 3: . Input: nums = [1,2,5,2,3], target = 5 Output: [4] Explanation: After sorting, nums is [1,2,2,3,5]. The index where nums[i] == 5 is 4. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i], target &lt;= 100 | . Solution: O(nLogN) complexity . class Solution { public List&lt;Integer&gt; targetIndices(int[] nums, int target) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++){ if(nums[i] == target){ ans.add(i); }else if(nums[i] &gt; target) break; } return ans; } } . Greedy Approach | Optimized Code . class Solution { public List&lt;Integer&gt; targetIndices(int[] nums, int target) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int lesserCount = 0; int targetCount = 0; for(int n : nums){ if(n &lt; target) lesserCount++; else if(n == target) targetCount++; } while(targetCount-- &gt; 0){ ans.add(lesserCount++); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-323-Find%20Target%20Indices%20After%20Sorting%20Array/",
    "relUrl": "/problem-323-Find Target Indices After Sorting Array/"
  },"456": {
    "doc": "Finding 3-Digit Even Numbers",
    "title": "Finding 3-Digit Even Numbers",
    "content": "You are given an integer array digits, where each element is a digit. The array may contain duplicates. You need to find all the unique integers that follow the given requirements: . | The integer consists of the concatenation of three elements from digits in any arbitrary order. | The integer does not have leading zeros. | The integer is even. For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements. | . Return a sorted array of the unique integers. Example 1: . Input: digits = [2,1,3,0] Output: [102,120,130,132,210,230,302,310,312,320] Explanation: All the possible integers that follow the requirements are in the output array. Notice that there are no odd integers or integers with leading zeros. Example 2: . Input: digits = [2,2,8,8,2] Output: [222,228,282,288,822,828,882] Explanation: The same digit can be used as many times as it appears in digits. In this example, the digit 8 is used twice each time in 288, 828, and 882. Example 3: . Input: digits = [3,7,5] Output: [] Explanation: No even integers can be formed using the given digits. Constraints: . | 3 &lt;= digits.length &lt;= 100 | 0 &lt;= digits[i] &lt;= 9 | . Solution: . class Solution { public int[] findEvenNumbers(int[] digits) { int[] digitsCount = new int[10]; for(int i : digits) digitsCount[i]++; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=100; i&lt;=998; i=i+2) { if(checkNum(i, digitsCount)) list.add(i); } return list.stream().mapToInt(x -&gt; x).toArray(); } public boolean checkNum(int num, int[] digitsCount) { int[] numCount = new int[10]; while(num != 0) { numCount[num%10]++; num/=10; } for(int i=0; i&lt;10; i++) if(numCount[i] &gt; digitsCount[i]) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-324-Finding%203-Digit%20Even%20Numbers/",
    "relUrl": "/problem-324-Finding 3-Digit Even Numbers/"
  },"457": {
    "doc": "Find Subsequence of Length K With the Largest Sum",
    "title": "Find Subsequence of Length K With the Largest Sum",
    "content": "You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum. Return any such subsequence as an integer array of length k. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1: . Input: nums = [2,1,3,3], k = 2 Output: [3,3] Explanation: The subsequence has the largest sum of 3 + 3 = 6. Example 2: . Input: nums = [-1,-2,3,4], k = 3 Output: [-1,3,4] Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6. Example 3: . Input: nums = [3,4,3,3], k = 2 Output: [3,4] Explanation: The subsequence has the largest sum of 3 + 4 = 7. Another possible subsequence is [4, 3]. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -105 &lt;= nums[i] &lt;= 105 | 1 &lt;= k &lt;= nums.length | . Solution: . class Solution { public int[] maxSubsequence(int[] nums, int k) { int[][] dp = new int[nums.length][2]; for(int i =0; i &lt; nums.length; i++){ dp[i][0] = nums[i]; dp[i][1] = i; } Arrays.sort(dp,(a,b) -&gt; a[0] - b[0]); int[][] sortedSeq = new int[k][2]; int m = k - 1; for(int i = nums.length - 1; i &gt;= nums.length - k; i--, m--){ sortedSeq[m][0] = dp[i][0]; sortedSeq[m][1] = dp[i][1]; } Arrays.sort(sortedSeq, (a,b) -&gt; a[1] - b[1]); int[] ans = new int[k]; for(int i = 0; i &lt; k; i++){ ans[i] = sortedSeq[i][0]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-325-Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/",
    "relUrl": "/problem-325-Find Subsequence of Length K With the Largest Sum/"
  },"458": {
    "doc": "Rings and Rods",
    "title": "Rings and Rods",
    "content": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9. You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where: . | The first character of the ith pair denotes the ith ring’s color (‘R’, ‘G’, ‘B’). | The second character of the ith pair denotes the rod that the ith ring is placed on (‘0’ to ‘9’). | . For example, “R3G2B1” describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return the number of rods that have all three colors of rings on them. Example 1: . Input: rings = \"B0B6G0R6R0R6G9\" Output: 1 Explanation: - The rod labeled 0 holds 3 rings with all colors: red, green, and blue. - The rod labeled 6 holds 3 rings, but it only has red and blue. - The rod labeled 9 holds only a green ring. Thus, the number of rods with all three colors is 1. Example 2: . Input: rings = \"B0R0G0R9R0B0G0\" Output: 1 Explanation: - The rod labeled 0 holds 6 rings with all colors: red, green, and blue. - The rod labeled 9 holds only a red ring. Thus, the number of rods with all three colors is 1. Example 3: . Input: rings = \"G4\" Output: 0 Explanation: Only one ring is given. Thus, no rods have all three colors. Constraints: . | rings.length == 2 * n | 1 &lt;= n &lt;= 100 | rings[i] where i is even is either ‘R’, ‘G’, or ‘B’ (0-indexed). | rings[i] where i is odd is a digit from ‘0’ to ‘9’ (0-indexed). | . Solution . class Solution { public int countPoints(String rings) { boolean[][] dp = new boolean[10][3]; for(int i = 0; i &lt; rings.length(); i = i + 2){ char ch = rings.charAt(i); if(ch == 'R'){ dp[rings.charAt(i+1) - '0'][0] = true; }else if(ch == 'G'){ dp[rings.charAt(i+1) - '0'][1] = true; }else{ dp[rings.charAt(i+1) - '0'][2] = true; } } int c = 0; for(int i = 0; i &lt; 10; i++){ if(dp[i][0] &amp;&amp; dp[i][1] &amp;&amp; dp[i][2]) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-326-Rings%20and%20Rods/",
    "relUrl": "/problem-326-Rings and Rods/"
  },"459": {
    "doc": "Find First Palindromic String in the Array",
    "title": "Find First Palindromic String in the Array",
    "content": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string “”. A string is palindromic if it reads the same forward and backward. Example 1: . Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"] Output: \"ada\" Explanation: The first string that is palindromic is \"ada\". Note that \"racecar\" is also palindromic, but it is not the first. Example 2: . Input: words = [\"notapalindrome\",\"racecar\"] Output: \"racecar\" Explanation: The first and only string that is palindromic is \"racecar\". Example 3: . Input: words = [\"def\",\"ghi\"] Output: \"\" Explanation: There are no palindromic strings, so the empty string is returned. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists only of lowercase English letters. | . Solution: . class Solution { public String firstPalindrome(String[] words) { for(String str : words){ if(checkPalindrome(str)) return str; } return \"\"; } public boolean checkPalindrome(String str){ int i = 0; int j = str.length() - 1; while(i &lt; j){ if(str.charAt(i) != str.charAt(j)) return false; i++; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-327-Find%20First%20Palindromic%20String%20in%20the%20Array/",
    "relUrl": "/problem-327-Find First Palindromic String in the Array/"
  },"460": {
    "doc": "Maximum Number of Words Found in Sentences",
    "title": "Maximum Number of Words Found in Sentences",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences, where each sentences[i] represents a single sentence. Return the maximum number of words that appear in a single sentence. Example 1: . Input: sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"] Output: 6 Explanation: - The first sentence, \"alice and bob love leetcode\", has 5 words in total. - The second sentence, \"i think so too\", has 4 words in total. - The third sentence, \"this is great thanks very much\", has 6 words in total. Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words. Example 2: . Input: sentences = [\"please wait\", \"continue to fight\", \"continue to win\"] Output: 3 Explanation: It is possible that multiple sentences contain the same number of words. In this example, the second and third sentences (underlined) have the same number of words. Constraints: . | 1 &lt;= sentences.length &lt;= 100 | 1 &lt;= sentences[i].length &lt;= 100 | sentences[i] consists only of lowercase English letters and ‘ ‘ only. | sentences[i] does not have leading or trailing spaces. | All the words in sentences[i] are separated by a single space. | . Solution: . class Solution { public int mostWordsFound(String[] sentences) { int max = -1; for(String str : sentences){ String[] s = str.split(\" \"); max = Math.max(max,s.length); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-328-Maximum%20Number%20of%20Words%20Found%20in%20Sentences/",
    "relUrl": "/problem-328-Maximum Number of Words Found in Sentences/"
  },"461": {
    "doc": "A Number After a Double Reversal",
    "title": "A Number After a Double Reversal",
    "content": "Reversing an integer means to reverse all its digits. For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained. Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false. Example 1: . Input: num = 526 Output: true Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num. Example 2: . Input: num = 1800 Output: false Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num. Example 3: . Input: num = 0 Output: true Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num. Constraints: . | 0 &lt;= num &lt;= 106 | . Solution: . class Solution { public boolean isSameAfterReversals(int num) { if(num == 0) return true; if(num % 10 == 0) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-329-A%20Number%20After%20a%20Double%20Reversal/",
    "relUrl": "/problem-329-A Number After a Double Reversal/"
  },"462": {
    "doc": "Intersection of Two Linked Lists",
    "title": "Intersection of Two Linked Lists",
    "content": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: . The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: . The inputs to the judge are given as follows (your program is not given these inputs): . intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. | listA - The first linked list. | listB - The second linked list. | skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. | skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. | . The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: . Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at '8' Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode ptrA = headA, ptrB = headB; while (ptrA != ptrB) { // loop until we found the first common node ptrA = ptrA == null ? headB : ptrA.next; // once we're done with A, move to B ptrB = ptrB == null ? headA : ptrB.next; // once we're done with B, move to A } return ptrA; } } . ",
    "url": "https://1001anjan.github.io/problem-33-Intersection-of-Two-Linked-Lists/",
    "relUrl": "/problem-33-Intersection-of-Two-Linked-Lists/"
  },"463": {
    "doc": "Spiral Matrix II",
    "title": "Spiral Matrix II",
    "content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. Example 1: . Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] . Example 2: . Input: n = 1 Output: [[1]] . Constraints: . | 1 &lt;= n &lt;= 20 | . Solution: . class Solution { public int[][] generateMatrix(int n) { int[][] mat = new int[n][n]; int c = 1, total = n * n; int i = 0, j = 0, yRight = 0, yLeft = 0, xUp = 1, xDown = 0; while(c &lt;= total){ while(c &lt;= total &amp;&amp; j &lt; n - yRight) mat[i][j ++] = c ++; yRight ++; j--; i++; while(c &lt;= total &amp;&amp; i &lt; n - xDown) mat[i ++][j] = c ++; xDown ++; i --; j --; while(c &lt;= total &amp;&amp; j &gt;= yLeft) mat[i][j --] = c ++; yLeft++; j++; i --; while(c &lt;= total &amp;&amp; i &gt;= xUp) mat[i --][j] = c ++; xUp++; i++; j++; } return mat; } } . ",
    "url": "https://1001anjan.github.io/problem-33-Spiral%20Matrix%20II/",
    "relUrl": "/problem-33-Spiral Matrix II/"
  },"464": {
    "doc": "Check if All A's Appears Before All B's",
    "title": "Check if All A’s Appears Before All B’s",
    "content": "Given a string s consisting of only the characters ‘a’ and ‘b’, return true if every ‘a’ appears before every ‘b’ in the string. Otherwise, return false. Example 1: . Input: s = \"aaabbb\" Output: true Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true. Example 2: . Input: s = \"abab\" Output: false Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not every 'a' appears before every 'b' and we return false. Example 3: . Input: s = \"bbb\" Output: true Explanation: There are no 'a's, hence, every 'a' appears before every 'b' and we return true. Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘a’ or ‘b’. | . Solution: . class Solution { public boolean checkString(String s) { // traversing all a's first int i = 0; int n = s.length(); while(i &lt; n &amp;&amp; s.charAt(i) == 'a') i++; if(i == n) return true; while(i &lt; n &amp;&amp;s.charAt(i) == 'b') i++; return i == n; } } . ",
    "url": "https://1001anjan.github.io/problem-330-Check%20if%20All%20A's%20Appears%20Before%20All%20B's/#check-if-all-as-appears-before-all-bs",
    "relUrl": "/problem-330-Check if All A's Appears Before All B's/#check-if-all-as-appears-before-all-bs"
  },"465": {
    "doc": "Check if All A's Appears Before All B's",
    "title": "Check if All A's Appears Before All B's",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-330-Check%20if%20All%20A's%20Appears%20Before%20All%20B's/",
    "relUrl": "/problem-330-Check if All A's Appears Before All B's/"
  },"466": {
    "doc": "Capitalize the Title",
    "title": "Capitalize the Title",
    "content": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that: . | If the length of the word is 1 or 2 letters, change all letters to lowercase. | Otherwise, change the first letter to uppercase and the remaining letters to lowercase. Return the capitalized title. | . Example 1: . Input: title = \"capiTalIze tHe titLe\" Output: \"Capitalize The Title\" Explanation: Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase. Example 2: . Input: title = \"First leTTeR of EACH Word\" Output: \"First Letter of Each Word\" Explanation: The word \"of\" has length 2, so it is all lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. Example 3: . Input: title = \"i lOve leetcode\" Output: \"i Love Leetcode\" Explanation: The word \"i\" has length 1, so it is lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. Constraints: . | 1 &lt;= title.length &lt;= 100 | title consists of words separated by a single space without any leading or trailing spaces. | Each word consists of uppercase and lowercase English letters and is non-empty. | . Solution: . class Solution { public String capitalizeTitle(String title) { StringBuilder sb = new StringBuilder(); String[] words = title.split(\" \"); for(String str : words){ str = str.toLowerCase(); if(str.length() &lt;= 2){ sb.append(str).append(\" \"); }else{ sb.append(Character.toUpperCase(str.charAt(0))) .append(str.substring(1,str.length())).append(\" \"); } } return sb.substring(0,sb.length() - 1).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-331-Capitalize%20the%20Title/",
    "relUrl": "/problem-331-Capitalize the Title/"
  },"467": {
    "doc": "Check if Every Row and Column Contains All Numbers",
    "title": "Check if Every Row and Column Contains All Numbers",
    "content": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive). Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false. Example 1: . Input: matrix = [[1,2,3],[3,1,2],[2,3,1]] Output: true Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. Example 2: . Input: matrix = [[1,1,1],[1,2,3],[1,2,3]] Output: false Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. Constraints: . | n == matrix.length == matrix[i].length | 1 &lt;= n &lt;= 100 | 1 &lt;= matrix[i][j] &lt;= n | . Solution: . class Solution { public boolean checkValid(int[][] matrix) { //check for row int n = matrix.length; for(int i = 0;i &lt; matrix.length; i++){ Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int j = 0; j &lt; matrix[i].length; j++){ s.add(matrix[i][j]); } if(s.size() != n){ return false; } } //check for column for(int i = 0;i &lt; matrix.length; i++){ Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int j = 0; j &lt; matrix[i].length; j++){ s.add(matrix[j][i]); } if(s.size() != n){ return false; } } return true; } } . Faster execution time . class Solution { public boolean checkValid(int[][] matrix) { for(int i=0;i&lt;matrix.length;i++){ boolean [] checkrow = new boolean[matrix[i].length]; for(int j= 0 ; j&lt;checkrow.length;j++){ int temp = matrix[i][j]; if(checkrow[temp-1]) return false; checkrow[temp-1] = true; } boolean [] checkcol = new boolean[matrix[i].length]; for(int j= 0 ; j&lt;checkcol.length;j++){ int temp = matrix[j][i]; if(checkcol[temp-1]) return false; checkcol[temp-1] = true; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-332-Check%20if%20Every%20Row%20and%20Column%20Contains%20All%20Numbers/",
    "relUrl": "/problem-332-Check if Every Row and Column Contains All Numbers/"
  },"468": {
    "doc": "Divide a String Into Groups of Size k",
    "title": "Divide a String Into Groups of Size k",
    "content": "A string s can be partitioned into groups of size k using the following procedure: . | The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group. | For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. | . Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure. Example 1: . Input: s = \"abcdefghi\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\"] Explanation: The first 3 characters \"abc\" form the first group. The next 3 characters \"def\" form the second group. The last 3 characters \"ghi\" form the third group. Since all groups can be completely filled by characters from the string, we do not need to use fill. Thus, the groups formed are \"abc\", \"def\", and \"ghi\". Example 2: . Input: s = \"abcdefghij\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\",\"jxx\"] Explanation: Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\". For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice. Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters only. | 1 &lt;= k &lt;= 100 | fill is a lowercase English letter. | . Solution: . class Solution { public String[] divideString(String s, int k, char fill) { int n = s.length(); String[] ans = new String[(int)Math.ceil((double)n/k)]; StringBuilder sb = new StringBuilder(); int i = 0; int l = 0; while(i &lt; n){ sb.setLength(0); int m = k; while(m &gt; 0 &amp;&amp; i &lt; n){ sb.append(s.charAt(i)); i++; m--; } while(m &gt; 0){ sb.append(fill); m--; } ans[l++] = sb.toString(); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-333-Divide%20a%20String%20Into%20Groups%20of%20Size%20k/",
    "relUrl": "/problem-333-Divide a String Into Groups of Size k/"
  },"469": {
    "doc": "Minimum Cost of Buying Candies With Discount",
    "title": "Minimum Cost of Buying Candies With Discount",
    "content": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free. The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought. | For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4. Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies. | . Example 1: . Input: cost = [1,2,3] Output: 5 Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free. The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies. Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free. The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies. Example 2: . Input: cost = [6,5,7,9,2,2] Output: 23 Explanation: The way in which we can get the minimum cost is described below: - Buy candies with costs 9 and 7 - Take the candy with cost 6 for free - We buy candies with costs 5 and 2 - Take the last remaining candy with cost 2 for free Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23. Example 3: . Input: cost = [5,5] Output: 10 Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free. Hence, the minimum cost to buy all candies is 5 + 5 = 10. Constraints: . | 1 &lt;= cost.length &lt;= 100 | 1 &lt;= cost[i] &lt;= 100 | . Solution: . class Solution { public int minimumCost(int[] cost) { Arrays.sort(cost); int d = 0; int sum = 0; for(int i = cost.length - 1; i &gt;= 0; i--){ d++; if(d % 3 == 0) continue; sum += cost[i]; } return sum; } } . class Solution { public int minimumCost(int[] cost) { Arrays.sort(cost); int sum = 0; for(int i = 1; i &lt;= cost.length; i++){ if(i % 3 == 0){ continue; } else{ sum += cost[cost.length - i]; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-334-Minimum%20Cost%20of%20Buying%20Candies%20With%20Discount/",
    "relUrl": "/problem-334-Minimum Cost of Buying Candies With Discount/"
  },"470": {
    "doc": "Keep Multiplying Found Values by Two",
    "title": "Keep Multiplying Found Values by Two",
    "content": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums. You then do the following steps: . | If original is found in nums, multiply it by two (i.e., set original = 2 * original). | Otherwise, stop the process. | Repeat this process with the new number as long as you keep finding the number. Return the final value of original. | . Example 1: . Input: nums = [5,3,6,1,12], original = 3 Output: 24 Explanation: - 3 is found in nums. 3 is multiplied by 2 to obtain 6. - 6 is found in nums. 6 is multiplied by 2 to obtain 12. - 12 is found in nums. 12 is multiplied by 2 to obtain 24. - 24 is not found in nums. Thus, 24 is returned. Example 2: . Input: nums = [2,7,9], original = 4 Output: 4 Explanation: - 4 is not found in nums. Thus, 4 is returned. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i], original &lt;= 1000 | . Solution: . class Solution { public int findFinalValue(int[] nums, int original) { Arrays.sort(nums); for(int n : nums){ if(n == original) original *= 2; } return original; } } . Improvement using binary search . class Solution { public int findFinalValue(int[] nums, int original) { Arrays.sort(nums); int s = 0; int e = nums.length - 1; while(s &lt;= e){ int mid = (s + e)/2; if(nums[mid] == original){ original *= 2; e = nums.length - 1; }else if(nums[mid] &gt; original){ e = mid - 1; }else{ s = mid + 1; } } return original; } } . But faster approach . class Solution { public int findFinalValue(int[] nums, int original) { while(isPresent(nums, original)) original *= 2; return original; } public boolean isPresent(int[] nums, int target){ for(int i: nums) if(i == target) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-335-Keep%20Multiplying%20Found%20Values%20by%20Two/",
    "relUrl": "/problem-335-Keep Multiplying Found Values by Two/"
  },"471": {
    "doc": "Minimum Sum of Four Digit Number After Splitting Digits",
    "title": "Minimum Sum of Four Digit Number After Splitting Digits",
    "content": "You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used. | For example, given num = 2932, you have the following digits: two 2’s, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329]. Return the minimum possible sum of new1 and new2. | . Example 1: . Input: num = 2932 Output: 52 Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc. The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52. Example 2: . Input: num = 4009 Output: 13 Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13. Constraints: . | 1000 &lt;= num &lt;= 9999 | . Solution: . class Solution { public int minimumSum(int num) { int[] d = new int[4]; int i = 0; while(num &gt; 0){ d[i++] = num % 10; num = num / 10; } Arrays.sort(d); int d1 = d[0] * 10 + d[2]; int d2 = d[1] * 10 + d[3]; return d1 + d2; } } . ",
    "url": "https://1001anjan.github.io/problem-336-Minimum%20Sum%20of%20Four%20Digit%20Number%20After%20Splitting%20Digits/",
    "relUrl": "/problem-336-Minimum Sum of Four Digit Number After Splitting Digits/"
  },"472": {
    "doc": "Sort Even and Odd Indices Independently",
    "title": "Sort Even and Odd Indices Independently",
    "content": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules: . | Sort the values at odd indices of nums in non-increasing order. | For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order. | . | Sort the values at even indices of nums in non-decreasing order. | For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order. Return the array formed after rearranging the values of nums. | . | . Example 1: . Input: nums = [4,1,2,3] Output: [2,3,4,1] Explanation: First, we sort the values present at odd indices (1 and 3) in non-increasing order. So, nums changes from [4,1,2,3] to [4,3,2,1]. Next, we sort the values present at even indices (0 and 2) in non-decreasing order. So, nums changes from [4,1,2,3] to [2,3,4,1]. Thus, the array formed after rearranging the values is [2,3,4,1]. Example 2: . Input: nums = [2,1] Output: [2,1] Explanation: Since there is exactly one odd index and one even index, no rearrangement of values takes place. The resultant array formed is [2,1], which is the same as the initial array. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] sortEvenOdd(int[] nums) { int[] even, odd; if(nums.length % 2 == 0){ even = new int[nums.length/2]; odd = new int[nums.length/2]; }else{ even = new int[nums.length/2 + 1]; odd = new int[nums.length/2]; } int k = 0,l = 0; for(int i = 0; i &lt; nums.length; i++){ if(i % 2 == 0){ even[k++] = nums[i]; }else{ odd[l++] = nums[i]; } } Arrays.sort(even); Arrays.sort(odd); k = 0; l = odd.length - 1; for(int i = 0; i &lt; nums.length; i++){ if(i % 2 == 0){ nums[i] = even[k++]; }else{ nums[i] = odd[l--]; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-337-Sort%20Even%20and%20Odd%20Indices%20Independently/",
    "relUrl": "/problem-337-Sort Even and Odd Indices Independently/"
  },"473": {
    "doc": "Count Operations to Obtain Zero",
    "title": "Count Operations to Obtain Zero",
    "content": "You are given two non-negative integers num1 and num2. In one operation, if num1 &gt;= num2, you must subtract num2 from num1, otherwise subtract num1 from num2. | For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1. Return the number of operations required to make either num1 = 0 or num2 = 0. | . Example 1: . Input: num1 = 2, num2 = 3 Output: 3 Explanation: - Operation 1: num1 = 2, num2 = 3. Since num1 &lt; num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1. - Operation 2: num1 = 2, num2 = 1. Since num1 &gt; num2, we subtract num2 from num1. - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1. Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations. So the total number of operations required is 3. Example 2: . Input: num1 = 10, num2 = 10 Output: 1 Explanation: - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0. Now num1 = 0 and num2 = 10. Since num1 == 0, we are done. So the total number of operations required is 1. Constraints: . | 0 &lt;= num1, num2 &lt;= 105 | . Solution: . class Solution { public int countOperations(int num1, int num2) { int op = 0; while(num1 &gt; 0 &amp;&amp; num2 &gt; 0){ if(num1 &gt; num2){ num1 = num1 - num2; }else{ num2 = num2 - num1; } op++; } return op; } } . Optimised . class Solution { public int countOperations(int num1, int num2) { int op = 0; while(num1 &gt; 0 &amp;&amp; num2 &gt; 0){ int max = Math.max(num1,num2); int min = Math.min(num1,num2); op += max / min; num1 = min; num2 = max % min; } return op; } } . ",
    "url": "https://1001anjan.github.io/problem-338-Count%20Operations%20to%20Obtain%20Zero/",
    "relUrl": "/problem-338-Count Operations to Obtain Zero/"
  },"474": {
    "doc": "Count Equal and Divisible Pairs in an Array",
    "title": "Count Equal and Divisible Pairs in an Array",
    "content": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 &lt;= i &lt; j &lt; n, such that nums[i] == nums[j] and (i * j) is divisible by k. Example 1: . Input: nums = [3,1,2,2,2,1,3], k = 2 Output: 4 Explanation: There are 4 pairs that meet all the requirements: - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2. - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2. - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2. - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2. Example 2: . Input: nums = [1,2,3,4], k = 1 Output: 0 Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i], k &lt;= 100 | . Solution: . class Solution { public int countPairs(int[] nums, int k) { int c = 0; for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ if(nums[i] == nums[j]){ if((i*j)%k == 0) c++; } } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-339-Count%20Equal%20and%20Divisible%20Pairs%20in%20an%20Array/",
    "relUrl": "/problem-339-Count Equal and Divisible Pairs in an Array/"
  },"475": {
    "doc": "Excel Sheet Column Title",
    "title": "Excel Sheet Column Title",
    "content": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example: . A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... Example 1: . Input: columnNumber = 1 Output: \"A\" . Example 2: . Input: columnNumber = 28 Output: \"AB\" . Example 3: . Input: columnNumber = 701 Output: \"ZY\" . Constraints: . | 1 &lt;= columnNumber &lt;= 231 - 1 | . Solution . class Solution { public String convertToTitle(int columnNumber) { StringBuilder sb = new StringBuilder(); int digit; while(columnNumber&gt;0){ digit = (columnNumber-1)%26; sb.append((char)((int)'A' + digit)); columnNumber = (columnNumber-1)/26; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-34-Excel-Sheet-Column-Title/",
    "relUrl": "/problem-34-Excel-Sheet-Column-Title/"
  },"476": {
    "doc": "Rotate List",
    "title": "Rotate List",
    "content": "Given the head of a linked list, rotate the list to the right by k places. Example 1: . Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] . Example 2: . Input: head = [0,1,2], k = 4 Output: [2,0,1] . Constraints: . | The number of nodes in the list is in the range [0, 500]. | -100 &lt;= Node.val &lt;= 100 | 0 &lt;= k &lt;= 2 * 10^9 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || k ==0 || head.next == null) return head; int len = 1; ListNode ptr; ptr = head; while(ptr.next != null){ len++; ptr = ptr.next; } int t = k % len; if(t == 0) return head; ListNode slow, fast; slow = fast = head; for(int i = 0; i &lt; t &amp;&amp; fast.next != null; i++, fast = fast.next); while(fast.next != null){ slow = slow.next; fast = fast.next; } ptr = slow.next; slow.next = null; fast.next = head; head = ptr; return head; } } . ",
    "url": "https://1001anjan.github.io/problem-34-Rotate%20List/",
    "relUrl": "/problem-34-Rotate List/"
  },"477": {
    "doc": "Count Integers With Even Digit Sum",
    "title": "Count Integers With Even Digit Sum",
    "content": "Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even. The digit sum of a positive integer is the sum of all its digits. Example 1: . Input: num = 4 Output: 2 Explanation: The only integers less than or equal to 4 whose digit sums are even are 2 and 4. Example 2: . Input: num = 30 Output: 14 Explanation: The 14 integers less than or equal to 30 whose digit sums are even are 2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28. Constraints: . | 1 &lt;= num &lt;= 1000 | . Solution: . class Solution { public int countEven(int num) { int c = 0; for(int i = 2; i &lt;= num; i++){ if(digitSum(i) % 2 == 0) c++; } return c; } public int digitSum(int n){ int sum = 0; while(n &gt; 0){ sum += n % 10; n = n / 10; } return sum; } } . Improvement . class Solution { public boolean sumOfDigits(int n){ int sum = 0; while(n != 0){ sum += (n % 10); n = n / 10; } return sum %2 == 0 ? true : false; } public int countEven(int num) { int c = 0; for(int i = 2;i &lt;= num; i++){ if(i &lt; 10 &amp;&amp; i %2 == 0) c++; else if(sumOfDigits(i) == true) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-340-Count%20Integers%20With%20Even%20Digit%20Sum/",
    "relUrl": "/problem-340-Count Integers With Even Digit Sum/"
  },"478": {
    "doc": "Counting Words With a Given Prefix",
    "title": "Counting Words With a Given Prefix",
    "content": "You are given an array of strings words and a string pref. Return the number of strings in words that contain pref as a prefix. A prefix of a string s is any leading contiguous substring of s. Example 1: . Input: words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\" Output: 2 Explanation: The 2 strings that contain \"at\" as a prefix are: \"attention\" and \"attend\". Example 2: . Input: words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\" Output: 0 Explanation: There are no strings that contain \"code\" as a prefix. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length, pref.length &lt;= 100 | words[i] and pref consist of lowercase English letters. | . Solution: . class Solution { public int prefixCount(String[] words, String pref) { int c = 0; for(String str : words){ if(str.indexOf(pref) == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-341-Counting%20Words%20With%20a%20Given%20Prefix/",
    "relUrl": "/problem-341-Counting Words With a Given Prefix/"
  },"479": {
    "doc": "Find All K-Distant Indices in an Array",
    "title": "Find All K-Distant Indices in an Array",
    "content": "You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| &lt;= k and nums[j] == key. Return a list of all k-distant indices sorted in increasing order. Example 1: . Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1 Output: [1,2,3,4,5,6] Explanation: Here, nums[2] == key and nums[5] == key. - For index 0, |0 - 2| &gt; k and |0 - 5| &gt; k, so there is no j where |0 - j| &lt;= k and nums[j] == key. Thus, 0 is not a k-distant index. - For index 1, |1 - 2| &lt;= k and nums[2] == key, so 1 is a k-distant index. - For index 2, |2 - 2| &lt;= k and nums[2] == key, so 2 is a k-distant index. - For index 3, |3 - 2| &lt;= k and nums[2] == key, so 3 is a k-distant index. - For index 4, |4 - 5| &lt;= k and nums[5] == key, so 4 is a k-distant index. - For index 5, |5 - 5| &lt;= k and nums[5] == key, so 5 is a k-distant index. - For index 6, |6 - 5| &lt;= k and nums[5] == key, so 6 is a k-distant index. Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. Example 2: . Input: nums = [2,2,2,2,2], key = 2, k = 2 Output: [0,1,2,3,4] Explanation: For all indices i in nums, there exists some index j such that |i - j| &lt;= k and nums[j] == key, so every index is a k-distant index. Hence, we return [0,1,2,3,4]. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | key is an integer from the array nums. | 1 &lt;= k &lt;= nums.length | . Solution: . class Solution { public List&lt;Integer&gt; findKDistantIndices(int[] nums, int key, int k) { Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++){ if(nums[i] == key){ if(s.add(i)){ for(int j = i - 1; j &gt;= 0 &amp;&amp; j &gt;= i - k ; j--){ if(!s.add(j)) break; } } for(int j = i + 1; j &lt; nums.length &amp;&amp; j &lt;= i + k ; j++){ s.add(j); } } } List&lt;Integer&gt; ans = s.stream().collect(Collectors.toList()); Collections.sort(ans); return ans; } } . Improvement and O(n) complexity . class Solution { public List&lt;Integer&gt; findKDistantIndices(int[] nums, int key, int k) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0, j =0, lastVisited = 0; i &lt; nums.length; i++){ if(nums[i] == key){ for(j = Math.max(lastVisited,i - k); j &lt; Math.min(nums.length,i + k + 1); j++){ ans.add(j); } lastVisited = j; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-342-Find%20All%20K-Distant%20Indices%20in%20an%20Array/",
    "relUrl": "/problem-342-Find All K-Distant Indices in an Array/"
  },"480": {
    "doc": "Divide Array Into Equal Pairs",
    "title": "Divide Array Into Equal Pairs",
    "content": "You are given an integer array nums consisting of 2 * n integers. You need to divide nums into n pairs such that: . | Each element belongs to exactly one pair. | The elements present in a pair are equal. Return true if nums can be divided into n pairs, otherwise return false. | . Example 1: . Input: nums = [3,2,3,2,2,2] Output: true Explanation: There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs. If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions. Example 2: . Input: nums = [1,2,3,4] Output: false Explanation: There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition. Constraints: . | nums.length == 2 * n | 1 &lt;= n &lt;= 500 | 1 &lt;= nums[i] &lt;= 500 | . Solution: . class Solution { public boolean divideArray(int[] nums) { int[] dp = new int[501]; for(int n : nums) dp[n]++; for(int n : dp){ if(n % 2 != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-343-Divide%20Array%20Into%20Equal%20Pairs/",
    "relUrl": "/problem-343-Divide Array Into Equal Pairs/"
  },"481": {
    "doc": "Count Hills and Valleys in an Array",
    "title": "Count Hills and Valleys in an Array",
    "content": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums. Example 1: . Input: nums = [2,4,1,1,6,5] Output: 3 Explanation: At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley. At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill. At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley. At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2. At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill. At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. There are 3 hills and valleys so we return 3. Example 2: . Input: nums = [6,6,5,5,4,1] Output: 0 Explanation: At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley. At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley. At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley. At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley. At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley. At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley. There are 0 hills and valleys so we return 0. Constraints: . | 3 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int countHillValley(int[] nums) { int c = 0; int lastElement = nums[0]; int i = 1; while(i &lt; nums.length - 1){ lastElement = nums[i-1]; while(i &lt; nums.length &amp;&amp; nums[i - 1] == nums[i]) i++; while(i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i+1]) i++; if(i &lt; nums.length - 1 &amp;&amp; lastElement &gt; nums[i] &amp;&amp; nums[i] &lt; nums[i+1]) c++; if(i &lt; nums.length - 1 &amp;&amp; lastElement &lt; nums[i] &amp;&amp; nums[i] &gt; nums[i+1]) c++; i++; } return c; } } . Another way . class Solution { public int countHillValley(int[] nums) { int res = 0; int prev = 0; for(int i = 1; i &lt; nums.length; ++i) { int diff = nums[i] - nums[i - 1]; if (prev != 0 &amp;&amp; diff != 0 &amp;&amp; !((prev &gt; 0 &amp;&amp; diff &gt; 0) || (prev &lt; 0 &amp;&amp; diff &lt; 0))) ++res; prev = diff == 0 ? prev : diff; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-344-Count%20Hills%20and%20Valleys%20in%20an%20Array/",
    "relUrl": "/problem-344-Count Hills and Valleys in an Array/"
  },"482": {
    "doc": "Find the Difference of Two Arrays",
    "title": "Find the Difference of Two Arrays",
    "content": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: . | answer[0] is a list of all distinct integers in nums1 which are not present in nums2. | answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order. | . Example 1: . Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. Example 2: . Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | -1000 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; findDifference(int[] nums1, int[] nums2) { Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;(); for(int n : nums1) s1.add(n); for(int n : nums2) s2.add(n); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int n : s1){ if(!s2.contains(n)) temp.add(n); } ans.add(temp); List&lt;Integer&gt; temp1 = new ArrayList&lt;&gt;(); for(int n : s2){ if(!s1.contains(n)) temp1.add(n); } ans.add(temp1); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-345-Find%20the%20Difference%20of%20Two%20Arrays/",
    "relUrl": "/problem-345-Find the Difference of Two Arrays/"
  },"483": {
    "doc": "Minimum Bit Flips to Convert Number",
    "title": "Minimum Bit Flips to Convert Number",
    "content": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0. | For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc. Given two integers start and goal, return the minimum number of bit flips to convert start to goal. | . Example 1: . Input: start = 10, goal = 7 Output: 3 Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps: - Flip the first bit from the right: 1010 -&gt; 1011. - Flip the third bit from the right: 1011 -&gt; 1111. - Flip the fourth bit from the right: 1111 -&gt; 0111. It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3. Example 2: . Input: start = 3, goal = 4 Output: 3 Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps: - Flip the first bit from the right: 011 -&gt; 010. - Flip the second bit from the right: 010 -&gt; 000. - Flip the third bit from the right: 000 -&gt; 100. It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3. Constraints: . | 0 &lt;= start, goal &lt;= 10^9 | . Solution: . class Solution { public int minBitFlips(int start, int goal) { int n = start ^ goal; int c = 0; while(n != 0){ if((n &amp; 1) == 1) c++; n = n &gt;&gt; 1; } return c; } } . Faster excution . class Solution { public int minBitFlips(int start, int goal) { int xORStartGoal= start ^ goal; // Different bits will be set int count=0; while(xORStartGoal &gt; 0) { xORStartGoal &amp;= (xORStartGoal - 1); count++; // Count number of set Bits } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-346-Minimum%20Bit%20Flips%20to%20Convert%20Number/",
    "relUrl": "/problem-346-Minimum Bit Flips to Convert Number/"
  },"484": {
    "doc": "Minimum Number of Operations to Convert Time",
    "title": "Minimum Number of Operations to Convert Time",
    "content": "You are given two strings current and correct representing two 24-hour times. 24-hour times are formatted as “HH:MM”, where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59. In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times. Return the minimum number of operations needed to convert current to correct. Example 1: . Input: current = \"02:30\", correct = \"04:35\" Output: 3 Explanation: We can convert current to correct in 3 operations as follows: - Add 60 minutes to current. current becomes \"03:30\". - Add 60 minutes to current. current becomes \"04:30\". - Add 5 minutes to current. current becomes \"04:35\". It can be proven that it is not possible to convert current to correct in fewer than 3 operations. Example 2: . Input: current = \"11:00\", correct = \"11:01\" Output: 1 Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1. Constraints: . | current and correct are in the format “HH:MM” | current &lt;= correct | . Solution: . class Solution { public int convertTime(String current, String correct) { String[] cr = current.split(\":\"); String[] co = correct.split(\":\"); int minCurr = Integer.parseInt(cr[0]) * 60 + Integer.parseInt(cr[1]); int minCorr = Integer.parseInt(co[0]) * 60 + Integer.parseInt(co[1]); int minDiff = minCorr - minCurr; int op = 0; if(minDiff &gt;= 60){ int d = minDiff / 60; op += d; minDiff -= d * 60; } if(minDiff &gt;= 15){ int d = minDiff / 15; op += d; minDiff -= d * 15; } if(minDiff &gt;= 5){ int d = minDiff / 5; op += d; minDiff -= d * 5; } if(minDiff &gt;= 1){ op += minDiff; } return op; } } . Faster execution . class Solution { public int HHMMToMinutes(String s){ return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ; } public int convertTime(String current, String correct) { int diff = HHMMToMinutes(correct) - HHMMToMinutes(current); int[] order = {60,15,5,1}; int i = 0; int ops = 0; while(i &lt; 4){ ops += (diff / order[i]); diff %= order[i]; i++; } return ops; } } . ",
    "url": "https://1001anjan.github.io/problem-347-Minimum%20Number%20of%20Operations%20to%20Convert%20Time/",
    "relUrl": "/problem-347-Minimum Number of Operations to Convert Time/"
  },"485": {
    "doc": "Find Closest Number to Zero",
    "title": "Find Closest Number to Zero",
    "content": "Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value. Example 1: . Input: nums = [-4,-2,1,4,8] Output: 1 Explanation: The distance from -4 to 0 is |-4| = 4. The distance from -2 to 0 is |-2| = 2. The distance from 1 to 0 is |1| = 1. The distance from 4 to 0 is |4| = 4. The distance from 8 to 0 is |8| = 8. Thus, the closest number to 0 in the array is 1. Example 2: . Input: nums = [2,-1,1] Output: 1 Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned. Constraints: . | 1 &lt;= n &lt;= 1000 | -105 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public int findClosestNumber(int[] nums) { int num = nums[0]; int diff = Math.abs(nums[0]); for(int n : nums){ int abs = Math.abs(n); if(diff &gt; abs){ diff = abs; num = n; }else if(diff == abs &amp;&amp; n &gt; num){ num = n; } } return num; } } . ",
    "url": "https://1001anjan.github.io/problem-348-Find%20Closest%20Number%20to%20Zero/",
    "relUrl": "/problem-348-Find Closest Number to Zero/"
  },"486": {
    "doc": "Calculate Digit Sum of a String",
    "title": "Calculate Digit Sum of a String",
    "content": "You are given a string s consisting of digits and an integer k. A round can be completed if the length of s is greater than k. In one round, do the following: . | Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k. | Replace each group of s with a string representing the sum of all its digits. For example, “346” is replaced with “13” because 3 + 4 + 6 = 13. | Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1. Return s after all rounds have been completed. | . Example 1: . Input: s = \"11111222223\", k = 3 Output: \"135\" Explanation: - For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\". Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round. - For the second round, we divide s into \"346\" and \"5\". Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. So, s becomes \"13\" + \"5\" = \"135\" after second round. Now, s.length &lt;= k, so we return \"135\" as the answer. Example 2: . Input: s = \"00000000\", k = 3 Output: \"000\" Explanation: We divide s into \"000\", \"000\", and \"00\". Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. s becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\". Constraints: . | 1 &lt;= s.length &lt;= 100 | 2 &lt;= k &lt;= 100 | s consists of digits only. | . Solution: . class Solution { public String digitSum(String s, int k) { StringBuilder sb = new StringBuilder(); while(s.length() &gt; k){ int d = s.charAt(0) - '0'; int i = 1; for(; i &lt; s.length(); i++){ if(i % k == 0){ sb.append(d); d = s.charAt(i) - '0'; }else{ d += s.charAt(i) - '0'; } } sb.append(d); s = sb.toString(); sb.setLength(0); } return s; } } . ",
    "url": "https://1001anjan.github.io/problem-349-Calculate%20Digit%20Sum%20of%20a%20String/",
    "relUrl": "/problem-349-Calculate Digit Sum of a String/"
  },"487": {
    "doc": "Majority Element",
    "title": "Majority Element",
    "content": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1: . Input: nums = [3,2,3] Output: 3 . Example 2: . Input: nums = [2,2,1,1,1,2,2] Output: 2 . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 5 * 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution . Sorting Approach: NlogN complexity. Space: O(1) . class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; } } . HashMap Approach: Time Complexity O(n), Space Complexity: O(n) . class Solution { public int majorityElement(int[] nums) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i=0; i&lt;nums.length; i++){ if(map.containsKey(nums[i])){ map.put(nums[i],map.get(nums[i])+1); }else{ map.put(nums[i],1); } } int count = 0; int key = 0; for(Map.Entry&lt;Integer,Integer&gt; keyValue : map.entrySet()){ if(keyValue.getValue()&gt;count){ count = keyValue.getValue(); key = keyValue.getKey(); } } return key; } } . Moor’s Algorithm: Time Complexity: O(n), Space Complexity: O(1) . class Solution { public int majorityElement(int[] nums) { if(nums.length == 1) return nums[0]; int majorElementIndex = 0; int majorElementCount = 1; for(int i=1; i&lt;nums.length; i++){ if(nums[majorElementIndex] == nums[i]){ majorElementCount ++; }else{ majorElementCount --; } if(majorElementCount == 0){ majorElementCount = 1; majorElementIndex = i; } } return nums[majorElementIndex]; } } . ",
    "url": "https://1001anjan.github.io/problem-35-Majority-Element/",
    "relUrl": "/problem-35-Majority-Element/"
  },"488": {
    "doc": "Unique Paths",
    "title": "Unique Paths",
    "content": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: . Input: m = 3, n = 7 Output: 28 . Example 2: . Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Down . Constraints: . | 1 &lt;= m, n &lt;= 100 | . Solution: . Time limits exceeds with backtracking () . class Solution { public int uniquePaths(int m, int n) { return processPaths(m,n,1,1); } public int processPaths(int m, int n, int i, int j){ // index stating from (1,1) if(i == m &amp;&amp; j == n) return 1; if(i &gt; m || j &gt; n) return 0; int ans = processPaths(m,n,i + 1, j) + processPaths(m,n,i, j + 1); return ans; } } . O(m*n) time complexity . class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } return dp[m - 1][n - 1]; } } . class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; for(int j = 0; j &lt; n; j++) dp[j] = 1; for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++) dp[j] += dp[j - 1]; } return dp[n - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-35-Unique%20Paths/",
    "relUrl": "/problem-35-Unique Paths/"
  },"489": {
    "doc": "Intersection of Multiple Arrays",
    "title": "Intersection of Multiple Arrays",
    "content": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order. Example 1: . Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] Output: [3,4] Explanation: The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4]. Example 2: . Input: nums = [[1,2,3],[4,5,6]] Output: [] Explanation: There does not exist any integer present both in nums[0] and nums[1], so we return an empty list []. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= sum(nums[i].length) &lt;= 1000 | 1 &lt;= nums[i][j] &lt;= 1000 | All the values of nums[i] are unique. | . Solution: . class Solution { public List&lt;Integer&gt; intersection(int[][] nums) { int[] dp = new int[1001]; for(int[] arr : nums){ for(int n : arr) dp[n]++; } List&lt;Integer&gt; ans = new LinkedList(); for(int i = 0; i &lt; 1001; i++){ if(dp[i] == nums.length) ans.add(i); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-350-Intersection%20of%20Multiple%20Arrays/",
    "relUrl": "/problem-350-Intersection of Multiple Arrays/"
  },"490": {
    "doc": "Count Prefixes of a Given String",
    "title": "Count Prefixes of a Given String",
    "content": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters. Return the number of strings in words that are a prefix of s. A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string. Example 1: . Input: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\" Output: 3 Explanation: The strings in words which are a prefix of s = \"abc\" are: \"a\", \"ab\", and \"abc\". Thus the number of strings in words which are a prefix of s is 3. Example 2: . Input: words = [\"a\",\"a\"], s = \"aa\" Output: 2 Explanation: Both of the strings are a prefix of s. Note that the same string can occur multiple times in words, and it should be counted each time. Constraints: . | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length, s.length &lt;= 10 | words[i] and s consist of lowercase English letters only. | . Solution: . class Solution { public int countPrefixes(String[] words, String s) { int c = 0; for(String str : words){ if(s.indexOf(str) == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-351-Count%20Prefixes%20of%20a%20Given%20String/",
    "relUrl": "/problem-351-Count Prefixes of a Given String/"
  },"491": {
    "doc": "Remove Digit From Number to Maximize Result",
    "title": "Remove Digit From Number to Maximize Result",
    "content": "You are given a string number representing a positive integer and a character digit. Return the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number. Example 1: . Input: number = \"123\", digit = \"3\" Output: \"12\" Explanation: There is only one '3' in \"123\". After removing '3', the result is \"12\". Example 2: . Input: number = \"1231\", digit = \"1\" Output: \"231\" Explanation: We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\". Since 231 &gt; 123, we return \"231\". Example 3: . Input: number = \"551\", digit = \"5\" Output: \"51\" Explanation: We can remove either the first or second '5' from \"551\". Both result in the string \"51\". Constraints: . | 2 &lt;= number.length &lt;= 100 | number consists of digits from ‘1’ to ‘9’. | digit is a digit from ‘1’ to ‘9’. | digit occurs at least once in number. | . Solution: . class Solution { public String removeDigit(String number, char digit) { int index = 0; int n = number.length(); for(int i = 0; i &lt; n; i++){ if(number.charAt(i) == digit){ index = i; if(i &lt; n - 1 &amp;&amp; digit &lt; number.charAt(i + 1)) break; } } return number.substring(0,index) + number.substring(index + 1, n); } } . ",
    "url": "https://1001anjan.github.io/problem-352-Remove%20Digit%20From%20Number%20to%20Maximize%20Result/",
    "relUrl": "/problem-352-Remove Digit From Number to Maximize Result/"
  },"492": {
    "doc": "Largest 3-Same-Digit Number in String",
    "title": "Largest 3-Same-Digit Number in String",
    "content": "You are given a string num representing a large integer. An integer is good if it meets the following conditions: . | It is a substring of num with length 3. | It consists of only one unique digit. Return the maximum good integer as a string or an empty string “” if no such integer exists. | . Note: . | A substring is a contiguous sequence of characters within a string. | There may be leading zeroes in num or a good integer. | . Example 1: . Input: num = \"6777133339\" Output: \"777\" Explanation: There are two distinct good integers: \"777\" and \"333\". \"777\" is the largest, so we return \"777\". Example 2: . Input: num = \"2300019\" Output: \"000\" Explanation: \"000\" is the only good integer. Example 3: . Input: num = \"42352338\" Output: \"\" Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers. Constraints: . | 3 &lt;= num.length &lt;= 1000 | num only consists of digits. | . Solution: . class Solution { public String largestGoodInteger(String num) { int d = -1; String ans = \"\"; char[] str = num.toCharArray(); for(int i = 0; i &lt; str.length - 2; i++){ if(str[i] == str[i + 1] &amp;&amp; str[i] == str[i + 2] &amp;&amp; d &lt; str[i] - '0'){ d = str[i] - '0'; ans = num.substring(i,i + 3); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-353-Largest%203-Same-Digit%20Number%20in%20String/",
    "relUrl": "/problem-353-Largest 3-Same-Digit Number in String/"
  },"493": {
    "doc": "Find the K-Beauty of a Number",
    "title": "Find the K-Beauty of a Number",
    "content": "The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions: . | It has a length of k. | It is a divisor of num. Given integers num and k, return the k-beauty of num. | . Note: . | Leading zeros are allowed. | 0 is not a divisor of any value. | A substring is a contiguous sequence of characters in a string. | . Example 1: . Input: num = 240, k = 2 Output: 2 Explanation: The following are the substrings of num of length k: - \"24\" from \"240\": 24 is a divisor of 240. - \"40\" from \"240\": 40 is a divisor of 240. Therefore, the k-beauty is 2. Example 2: . Input: num = 430043, k = 2 Output: 2 Explanation: The following are the substrings of num of length k: - \"43\" from \"430043\": 43 is a divisor of 430043. - \"30\" from \"430043\": 30 is not a divisor of 430043. - \"00\" from \"430043\": 0 is not a divisor of 430043. - \"04\" from \"430043\": 4 is not a divisor of 430043. - \"43\" from \"430043\": 43 is a divisor of 430043. Therefore, the k-beauty is 2. Constraints: . | 1 &lt;= num &lt;= 109 | 1 &lt;= k &lt;= num.length (taking num as a string) | . Solution: . class Solution { public int divisorSubstrings(int num, int k) { String str = String.valueOf(num); int c = 0; for(int i = 0; i &lt;= str.length() - k; i++){ int d = Integer.parseInt(str.substring(i, i + k)); if(d != 0 &amp;&amp; num % d == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-354-Find%20the%20K-Beauty%20of%20a%20Number/",
    "relUrl": "/problem-354-Find the K-Beauty of a Number/"
  },"494": {
    "doc": "Find Resultant Array After Removing Anagrams",
    "title": "Find Resultant Array After Removing Anagrams",
    "content": "You are given a 0-indexed string array words, where words[i] consists of lowercase English letters. In one operation, select any index i such that 0 &lt; i &lt; words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions. Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, “dacb” is an anagram of “abdc”. Example 1: . Input: words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"] Output: [\"abba\",\"cd\"] Explanation: One of the ways we can obtain the resultant array is by using the following operations: - Since words[2] = \"bbaa\" and words[1] = \"baba\" are anagrams, we choose index 2 and delete words[2]. Now words = [\"abba\",\"baba\",\"cd\",\"cd\"]. - Since words[1] = \"baba\" and words[0] = \"abba\" are anagrams, we choose index 1 and delete words[1]. Now words = [\"abba\",\"cd\",\"cd\"]. - Since words[2] = \"cd\" and words[1] = \"cd\" are anagrams, we choose index 2 and delete words[2]. Now words = [\"abba\",\"cd\"]. We can no longer perform any operations, so [\"abba\",\"cd\"] is the final answer. Example 2: . Input: words = [\"a\",\"b\",\"c\",\"d\",\"e\"] Output: [\"a\",\"b\",\"c\",\"d\",\"e\"] Explanation: No two adjacent strings in words are anagrams of each other, so no operations are performed. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 10 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;String&gt; removeAnagrams(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] dp = new int[26]; ans.add(words[0]); for(char ch : words[0].toCharArray()) dp[ch - 'a']++; for(int i = 1; i &lt; words.length; i++){ int[] dpp = getAnagramsMap(words[i]); boolean flag = true; for(int j = 0; j &lt; 26; j++){ if(dpp[j] != dp[j]) flag = false; dp[j] = dpp[j]; } if(!flag) ans.add(words[i]); } return ans; } public int[] getAnagramsMap(String str){ int[] dp = new int[26]; for(char ch : str.toCharArray()) dp[ch - 'a']++; return dp; } } . Anotherway . class Solution { public List&lt;String&gt; removeAnagrams(String[] words) { int low = 0; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] prev = count(words[low]); for(int i=1;i&lt;words.length;i++){ int[] curr = count(words[i]); if(Arrays.equals(prev,curr)){ continue; } ans.add(words[low]); low = i; prev = count(words[low]); } ans.add(words[low]); return ans; } private int[] count(String s){ int[] c = new int[26]; int n = s.length(); for(int i=0;i&lt;n;i++){ c[s.charAt(i)-'a']++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-355-Find%20Resultant%20Array%20After%20Removing%20Anagrams/",
    "relUrl": "/problem-355-Find Resultant Array After Removing Anagrams/"
  },"495": {
    "doc": "Percentage of Letter in String",
    "title": "Percentage of Letter in String",
    "content": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent. Example 1: . Input: s = \"foobar\", letter = \"o\" Output: 33 Explanation: The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33. Example 2: . Input: s = \"jjjj\", letter = \"k\" Output: 0 Explanation: The percentage of characters in s that equal the letter 'k' is 0%, so we return 0. Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | letter is a lowercase English letter. | . Solution: . class Solution { public int percentageLetter(String s, char letter) { int c = 0; for(char ch : s.toCharArray()) if(ch == letter) c++; return (c * 100) / s.length(); } } . ",
    "url": "https://1001anjan.github.io/problem-356-Percentage%20of%20Letter%20in%20String/",
    "relUrl": "/problem-356-Percentage of Letter in String/"
  },"496": {
    "doc": "Check if Number Has Equal Digit Count and Digit Value",
    "title": "Check if Number Has Equal Digit Count and Digit Value",
    "content": "You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 &lt;= i &lt; n, the digit i occurs num[i] times in num, otherwise return false. #####Example 1: . Input: num = \"1210\" Output: true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true. Example 2: . Input: num = \"030\" Output: false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. Constraints: . | n == num.length | 1 &lt;= n &lt;= 10 | num consists of digits. | . Solution: . class Solution { public boolean digitCount(String num) { int[] dm = new int[10]; for(char ch : num.toCharArray()){ dm[ch - '0']++; } for(int i = 0; i &lt; num.length(); i++){ int d = num.charAt(i) - '0'; if(dm[i] != d) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-357-Check%20if%20Number%20Has%20Equal%20Digit%20Count%20and%20Digit%20Value/",
    "relUrl": "/problem-357-Check if Number Has Equal Digit Count and Digit Value/"
  },"497": {
    "doc": "Rearrange Characters to Make Target String",
    "title": "Rearrange Characters to Make Target String",
    "content": "You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings. Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them. Example 1: . Input: s = \"ilovecodingonleetcode\", target = \"code\" Output: 2 Explanation: For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7. For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20. The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\". We can make at most two copies of \"code\", so we return 2. Example 2: . Input: s = \"abcba\", target = \"abc\" Output: 1 Explanation: We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2. We can make at most one copy of \"abc\", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\". Example 3: . Input: s = \"abbaccaddaeea\", target = \"aaaaa\" Output: 1 Explanation: We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of \"aaaaa\", so we return 1. Constraints: . | 1 &lt;= s.length &lt;= 100 | 1 &lt;= target.length &lt;= 10 | s and target consist of lowercase English letters. | . Solution: . class Solution { public int rearrangeCharacters(String s, String target) { int[] dp1 = new int[26]; int[] dp2 = new int[26]; for(char ch : s.toCharArray()) dp1[ch - 'a']++; for(char ch : target.toCharArray()) dp2[ch - 'a']++; int max = Integer.MAX_VALUE; for(int i = 0; i &lt; 26; i++){ if(dp2[i] != 0) max= Math.min(max,dp1[i] / dp2[i]); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-358-Rearrange%20Characters%20to%20Make%20Target%20String/",
    "relUrl": "/problem-358-Rearrange Characters to Make Target String/"
  },"498": {
    "doc": "Min Max Game",
    "title": "Min Max Game",
    "content": "You are given a 0-indexed integer array nums whose length is a power of 2. Apply the following algorithm on nums: . | Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2. | For every even index i where 0 &lt;= i &lt; n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]). | For every odd index i where 0 &lt;= i &lt; n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]). | Replace the array nums with newNums. | Repeat the entire process starting from step 1. Return the last number that remains in nums after applying the algorithm. | . Example 1: . Input: nums = [1,3,5,2,4,8,2,2] Output: 1 Explanation: The following arrays are the results of applying the algorithm repeatedly. First: nums = [1,5,4,2] Second: nums = [1,4] Third: nums = [1] 1 is the last remaining number, so we return 1. Example 2: . Input: nums = [3] Output: 3 Explanation: 3 is already the last remaining number, so we return 3. Constraints: . | 1 &lt;= nums.length &lt;= 1024 | 1 &lt;= nums[i] &lt;= 109 | nums.length is a power of 2. | . Solution: . class Solution { public int minMaxGame(int[] nums) { while(nums.length != 1){ int[] temp = new int[nums.length / 2]; boolean min = true; for(int i = 0, k = 0; i &lt; nums.length - 1; i = i + 2, k++){ if(min){ temp[k] = Math.min(nums[i],nums[i+1]); }else{ temp[k] = Math.max(nums[i],nums[i+1]); } min = !min; } nums = temp; } return nums[0]; } } . Improvement using recursion . class Solution { public int minMaxGame(int[] nums) { if(nums.length == 1) return nums[0]; int[] temp = new int[nums.length / 2]; boolean min = true; for(int i = 0, k = 0; i &lt; nums.length - 1; i = i + 2, k++){ if(min){ temp[k] = Math.min(nums[i],nums[i+1]); }else{ temp[k] = Math.max(nums[i],nums[i+1]); } min = !min; } return minMaxGame(temp); } } . Optimised extra variables . class Solution { public int minMaxGame(int[] nums) { if(nums.length == 1) return nums[0]; int[] temp = new int[nums.length / 2]; for(int i = 0; i &lt; nums.length / 2; i++){ if(i % 2 == 0){ temp[i] = Math.min(nums[2*i],nums[2*i+1]); }else{ temp[i] = Math.max(nums[2*i],nums[2*i+1]); } } return minMaxGame(temp); } } . ",
    "url": "https://1001anjan.github.io/problem-359-Min%20Max%20Game/",
    "relUrl": "/problem-359-Min Max Game/"
  },"499": {
    "doc": "Excel Sheet Column Number",
    "title": "Excel Sheet Column Number",
    "content": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number. For example: . A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... Example 1: . Input: columnTitle = \"A\" Output: 1 . Example 2: . Input: columnTitle = \"AB\" Output: 28 . Example 3: . Input: columnTitle = \"ZY\" Output: 701 . Constraints: . | 1 &lt;= columnTitle.length &lt;= 7 | columnTitle consists only of uppercase English letters. | columnTitle is in the range [“A”, “FXSHRXW”]. | . Solution . class Solution { public int titleToNumber(String columnTitle) { int ans = 0; for(int i=0; i&lt;=columnTitle.length() -1; i++){ ans = 26*ans + columnTitle.charAt(i) - 'A' +1; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-36-Excel-Sheet-Column-Number/",
    "relUrl": "/problem-36-Excel-Sheet-Column-Number/"
  },"500": {
    "doc": "Unique Paths II",
    "title": "Unique Paths II",
    "content": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109. Example 1: . Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right -&gt; Right . Example 2: . Input: obstacleGrid = [[0,1],[0,0]] Output: 1 . Constraints: . | m == obstacleGrid.length | n == obstacleGrid[i].length | 1 &lt;= m, n &lt;= 100 | obstacleGrid[i][j] is 0 or 1. | . Solution: . Time Limit Exceeded . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) { return 0; } return paths(obstacleGrid, obstacleGrid.length-1, obstacleGrid[0].length-1); } private int paths(int[][] obstacleGrid, int m, int n){ if(m == 0 &amp;&amp; n == 0) return 1; if(m&lt;0 || n&lt;0 || obstacleGrid[m][n] == 1) return 0; return paths(obstacleGrid, m-1,n)+paths(obstacleGrid, m,n-1); } } . With memorization . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { Map&lt;String,Integer&gt; dp = new HashMap&lt;&gt;(); if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) { return 0; } return paths(obstacleGrid, obstacleGrid.length-1, obstacleGrid[0].length-1, dp); } private int paths(int[][] obstacleGrid, int m, int n, Map&lt;String,Integer&gt; dp){ String key = m+\"-\"+n; if(m == 0 &amp;&amp; n == 0) return 1; if(m&lt;0 || n&lt;0 || obstacleGrid[m][n] == 1) return 0; if(dp.containsKey(key)) return dp.get(key); dp.put(key, paths(obstacleGrid, m-1,n, dp)+paths(obstacleGrid, m,n-1, dp)); return dp.get(key); } } . Dynamic programming . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; // intializing base dp boolean found = false; for(int i = 0; i &lt; m ; i++){ if(obstacleGrid[i][0] == 1) found = true; if(!found) dp[i][0] = 1; else dp[i][0] = 0; } found = false; for(int i = 0; i &lt; n ; i++){ if(obstacleGrid[0][i] == 1) found = true; if(!found) dp[0][i] = 1; else dp[0][i] = 0; } // process the paths for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ if(obstacleGrid[i][j] == 1){ dp[i][j] = 0; }else{ dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for (int[] row : obstacleGrid) { for (int j = 0; j &lt; width; j++) { if (row[j] == 1) dp[j] = 0; else if (j &gt; 0) dp[j] += dp[j - 1]; } } return dp[width - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-36-Unique%20Paths%20II/",
    "relUrl": "/problem-36-Unique Paths II/"
  },"501": {
    "doc": "Strong Password Checker II",
    "title": "Strong Password Checker II",
    "content": "A password is said to be strong if it satisfies all the following criteria: . | It has at least 8 characters. | It contains at least one lowercase letter. | It contains at least one uppercase letter. | It contains at least one digit. | It contains at least one special character. The special characters are the characters in the following string: “!@#$%^&amp;*()-+”. | It does not contain 2 of the same character in adjacent positions (i.e., “aab” violates this condition, but “aba” does not). Given a string password, return true if it is a strong password. Otherwise, return false. | . Example 1: . Input: password = \"IloveLe3tcode!\" Output: true Explanation: The password meets all the requirements. Therefore, we return true. Example 2: . Input: password = \"Me+You--IsMyDream\" Output: false Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false. Example 3: . Input: password = \"1aB!\" Output: false Explanation: The password does not meet the length requirement. Therefore, we return false. Constraints: . | 1 &lt;= password.length &lt;= 100 | password consists of letters, digits, and special characters: “!@#$%^&amp;*()-+”. | . Solution: . class Solution { public boolean strongPasswordCheckerII(String password) { if(password.length() &lt; 8) return false; boolean lc = false, uc = false, d = false, sc = false; char prev = ' '; for(char crr : password.toCharArray()){ if(prev == crr) return false; if(Character.isDigit(crr)){ d = true; }else if(Character.isLetter(crr)){ if(Character.isUpperCase(crr)){ uc= true; }else{ lc = true; } }else{ sc = true; } prev = crr; } return lc &amp;&amp; uc &amp;&amp; d &amp;&amp; sc; } } . ",
    "url": "https://1001anjan.github.io/problem-360-Strong%20Password%20Checker%20II/",
    "relUrl": "/problem-360-Strong Password Checker II/"
  },"502": {
    "doc": "Greatest English Letter in Upper and Lower Case",
    "title": "Greatest English Letter in Upper and Lower Case",
    "content": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string. An English letter b is greater than another letter a if b appears after a in the English alphabet. Example 1: . Input: s = \"lEeTcOdE\" Output: \"E\" Explanation: The letter 'E' is the only letter to appear in both lower and upper case. Example 2: . Input: s = \"arRAzFif\" Output: \"R\" Explanation: The letter 'R' is the greatest letter to appear in both lower and upper case. Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'. Example 3: . Input: s = \"AbCdEfGhIjK\" Output: \"\" Explanation: There is no letter that appears in both lower and upper case. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of lowercase and uppercase English letters. | . Solution: . class Solution { public String greatestLetter(String s) { boolean[][] cm = new boolean[26][2]; for(char c : s.toCharArray()){ if(Character.isUpperCase(c)){ cm[c - 'A'][0] = true; }else{ cm[c - 'a'][1] = true; } } for(int i = 25; i &gt;= 0; i--){ if(cm[i][0] &amp;&amp; cm[i][1]) return Character.toString('A' + i); } return \"\"; } } . Improvement . class Solution { public String greatestLetter(String s) { boolean[] letters = new boolean[58]; for (char c : s.toCharArray()) { letters[c - 'A'] = true; } for (int i = 26; i &gt;= 0; i--) { if (letters[i] &amp;&amp; letters[i + 32]) { return \"\" + (char)('A' + i); } } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-361-Greatest%20English%20Letter%20in%20Upper%20and%20Lower%20Case/",
    "relUrl": "/problem-361-Greatest English Letter in Upper and Lower Case/"
  },"503": {
    "doc": "Count Asterisks",
    "title": "Count Asterisks",
    "content": "You are given a string s, where every two consecutive vertical bars ‘|’ are grouped into a pair. In other words, the 1st and 2nd ‘|’ make a pair, the 3rd and 4th ‘|’ make a pair, and so forth. | Return the number of ‘’ in s, excluding the ‘’ between each pair of ‘ | ’. | . | Note that each ‘ | ’ will belong to exactly one pair. | . Example 1: . Input: s = \"l|*e*et|c**o|*de|\" Output: 2 Explanation: The considered characters are underlined: \"l|*e*et|c**o|*de|\". The characters between the first and second '|' are excluded from the answer. Also, the characters between the third and fourth '|' are excluded from the answer. There are 2 asterisks considered. Therefore, we return 2. Example 2: . Input: s = \"iamprogrammer\" Output: 0 Explanation: In this example, there are no asterisks in s. Therefore, we return 0. Example 3: . Input: s = \"yo|uar|e**|b|e***au|tifu|l\" Output: 5 Explanation: The considered characters are underlined: \"yo|uar|e**|b|e***au|tifu|l\". There are 5 asterisks considered. Therefore, we return 5. Constraints: . | 1 &lt;= s.length &lt;= 1000 | | s consists of lowercase English letters, vertical bars ‘ | ’, and asterisks ‘*’. | . | | s contains an even number of vertical bars ‘ | ’. | . | . Solution: . class Solution { public int countAsterisks(String s) { String[] words = s.split(\"\\\\|\"); int c = 0; for(int i = 0; i &lt; words.length; i = i+ 2){ for(char ch : words[i].toCharArray()){ if(ch == '*') c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-362-Count%20Asterisks/",
    "relUrl": "/problem-362-Count Asterisks/"
  },"504": {
    "doc": "Check if Matrix Is X-Matrix",
    "title": "Check if Matrix Is X-Matrix",
    "content": "A square matrix is said to be an X-Matrix if both of the following conditions hold: . | All the elements in the diagonals of the matrix are non-zero. | All other elements are 0. Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false. | . Example 1: . Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] Output: true Explanation: Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is an X-Matrix. Example 2: . Input: grid = [[5,7,0],[0,3,1],[0,5,0]] Output: false Explanation: Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is not an X-Matrix. Constraints: . | n == grid.length == grid[i].length | 3 &lt;= n &lt;= 100 | 0 &lt;= grid[i][j] &lt;= 10^5 | . Solution: . class Solution { private boolean isDiagonal(int i, int j, int length) { return (i == j || j == length - 1 - i); } public boolean checkXMatrix(int[][] grid) { for(int i = 0; i &lt; grid.length; i++) { for(int j = 0; j &lt; grid[i].length; j++) { if(isDiagonal(i, j, grid.length)){ if(grid[i][j] == 0) return false; }else{ if(grid[i][j] != 0) return false; } } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-363-Check%20if%20Matrix%20Is%20X-Matrix/",
    "relUrl": "/problem-363-Check if Matrix Is X-Matrix/"
  },"505": {
    "doc": "Decode the Message",
    "title": "Decode the Message",
    "content": "You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows: . | Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table. | Align the substitution table with the regular English alphabet. | Each letter in message is then substituted using the table. | Spaces ‘ ‘ are transformed to themselves. | For example, given key = “happy boy” (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of (‘h’ -&gt; ‘a’, ‘a’ -&gt; ‘b’, ‘p’ -&gt; ‘c’, ‘y’ -&gt; ‘d’, ‘b’ -&gt; ‘e’, ‘o’ -&gt; ‘f’). Return the decoded message. | . | . Example 1: . Input: key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\" Output: \"this is a secret\" Explanation: The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"the quick brown fox jumps over the lazy dog\". Example 2: . Input: key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\" Output: \"the five boxing wizards jump quickly\" Explanation: The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"eljuxhpwnyrdgtqkviszcfmabo\". Constraints: . | 26 &lt;= key.length &lt;= 2000 | key consists of lowercase English letters and ‘ ‘. | key contains every letter in the English alphabet (‘a’ to ‘z’) at least once. | 1 &lt;= message.length &lt;= 2000 | message consists of lowercase English letters and ‘ ‘. | . Solution: . class Solution { public String decodeMessage(String key, String message) { char[] dp = new char[26]; char c = 'a'; for(char ch : key.toCharArray()){ int index = ch - 'a'; if(ch != ' ' &amp;&amp; dp[index] == 0){ dp[index] = c++; } } StringBuilder sb = new StringBuilder(); for(char ch : message.toCharArray()){ if(ch == ' '){ sb.append(ch); } else{ sb.append(dp[ch - 'a']); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-364-Decode%20the%20Message/",
    "relUrl": "/problem-364-Decode the Message/"
  },"506": {
    "doc": "Evaluate Boolean Binary Tree",
    "title": "Evaluate Boolean Binary Tree",
    "content": "You are given the root of a full binary tree with the following properties: . | Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True. | Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND. The evaluation of a node is as follows: . | If the node is a leaf node, the evaluation is the value of the node, i.e. True or False. | Otherwise, evaluate the node’s two children and apply the boolean operation of its value with the children’s evaluations. Return the boolean result of evaluating the root node. | . A full binary tree is a binary tree where each node has either 0 or 2 children. A leaf node is a node that has zero children. Example 1: . Input: root = [2,1,3,null,null,0,1] Output: true Explanation: The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. Example 2: . Input: root = [0] Output: false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | 0 &lt;= Node.val &lt;= 3 | Every node has either 0 or 2 children. | Leaf nodes have a value of 0 or 1. | Non-leaf nodes have a value of 2 or 3. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean evaluateTree(TreeNode root) { if(root.left == null &amp;&amp; root.right == null) return root.val == 1; if(root.val == 2){ return evaluateTree(root.left) | evaluateTree(root.right); }else{ return evaluateTree(root.left) &amp; evaluateTree(root.right); } } } . ",
    "url": "https://1001anjan.github.io/problem-365-Evaluate%20Boolean%20Binary%20Tree/",
    "relUrl": "/problem-365-Evaluate Boolean Binary Tree/"
  },"507": {
    "doc": "Maximum Number of Pairs in Array",
    "title": "Maximum Number of Pairs in Array",
    "content": "You are given a 0-indexed integer array nums. In one operation, you may do the following: . | Choose two integers in nums that are equal. | Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. | . Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible. Example 1: . Input: nums = [1,3,2,1,3,2,2] Output: [3,1] Explanation: Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]. Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]. No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums. Example 2: . Input: nums = [1,1] Output: [1,0] Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = []. No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums. Example 3: . Input: nums = [0] Output: [0,1] Explanation: No pairs can be formed, and there is 1 number leftover in nums. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] numberOfPairs(int[] nums) { int[] dp = new int[101]; int pair = 0, leftOver = 0; for(int n : nums) dp[n]++; for(int n : dp){ pair += n / 2; leftOver += n % 2; } return new int[] {pair,leftOver}; } } . ",
    "url": "https://1001anjan.github.io/problem-366-Maximum%20Number%20of%20Pairs%20in%20Array/",
    "relUrl": "/problem-366-Maximum Number of Pairs in Array/"
  },"508": {
    "doc": "First Letter to Appear Twice",
    "title": "First Letter to Appear Twice",
    "content": "Given a string s consisting of lowercase English letters, return the first letter to appear twice. Note: . | A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b. | s will contain at least one letter that appears twice. | . Example 1: . Input: s = \"abccbaacz\" Output: \"c\" Explanation: The letter 'a' appears on the indexes 0, 5 and 6. The letter 'b' appears on the indexes 1 and 4. The letter 'c' appears on the indexes 2, 3 and 7. The letter 'z' appears on the index 8. The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest. Example 2: . Input: s = \"abcdd\" Output: \"d\" Explanation: The only letter that appears twice is 'd' so we return 'd'. Constraints: . | 2 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | s has at least one repeated letter. | . Solution: . class Solution { public char repeatedCharacter(String s) { boolean[] dp = new boolean[26]; for(char ch : s.toCharArray()){ if(dp[ch - 'a']) return ch; dp[ch - 'a'] = true; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-367-First%20Letter%20to%20Appear%20Twice/",
    "relUrl": "/problem-367-First Letter to Appear Twice/"
  },"509": {
    "doc": "Make Array Zero by Subtracting Equal Amounts",
    "title": "Make Array Zero by Subtracting Equal Amounts",
    "content": "You are given a non-negative integer array nums. In one operation, you must: . | Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. | Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0. | . Example 1: . Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1. Now, nums = [0,4,0,2,4]. In the second operation, choose x = 2. Now, nums = [0,2,0,0,2]. In the third operation, choose x = 2. Now, nums = [0,0,0,0,0]. Example 2: . Input: nums = [0] Output: 0 Explanation: Each element in nums is already 0 so no operations are needed. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int minimumOperations(int[] nums) { int c = 0; Arrays.sort(nums); int prev = 0; for(int n : nums){ if(n - prev != 0) c++; prev = n; } return c; } } . O(n) complexity . class Solution { public int minimumOperations(int[] nums) { int c = 0; boolean[] dp = new boolean[101]; for(int n : nums){ if(n == 0) continue; if(!dp[n]){ dp[n] = true; c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-368-Make%20Array%20Zero%20by%20Subtracting%20Equal%20Amounts/",
    "relUrl": "/problem-368-Make Array Zero by Subtracting Equal Amounts/"
  },"510": {
    "doc": "Merge Similar Items",
    "title": "Merge Similar Items",
    "content": "You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties: . | items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item. | The value of each item in items is unique. Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei. | . Note: ret should be returned in ascending order by value. Example 1: . Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] Output: [[1,6],[3,9],[4,5]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6. The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9. The item with value = 4 occurs in items1 with weight = 5, total weight = 5. Therefore, we return [[1,6],[3,9],[4,5]]. Example 2: . Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] Output: [[1,4],[2,4],[3,4]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4. The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4. The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. Therefore, we return [[1,4],[2,4],[3,4]]. Example 3: . Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] Output: [[1,7],[2,4],[7,1]] Explanation: The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. The item with value = 7 occurs in items2 with weight = 1, total weight = 1. Therefore, we return [[1,7],[2,4],[7,1]]. Constraints: . | 1 &lt;= items1.length, items2.length &lt;= 1000 | items1[i].length == items2[i].length == 2 | 1 &lt;= valuei, weighti &lt;= 1000 | Each valuei in items1 is unique. | Each valuei in items2 is unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; mergeSimilarItems(int[][] items1, int[][] items2) { int[] dp = new int[1001]; for(int arr[] : items1) dp[arr[0]] += arr[1]; for(int arr[] : items2) dp[arr[0]] += arr[1]; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; 1001; i++){ if(dp[i] != 0){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(); t.add(i); t.add(dp[i]); ans.add(t); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-369-Merge%20Similar%20Items/",
    "relUrl": "/problem-369-Merge Similar Items/"
  },"511": {
    "doc": "Minimum Path Sum",
    "title": "Minimum Path Sum",
    "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: . Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum. Example 2: . Input: grid = [[1,2,3],[4,5,6]] Output: 12 . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m, n &lt;= 200 | 0 &lt;= grid[i][j] &lt;= 100 | . Solution: . class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; int sum = 0; for(int i = 0; i &lt; n; i++){ sum = sum + grid[0][i]; dp[0][i] = sum; } sum = 0; for(int i = 0; i &lt; m; i++){ sum += grid[i][0]; dp[i][0] = sum; } for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = Math.min(grid[i][j] + dp[i - 1][j], grid[i][j] + dp[i][j - 1]); } } return dp[m - 1][n - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-37-Minimum%20Path%20Sum/",
    "relUrl": "/problem-37-Minimum Path Sum/"
  },"512": {
    "doc": "Reverse Bits",
    "title": "Reverse Bits",
    "content": "Reverse bits of a given 32 bits unsigned integer. Note: . | Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. | In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. | . Example 1: . Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: . Input: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints: . | The input must be a binary string of length 32 | . Solution . public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { return Integer.reverse(n); } } . ",
    "url": "https://1001anjan.github.io/problem-37-Reverse-Bits/",
    "relUrl": "/problem-37-Reverse-Bits/"
  },"513": {
    "doc": "Number of Arithmetic Triplets",
    "title": "Number of Arithmetic Triplets",
    "content": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met: . | i &lt; j &lt; k, | nums[j] - nums[i] == diff, and | nums[k] - nums[j] == diff. Return the number of unique arithmetic triplets. | . Example 1: . Input: nums = [0,1,4,6,7,10], diff = 3 Output: 2 Explanation: (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3. (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. Example 2: . Input: nums = [4,5,6,7,8,9], diff = 2 Output: 2 Explanation: (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2. (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2. Constraints: . | 3 &lt;= nums.length &lt;= 200 | 0 &lt;= nums[i] &lt;= 200 | 1 &lt;= diff &lt;= 50 | nums is strictly increasing. | . Solution: . Complexity O(n^3) . class Solution { public int arithmeticTriplets(int[] nums, int diff) { int count = 0; for(int i = 0; i &lt; nums.length - 2; i++){ for(int j = i + 1; j &lt; nums.length - 1; j++){ for(int k = j + 1; k &lt; nums.length; k++){ if(nums[j] - nums[i] == diff &amp;&amp; nums[k] - nums[j] == diff) count++; } } } return count; } } . Complexity O(nLogN) . class Solution { public int arithmeticTriplets(int[] nums, int diff) { int count = 0; for(int i = 0; i &lt; nums.length - 2; i++){ int findNum = nums[i] + diff; int index = Arrays.binarySearch(nums,i + 1, nums.length, findNum); if(index &gt; 0 &amp;&amp; Arrays.binarySearch(nums,i + 1, nums.length, findNum + diff) &gt; 0) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-370-Number%20of%20Arithmetic%20Triplets/",
    "relUrl": "/problem-370-Number of Arithmetic Triplets/"
  },"514": {
    "doc": "Find Subarrays With Equal Sum",
    "title": "Find Subarrays With Equal Sum",
    "content": "Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices. Return true if these subarrays exist, and false otherwise. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: . Input: nums = [4,2,4] Output: true Explanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6. Example 2: . Input: nums = [1,2,3,4,5] Output: false Explanation: No two subarrays of size 2 have the same sum. Example 3: . Input: nums = [0,0,0] Output: true Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. Note that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | -109 &lt;= nums[i] &lt;= 10^9 | . Solution: . class Solution { public boolean findSubarrays(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length - 1; i++){ if(!set.add(nums[i] + nums[i + 1])) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-371-Find%20Subarrays%20With%20Equal%20Sum/",
    "relUrl": "/problem-371-Find Subarrays With Equal Sum/"
  },"515": {
    "doc": "Check Distances Between Same Letters",
    "title": "Check Distances Between Same Letters",
    "content": "You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26. Each letter in the alphabet is numbered from 0 to 25 (i.e. ‘a’ -&gt; 0, ‘b’ -&gt; 1, ‘c’ -&gt; 2, … , ‘z’ -&gt; 25). In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored. Return true if s is a well-spaced string, otherwise return false. Example 1: . Input: s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: true Explanation: - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1. - 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3. - 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0. Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored. Return true because s is a well-spaced string. Example 2: . Input: s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: false Explanation: - 'a' appears at indices 0 and 1 so there are zero letters between them. Because distance[0] = 1, s is not a well-spaced string. Constraints: . | 2 &lt;= s.length &lt;= 52 | s consists only of lowercase English letters. | Each letter appears in s exactly twice. | distance.length == 26 | 0 &lt;= distance[i] &lt;= 50 | . Solution: . class Solution { public boolean checkDistances(String s, int[] distance) { int[] dp = new int[26]; for(int i = 0; i &lt; s.length(); i++){ int d = s.charAt(i) - 'a'; if(dp[d] == 0){ dp[d] = i + 1; }else{ dp[d] = i - dp[d] + 1; } } for(int i = 0; i &lt; 26; i++){ if(dp[i] != 0 &amp;&amp; distance[i] + 1 != dp[i]) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-372-Check%20Distances%20Between%20Same%20Letters/",
    "relUrl": "/problem-372-Check Distances Between Same Letters/"
  },"516": {
    "doc": "Most Frequent Even Element",
    "title": "Most Frequent Even Element",
    "content": "Given an integer array nums, return the most frequent even element. If there is a tie, return the smallest one. If there is no such element, return -1. Example 1: . Input: nums = [0,1,2,2,4,4,1] Output: 2 Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most. We return the smallest one, which is 2. Example 2: . Input: nums = [4,4,4,9,2,4] Output: 4 Explanation: 4 is the even element appears the most. Example 3: . Input: nums = [29,47,21,41,13,37,25,7] Output: -1 Explanation: There is no even element. Constraints: . | 1 &lt;= nums.length &lt;= 2000 | 0 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public int mostFrequentEven(int[] nums) { int max = 0; Arrays.sort(nums); int prev = -1; int count = 0; int element = -1; for(int n : nums){ if(n != prev) count = 0; if(n % 2 == 0) count++; if(count &gt; max){ element = n; max = count; } prev = n; } return element; } } . ",
    "url": "https://1001anjan.github.io/problem-373-Most%20Frequent%20Even%20Element/",
    "relUrl": "/problem-373-Most Frequent Even Element/"
  },"517": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle",
    "content": "Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] . Example 2: . Input: numRows = 1 Output: [[1]] . Constraints: . | 1 &lt;= numRows &lt;= 30 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; prev = null, curr = null; for(int i = 0; i &lt; numRows; i++){ curr = new ArrayList&lt;&gt;(); for(int j = 0; j &lt;= i; j++){ if(j == 0 || j == i){ curr.add(1); }else{ curr.add(prev.get(j - 1) + prev.get(j)); } } prev = curr; ans.add(curr); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-374-Pascal's%20Triangle/#pascals-triangle",
    "relUrl": "/problem-374-Pascal's Triangle/#pascals-triangle"
  },"518": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-374-Pascal's%20Triangle/",
    "relUrl": "/problem-374-Pascal's Triangle/"
  },"519": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle II",
    "content": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: rowIndex = 3 Output: [1,3,3,1] . Example 2: . Input: rowIndex = 0 Output: [1] . Example 3: . Input: rowIndex = 1 Output: [1,1] . Constraints: . | 0 &lt;= rowIndex &lt;= 33 | . Solution: . class Solution { // Time Complexity = O(N*N) (approximation) // Space Complexity = O(N) public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (int row = 0; row &lt;= rowIndex; row++) { result.add(0, 1); for (int i = 1; i &lt; row; i++) result.set(i, result.get(i) + result.get(i + 1)); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-375-Pascal's%20Triangle%20II/#pascals-triangle-ii",
    "relUrl": "/problem-375-Pascal's Triangle II/#pascals-triangle-ii"
  },"520": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-375-Pascal's%20Triangle%20II/",
    "relUrl": "/problem-375-Pascal's Triangle II/"
  },"521": {
    "doc": "Implement Stack using Queues",
    "title": "Implement Stack using Queues",
    "content": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: . | void push(int x) Pushes element x to the top of the stack. | int pop() Removes the element on the top of the stack and returns it. | int top() Returns the element on the top of the stack. | boolean empty() Returns true if the stack is empty, false otherwise. Notes: | . You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. Example 1: . Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, top, and empty. | All the calls to pop and top are valid. | . Follow-up: Can you implement the stack using only one queue? . Solution: . class MyStack { Queue&lt;Integer&gt; queue; public MyStack() { queue = new LinkedList&lt;&gt;(); } public void push(int x) { int size = queue.size(); queue.add(x); while(size &gt; 0){ queue.add(queue.remove()); size--; } } public int pop() { return queue.remove(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ . ",
    "url": "https://1001anjan.github.io/problem-376-Implement%20Stack%20using%20Queues/",
    "relUrl": "/problem-376-Implement Stack using Queues/"
  },"522": {
    "doc": "Isomorphic Strings",
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: . Input: s = \"egg\", t = \"add\" Output: true . Example 2: . Input: s = \"foo\", t = \"bar\" Output: false . Example 3: . Input: s = \"paper\", t = \"title\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | t.length == s.length | s and t consist of any valid ascii character. | . Solution: . class Solution { public boolean isIsomorphic(String s, String t) { Map&lt;Character,Character&gt; mp1 = new HashMap&lt;&gt;(); Map&lt;Character,Character&gt; mp2 = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++){ char ch1 = s.charAt(i); char ch2 = t.charAt(i); boolean s1 = mp1.containsKey(ch1); boolean s2 = mp2.containsKey(ch2); if(s1 != s2) return false; if(!s1){ mp1.put(ch1,ch2); mp2.put(ch2,ch1); }else{ if(mp1.get(ch1) != ch2 || mp2.get(ch2) != ch1) return false; } } return true; } } . Improvement . class Solution { public boolean isIsomorphic(String s, String t) { int[] mappingDictStoT = new int[256]; Arrays.fill(mappingDictStoT, -1); int[] mappingDictTtoS = new int[256]; Arrays.fill(mappingDictTtoS, -1); for (int i = 0; i &lt; s.length(); ++i) { char c1 = s.charAt(i); char c2 = t.charAt(i); // Case 1: No mapping exists in either of the dictionaries if (mappingDictStoT[c1] == -1 &amp;&amp; mappingDictTtoS[c2] == -1) { mappingDictStoT[c1] = c2; mappingDictTtoS[c2] = c1; } // Case 2: Ether mapping doesn't exist in one of the dictionaries or Mapping exists and // it doesn't match in either of the dictionaries or both else if (!(mappingDictStoT[c1] == c2 &amp;&amp; mappingDictTtoS[c2] == c1)) { return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-377-Isomorphic%20Strings/",
    "relUrl": "/problem-377-Isomorphic Strings/"
  },"523": {
    "doc": "Implement Queue using Stacks",
    "title": "Implement Queue using Stacks",
    "content": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: . | void push(int x) Pushes element x to the back of the queue. | int pop() Removes the element from the front of the queue and returns it. | int peek() Returns the element at the front of the queue. | boolean empty() Returns true if the queue is empty, false otherwise. Notes: | . You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. Example 1: . Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, peek, and empty. | All the calls to pop and peek are valid. | . Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Solution: . ",
    "url": "https://1001anjan.github.io/problem-378-Implement%20Queue%20using%20Stacks/",
    "relUrl": "/problem-378-Implement Queue using Stacks/"
  },"524": {
    "doc": "First Bad Version",
    "title": "First Bad Version",
    "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1: . Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -&gt; false call isBadVersion(5) -&gt; true call isBadVersion(4) -&gt; true Then 4 is the first bad version. Example 2: . Input: n = 1, bad = 1 Output: 1 . Constraints: . | 1 &lt;= bad &lt;= n &lt;= 231 - 1 | . Solution: . /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int l = 1; while(l &lt;= n){ int m = l + (n - l)/2;; if(isBadVersion(m)){ n = m - 1; }else{ l = m + 1; } } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-379-First%20Bad%20Version/",
    "relUrl": "/problem-379-First Bad Version/"
  },"525": {
    "doc": "Number of 1 Bits",
    "title": "Number of 1 Bits",
    "content": "Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: . | Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. | In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. | . Example 1: . Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: . Input: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: . Input: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Constraints: . | The input must be a binary string of length 32. | . Solution . public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { String str = Integer.toBinaryString(n); int c = 0; for(int i=0; i&lt;str.length(); i++){ if(str.charAt(i) == '1') c++; } return c; } } . Other . public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int sum = 0; while(n != 0) { sum++; n &amp;= (n-1); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-38-Number-of-1-Bits/",
    "relUrl": "/problem-38-Number-of-1-Bits/"
  },"526": {
    "doc": "Simplify Path",
    "title": "Simplify Path",
    "content": "Given a string path, which is an absolute path (starting with a slash ‘/’) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period ‘.’ refers to the current directory, a double period ‘..’ refers to the directory up a level, and any multiple consecutive slashes (i.e. ‘//’) are treated as a single slash ‘/’. For this problem, any other format of periods such as ‘…’ are treated as file/directory names. The canonical path should have the following format: . | The path starts with a single slash ‘/’. | Any two directories are separated by a single slash ‘/’. | The path does not end with a trailing ‘/’. | The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period ‘.’ or double period ‘..’) Return the simplified canonical path. | . Example 1: . Input: path = \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: . Input: path = \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: . Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints: . | 1 &lt;= path.length &lt;= 3000 | path consists of English letters, digits, period ‘.’, slash ‘/’ or ‘_’. | path is a valid absolute Unix path. | . Solution: . class Solution { public String simplifyPath(String path) { LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); for(String s : path.split(\"/\")){ if(s.equals(\".\") || s.equals(\"\")) continue; else if(s.equals(\"..\")){ if(list.size() &gt; 0) list.removeLast(); }else{ list.add(\"/\"+s); } } if(list.size() == 0) return \"/\"; StringBuilder sb = new StringBuilder(); for(String s : list) sb.append(s); return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-38-Simplify%20Path/",
    "relUrl": "/problem-38-Simplify Path/"
  },"527": {
    "doc": "Word Pattern",
    "title": "Word Pattern",
    "content": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Example 1: . Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true . Example 2: . Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false . Example 3: . Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false . Constraints: . | 1 &lt;= pattern.length &lt;= 300 | pattern contains only lower-case English letters. | 1 &lt;= s.length &lt;= 3000 | s contains only lowercase English letters and spaces ‘ ‘. | s does not contain any leading or trailing spaces. | All the words in s are separated by a single space. | . Solution: . class Solution { public boolean wordPattern(String pattern, String s) { String[] str = s.split(\" \"); if(pattern.length()!=str.length) return false; HashMap&lt;Character, String&gt; hm = new HashMap&lt;&gt;(); for(int i=0; i&lt;pattern.length(); i++){ char c = pattern.charAt(i); if(hm.containsKey(c)){ if(!hm.get(c).equals(str[i]))return false; } else{ if(hm.containsValue(str[i])) return false; hm.put(c, str[i]); } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-380-Word%20Pattern/",
    "relUrl": "/problem-380-Word Pattern/"
  },"528": {
    "doc": "Implement Queue using Stacks",
    "title": "Implement Queue using Stacks",
    "content": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: . | void push(int x) Pushes element x to the back of the queue. | int pop() Removes the element from the front of the queue and returns it. | int peek() Returns the element at the front of the queue. | boolean empty() Returns true if the queue is empty, false otherwise. Notes: . | You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. | Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. | . Example 1: . Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, peek, and empty. | All the calls to pop and peek are valid. | . Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Solution: . class MyQueue { Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() { s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); } public void push(int x) { s1.push(x); } public int pop() { s2.clear(); while(s1.size() &gt; 1){ s2.push(s1.pop()); } int v = s1.pop(); while(!s2.isEmpty()) s1.push(s2.pop()); return v; } public int peek() { s2.clear(); while(s1.size() &gt; 0){ s2.push(s1.pop()); } int v = s2.peek(); while(!s2.isEmpty()) s1.push(s2.pop()); return v; } public boolean empty() { return s1.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ . ",
    "url": "https://1001anjan.github.io/problem-381-Implement%20Queue%20using%20Stacks/",
    "relUrl": "/problem-381-Implement Queue using Stacks/"
  },"529": {
    "doc": "Longest Uncommon Subsequence I",
    "title": "Longest Uncommon Subsequence I",
    "content": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1. An uncommon subsequence between two strings is a string that is a subsequence of one but not the other. A subsequence of a string s is a string that can be obtained after deleting any number of characters from s. | For example, “abc” is a subsequence of “aebdc” because you can delete the underlined characters in “aebdc” to get “abc”. Other subsequences of “aebdc” include “aebdc”, “aeb”, and “” (empty string). | . Example 1: . Input: a = \"aba\", b = \"cdc\" Output: 3 Explanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\". Note that \"cdc\" is also a longest uncommon subsequence. Example 2: . Input: a = \"aaa\", b = \"bbb\" Output: 3 Explanation: The longest uncommon subsequences are \"aaa\" and \"bbb\". Example 3: . Input: a = \"aaa\", b = \"aaa\" Output: -1 Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. Constraints: . | 1 &lt;= a.length, b.length &lt;= 100 | a and b consist of lower-case English letters. | . Solution: . class Solution { public int findLUSlength(String a, String b) { if(a.equals(b)) return -1; return Math.max(a.length(),b.length()); } } . ",
    "url": "https://1001anjan.github.io/problem-382-Longest%20Uncommon%20Subsequence%20I/",
    "relUrl": "/problem-382-Longest Uncommon Subsequence I/"
  },"530": {
    "doc": "Minimum Absolute Difference in BST",
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 104]. | 0 &lt;= Node.val &lt;= 10^5 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int getMinimumDifference(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inoderTraverse(root,list); int prev = list.get(1); int diff = prev - list.get(0); for(int i = 2; i &lt; list.size(); i++){ int curr = list.get(i); diff = Math.min(diff,curr - prev); prev = curr; } return diff; } public void inoderTraverse(TreeNode tree, List&lt;Integer&gt; list){ if(tree == null) return; inoderTraverse(tree.left,list); list.add(tree.val); inoderTraverse(tree.right,list); } } . Faster solution . class Solution { /* As the tree is BST, we will do the inorder so that we will get a asceding order. We will just calculate the difference with adjaced nodes in the inorder. PS: Just consider the inorder of the tree as soreted array in ascending order and you have to find the min diff of two elements. */ int minDiff=Integer.MAX_VALUE,prev=-1; public int getMinimumDifference(TreeNode root) { inorder(root); return minDiff; } public void inorder(TreeNode root){ if(root != null){ inorder(root.left); if(prev != -1) minDiff = Math.min(Math.abs(root.val-prev),minDiff); prev=root.val; inorder(root.right); } } } . ",
    "url": "https://1001anjan.github.io/problem-383-Minimum%20Absolute%20Difference%20in%20BST/",
    "relUrl": "/problem-383-Minimum Absolute Difference in BST/"
  },"531": {
    "doc": "Range Addition IIRange Addition II",
    "title": "Range Addition II",
    "content": "You are given an m x n matrix M initialized with all 0’s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi. Count and return the number of maximum integers in the matrix after performing all the operations. Example 1: . Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4. Example 2: . Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] Output: 4 . Example 3: . Input: m = 3, n = 3, ops = [] Output: 9 . Constraints: . | 1 &lt;= m, n &lt;= 4 * 104 | 0 &lt;= ops.length &lt;= 104 | ops[i].length == 2 | 1 &lt;= ai &lt;= m | 1 &lt;= bi &lt;= n | . Solution: . Memory limits exceeds . class Solution { // Goal should be to find that maxima grid which is common (overlapping) across ops[i] range. // e.g: M[0][0] would always hold maxValue but it would not give us number of maximas // so if we keep on reducing row and columns by scanning ops set, we would end up with that maxima grid (r*c) :) // Runtime: 0 ms, faster than 100.00% of Java online submissions for Range Addition II. // Memory Usage: 42 MB, less than 99.81% of Java online submissions for Range Addition II. public int maxCount(int m, int n, int[][] ops) { int rowMinima = m; // number of row cells holding max value int colMinima = n; // number of column cells holding max value for(int i = 0; i &lt; ops.length; i++){ rowMinima = Math.min(rowMinima, ops[i][0]); colMinima = Math.min(colMinima, ops[i][1]); } return rowMinima * colMinima; } } . Improvement . ",
    "url": "https://1001anjan.github.io/problem-384-Range%20Addition%20II/#range-addition-ii",
    "relUrl": "/problem-384-Range Addition II/#range-addition-ii"
  },"532": {
    "doc": "Range Addition IIRange Addition II",
    "title": "Range Addition IIRange Addition II",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-384-Range%20Addition%20II/",
    "relUrl": "/problem-384-Range Addition II/"
  },"533": {
    "doc": "Set Mismatch",
    "title": "Set Mismatch",
    "content": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: . Input: nums = [1,2,2,4] Output: [2,3] . Example 2: . Input: nums = [1,1] Output: [1,2] . Constraints: . | 2 &lt;= nums.length &lt;= 10^4 | 1 &lt;= nums[i] &lt;= 10^4 | . Solution: Time Complexity: O(nlogN) . class Solution { public int[] findErrorNums(int[] nums) { Arrays.sort(nums); int dup = 0, miss = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] == nums[i - 1]) dup = nums[i]; else if(nums[i] &gt; nums[i - 1] + 1) miss = nums[i - 1] + 1; } miss = nums[nums.length - 1] != nums.length? nums.length : miss; return new int[]{dup,miss}; } } . Solution: Time Complexity O(n) Space Complexity: O(n) . class Solution { public int[] findErrorNums(int[] nums) { int dup = 0, miss = 0; int[] temp = new int[nums.length]; for(int n : nums) temp[n - 1]++; for(int i = 0; i &lt; temp.length; i++){ if(temp[i] == 0) miss = i + 1; else if(temp[i] == 2) dup = i + 1; } return new int[]{dup,miss}; } } . ",
    "url": "https://1001anjan.github.io/problem-385-Set%20Mismatch/",
    "relUrl": "/problem-385-Set Mismatch/"
  },"534": {
    "doc": "Count Binary Substrings",
    "title": "Count Binary Substrings",
    "content": "Given a binary string s, return the number of non-empty substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: . Input: s = \"00110011\" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\". Notice that some of these substrings repeat and are counted the number of times they occur. Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: . Input: s = \"10101\" Output: 4 Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's. Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public int countBinarySubstrings(String s) { int count = 0, curr = 1, prev = 0; char[] str = s.toCharArray(); for(int i = 1; i &lt; str.length; i++){ if(str[i - 1] != str[i]){ count += Math.min(curr,prev); prev = curr; curr = 1; }else{ curr++; } } count += Math.min(curr,prev); return count; } } . ",
    "url": "https://1001anjan.github.io/problem-386-Count%20Binary%20Substrings/",
    "relUrl": "/problem-386-Count Binary Substrings/"
  },"535": {
    "doc": "Degree of an Array",
    "title": "Degree of an Array",
    "content": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: . Input: nums = [1,2,2,3,1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2: . Input: nums = [1,2,2,3,1,4,2] Output: 6 Explanation: The degree is 3 because the element 2 is repeated 3 times. So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6. Constraints: . | nums.length will be between 1 and 50,000. | nums[i] will be an integer between 0 and 49,999. | . Solution: . class Solution { public int findShortestSubArray(int[] nums) { Map&lt;Integer, Integer&gt; leftIndex = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; rightIndex = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++){ if(leftIndex.get(nums[i]) == null) leftIndex.put(nums[i],i); rightIndex.put(nums[i],i); count.put(nums[i],count.getOrDefault(nums[i],0) + 1); } int ans = nums.length; int degree = Collections.max(count.values()); for (int x: count.keySet()) { if (count.get(x) == degree) { ans = Math.min(ans, rightIndex.get(x) - leftIndex.get(x) + 1); } } return ans; } } . class Solution { public int findShortestSubArray(int[] nums) { if (nums.length == 0 || nums == null) return 0; Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ if (!map.containsKey(nums[i])){ map.put(nums[i], new int[]{1, i, i}); // the first element in array is degree, second is first index of this key, third is last index of this key } else { int[] temp = map.get(nums[i]); temp[0]++; temp[2] = i; } } int degree = Integer.MIN_VALUE, res = Integer.MAX_VALUE; for (int[] value : map.values()){ if (value[0] &gt; degree){ degree = value[0]; res = value[2] - value[1] + 1; } else if (value[0] == degree){ res = Math.min( value[2] - value[1] + 1, res); } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-387-Degree%20of%20an%20Array/",
    "relUrl": "/problem-387-Degree of an Array/"
  },"536": {
    "doc": "Kth Largest Element in a Stream",
    "title": "Kth Largest Element in a Stream",
    "content": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: . KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. Example 1: . Input [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 . Constraints: . | 1 &lt;= k &lt;= 104 | 0 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | -104 &lt;= val &lt;= 104 | At most 104 calls will be made to add. | It is guaranteed that there will be at least k elements in the array when you search for the kth element. | . Solution: . class KthLargest { private int k; private PriorityQueue&lt;Integer&gt; heap; public KthLargest(int k, int[] nums) { this.k = k; heap = new PriorityQueue&lt;&gt;(); for(int n : nums) heap.offer(n); while(heap.size() &gt; k) heap.poll(); } public int add(int val) { heap.offer(val); if (heap.size() &gt; k) { heap.poll(); } return heap.peek(); } } /** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ . ",
    "url": "https://1001anjan.github.io/problem-388-Kth%20Largest%20Element%20in%20a%20Stream/",
    "relUrl": "/problem-388-Kth Largest Element in a Stream/"
  },"537": {
    "doc": "Flood Fill",
    "title": "Flood Fill",
    "content": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color. Return the modified image after performing the flood fill. Example 1: . Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2: . Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 Output: [[0,0,0],[0,0,0]] Explanation: The starting pixel is already colored 0, so no changes are made to the image. Constraints: . | m == image.length | n == image[i].length | 1 &lt;= m, n &lt;= 50 | 0 &lt;= image[i][j], color &lt; 216 | 0 &lt;= sr &lt; m | 0 &lt;= sc &lt; n | . Solution: . class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if(image[sr][sc] != color){ dfsFill(image,sr,sc,image[sr][sc],color); } return image; } public void dfsFill(int[][] image, int sr, int sc,int baseColor, int color){ if(image[sr][sc] == baseColor){ image[sr][sc] = color; if(sc + 1 &lt; image[sr].length) dfsFill(image,sr,sc + 1,baseColor,color); if(sc - 1 &gt;= 0) dfsFill(image,sr,sc - 1,baseColor,color); if(sr - 1 &gt;= 0) dfsFill(image,sr - 1,sc,baseColor,color); if(sr + 1 &lt; image.length) dfsFill(image,sr + 1,sc,baseColor,color); } } } . ",
    "url": "https://1001anjan.github.io/problem-389-Flood%20Fill/",
    "relUrl": "/problem-389-Flood Fill/"
  },"538": {
    "doc": "Happy Number",
    "title": "Happy Number",
    "content": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: . | Starting with any positive integer, replace the number by the sum of the squares of its digits. | Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. | Those numbers for which this process ends in 1 are happy. | Return true if n is a happy number, and false if not. | . Example 1: . Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 . Example 2: . Input: n = 2 Output: false . Constraints: . | 1 &lt;= n &lt;= 231 - 1 Solution . class Solution { public boolean isHappy(int n) { while(n != 1 &amp;&amp; n != 4){ n = getNext(n); } return n==1; } public int getNext(int n){ int sum = 0; int d; while(n&gt;0){ d = n%10; sum += d*d; n = n/10; } return sum; } } . Approach : Detect Cycles with a HashSet . More details: https://leetcode.com/problems/happy-number/solution/ . class Solution { public boolean isHappy(int n) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int sum = 0; int d; while(n != 1){ n = getDigitsSum(n); if(set.contains(n)) return false; set.add(n); } return true; } public int getDigitsSum(int n){ int sum = 0; int d; while(n&gt;0){ d = n%10; sum += d*d; n = n/10; } return sum; } } . | . ",
    "url": "https://1001anjan.github.io/problem-39-Number-of-1-Bits/",
    "relUrl": "/problem-39-Number-of-1-Bits/"
  },"539": {
    "doc": "Set Matrix Zeroes",
    "title": "Set Matrix Zeroes",
    "content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0’s. You must do it in place. Example 1: . Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] . Example 2: . Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] . Constraints: . | m == matrix.length | n == matrix[0].length | 1 &lt;= m, n &lt;= 200 | -2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1 | . Solution: . class Solution { public void setZeroes(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(matrix[i][j] == 0){ list.add(new int[]{i,j}); } } } for(int[] l : list){ for(int i = 0; i &lt; m; i++) matrix[i][l[1]] = 0; for(int i = 0; i &lt; n; i++) matrix[l[0]][i] = 0; } } } . ",
    "url": "https://1001anjan.github.io/problem-39-Set%20Matrix%20Zeroes/",
    "relUrl": "/problem-39-Set Matrix Zeroes/"
  },"540": {
    "doc": "Min Cost Climbing Stairs",
    "title": "Min Cost Climbing Stairs",
    "content": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: . Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: . Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: . | 2 &lt;= cost.length &lt;= 1000 | 0 &lt;= cost[i] &lt;= 999 | . Solution: . class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length + 2]; for(int i = cost.length - 1; i &gt;= 0; i--){ dp[i] = cost[i] + Math.min(dp[i + 1], dp[i + 2]); } return Math.min(dp[0],dp[1]); } } . ",
    "url": "https://1001anjan.github.io/problem-390-Min%20Cost%20Climbing%20Stairs/",
    "relUrl": "/problem-390-Min Cost Climbing Stairs/"
  },"541": {
    "doc": "Shortest Completing Word",
    "title": "Shortest Completing Word",
    "content": "Given a string licensePlate and an array of strings words, find the shortest completing word in words. A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more. For example, if licensePlate = “aBc 12c”, then it contains letters ‘a’, ‘b’ (ignoring case), and ‘c’ twice. Possible completing words are “abccdef”, “caaacab”, and “cbca”. Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words. Example 1: . Input: licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"] Output: \"steps\" Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'. \"step\" contains 't' and 'p', but only contains 1 's'. \"steps\" contains 't', 'p', and both 's' characters. \"stripe\" is missing an 's'. \"stepple\" is missing an 's'. Since \"steps\" is the only word containing all the letters, that is the answer. Example 2: . Input: licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"] Output: \"pest\" Explanation: licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3. Constraints: . | 1 &lt;= licensePlate.length &lt;= 7 | licensePlate contains digits, letters (uppercase or lowercase), or space ‘ ‘. | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length &lt;= 15 | words[i] consists of lower case English letters. | . Solution: . class Solution { public String shortestCompletingWord(String licensePlate, String[] words) { String str = licensePlate.toLowerCase(); int[] cm = new int[26]; for(char ch : str.toCharArray()) { if(Character.isLetter(ch)) cm[ch - 'a']++; } String ans = null; for(String s : words){ int[] cm1 = new int[26]; for(char ch : s.toCharArray()) cm1[ch - 'a']++; int i = 0; for(; i &lt; 26; i++){ if(cm[i] &gt; cm1[i]) break; } if(i == 26){ if(ans != null){ if(ans.length() &gt; s.length()) ans = s; }else{ ans = s; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-391-Shortest%20Completing%20Word/",
    "relUrl": "/problem-391-Shortest Completing Word/"
  },"542": {
    "doc": "Toeplitz Matrix",
    "title": "Toeplitz Matrix",
    "content": "Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. Example 1: . Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation: In the above grid, the diagonals are: \"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\". In each diagonal all elements are the same, so the answer is True. Example 2: . Input: matrix = [[1,2],[2,2]] Output: false Explanation: The diagonal \"[1, 2]\" has different elements. Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 20 | 0 &lt;= matrix[i][j] &lt;= 99 | . Follow up: . | What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? | What if the matrix is so large that you can only load up a partial row into the memory at once? | . Solution: . class Solution { public boolean isToeplitzMatrix(int[][] matrix) { for(int i = 0; i &lt; matrix.length - 1; i++){ for(int j = 0; j &lt; matrix[i].length - 1; j++){ if(matrix[i][j] != matrix[i + 1][j + 1]) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-392-Toeplitz%20Matrix/",
    "relUrl": "/problem-392-Toeplitz Matrix/"
  },"543": {
    "doc": "Jewels and Stones",
    "title": "Jewels and Stones",
    "content": "You’re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example 1: . Input: jewels = \"aA\", stones = \"aAAbbbb\" Output: 3 . Example 2: . Input: jewels = \"z\", stones = \"ZZ\" Output: 0 . Constraints: . | 1 &lt;= jewels.length, stones.length &lt;= 50 | jewels and stones consist of only English letters. | All the characters of jewels are unique. | . Solution: . class Solution { public int numJewelsInStones(String jewels, String stones) { int count = 0; boolean[] um = new boolean[26]; boolean[] lm = new boolean[26]; for(char ch : jewels.toCharArray()){ if(Character.isUpperCase(ch)){ um[ch - 'A'] = true; }else{ lm[ch - 'a'] = true; } } for(char ch : stones.toCharArray()){ if(Character.isUpperCase(ch)){ if(um[ch - 'A']) count++; }else{ if(lm[ch - 'a']) count++; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-393-Jewels%20and%20Stones/",
    "relUrl": "/problem-393-Jewels and Stones/"
  },"544": {
    "doc": "Minimum Distance Between BST Nodes",
    "title": "Minimum Distance Between BST Nodes",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 100]. | 0 &lt;= Node.val &lt;= 10^5 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDiffInBST(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list = inorderTravaerse(root, list); int prev = list.get(1); int diff = prev - list.get(0); for(int i = 2; i &lt; list.size(); i++){ int curr = list.get(i); diff = Math.min(diff, curr - prev); prev = curr; } return diff; } public List&lt;Integer&gt; inorderTravaerse(TreeNode root, List&lt;Integer&gt; list){ if(root == null) return list; list = inorderTravaerse(root.left, list); list.add(root.val); list = inorderTravaerse(root.right, list); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-394-Minimum%20Distance%20Between%20BST%20Nodes/",
    "relUrl": "/problem-394-Minimum Distance Between BST Nodes/"
  },"545": {
    "doc": "Rotate String",
    "title": "Rotate String",
    "content": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s. A shift on s consists of moving the leftmost character of s to the rightmost position. For example, if s = “abcde”, then it will be “bcdea” after one shift. Example 1: . Input: s = \"abcde\", goal = \"cdeab\" Output: true . Example 2: . Input: s = \"abcde\", goal = \"abced\" Output: false . Constraints: . | 1 &lt;= s.length, goal.length &lt;= 100 | s and goal consist of lowercase English letters. | . Solution: . class Solution { public boolean rotateString(String s, String goal) { if(goal.length() &lt; s.length()) return false; return (goal + goal).indexOf(s) != -1; } } . ",
    "url": "https://1001anjan.github.io/problem-395-Rotate%20String/",
    "relUrl": "/problem-395-Rotate String/"
  },"546": {
    "doc": "Unique Morse Code Words",
    "title": "Unique Morse Code Words",
    "content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: . | ‘a’ maps to “.-“, | ‘b’ maps to “-…”, | ‘c’ maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: | . [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] . Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. | For example, “cab” can be written as “-.-..–…”, which is the concatenation of “-.-.”, “.-“, and “-…”. We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. | . Example 1: . Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -&gt; \"--...-.\" \"zen\" -&gt; \"--...-.\" \"gig\" -&gt; \"--...--.\" \"msg\" -&gt; \"--...--.\" There are 2 different transformations: \"--...-.\" and \"--...--.\". Example 2: . Input: words = [\"a\"] Output: 1 . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 12 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public int uniqueMorseRepresentations(String[] words) { String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\", \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\", \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; Set&lt;String&gt; seen = new HashSet(); for (String word: words) { StringBuilder code = new StringBuilder(); for (char c: word.toCharArray()) code.append(MORSE[c - 'a']); seen.add(code.toString()); } return seen.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-396-Unique%20Morse%20Code%20Words/",
    "relUrl": "/problem-396-Unique Morse Code Words/"
  },"547": {
    "doc": "Most Common Word",
    "title": "Most Common Word",
    "content": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase. Example 1: . Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"] Output: \"ball\" Explanation: \"hit\" occurs 3 times, but it is a banned word. \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \"ball,\"), and that \"hit\" isn't the answer even though it occurs more because it is banned. Example 2: . Input: paragraph = \"a.\", banned = [] Output: \"a\" . Constraints: . | 1 &lt;= paragraph.length &lt;= 1000 | paragraph consists of English letters, space ‘ ‘, or one of the symbols: “!?’,;.”. | 0 &lt;= banned.length &lt;= 100 | 1 &lt;= banned[i].length &lt;= 10 | banned[i] consists of only lowercase English letters. | . Solution . class Solution { public String mostCommonWord(String paragraph, String[] banned) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String str : banned) set.add(str); HashMap&lt;String,Integer&gt; mp = new HashMap&lt;&gt;(); int i = 0; int size = paragraph.length(); char[] str = paragraph.toCharArray(); StringBuilder sb = new StringBuilder(); while(i &lt; size){ while(i &lt; size &amp;&amp; str[i] == ' ') i++; sb.setLength(0); while(i &lt; size){ if(Character.isLetter(str[i])) sb.append(Character.toLowerCase(str[i])); else break; i++; } String s = sb.toString(); if(sb.length() &gt; 0 &amp;&amp; !set.contains(s)) mp.put(s, mp.getOrDefault(s,0) + 1); i++; } int max = Collections.max(mp.values()); for(String key : mp.keySet()){ if(mp.get(key) == max) return key; } return null; } } . ",
    "url": "https://1001anjan.github.io/problem-397-Most%20Common%20Word/",
    "relUrl": "/problem-397-Most Common Word/"
  },"548": {
    "doc": "Largest Triangle Area",
    "title": "Largest Triangle Area",
    "content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2.00000 Explanation: The five points are shown in the above figure. The red triangle is the largest. Example 2: . Input: points = [[1,0],[0,0],[0,1]] Output: 0.50000 . Constraints: . | 3 &lt;= points.length &lt;= 50 | -50 &lt;= xi, yi &lt;= 50 | All the given points are unique. | . Solution: . class Solution { public double largestTriangleArea(int[][] points) { double max = 0.0; for(int i = 0; i &lt; points.length - 2; i++){ for(int j = i + 1; j &lt; points.length - 1; j++){ for(int k = j + 1; k &lt; points.length; k++){ max = Math.max(max,calculateTriangleArea(points[i], points[j], points[k])); } } } return max; } public double calculateTriangleArea(int[] p1, int[] p2, int[] p3){ return Math.abs(p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))/2.0; } } . ",
    "url": "https://1001anjan.github.io/problem-398-Largest%20Triangle%20Area/",
    "relUrl": "/problem-398-Largest Triangle Area/"
  },"549": {
    "doc": "Rectangle Overlap",
    "title": "Rectangle Overlap",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-399-Rectangle%20Overlap/",
    "relUrl": "/problem-399-Rectangle Overlap/"
  },"550": {
    "doc": "Longest Palindromic Substring",
    "title": "Longest Palindromic Substring",
    "content": "Given a string s, return the longest palindromic substring in s. Example 1: . Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: . Input: s = \"cbbd\" Output: \"bb\" . Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consist of only digits and English letters. | . Solution: . class Solution { public String longestPalindrome(String s) { int n = s.length(); int start = 0, end = 0; boolean[][] dp = new boolean[n][n]; for(int len = 0; len &lt; n; len++){ for(int i = 0; len + i &lt; n; i++){ dp[i][i + len] = (s.charAt(i) == s.charAt(i + len)) &amp;&amp; (len &lt; 2 || dp[i + 1][i + len -1]); if(dp[i][i + len] &amp;&amp; len &gt; (end - start)){ start = i; end = i + len; } } } return s.substring(start, end + 1); } } . Logic: . The dynamic programmic approach to this question is quite simple actually! For any given substring, we can confirm if it is a palindrome in O(1) time if: . The characters at the ends of the substring are the same. If the inner substring is a palindrome. Observe this relationship below: . Algorithm: . | Our outter loop will represent our length - 1, len. | Our inner loop will represent our left pointer, i. Therefore, our right pointer will be represented by i+len. This makes our logic a bit easier: | . Our base cases are when len is 0 or 1 (i.e. when the length of the substring is of length 1 or 2). In these situations, DP won’t work. Thankfully, all we need to check for is whether s.charAt(i) == s.charAt(i + len). For len &gt; 1, we would also need to check whether the inner substring is a palindrome as illustrated above. Therefore, we’ll also check if dp[i+1][i+len-1] is true. There are a few ways we could keep track of our longest substring. We could just assign a new substring whenever our current window length is greater than the current string’s length. However, assigning a new substring on each update takes O(n) time at worst. Therefore, we’ll just keep track of the indices of our longest substring using start and end and we’ll only convert this into a substring at the end. ",
    "url": "https://1001anjan.github.io/problem-4-Longest%20Palindromic%20Substring/",
    "relUrl": "/problem-4-Longest Palindromic Substring/"
  },"551": {
    "doc": "Longest Common Prefix",
    "title": "Longest Common Prefix",
    "content": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: . Input: strs = [\"flower\",\"flow\",\"flight\"] Output: \"fl\" . Example 2: . Input: strs = [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Constraints: . | 1 &lt;= strs.length &lt;= 200 | 0 &lt;= strs[i].length &lt;= 200 | strs[i] consists of only lowercase English letters. | . Solution: . class Solution { public String longestCommonPrefix(String[] strs) { if(strs == null || strs.length ==0) return \"\"; String str= strs[0]; int i; for(i=0; i&lt;str.length(); i++){ for(int j=0;j&lt;strs.length; j++){ if(strs[j].length()&lt;=i) return str.substring(0,i); if(strs[j].charAt(i) != str.charAt(i)) return str.substring(0,i); } } if(i==0) return \"\"; return strs[0]; } } . Complexity Analysis . Time complexity : O(S) , where S is the sum of all characters in all strings. In the worst case there will be nn equal strings with length m and the algorithm performs S = m \\cdot nS=m⋅n character comparisons. Even though the worst case is still the same as Approach 1, in the best case there are at most n \\cdot minLenn⋅minLen comparisons where minLenminLen is the length of the shortest string in the array. Space complexity : O(1). We only used constant extra space. Solution: Divide and Conquer . class Solution { public String longestCommonPrefix(String[] strs) { if(strs == null || strs.length ==0) return \"\"; return longestCommonPrefix(strs,0, strs.length-1); } private String longestCommonPrefix(String[] strs, int l, int u){ if(l == u ) return strs[l]; int mid = (l+u)/2; String left = longestCommonPrefix(strs, l, mid); String right = longestCommonPrefix(strs, mid+1, u); return commonPrefix(left, right); } private String commonPrefix(String left, String right){ int min = Math.min(left.length(), right.length()); for(int i=0; i&lt;min; i++){ if(left.charAt(i) != right.charAt(i)) return left.substring(0, i); } return left.substring(0,min); } } . Complexity Analysis . In the worst case we have nn equal strings with length m . | Time complexity : O(S), where S is the number of all characters in the array, S = m \\cdot nS=m⋅n Time complexity is 2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)2⋅T(2 n )+O(m). Therefore time complexity is O(S)O(S). In the best case this algorithm performs O(minLen \\cdot n)O(minLen⋅n) comparisons, where minLenminLen is the shortest string of the array . | Space complexity : O(m \\cdot \\log n)O(m⋅logn) . | . There is a memory overhead since we store recursive calls in the execution stack. There are \\log nlogn recursive calls, each store need mm space to store the result, so space complexity is O(m \\cdot \\log n)O(m⋅logn) . ",
    "url": "https://1001anjan.github.io/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-4-Longest-Common-Prefix/",
    "relUrl": "/docs/DAS-Difficulty-Easy/ds-easy-set-1/problem-4-Longest-Common-Prefix/"
  },"552": {
    "doc": "Remove Linked List Elements",
    "title": "Remove Linked List Elements",
    "content": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Example 1: . Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] . Example 2: . Input: head = [], val = 1 Output: [] . Example 3: . Input: head = [7,7,7,7], val = 7 Output: [] . Constraints: . | The number of nodes in the list is in the range [0, 104]. | 1 &lt;= Node.val &lt;= 50 | 0 &lt;= val &lt;= 50 | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode ptr, qtr; while(head != null &amp;&amp; head.val == val){ ptr = head; head = head.next; ptr.next = null; } if(head == null) return head; ptr = head; while(ptr.next != null){ if(ptr.next.val == val){ qtr = ptr.next; ptr.next = ptr.next.next; qtr.next = null; }else ptr = ptr.next; } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-40-Remove-Linked-List-Elements/",
    "relUrl": "/problem-40-Remove-Linked-List-Elements/"
  },"553": {
    "doc": "Search a 2D Matrix",
    "title": "Search a 2D Matrix",
    "content": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: . | Integers in each row are sorted from left to right. | The first integer of each row is greater than the last integer of the previous row. | . Example 1: . Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true . Example 2: . Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 100 | -10^4 &lt;= matrix[i][j], target &lt;= 10^4 | . Solution: . class Solution { public boolean searchMatrix(int[][] matrix, int target) { int n = matrix[0].length - 1; for(int[] arr : matrix){ if(arr[0] == target || target == arr[n]) return true; if(arr[0] &lt; target &amp;&amp; target &lt; arr[n]) return binarySearch(arr, 0, n, target); } return false; } public boolean binarySearch(int[] arr, int l, int u, int target){ if(l &gt; u) return false; int m = (l + u)/2; if(arr[m] == target) return true; if(arr[m] &gt; target) return binarySearch(arr, l, m - 1, target); else return binarySearch(arr, m + 1, u, target); } } . ",
    "url": "https://1001anjan.github.io/problem-40-Search%20a%202D%20Matrix/",
    "relUrl": "/problem-40-Search a 2D Matrix/"
  },"554": {
    "doc": "Fair Candy Swap",
    "title": "Fair Candy Swap",
    "content": "Fair Candy Swap . Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists. Example 1: . Input: aliceSizes = [1,1], bobSizes = [2,2] Output: [1,2] . Example 2: . Input: aliceSizes = [1,2], bobSizes = [2,3] Output: [1,2] . Example 3: . Input: aliceSizes = [2], bobSizes = [1,3] Output: [2,3] . Constraints: . | 1 &lt;= aliceSizes.length, bobSizes.length &lt;= 104 | 1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 105 | Alice and Bob have a different total number of candies. | There will be at least one valid answer for the given input. | . Solution . Time Complexity O(m*n) Space Complexity: O(1) . class Solution { public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) { int aliceSum = 0, bobSum = 0; for(int n : aliceSizes) aliceSum += n; for(int n : bobSizes) bobSum += n; int total = (aliceSum + bobSum)/2; for(int m : aliceSizes){ for(int n : bobSizes){ if(total == (aliceSum - m + n)) return new int[]{m,n}; } } throw null; } } . class Solution { public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) { int aliceSum = 0, bobSum = 0; for(int n : aliceSizes) aliceSum += n; for(int n : bobSizes) bobSum += n; int total = (aliceSum + bobSum)/2; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); if(aliceSizes.length &gt; bobSizes.length){ for(int n : aliceSizes) set.add(n); int delta = total - bobSum; for(int m : bobSizes){ if(set.contains(delta + m)) return new int[]{delta + m, m}; } }else{ for(int n : bobSizes) set.add(n); int delta = total - aliceSum; for(int m : aliceSizes){ if(set.contains(delta + m)) return new int[]{m,delta + m}; } } throw null; } } . class Solution { public int[] fairCandySwap(int[] A, int[] B) { int sa = 0, sb = 0; // sum of A, B respectively for (int x: A) sa += x; for (int x: B) sb += x; int delta = (sb - sa) / 2; // If Alice gives x, she expects to receive x + delta Set&lt;Integer&gt; setB = new HashSet(); for (int x: B) setB.add(x); for (int x: A) if (setB.contains(x + delta)) return new int[]{x, x + delta}; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-400-Fair%20Candy%20Swap/",
    "relUrl": "/problem-400-Fair Candy Swap/"
  },"555": {
    "doc": "Smallest Range I",
    "title": "Smallest Range I",
    "content": "Smallest Range I . You are given an integer array nums and an integer k. In one operation, you can choose any index i where 0 &lt;= i &lt; nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after applying the mentioned operation at most once for each index in it. Example 1: . Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: . Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: . Input: nums = [1,3,6], k = 3 Output: 0 Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0. Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 10^4 | 0 &lt;= k &lt;= 10^4 | . Solution: . class Solution { public int smallestRangeI(int[] nums, int k) { int max = -1, min = Integer.MAX_VALUE; for(int n : nums){ max = Math.max(max,n); min = Math.min(min,n); } if((max - min) &lt;= 2*k) return 0; return max - k - min - k; } } . ",
    "url": "https://1001anjan.github.io/problem-401-Smallest%20Range%20I/",
    "relUrl": "/problem-401-Smallest Range I/"
  },"556": {
    "doc": "X of a Kind in a Deck of Cards",
    "title": "X of a Kind in a Deck of Cards",
    "content": "You are given an integer array deck where deck[i] represents the number written on the ith card. Partition the cards into one or more groups such that: . | Each group has exactly x cards where x &gt; 1, and | All the cards in one group have the same integer written on them. Return true if such partition is possible, or false otherwise. | . Example 1: . Input: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2: . Input: deck = [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. Constraints: . | 1 &lt;= deck.length &lt;= 10^4 | 0 &lt;= deck[i] &lt; 10^4 | . Solution: . class Solution { public boolean hasGroupsSizeX(int[] deck) { if(deck.length == 1) return false; int[] dp = new int[10000]; for(int n : deck) dp[n]++; int minCount = Integer.MAX_VALUE; for(int n : dp) { if(n != 0) minCount = Math.min(minCount,n); } int i = 2; for(; i &lt;= minCount; i++){ boolean f = true; for(int n : dp){ if(n != 0 &amp;&amp; (n%i != 0)){ f = false; break; } } if(f) break; } return i &lt;= minCount; } } . Improvement . class Solution { public boolean hasGroupsSizeX(int[] deck) { int[] count = new int[10000]; for (int c: deck) count[c]++; int g = -1; for (int i = 0; i &lt; 10000; ++i) if (count[i] &gt; 0) { if (g == -1) g = count[i]; else g = gcd(g, count[i]); } return g &gt;= 2; } public int gcd(int x, int y) { return x == 0 ? y : gcd(y%x, x); } } . Complexity Analysis . | Time Complexity: O(Nlog^2 N)where N is the number of votes. If there are Ci cards with number i, then each gcd operation is naively O(log^2Ci). Better bounds exist, but are outside the scope of this article to develop. | Space Complexity: O(N). | . ",
    "url": "https://1001anjan.github.io/problem-402-X%20of%20a%20Kind%20in%20a%20Deck%20of%20Cards/",
    "relUrl": "/problem-402-X of a Kind in a Deck of Cards/"
  },"557": {
    "doc": "Best Time to Buy and Sell Stock",
    "title": "Best Time to Buy and Sell Stock",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: . Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: . Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: . | 1 &lt;= prices.length &lt;= 10^5 | 0 &lt;= prices[i] &lt;= 10^4 | . Solution . class Solution { public int maxProfit(int[] prices) { int i = 0, j = 0; int max = 0; while(j &lt; prices.length){ if(prices[i] &gt; prices[j]){ i = j; }else{ max = Math.max(max,prices[j] - prices[i]); j++; } } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-403-Best%20Time%20to%20Buy%20and%20Sell%20Stock/",
    "relUrl": "/problem-403-Best Time to Buy and Sell Stock/"
  },"558": {
    "doc": "DI String Match",
    "title": "DI String Match",
    "content": "A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where: . | s[i] == ‘I’ if perm[i] &lt; perm[i + 1], and | s[i] == ‘D’ if perm[i] &gt; perm[i + 1]. Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them. | . Example 1: . Input: s = \"IDID\" Output: [0,4,1,3,2] . Example 2: . Input: s = \"III\" Output: [0,1,2,3] . Example 3: . Input: s = \"DDI\" Output: [3,2,0,1] . Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘I’ or ‘D’. | . Solution: . class Solution { public int[] diStringMatch(String s) { char[] chs = s.toCharArray(); int[] ans = new int[chs.length + 1]; int u = chs.length; int l = 0; for(int i = 0; i &lt; chs.length; i++){ if(chs[i] == 'I'){ ans[i] = l++; }else{ ans[i] = u--; } } ans[chs.length] = l; return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-404-DI%20String%20Match/",
    "relUrl": "/problem-404-DI String Match/"
  },"559": {
    "doc": "Verifying an Alien Dictionary",
    "title": "Verifying an Alien Dictionary",
    "content": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: . Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: . Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] &gt; words[1], hence the sequence is unsorted. Example 3: . Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" &gt; \"app\", because 'l' &gt; '∅', where '∅' is defined as the blank character which is less than any other character (More info). Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 20 | order.length == 26 | All characters in words[i] and order are English lowercase letters. | . Solution: . class Solution { public boolean isAlienSorted(String[] words, String order) { int[] mp = new int[26]; for(int i = 0; i &lt; order.length(); i++){ mp[order.charAt(i) - 'a'] = i; } for(int i = 0; i &lt; words.length - 1; i++){ int k = 0; int kn = words[i].length(); int ln = words[i + 1].length(); int minDiff = 0; while(k &lt; kn &amp;&amp; k &lt; ln){ int diff = mp[words[i].charAt(k) - 'a'] - mp[words[i + 1].charAt(k) - 'a']; minDiff = Math.min(diff,minDiff); if(diff &lt; 0) break; if(diff &gt; 0) return false; k++; } if(minDiff == 0 &amp;&amp; kn &gt; ln) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-405-Verifying%20an%20Alien%20Dictionary/",
    "relUrl": "/problem-405-Verifying an Alien Dictionary/"
  },"560": {
    "doc": "Remove Outermost Parentheses",
    "title": "Remove Outermost Parentheses",
    "content": "A valid parentheses string is either empty “”, “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. | For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings. | . A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + … + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s. Example 1: . Input: s = \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: . Input: s = \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: . Input: s = \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘(‘ or ‘)’. | s is a valid parentheses string. | . Solution: . class Solution { public String removeOuterParentheses(String s) { int open = 0; StringBuilder sb = new StringBuilder(); for(char ch : s.toCharArray()){ if(ch == '('){ if(open == 0){ open++; }else{ open++; sb.append(ch); } }else{ if(open &gt; 1){ open--; sb.append(ch); }else{ open = 0; } } } return sb.toString(); } } . class Solution { public String removeOuterParentheses(String S) { StringBuilder s = new StringBuilder(); int opened = 0; for (char c : S.toCharArray()) { if (c == '(' &amp;&amp; opened++ &gt; 0) s.append(c); if (c == ')' &amp;&amp; opened-- &gt; 1) s.append(c); } return s.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-406-Remove%20Outermost%20Parentheses/",
    "relUrl": "/problem-406-Remove Outermost Parentheses/"
  },"561": {
    "doc": "Matrix Cells in Distance Order",
    "title": "Matrix Cells in Distance Order",
    "content": "You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter). Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition. | The distance between two cells (r1, c1) and (r2, c2) is | r1 - r2 | + | c1 - c2 | . | . Example 1: . Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0 Output: [[0,0],[0,1]] Explanation: The distances from (0, 0) to other cells are: [0,1] . Example 2: . Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1 Output: [[0,1],[0,0],[1,1],[1,0]] Explanation: The distances from (0, 1) to other cells are: [0,1,1,2] The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct. Example 3: . Input: rows = 2, cols = 3, rCenter = 1, cCenter = 2 Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] Explanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3] There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]. Constraints: . | 1 &lt;= rows, cols &lt;= 100 | 0 &lt;= rCenter &lt; rows | 0 &lt;= cCenter &lt; cols | . Solution: . Using Sorting: . class Solution { public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) { int[][] ans = new int[rows*cols][2]; int k = 0; for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; cols; j++){ ans[k][0] = i; ans[k][1] = j; k++; } } // sort the array Arrays.sort(ans, (a,b) -&gt;{ int d1 = Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter); int d2 = Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter); return d1 - d2; }); return ans; } } . Using BFS but slow execution . class Solution { public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) { int[][] ans = new int[rows*cols][2]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[rows][cols]; queue.offer(new int[]{rCenter,cCenter}); int k = 0; while(!queue.isEmpty()){ int[] item = queue.poll(); if(item[0] &lt; 0 || item[0] &gt;= rows || item[1] &lt; 0 || item[1] &gt;= cols) continue; if(visited[item[0]][item[1]]) continue; visited[item[0]][item[1]] = true; ans[k++] = item; queue.offer(new int[]{item[0], item[1] + 1}); queue.offer(new int[]{item[0], item[1] - 1}); queue.offer(new int[]{item[0] + 1, item[1]}); queue.offer(new int[]{item[0] - 1, item[1]}); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-407-Matrix%20Cells%20in%20Distance%20Order/",
    "relUrl": "/problem-407-Matrix Cells in Distance Order/"
  },"562": {
    "doc": "Greatest Common Divisor of Strings",
    "title": "Greatest Common Divisor of Strings",
    "content": "For two strings s and t, we say “t divides s” if and only if s = t + … + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. Example 1: . Input: str1 = \"ABCABC\", str2 = \"ABC\" Output: \"ABC\" . Example 2: . Input: str1 = \"ABABAB\", str2 = \"ABAB\" Output: \"AB\" . Example 3: . Input: str1 = \"LEET\", str2 = \"CODE\" Output: \"\" . Constraints: . | 1 &lt;= str1.length, str2.length &lt;= 1000 | str1 and str2 consist of English uppercase letters. | . Solution: . class Solution { public String gcdOfStrings(String str1, String str2) { if (!(str1+str2).equals(str2+str1)) return \"\"; int gcdVal = gcd(str1.length() , str2.length()); return str2.substring(0, gcdVal); } public static int gcd(int p, int q) { if (q == 0) return p; else return gcd(q, p % q); } } . ",
    "url": "https://1001anjan.github.io/problem-408-Greatest%20Common%20Divisor%20of%20Strings/",
    "relUrl": "/problem-408-Greatest Common Divisor of Strings/"
  },"563": {
    "doc": "Duplicate Zeros",
    "title": "Duplicate Zeros",
    "content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: . Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] . Example 2: . Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] . Constraints: . | 1 &lt;= arr.length &lt;= 10^4 | 0 &lt;= arr[i] &lt;= 9 | . Solution: . class Solution { public void duplicateZeros(int[] arr) { for(int i = 0; i &lt; arr.length - 1; i++){ if(arr[i] == 0){ for(int j = arr.length - 2; j &gt; i; j--){ arr[j + 1] = arr[j]; } arr[i + 1] = 0; i++; } } } } . class Solution { public void duplicateZeros(int[] arr) { int possibleDups = 0; int length_ = arr.length - 1; // Find the number of zeros to be duplicated // Stopping when left points beyond the last element in the original array // which would be part of the modified array for (int left = 0; left &lt;= length_ - possibleDups; left++) { // Count the zeros if (arr[left] == 0) { // Edge case: This zero can't be duplicated. We have no more space, // as left is pointing to the last element which could be included if (left == length_ - possibleDups) { // For this zero we just copy it without duplication. arr[length_] = 0; length_ -= 1; break; } possibleDups++; } } // Start backwards from the last element which would be part of new array. int last = length_ - possibleDups; // Copy zero twice, and non zero once. for (int i = last; i &gt;= 0; i--) { if (arr[i] == 0) { arr[i + possibleDups] = 0; possibleDups--; arr[i + possibleDups] = 0; } else { arr[i + possibleDups] = arr[i]; } } } } . Practice link . ",
    "url": "https://1001anjan.github.io/problem-409-Duplicate%20Zeros/",
    "relUrl": "/problem-409-Duplicate Zeros/"
  },"564": {
    "doc": "Reverse Linked List",
    "title": "Reverse Linked List",
    "content": "Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: . Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] . Solution . Non-recursive . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { if(head == null) return head; ListNode ptr = null, qtr ; while(head != null){ qtr = head; head = head.next; qtr.next = ptr; ptr = qtr; } return ptr; } } . Recursive . class Solution { public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newNode = reverseList(head.next); head.next.next = head; head.next = null; return newNode; } } . ",
    "url": "https://1001anjan.github.io/problem-41-Reverse-Linked-List/",
    "relUrl": "/problem-41-Reverse-Linked-List/"
  },"565": {
    "doc": "Sort Colors",
    "title": "Sort Colors",
    "content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. Example 1: . Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] . Example 2: . Input: nums = [2,0,1] Output: [0,1,2] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 300 | nums[i] is either 0, 1, or 2. | . Follow up: Could you come up with a one-pass algorithm using only constant extra space? . Solution: . class Solution { public void sortColors(int[] nums) { int s = 0,e = 0; int l = nums.length - 1; int pivot = 1; while(e &lt;= l){ if(nums[e] &lt; pivot){ swap(nums, s, e); s++; e++; } else if(nums[e] == pivot){ e++; } else{ swap(nums, e, l); l--; } } } public void swap(int[] arr, int i, int j){ int t = arr[i]; arr[i] = arr[j]; arr[j] = t; } } . ",
    "url": "https://1001anjan.github.io/problem-41-Sort%20Colors/",
    "relUrl": "/problem-41-Sort Colors/"
  },"566": {
    "doc": "Day of the Year",
    "title": "Day of the Year",
    "content": "Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. Example 1: . Input: date = \"2019-01-09\" Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2: . Input: date = \"2019-02-10\" Output: 41 . Constraints: . | date.length == 10 | date[4] == date[7] == ‘-‘, and all other date[i]’s are digits | date represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019. | . Solution: . import java.time.LocalDate; class Solution { public int dayOfYear(String date) { return LocalDate.parse(date).getDayOfYear(); } } . class Solution { public int dayOfYear(String S) { String[] s = S.split(\"-\"); int year = Integer.parseInt(s[0]); int month = Integer.parseInt(s[1]); int date = Integer.parseInt(s[2]); boolean isLeap = checkYear(year); int noOfDays = 0; int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; for (int i = 0; i &lt; month - 1; i++) { if (isLeap &amp;&amp; i == 1) { noOfDays += days[i] + 1; continue; } noOfDays += days[i]; } return noOfDays + date; } boolean checkYear(int year) { if (year % 400 == 0) return true; if (year % 100 == 0) return false; if (year % 4 == 0) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-410-Day%20of%20the%20Year/",
    "relUrl": "/problem-410-Day of the Year/"
  },"567": {
    "doc": "Prime Arrangements",
    "title": "Prime Arrangements",
    "content": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) . (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) . Since the answer may be large, return the answer modulo 10^9 + 7. Example 1: . Input: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. Example 2: . Input: n = 100 Output: 682289015 . Constraints: . | 1 &lt;= n &lt;= 100 Prime Arrangements | . ",
    "url": "https://1001anjan.github.io/problem-411-Prime%20Arrangements/",
    "relUrl": "/problem-411-Prime Arrangements/"
  },"568": {
    "doc": "Day of the Week",
    "title": "Day of the Week",
    "content": "Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}. Example 1: . Input: day = 31, month = 8, year = 2019 Output: \"Saturday\" . Example 2: . Input: day = 18, month = 7, year = 1999 Output: \"Sunday\" . Example 3: . Input: day = 15, month = 8, year = 1993 Output: \"Sunday\" . Constraints: . | The given dates are valid dates between the years 1971 and 2100. | . Solution: . class Solution { int[] m = {0,31,28,31,30,31,30,31,31,30,31,30,31}; String[] res = {\"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"}; public String dayOfTheWeek(int day, int month, int year) { int days = years(year); if(isLeap(year)) m[2] = 29; for(int i=0; i &lt; month; i++){ days += m[i]; } days += day-1; return res[days%7]; } private int years(int y){ int count = 0; for(int i=1971; i &lt; y; i++){ if(isLeap(i)) count += 366; else count += 365; } return count; } private boolean isLeap(int y){ if(y % 4 != 0) return false; else if(y%100 != 0) return true; else if(y % 400 != 0) return false; else return true; } } . ",
    "url": "https://1001anjan.github.io/problem-412-Day%20of%20the%20Week/",
    "relUrl": "/problem-412-Day of the Week/"
  },"569": {
    "doc": "Minimum Cost to Move Chips to The Same Position",
    "title": "Minimum Cost to Move Chips to The Same Position",
    "content": "We have n chips, where the position of the ith chip is position[i]. We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to: . | position[i] + 2 or position[i] - 2 with cost = 0. | position[i] + 1 or position[i] - 1 with cost = 1. Return the minimum cost needed to move all the chips to the same position. | . Example 1: . Input: position = [1,2,3] Output: 1 Explanation: First step: Move the chip at position 3 to position 1 with cost = 0. Second step: Move the chip at position 2 to position 1 with cost = 1. Total cost is 1. Example 2: . Input: position = [2,2,2,3,3] Output: 2 Explanation: We can move the two chips at position 3 to position 2. Each move has cost = 1. The total cost = 2. Example 3: . Input: position = [1,1000000000] Output: 1 . Constraints: . | 1 &lt;= position.length &lt;= 100 | 1 &lt;= position[i] &lt;= 10^9 | . Solution: . class Solution { public int minCostToMoveChips(int[] position) { int even_cnt = 0; int odd_cnt = 0; for (int i : position) { if (i % 2 == 0) { even_cnt++; } else { odd_cnt++; } } return Math.min(odd_cnt, even_cnt); } } . ",
    "url": "https://1001anjan.github.io/problem-413-Minimum%20Cost%20to%20Move%20Chips%20to%20The%20Same%20Position/",
    "relUrl": "/problem-413-Minimum Cost to Move Chips to The Same Position/"
  },"570": {
    "doc": "Check If It Is a Straight Line",
    "title": "Check If It Is a Straight Line",
    "content": "You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane. Example 1: . Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true . Example 2: . Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false . Constraints: . | 2 &lt;= coordinates.length &lt;= 1000 | coordinates[i].length == 2 | -10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4 | coordinates contains no duplicate point. | . Solution: . The slope for a line through any 2 points (x0, y0) and (x1, y1) is (y1 - y0) / (x1 - x0); Therefore, for any given 3 points (denote the 3rd point as (x, y)), if they are in a straight line, the slopes of the lines from the 3rd point to the 2nd point and the 2nd point to the 1st point must be equal: . (y - y1) / (x - x1) = (y1 - y0) / (x1 - x0) In order to avoid being divided by 0, use multiplication form: . (x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) =&gt; dx * (y - y1) = dy * (x - x1), where dx = x1 - x0 and dy = y1 - y0 . class Solution { public boolean checkStraightLine(int[][] coordinates) { int dx = coordinates[1][0] - coordinates[0][0]; int dy = coordinates[1][1] - coordinates[0][1]; for(int i = 2; i &lt; coordinates.length; i++){ int dxi = coordinates[i][0] - coordinates[i - 1][0]; int dyi = coordinates[i][1] - coordinates[i - 1][1]; if(dx * dyi != dy * dxi) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-414-Check%20If%20It%20Is%20a%20Straight%20Line/",
    "relUrl": "/problem-414-Check If It Is a Straight Line/"
  },"571": {
    "doc": "Minimum Time Visiting All Points",
    "title": "Minimum Time Visiting All Points",
    "content": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move according to these rules: . | In 1 second, you can either: | move vertically by one unit, | move horizontally by one unit, or | move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second). | You have to visit the points in the same order as they appear in the array. | You are allowed to pass through points that appear later in the order, but these do not count as visits. | . Example 1: . Input: points = [[1,1],[3,4],[-1,0]] Output: 7 Explanation: One optimal path is [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] Time from [1,1] to [3,4] = 3 seconds Time from [3,4] to [-1,0] = 4 seconds Total time = 7 seconds . Example 2: . Input: points = [[3,2],[-2,2]] Output: 5 . Constraints: . | points.length == n | 1 &lt;= n &lt;= 100 | points[i].length == 2 | -1000 &lt;= points[i][0], points[i][1] &lt;= 1000 | . Solution: . class Solution { public int minTimeToVisitAllPoints(int[][] points) { int time = 0; for(int i = 0; i &lt; points.length - 1; i++) { int xDiff = Math.abs(points[i][0] - points[i + 1][0]); int yDiff = Math.abs(points[i][1] - points[i + 1][1]); time += Math.max(xDiff, yDiff); } return time; } } . ",
    "url": "https://1001anjan.github.io/problem-415-Minimum%20Time%20Visiting%20All%20Points/",
    "relUrl": "/problem-415-Minimum Time Visiting All Points/"
  },"572": {
    "doc": "Find Winner on a Tic Tac Toe Game",
    "title": "Find Winner on a Tic Tac Toe Game",
    "content": "Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are: . | Players take turns placing characters into empty squares ‘ ‘. | The first player A always places ‘X’ characters, while the second player B always places ‘O’ characters. | ‘X’ and ‘O’ characters are always placed into empty squares, never on filled ones. | The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal. | The game also ends if all squares are non-empty. | No more moves can be played if the game is over. Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return “Draw”. If there are still movements to play return “Pending”. | . You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first. Example 1: . Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] Output: \"A\" Explanation: A wins, they always play first. Example 2: . Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] Output: \"B\" Explanation: B wins. Example 3: . Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] Output: \"Draw\" Explanation: The game ends in a draw since there are no moves to make. Constraints: . | 1 &lt;= moves.length &lt;= 9 | moves[i].length == 2 | 0 &lt;= rowi, coli &lt;= 2 | There are no repeated elements on moves. | moves follow the rules of tic tac toe. | . Solution: . There are 8 ways to win for each player: . | 3 columns | 3 rows | 2 diagonals Players make moves one by one so all odd moves are for player A, even for B. Now we just need to track if we reach 3 in any line for any of the players. One array keeps all ways to win for each player: . | 0,1,2 - for rows | 3,4,5 - for cols | 6 - for diagonal top left - bottom right | 7 - for diagonal top right - bottom left | . class Solution { public String tictactoe(int[][] moves) { int a[] = new int[8]; int b[] = new int[8]; boolean t = true; for(int m[] : moves){ int p[] = t ? a : b; t = t ? false : true; p[m[0]]++; p[m[1] + 3]++; if(m[0] == m[1]) p[6]++; if(m[0] == 2 - m[1]) p[7]++; } for(int i = 0; i &lt; 8 ; i++){ if(a[i] == 3) return \"A\"; if(b[i] == 3) return \"B\"; } return moves.length == 9 ? \"Draw\" : \"Pending\"; } } . ",
    "url": "https://1001anjan.github.io/problem-416-Find%20Winner%20on%20a%20Tic%20Tac%20Toe%20Game/",
    "relUrl": "/problem-416-Find Winner on a Tic Tac Toe Game/"
  },"573": {
    "doc": "Number of Days Between Two Dates",
    "title": "Number of Days Between Two Dates",
    "content": "Write a program to count the number of days between two dates. The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples. Example 1: . Input: date1 = \"2019-06-29\", date2 = \"2019-06-30\" Output: 1 . Example 2: . Input: date1 = \"2020-01-15\", date2 = \"2019-12-31\" Output: 15 . Constraints: . | The given dates are valid dates between the years 1971 and 2100. | . Solution: . class Solution { int dM[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; public int daysBetweenDates(String date1, String date2) { String ds1[] = date1.split(\"-\"); String ds2[] = date2.split(\"-\"); int ddy1 = Integer.parseInt(ds1[0]); int ddm1 = Integer.parseInt(ds1[1]); int ddd1 = Integer.parseInt(ds1[2]); int ddy2 = Integer.parseInt(ds2[0]); int ddm2 = Integer.parseInt(ds2[1]); int ddd2 = Integer.parseInt(ds2[2]); int dy1, dy2, dm1, dm2, dd1, dd2; dy1 = ddy1; dm1 = ddm1; dd1 = ddd1; dy2 = ddy2; dm2 = ddm2; dd2 = ddd2; if(ddy1 &gt; ddy2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; }else if(ddy1 == ddy2 &amp;&amp; ddm1 &gt; ddm2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; }else if(ddy1 == ddy2 &amp;&amp; ddm1 == ddm2 &amp;&amp; ddd1 &gt; ddd2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; } int count = 0; // cheacking is date1 and date2 if same year and same month if(dy1 == dy2 &amp;&amp; dm1 == dm2){ return dd2 - dd1; } // adding reaming day in the month count += dM[dm1] - dd1; if(dm1 == 2 &amp;&amp; isLeapYear(dy1)){ count++; } dm1++; // counting first year if(dy1 &lt; dy2){ while(dm1 &lt;= 12){ if(dm1 == 2 &amp;&amp; isLeapYear(dy1)) count++; count += dM[dm1]; dm1++; } } dy1++; // counting middle years while(dy1 &lt; dy2){ if(isLeapYear(dy1)) count++; count += 365; dy1++; } // countiing end year dm1 = 1; while(dy1 &lt;= dy2 &amp;&amp; dm1 &lt; dm2){ if(dm1 == 2 &amp;&amp; isLeapYear(dy1)) count++; count += dM[dm1]; dm1++; } // counting last month count += dd2; return count; } public boolean isLeapYear(int y){ if(y % 400 == 0) return true; if(y % 100 == 0) return false; if(y % 4 == 0) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-417-Number%20of%20Days%20Between%20Two%20Dates/",
    "relUrl": "/problem-417-Number of Days Between Two Dates/"
  },"574": {
    "doc": "Count Largest Group",
    "title": "Count Largest Group",
    "content": "You are given an integer n. Each number from 1 to n is grouped according to the sum of its digits. Return the number of groups that have the largest size. Example 1: . Input: n = 13 Output: 4 Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. Example 2: . Input: n = 2 Output: 2 Explanation: There are 2 groups [1], [2] of size 1. Constraints: . | 1 &lt;= n &lt;= 10^4 | . Solution: . class Solution { public int countLargestGroup(int n) { int count = 0; int[] dp = new int[n + 1]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 1; i &lt;= n; i++){ dp[i] = i % 10 + dp[i/10]; map.put(dp[i], map.getOrDefault(dp[i],0) + 1); } int max = 0; for(int key : map.keySet()){ if(map.get(key) &gt; max){ count = 1; max = map.get(key); }else if(map.get(key) == max) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-418-Count%20Largest%20Group/",
    "relUrl": "/problem-418-Count Largest Group/"
  },"575": {
    "doc": "Minimum Subsequence in Non-Increasing Order",
    "title": "Minimum Subsequence in Non-Increasing Order",
    "content": "Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order. Example 1: . Input: nums = [4,3,10,9,8] Output: [10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. Example 2: . Input: nums = [4,4,7,6,7] Output: [7,7,6] Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order. Constraints: . | 1 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; minSubsequence(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int sum = 0; for(int n : nums) sum += n; Arrays.sort(nums); int i = nums.length - 1; int currSum = 0; while(currSum &lt;= sum &amp;&amp; i &gt;= 0){ currSum += nums[i]; sum -= nums[i]; ans.add(nums[i]); i--; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-419-Minimum%20Subsequence%20in%20Non-Increasing%20Order/",
    "relUrl": "/problem-419-Minimum Subsequence in Non-Increasing Order/"
  },"576": {
    "doc": "Combinations",
    "title": "Combinations",
    "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order. Example 1: . Input: n = 4, k = 2 Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination. Example 2: . Input: n = 1, k = 1 Output: [[1]] Explanation: There is 1 choose 1 = 1 total combination. Constraints: . | 1 &lt;= n &lt;= 20 | 1 &lt;= k &lt;= n | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); process(1, n, k, ans, new ArrayList&lt;&gt;()); return ans; } public void process(int start, int n, int k, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; k) return; if(list.size() == k){ ans.add(new ArrayList&lt;&gt;(list)); return; } for(int i = start; i &lt;= n; i++){ list.add(i); process(i + 1, n, k, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-42-Combinations/",
    "relUrl": "/problem-42-Combinations/"
  },"577": {
    "doc": "Isomorphic Strings",
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: . Input: s = \"egg\", t = \"add\" Output: true . Example 2: . Input: s = \"foo\", t = \"bar\" Output: false . Example 3: . Input: s = \"paper\", t = \"title\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | t.length == s.length | s and t consist of any valid ascii character. | . Solution . https://leetcode.com/problems/isomorphic-strings/solution/ . ",
    "url": "https://1001anjan.github.io/problem-42-Isomorphic-Strings/",
    "relUrl": "/problem-42-Isomorphic-Strings/"
  },"578": {
    "doc": "Special Array With X Elements Greater Than or Equal X",
    "title": "Special Array With X Elements Greater Than or Equal X",
    "content": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x. Notice that x does not have to be an element in nums. Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique. Example 1: . Input: nums = [3,5] Output: 2 Explanation: There are 2 values (3 and 5) that are greater than or equal to 2. Example 2: . Input: nums = [0,0] Output: -1 Explanation: No numbers fit the criteria for x. If x = 0, there should be 0 numbers &gt;= x, but there are 2. If x = 1, there should be 1 number &gt;= x, but there are 0. If x = 2, there should be 2 numbers &gt;= x, but there are 0. x cannot be greater since there are only 2 numbers in nums. Example 3: . Input: nums = [0,4,3,0,4] Output: 3 Explanation: There are 3 values that are greater than or equal to 3. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int specialArray(int[] nums) { int l = 0, u = nums.length; while(l &lt;= u){ int mid = (l + u)/2; int count = 0; for(int n : nums) if(n &gt;= mid) count++; if(mid == count) return mid; if(count &gt; mid) l = mid + 1; else u = mid - 1; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-420-Special%20Array%20With%20X%20Elements%20Greater%20Than%20or%20Equal%20X/",
    "relUrl": "/problem-420-Special Array With X Elements Greater Than or Equal X/"
  },"579": {
    "doc": "Contains Duplicate",
    "title": "Contains Duplicate",
    "content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: . Input: nums = [1,2,3,1] Output: true . Example 2: . Input: nums = [1,2,3,4] Output: false . Example 3: . Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -109 &lt;= nums[i] &lt;= 109 | . Solution . class Solution { public boolean containsDuplicate(int[] nums) { Set&lt;Integer&gt; set = new HashSet(); for(int i : nums){ if(set.contains(i)) return true; set.add(i); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-43-Contains-Duplicate/",
    "relUrl": "/problem-43-Contains-Duplicate/"
  },"580": {
    "doc": "Subsets",
    "title": "Subsets",
    "content": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: . Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] . Example 2: . Input: nums = [0] Output: [[],[0]] . Constraints: . | 1 &lt;= nums.length &lt;= 10 | -10 &lt;= nums[i] &lt;= 10 | All the numbers of nums are unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); process(nums, 0, ans, new ArrayList&lt;&gt;()); return ans; } public void process(int[] nums, int start, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; nums.length) return; ans.add(new ArrayList&lt;&gt;(list)); for(int i = start; i &lt; nums.length; i++){ list.add(nums[i]); process(nums, i + 1, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-43-Subsets/",
    "relUrl": "/problem-43-Subsets/"
  },"581": {
    "doc": "Contains Duplicate II",
    "title": "Contains Duplicate II",
    "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k. Example 1: . Input: nums = [1,2,3,1], k = 3 Output: true . Example 2: . Input: nums = [1,0,1,1], k = 1 Output: true . Example 3: . Input: nums = [1,2,3,1,2,3], k = 2 Output: false . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -109 &lt;= nums[i] &lt;= 109 | 0 &lt;= k &lt;= 105 | . Solution . class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt;nums.length; i++){ if(map.containsKey(nums[i])){ if(Math.abs(map.get(nums[i]) - i) &lt;= k) return true; } map.put(nums[i],i); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-44-Contains-Duplicate-II/",
    "relUrl": "/problem-44-Contains-Duplicate-II/"
  },"582": {
    "doc": "Word Search",
    "title": "Word Search",
    "content": "Given an m x n grid of characters board and a string word, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. Example 1: . Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" Output: true . Example 2: . Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\" Output: true . Example 3: . Input: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\" Output: false . Constraints: . | m == board.length | n = board[i].length | 1 &lt;= m, n &lt;= 6 | 1 &lt;= word.length &lt;= 15 | board and word consists of only lowercase and uppercase English letters. | . Follow up: Could you use search pruning to make your solution faster with a larger board? . Solution: . class Solution { public boolean exist(char[][] board, String word) { boolean[][] visited = new boolean[board.length][board[0].length]; for(int i = 0; i &lt; board.length; i++){ for(int j = 0; j &lt; board[0].length; j++){ if(search(board, i, j, 0, word.toCharArray(), visited)) return true; } } return false; } public boolean search(char[][] board, int i, int j, int index, char[] word, boolean[][] visited){ if(index &gt;= word.length) return true; if(board[i][j] != word[index]) return false; if(board[i][j] == word[index] &amp;&amp; index == word.length - 1) return true; if(i &lt; 0 || j &lt; 0 || i &gt;= board.length || j &gt;= board[0].length) return false; visited[i][j] = true; boolean status1, status2, status3, status4; status1 = status2 = status3 = status4 = false; if(i &gt; 0 &amp;&amp; !visited[i - 1][j]){ status1 = search(board, i - 1, j, index + 1, word, visited); visited[i - 1][j] = false; } if(j &gt; 0 &amp;&amp; !visited[i][j - 1]){ status2 = search(board, i, j - 1, index + 1, word, visited); visited[i][j - 1] = false; } if(i + 1 &lt; board.length &amp;&amp; !visited[i + 1][j]){ status3 = search(board, i + 1, j, index + 1, word, visited); visited[i + 1][j] = false; } if(j + 1&lt; board[0].length &amp;&amp; !visited[i][j + 1]){ status4 = search(board, i, j + 1, index + 1, word, visited); visited[i][j + 1] = false; } visited[i][j] = false; return status1 | status2 | status3 | status4; } } . ",
    "url": "https://1001anjan.github.io/problem-44-Word%20Search/",
    "relUrl": "/problem-44-Word Search/"
  },"583": {
    "doc": "Implement Stack using Queues",
    "title": "Implement Stack using Queues",
    "content": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: . | void push(int x) Pushes element x to the top of the stack. | int pop() Removes the element on the top of the stack and returns it. | int top() Returns the element on the top of the stack. | boolean empty() Returns true if the stack is empty, false otherwise. | . Notes: . You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. Example 1: . Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] . Explanation . MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, top, and empty. | All the calls to pop and top are valid. | . Follow-up: Can you implement the stack using only one queue? . Solution . ",
    "url": "https://1001anjan.github.io/problem-45-Implement-Stack-using-Queues/",
    "relUrl": "/problem-45-Implement-Stack-using-Queues/"
  },"584": {
    "doc": "Remove Duplicates from Sorted Array II",
    "title": "Remove Duplicates from Sorted Array II",
    "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 1 &lt;= nums.length &lt;= 3 * 10^4 | -10^4 &lt;= nums[i] &lt;= 10^4 | nums is sorted in non-decreasing order. | . Solution: . class Solution { public int removeDuplicates(int[] nums) { int i = 0; for(int n : nums){ if(i &lt; 2 || n &gt; nums[i - 2]){ nums[i++] = n; } } return i; } } . ",
    "url": "https://1001anjan.github.io/problem-45-Remove%20Duplicates%20from%20Sorted%20Array%20II/",
    "relUrl": "/problem-45-Remove Duplicates from Sorted Array II/"
  },"585": {
    "doc": "Invert Binary Tree",
    "title": "Invert Binary Tree",
    "content": "Given the root of a binary tree, invert the tree, and return its root. Example 1: . Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if(root == null) return root; TreeNode ptr; ptr = root.left; root.left = root.right; root.right = ptr; invertTree(root.left); invertTree(root.right); return root; } } . ",
    "url": "https://1001anjan.github.io/problem-46-Invert-Binary-Tree/",
    "relUrl": "/problem-46-Invert-Binary-Tree/"
  },"586": {
    "doc": "Search in Rotated Sorted Array II",
    "title": "Search in Rotated Sorted Array II",
    "content": "There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values). Before being passed to your function, nums is rotated at an unknown pivot index k (0 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4]. Given the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums. You must decrease the overall operation steps as much as possible. Example 1: . Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true . Example 2: . Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false . Constraints: . | 1 &lt;= nums.length &lt;= 5000 | -10^4 &lt;= nums[i] &lt;= 10^4 | nums is guaranteed to be rotated at some pivot. | -10^4 &lt;= target &lt;= 10^4 | . Solution: . class Solution { public boolean search(int[] nums, int target) { int start = 0, end = nums.length - 1, mid = -1; while(start &lt;= end) { mid = (start + end) / 2; if (nums[mid] == target) { return true; } //If we know for sure right side is sorted or left side is unsorted if (nums[mid] &lt; nums[end] || nums[mid] &lt; nums[start]) { if (target &gt; nums[mid] &amp;&amp; target &lt;= nums[end]) { start = mid + 1; } else { end = mid - 1; } //If we know for sure left side is sorted or right side is unsorted } else if (nums[mid] &gt; nums[start] || nums[mid] &gt; nums[end]) { if (target &lt; nums[mid] &amp;&amp; target &gt;= nums[start]) { end = mid - 1; } else { start = mid + 1; } //If we get here, that means nums[start] == nums[mid] == nums[end], then shifting out //any of the two sides won't change the result but can help remove duplicate from //consideration, here we just use end-- but left++ works too } else { end--; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-46-Search%20in%20Rotated%20Sorted%20Array%20II/",
    "relUrl": "/problem-46-Search in Rotated Sorted Array II/"
  },"587": {
    "doc": "Power of Two",
    "title": "Power of Two",
    "content": "Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. Example 1: . Input: n = 1 Output: true Explanation: 20 = 1 . Example 2: . Input: n = 16 Output: true Explanation: 24 = 16 . Example 3: . Input: n = 3 Output: false . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isPowerOfTwo(int n) { if(n == 1) return true; if(n == 0) return false; while(n&gt;=0){ if(n == 0) return true; if(n == 2) return true; if(n % 2 == 1) return false; n = n/2; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-47-Power-of-Two/",
    "relUrl": "/problem-47-Power-of-Two/"
  },"588": {
    "doc": "Remove Duplicates from Sorted List II",
    "title": "Remove Duplicates from Sorted List II",
    "content": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well. Example 1: . Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] . Example 2: . Input: head = [1,1,1,2,3] Output: [2,3] . Constraints: . | The number of nodes in the list is in the range [0, 300]. | -100 &lt;= Node.val &lt;= 100 | The list is guaranteed to be sorted in ascending order. | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next == null) return head; ListNode ptr = head, qtr = head.next; // deleting starting node while(ptr.val == qtr.val){ while(qtr != null &amp;&amp; ptr.val == qtr.val){ ListNode temp = qtr; qtr = qtr.next; temp.next = null; } if(qtr == null) return null; head = ptr = qtr; qtr = qtr.next; if(qtr == null) return head; } // checking remaining nodes ListNode prev = head; ptr = qtr; qtr = qtr.next; while(qtr != null){ if(ptr.val != qtr.val){ prev = ptr; ptr = qtr; qtr = qtr.next; }else{ while(qtr != null &amp;&amp; ptr.val == qtr.val){ ptr.next = ptr.next; qtr = qtr.next; } if(qtr == null){ prev.next = null; return head; } prev.next = qtr; ptr = qtr; qtr = qtr.next; } } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-47-Remove%20Duplicates%20from%20Sorted%20List%20II/",
    "relUrl": "/problem-47-Remove Duplicates from Sorted List II/"
  },"589": {
    "doc": "Palindrome Linked List",
    "title": "Palindrome Linked List",
    "content": "Given the head of a singly linked list, return true if it is a palindrome. Example 1: . Input: head = [1,2,2,1] Output: true . Example 2: . Input: head = [1,2] Output: false . Constraints: . | The number of nodes in the list is in the range [1, 105]. | 0 &lt;= Node.val &lt;= 9 | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode slow, fast; slow = fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } if(fast != null) slow = slow.next; slow = reverseList(slow); return compareList(head, slow); } public ListNode reverseList(ListNode head){ ListNode ptr = null, qtr; while(head != null){ qtr = ptr; ptr = head; head = head.next; ptr.next = qtr; } return ptr; } public boolean compareList(ListNode l1, ListNode l2){ while(l1 != null &amp;&amp; l2 != null){ if(l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; } // if(l1 != null || l2 != null) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-48-Palindrome-Linked-List/",
    "relUrl": "/problem-48-Palindrome-Linked-List/"
  },"590": {
    "doc": "Partition List",
    "title": "Partition List",
    "content": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x. You should preserve the original relative order of the nodes in each of the two partitions. Example 1: . Input: head = [1,4,3,2,5,2], x = 3 Output: [1,2,2,4,3,5] . Example 2: . Input: head = [2,1], x = 2 Output: [1,2] . Constraints: . | The number of nodes in the list is in the range [0, 200]. | -100 &lt;= Node.val &lt;= 100 | -200 &lt;= x &lt;= 200 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode partition(ListNode head, int x) { if(head == null || head.next == null) return head; ListNode left = new ListNode(), right = new ListNode(); ListNode ptr = left, qtr = right; while(head != null){ if(head.val &lt; x){ ptr.next = head; ptr = ptr.next; }else{ qtr.next = head; qtr = qtr.next; } head = head.next; } qtr.next = null; ptr.next = right.next; return left.next; } } . ",
    "url": "https://1001anjan.github.io/problem-48-Partition%20List/",
    "relUrl": "/problem-48-Partition List/"
  },"591": {
    "doc": "Gray Code",
    "title": "Gray Code",
    "content": "An n-bit gray code sequence is a sequence of 2n integers where: . | Every integer is in the inclusive range [0, 2n - 1], | The first integer is 0, | An integer appears no more than once in the sequence, | The binary representation of every pair of adjacent integers differs by exactly one bit, and | The binary representation of the first and last integers differs by exactly one bit. Given an integer n, return any valid n-bit gray code sequence. | . Example 1: . Input: n = 2 Output: [0,1,3,2] Explanation: The binary representation of [0,1,3,2] is [00,01,11,10]. - 00 and 01 differ by one bit - 01 and 11 differ by one bit - 11 and 10 differ by one bit - 10 and 00 differ by one bit [0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01]. - 00 and 10 differ by one bit - 10 and 11 differ by one bit - 11 and 01 differ by one bit - 01 and 00 differ by one bit . Example 2: . Input: n = 1 Output: [0,1] . Constraints: . | 1 &lt;= n &lt;= 16 | . Solution: . class Solution { public List&lt;Integer&gt; grayCode(int n) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 1 &lt;&lt; n; i++){ ans.add(i^(i &gt;&gt; 1)); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-49-Gray%20Code/",
    "relUrl": "/problem-49-Gray Code/"
  },"592": {
    "doc": "Lowest Common Ancestor of a Binary Search Tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” . Example 1: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: . Input: root = [2,1], p = 2, q = 1 Output: 2 . Constraints: . | The number of nodes in the tree is in the range [2, 105]. | -109 &lt;= Node.val &lt;= 109 | All Node.val are unique. | p != q | p and q will exist in the BST. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if ( p.val &lt; root.val &amp;&amp; q.val &lt; root.val ) return this.lowestCommonAncestor(root.left, p, q); if ( p.val &gt; root.val &amp;&amp; q.val &gt; root.val ) return this.lowestCommonAncestor(root.right, p, q); return root; } } . ",
    "url": "https://1001anjan.github.io/problem-49-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/",
    "relUrl": "/problem-49-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"
  },"593": {
    "doc": "Reverse Integer",
    "title": "Reverse Integer",
    "content": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Example 1: . Input: x = 123 Output: 321 . Example 2: . Input: x = -123 Output: -321 . Example 3: . Input: x = 120 Output: 21 . Constraints: . | -2^31 &lt;= x &lt;= 2^31 - 1 | . Solution: . class Solution { public int reverse(int x) { long rev = 0; while(x != 0){ rev = rev * 10 + x % 10; x = x / 10; } if(rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; return (int)rev; } } . class Solution { public int reverse(int x) { int rev =0; boolean neg = false; if(x&lt;0){ x = x*-1; neg = true; } while(x&gt;0){ if(rev&gt;Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE/10 &amp;&amp; x%10&gt;Integer.MAX_VALUE%10)) return 0; rev = rev*10 + x%10 ; x = x/10; } if(neg) return rev*-1; return rev; } } . ",
    "url": "https://1001anjan.github.io/problem-5-Reverse%20Integer/",
    "relUrl": "/problem-5-Reverse Integer/"
  },"594": {
    "doc": "Valid Parentheses",
    "title": "Valid Parentheses",
    "content": "Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’ and ‘]’, determine if the input string is valid. An input string is valid if: . | Open brackets must be closed by the same type of brackets. | Open brackets must be closed in the correct order. | . Example 1: . Input: s = \"()\" Output: true . Example 2: . Input: s = \"()[]{}\" Output: true . Example 3: . Input: s = \"(]\" Output: false . Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of parentheses only ‘()[]{}’. | . class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack(); for(int i = 0; i&lt;s.length(); i++){ if(s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '['){ stack.push(s.charAt(i)); }else{ if(stack.isEmpty()) return false; if(s.charAt(i) != getCorrospondingBracket(stack.pop())) return false; } } if(stack.isEmpty()) return true; return false; } private char getCorrospondingBracket(char c){ switch(c){ case '(': return ')'; case '{': return '}'; case '[': return ']'; default : return '*'; } } } . ",
    "url": "https://1001anjan.github.io/problem-5-valid-parentheses/",
    "relUrl": "/problem-5-valid-parentheses/"
  },"595": {
    "doc": "Delete Node in a Linked List",
    "title": "Delete Node in a Linked List",
    "content": "Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list. Example 1: . Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Constraints: . | The number of the nodes in the given list is in the range [2, 1000]. | -1000 &lt;= Node.val &lt;= 1000 | The value of each node in the list is unique. | The node to be deleted is in the list and is not a tail node | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { //We are not going to delete the given node //We will delete the node next to it //Because for deleting the given node we need its previous node //And will copy its value to the given node //Storing the vaue of the next node to the given node int nextNodeVal = node.next.val; //Then removing that next node node.next = node.next.next; //And simply copy the value node.val = nextNodeVal; } } . ",
    "url": "https://1001anjan.github.io/problem-50-Delete-Node-in-a-Linked-List/",
    "relUrl": "/problem-50-Delete-Node-in-a-Linked-List/"
  },"596": {
    "doc": "Subsets II",
    "title": "Subsets II",
    "content": "Given an integer array nums that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: . Input: nums = [1,2,2] Output: [[],[1],[1,2],[1,2,2],[2],[2,2]] . Example 2: . Input: nums = [0] Output: [[],[0]] . Constraints: . | 1 &lt;= nums.length &lt;= 10 | -10 &lt;= nums[i] &lt;= 10 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) { Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); process(nums, 0, ans, new ArrayList&lt;&gt;()); return ans; } public void process(int[] nums, int start, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; nums.length) return; ans.add(new ArrayList&lt;&gt;(list)); for(int i = start; i &lt; nums.length; i++){ if(i &gt; start &amp;&amp; nums[i - 1] == nums[i]) continue; list.add(nums[i]); process(nums, i + 1, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-50-Subsets%20II/",
    "relUrl": "/problem-50-Subsets II/"
  },"597": {
    "doc": "Subsets II",
    "title": "Decode Ways",
    "content": "A message containing letters from A-Z can be encoded into numbers using the following mapping: . 'A' -&gt; \"1\" 'B' -&gt; \"2\" ... 'Z' -&gt; \"26\" . To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, “11106” can be mapped into: . | “AAJF” with the grouping (1 1 10 6) | “KJF” with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because “06” cannot be mapped into ‘F’ since “6” is different from “06”. | . Given a string s containing only digits, return the number of ways to decode it. The test cases are generated so that the answer fits in a 32-bit integer. Example 1: . Input: s = \"12\" Output: 2 Explanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12). Example 2: . Input: s = \"226\" Output: 3 Explanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6). Example 3: . Input: s = \"06\" Output: 0 Explanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\"). Constraints: . | 1 &lt;= s.length &lt;= 100 | s contains only digits and may contain leading zero(s). | . Solution: . class Solution { public int numDecodings(String s) { int n = s.length(); int[] dp = new int[n + 1]; dp[n] = 1; dp[n - 1] = s.charAt(n - 1) == '0'? 0 : 1; for(int i = n - 2; i &gt;= 0; i--){ if(s.charAt(i) == '0') continue; dp[i] = Integer.parseInt(s.substring(i, i + 2)) &lt;= 26 ? dp[i + 1] + dp[i + 2] : dp[i + 1]; } return dp[0]; } } . ",
    "url": "https://1001anjan.github.io/problem-51-Decode%20Ways/#decode-ways",
    "relUrl": "/problem-51-Decode Ways/#decode-ways"
  },"598": {
    "doc": "Subsets II",
    "title": "Subsets II",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-51-Decode%20Ways/",
    "relUrl": "/problem-51-Decode Ways/"
  },"599": {
    "doc": "Valid Anagram",
    "title": "Valid Anagram",
    "content": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: . Input: s = \"anagram\", t = \"nagaram\" Output: true . Example 2: . Input: s = \"rat\", t = \"car\" Output: false . Constraints: . | 1 &lt;= s.length, t.length &lt;= 5 * 104 | s and t consist of lowercase English letters. | . Solution . class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; map1 = new HashMap&lt;Character, Integer&gt;(); Map&lt;Character, Integer&gt; map2 = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;s.length(); i++){ if(map1.containsKey(s.charAt(i))){ map1.put(s.charAt(i), map1.get(s.charAt(i))+1); }else{ map1.put(s.charAt(i), 1); } if(map2.containsKey(t.charAt(i))){ map2.put(t.charAt(i), map2.get(t.charAt(i))+1); }else{ map2.put(t.charAt(i), 1); } } for(Character ch : map1.keySet()){ if(!map2.containsKey(ch)) return false; if((int)map1.get(ch) != (int)map2.get(ch)) return false; } return true; } } . try using simple map or only using array . class Solution { public boolean isAnagram(String s, String t) { int[] arr = new int[26]; if(s.length() != t.length()) return false; for(char a: s.toCharArray()) arr[a - 'a']++; for(char b : t.toCharArray()) arr[b - 'a']--; for(int i : arr){ if(i &gt; 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-51-Valid-Anagram/",
    "relUrl": "/problem-51-Valid-Anagram/"
  },"600": {
    "doc": "Binary Tree Paths",
    "title": "Binary Tree Paths",
    "content": "Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Example 1: . Input: root = [1,2,3,null,5] Output: [\"1-&gt;2-&gt;5\",\"1-&gt;3\"] . Constraints: . | The number of nodes in the tree is in the range [1, 100]. | -100 &lt;= Node.val &lt;= 100 | . Solution . Non-recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class NodeMap{ public TreeNode head; public StringBuilder sb; NodeMap(TreeNode head, String val){ sb = new StringBuilder(val); this.head = head; } } class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stack&lt;NodeMap&gt; stack = new Stack&lt;NodeMap&gt;(); stack.push(new NodeMap(root, String.valueOf(root.val))); NodeMap nodeMap; while(!stack.isEmpty()){ nodeMap = stack.pop(); if(nodeMap.head.left == null &amp;&amp; nodeMap.head.right == null){ list.add(nodeMap.sb.toString().substring(0,nodeMap.sb.length())); } if(nodeMap.head.right != null){ stack.push(new NodeMap(nodeMap.head.right, nodeMap.sb.toString()+\"-&gt;\"+String.valueOf(nodeMap.head.right.val))); } if(nodeMap.head.left != null){ stack.push(new NodeMap(nodeMap.head.left, nodeMap.sb.toString()+\"-&gt;\"+String.valueOf(nodeMap.head.left.val))); } } return list; } } . Recursive . class Solution { List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) { helper(root, new StringBuilder()); return res; } public void helper(TreeNode node, StringBuilder sb) { if (node == null) return; int len = sb.length(); sb.append(node.val); if (node.left == null &amp;&amp; node.right == null) { res.add(sb.toString()); } else { sb.append(\"-&gt;\"); helper(node.left, sb); helper(node.right, sb); } // deleting the extra characters we added sb.setLength(len); } } . ",
    "url": "https://1001anjan.github.io/problem-52-Binary-Tree-Paths/",
    "relUrl": "/problem-52-Binary-Tree-Paths/"
  },"601": {
    "doc": "Reverse Linked List II",
    "title": "Reverse Linked List II",
    "content": "Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list. Example 1: . Input: head = [1,2,3,4,5], left = 2, right = 4 Output: [1,4,3,2,5] . Example 2: . Input: head = [5], left = 1, right = 1 Output: [5] . Constraints: . | The number of nodes in the list is n. | 1 &lt;= n &lt;= 500 | -500 &lt;= Node.val &lt;= 500 | 1 &lt;= left &lt;= right &lt;= n | . Follow up: Could you do it in one pass? . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { ListNode dummyHead = new ListNode(1000), ptr, lptr, rptr; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); dummyHead.next = head; ptr = dummyHead; // searching left node int count = 1; while(ptr.next != null &amp;&amp; count++ != left) ptr = ptr.next; if(ptr.next == null) return head; lptr = ptr; ptr = ptr.next; // searching right node while(ptr != null &amp;&amp; count++ != right + 1){ stack.push(ptr); ptr = ptr.next; } if(ptr == null) return head; stack.push(ptr); rptr = ptr.next; if(stack.size() == 1) return head; while(!stack.isEmpty()){ ptr = stack.pop(); lptr.next = ptr; lptr = ptr; } lptr.next = rptr; return dummyHead.next; } } . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseBetween(ListNode head, int left, int right) { ListNode dummyHead = new ListNode(1000), ptr, lptr, rptr, rev = null; dummyHead.next = head; ptr = dummyHead; for(int i = 0; i &lt; left - 1; i++, ptr = ptr.next); lptr = ptr; ptr = ptr.next; rptr = ptr; for(int i = left; i &lt;= right; i++){ ListNode qtr = ptr; ptr = ptr.next; qtr.next = rev; rev = qtr; } lptr.next = rev; rptr.next = ptr; return dummyHead.next; } } . ",
    "url": "https://1001anjan.github.io/problem-52-Reverse%20Linked%20List%20II/",
    "relUrl": "/problem-52-Reverse Linked List II/"
  },"602": {
    "doc": "Add Digits",
    "title": "Add Digits",
    "content": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it. Example 1: . Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. Example 2: . Input: num = 0 Output: 0 . Constraints: . | 0 &lt;= num &lt;= 231 - 1 | . Solution . class Solution { public int addDigits(int num) { if (num == 0) return 0; if (num % 9 == 0) return 9; return num % 9; } } . class Solution { public int addDigits(int num) { if(num&lt;10) return num; while(num&gt;9){ num = getNext(num); } return num; } public int getNext(int n){ int sum = 0; while(n&gt;0){ sum = sum + n%10; n = n/10; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-53-Add-Digits/",
    "relUrl": "/problem-53-Add-Digits/"
  },"603": {
    "doc": "Restore IP Addresses",
    "title": "Restore IP Addresses",
    "content": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros. | For example, “0.1.2.201” and “192.168.1.1” are valid IP addresses, but “0.011.255.245”, “192.168.1.312” and “192.168@1.1” are invalid IP addresses. Given a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order. | . Example 1: . Input: s = \"25525511135\" Output: [\"255.255.11.135\",\"255.255.111.35\"] . Example 2: . Input: s = \"0000\" Output: [\"0.0.0.0\"] . Example 3: . Input: s = \"101023\" Output: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"] . Constraints: . | 1 &lt;= s.length &lt;= 20 | s consists of digits only. | . Solution: . class Solution { public List&lt;String&gt; restoreIpAddresses(String s) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); processIp(s, 0, 0, ans, new String()); return ans; } public void processIp(String s, int start, int count, List&lt;String&gt; ans, String sb){ if(count &gt; 4) return; if(count == 4 &amp;&amp; s.length() == start) ans.add(sb); for(int i = 1; i &lt; 4; i++){ if(start + i &gt; s.length()) break; String str = s.substring(start, start + i); if(str.startsWith(\"0\") &amp;&amp; str.length() &gt; 1) continue; if(i == 3 &amp;&amp; Integer.parseInt(str) &gt; 255) continue; processIp(s, start + i, count + 1, ans, sb + str + (count == 3? \"\" : \".\")); } } } . class Solution { public List&lt;String&gt; restoreIpAddresses(String s) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); processIpAddress(s, 0, new String(), s.length(), 0, ans); return ans; } private void processIpAddress(String s, int start, String sb, int len, int dotCount, List&lt;String&gt; ans){ if(dotCount &gt; 4) return; if(dotCount == 4 &amp;&amp; start == len){ ans.add(sb); return; } for(int i = 1; i &lt; 4; i++){ if(start + i &gt; len) break; String str = s.substring(start, start + i); if(str.startsWith(\"0\") &amp;&amp; i &gt; 1) continue; if(i == 3 &amp;&amp; Integer.parseInt(str) &gt; 255) continue; if(dotCount &lt; 3) str = str + \".\"; processIpAddress(s, start + i, sb + str, len, dotCount + 1, ans); } } } . ",
    "url": "https://1001anjan.github.io/problem-53-Restore%20IP%20Addresses/",
    "relUrl": "/problem-53-Restore IP Addresses/"
  },"604": {
    "doc": "Ugly Number",
    "title": "Ugly Number",
    "content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: . Input: n = 6 Output: true Explanation: 6 = 2 × 3 . Example 2: . Input: n = 1 Output: true Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Example 3: . Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7. Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isUgly(int n) { if (n==0) return false; while (n!=1) { if (n%2==0) n=n/2; else if (n%3==0) n=n/3; else if (n%5==0) n=n/5; else return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-54-Ugly-Number/",
    "relUrl": "/problem-54-Ugly-Number/"
  },"605": {
    "doc": "Validate Binary Search Tree",
    "title": "Validate Binary Search Tree",
    "content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows: . | The left subtree of a node contains only nodes with keys less than the node’s key. | The right subtree of a node contains only nodes with keys greater than the node’s key. | Both the left and right subtrees must also be binary search trees. | . Example 1: . Input: root = [2,1,3] Output: true . Example 2: . Input: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node's value is 5 but its right child's value is 4. Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -2^31 &lt;= Node.val &lt;= 2^31 - 1 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isValidBST(TreeNode root) { return checkIsValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } public boolean checkIsValidBST(TreeNode root, long minVal, long maxVal){ if(root == null) return true; if(root.val &gt;= maxVal || root.val &lt;= minVal) return false; return checkIsValidBST(root.left, minVal, root.val) &amp; checkIsValidBST(root.right, root.val, maxVal); } } . ",
    "url": "https://1001anjan.github.io/problem-54-Validate%20Binary%20Search%20Tree/",
    "relUrl": "/problem-54-Validate Binary Search Tree/"
  },"606": {
    "doc": "Binary Tree Level Order Traversal",
    "title": "Binary Tree Level Order Traversal",
    "content": "Given the root of a binary tree, return the level order traversal of its nodes’ values. (i.e., from left to right, level by level). Example 1: . Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] . Example 2: . Input: root = [1] Output: [[1]] . Example 3: . Input: root = [] Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 2000]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); if(root == null) return ans; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); int count = 1; while(!queue.isEmpty()){ Queue&lt;TreeNode&gt; temp = new LinkedList&lt;&gt;(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int c = 0; while(count &gt; 0){ TreeNode n = queue.remove(); list.add(n.val); if(n.left != null){ c++; temp.offer(n.left); } if(n.right != null){ c++; temp.offer(n.right); } count--; } ans.add(list); count = c; queue = temp; } return ans; } } . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processLevelOrder(root, 0, ans); return ans; } public void processLevelOrder(TreeNode root, int level, List&lt;List&lt;Integer&gt;&gt; ans){ if(root == null) return; if(level == ans.size()){ ans.add(new ArrayList&lt;&gt;()); } ans.get(level).add(root.val); processLevelOrder(root.left, level + 1, ans); processLevelOrder(root.right, level + 1, ans); } } . ",
    "url": "https://1001anjan.github.io/problem-55-Binary%20Tree%20Level%20Order%20Traversal/",
    "relUrl": "/problem-55-Binary Tree Level Order Traversal/"
  },"607": {
    "doc": "Missing Number",
    "title": "Missing Number",
    "content": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: . Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: . Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: . Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: . | n == nums.length | 1 &lt;= n &lt;= 104 | 0 &lt;= nums[i] &lt;= n | All the numbers of nums are unique. | . Solution . ",
    "url": "https://1001anjan.github.io/problem-55-Missing-Number/",
    "relUrl": "/problem-55-Missing-Number/"
  },"608": {
    "doc": "Missing Number",
    "title": "Missing Number",
    "content": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: . Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: . Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: . Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: . | n == nums.length | 1 &lt;= n &lt;= 104 | 0 &lt;= nums[i] &lt;= n | All the numbers of nums are unique. | . Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? . Solution . class Solution { public int missingNumber(int[] nums) { int len=nums.length; int sum = len*(len+1)/2; for(int items:nums){ sum-=items; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-56-Missing-Number/",
    "relUrl": "/problem-56-Missing-Number/"
  },"609": {
    "doc": "Recover Binary Search Tree",
    "title": "Recover Binary Search Tree",
    "content": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure. Example 1: . Input: root = [1,3,null,null,2] Output: [3,1,null,null,2] Explanation: 3 cannot be a left child of 1 because 3 &gt; 1. Swapping 1 and 3 makes the BST valid. Example 2: . Input: root = [3,1,4,null,null,2] Output: [2,1,4,null,null,3] Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid. Constraints: . | The number of nodes in the tree is in the range [2, 1000]. | -2^31 &lt;= Node.val &lt;= 2^31 - 1 | . Follow up: A solution using O(n) space is pretty straight-forward. Could you devise a constant O(1) space solution? . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public void recoverTree(TreeNode root) { while(!processRecoverTree(root, Long.MIN_VALUE, Long.MAX_VALUE, null, null)); } public boolean processRecoverTree(TreeNode root, long min, long max, TreeNode minNode, TreeNode maxNode){ if(root == null) return true; if(root.val &gt; max){ int t = root.val; root.val = maxNode.val; maxNode.val = t; return false; } if(root.val &lt; min){ int t = root.val; root.val = minNode.val; minNode.val = t; return false; } return processRecoverTree(root.left, min, root.val, minNode, root) &amp; processRecoverTree(root.right, root.val, max, root, maxNode); } } . ",
    "url": "https://1001anjan.github.io/problem-56-Recover%20Binary%20Search%20Tree/",
    "relUrl": "/problem-56-Recover Binary Search Tree/"
  },"610": {
    "doc": "Binary Tree Level Order Traversal II",
    "title": "Binary Tree Level Order Traversal II",
    "content": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes’ values. (i.e., from left to right, level by level from leaf to root). Example 1: . Input: root = [3,9,20,null,null,15,7] Output: [[15,7],[9,20],[3]] . Example 2: . Input: root = [1] Output: [[1]] . Example 3: . Input: root = [] Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 2000]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) { LinkedList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;(); processLevelOderBotton(root,ans, 0); return ans; } public void processLevelOderBotton(TreeNode root, LinkedList&lt;List&lt;Integer&gt;&gt; ans, int level){ if(root == null) return; if(level == ans.size()){ ans.addFirst(new ArrayList&lt;&gt;()); } ans.get(ans.size() - level - 1).add(root.val); processLevelOderBotton(root.left, ans, level + 1); processLevelOderBotton(root.right, ans, level + 1); } } . ",
    "url": "https://1001anjan.github.io/problem-57-Binary%20Tree%20Level%20Order%20Traversal%20II/",
    "relUrl": "/problem-57-Binary Tree Level Order Traversal II/"
  },"611": {
    "doc": "Move Zeroes",
    "title": "Move Zeroes",
    "content": "Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: . Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] . Example 2: . Input: nums = [0] Output: [0] . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -231 &lt;= nums[i] &lt;= 231 - 1 | . Solution . Faster . class Solution { public void moveZeroes(int[] nums) { int cnt = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != 0) { if (i &gt; cnt) { nums[cnt] = nums[i]; } cnt++; } } while (cnt &lt; nums.length) { nums[cnt++] = 0; } } } . class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = 0; int temp; while(i&lt;nums.length &amp;&amp; j&lt;nums.length){ while(i&lt;nums.length &amp;&amp; nums[i] != 0) i++; j = i; while(j&lt;nums.length &amp;&amp; nums[j] == 0) j++; if(i&lt;nums.length &amp;&amp; j&lt;nums.length){ nums[i] = nums[j]; nums[j] = 0; } i++; } } } . without maintaining order . class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = nums.length - 1; int temp; while(i&lt;j){ while(i&lt;=j &amp;&amp; nums[i] != 0) i++; while(j&gt;=0 &amp;&amp; nums[j] == 0) j--; if(i&lt;nums.length-1 &amp;&amp; j&gt;=0){ temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; } } } } . ",
    "url": "https://1001anjan.github.io/problem-57-Move-Zeroes/",
    "relUrl": "/problem-57-Move-Zeroes/"
  },"612": {
    "doc": "Binary Tree Zigzag Level Order Traversal",
    "title": "Binary Tree Zigzag Level Order Traversal",
    "content": "Given the root of a binary tree, return the zigzag level order traversal of its nodes’ values. (i.e., from left to right, then right to left for the next level and alternate between). Example 1: . Input: root = [3,9,20,null,null,15,7] Output: [[3],[20,9],[15,7]] . Example 2: . Input: root = [1] Output: [[1]] . Example 3: . Input: root = [] Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 2000]. | -100 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processZigzagLevelOrder(root, ans, 0, true); return ans; } public void processZigzagLevelOrder(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, int level, boolean isLeftToRight){ if(root == null) return; if(level == ans.size()){ ans.add(new ArrayList&lt;&gt;()); } if(isLeftToRight){ ans.get(level).add(root.val); }else{ ans.get(level).add(0,root.val); } processZigzagLevelOrder(root.left, ans, level + 1, !isLeftToRight); processZigzagLevelOrder(root.right, ans, level + 1, !isLeftToRight); } } . ",
    "url": "https://1001anjan.github.io/problem-58-Binary%20Tree%20Zigzag%20Level%20Order%20Traversal/",
    "relUrl": "/problem-58-Binary Tree Zigzag Level Order Traversal/"
  },"613": {
    "doc": "Nim Game",
    "title": "Nim Game",
    "content": "You are playing the following Nim Game with your friend: . | Initially, there is a heap of stones on the table. | You and your friend will alternate taking turns, and you go first. | On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. | The one who removes the last stone is the winner. | Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. | . Example 1: . Input: n = 4 Output: false . Explanation: These are the possible outcomes: . | You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins. | You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins. | You remove 3 stones. Your friend removes the last stone. Your friend wins. In all outcomes, your friend wins. Example 2: . Input: n = 1 Output: true . Example 3: . Input: n = 2 Output: true . Constraints: . | 1 &lt;= n &lt;= 231 - 1 | . | . Solution . class Solution { public boolean canWinNim(int n) { return n%4 != 0; } } . ",
    "url": "https://1001anjan.github.io/problem-58-Nim-Game/",
    "relUrl": "/problem-58-Nim-Game/"
  },"614": {
    "doc": "Convert Sorted List to Binary Search Tree",
    "title": "Convert Sorted List to Binary Search Tree",
    "content": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree. Example 1: . Input: head = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST. Example 2: . Input: head = [] Output: [] . Constraints: . | The number of nodes in head is in the range [0, 2 * 104]. | -10^5 &lt;= Node.val &lt;= 10^5 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedListToBST(ListNode head) { return constractBST(head); } public TreeNode constractBST(ListNode head){ if(head == null) return null; if(head.next == null) return new TreeNode(head.val); ListNode slow, fast, pre; slow = fast = pre = head; while(fast != null &amp;&amp; fast.next != null){ pre = slow; slow = slow.next; fast = fast.next.next; } pre.next = null; TreeNode root = new TreeNode(slow.val); root.left = constractBST(head); root.right = constractBST(slow.next); return root; } } . ",
    "url": "https://1001anjan.github.io/problem-59-Convert%20Sorted%20List%20to%20Binary%20Search%20Tree/",
    "relUrl": "/problem-59-Convert Sorted List to Binary Search Tree/"
  },"615": {
    "doc": "Power of Three",
    "title": "Power of Three",
    "content": "Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: . Input: n = 27 Output: true . Example 2: . Input: n = 0 Output: false . Example 3: . Input: n = 9 Output: true . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . public class Solution { public boolean isPowerOfThree(int n) { if (n &lt; 1) { return false; } while (n % 3 == 0) { n /= 3; } return n == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-59-Power-of-Three/",
    "relUrl": "/problem-59-Power-of-Three/"
  },"616": {
    "doc": "Merge Two Sorted Lists",
    "title": "Merge Two Sorted Lists",
    "content": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: . Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] . Example 2: . Input: list1 = [], list2 = [] Output: [] . Example 3: . Input: list1 = [], list2 = [0] Output: [0] . Constraints: . | The number of nodes in both lists is in the range [0, 50]. | -100 &lt;= Node.val &lt;= 100 | Both list1 and list2 are sorted in non-decreasing order. | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if(list1 == null ) return list2; if(list2 == null ) return list1; ListNode res, ptr; // create first node if(list1.val &lt; list2.val){ res = list1; list1 = list1.next; }else{ res = list2; list2 = list2.next; } res.next = null; ptr = res; // process both lists while(list1 != null &amp;&amp; list2 != null){ if(list1.val &lt; list2.val){ ptr.next = list1; list1 = list1.next; }else{ ptr.next = list2; list2 = list2.next; } ptr = ptr.next; } // handle remaining elements if(list1 != null){ ptr.next = list1; } if(list2 != null){ ptr.next = list2; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-6-merge-two-sorted-lists/",
    "relUrl": "/problem-6-merge-two-sorted-lists/"
  },"617": {
    "doc": "String to Integer (atoi)",
    "title": "String to Integer (atoi)",
    "content": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++’s atoi function). The algorithm for myAtoi(string s) is as follows: . Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is ‘-‘ or ‘+’. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. “123” -&gt; 123, “0032” -&gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1. Return the integer as the final result. Note: . Only the space character ‘ ‘ is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1: . Input: s = \"42\" Output: 42 Explanation: The underlined characters are what is read in, the caret is the current reader position. Step 1: \"42\" (no characters read because there is no leading whitespace) ^ Step 2: \"42\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"42\" (\"42\" is read in) ^ The parsed integer is 42. Since 42 is in the range [-2^31, 2^31 - 1], the final result is 42. Example 2: . Input: s = \" -42\" Output: -42 Explanation: Step 1: \" -42\" (leading whitespace is read and ignored) ^ Step 2: \" -42\" ('-' is read, so the result should be negative) ^ Step 3: \" -42\" (\"42\" is read in) ^ The parsed integer is -42. Since -42 is in the range [-2^31, 2^31 - 1], the final result is -42. Example 3: . Input: s = \"4193 with words\" Output: 4193 Explanation: Step 1: \"4193 with words\" (no characters read because there is no leading whitespace) ^ Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit) ^ The parsed integer is 4193. Since 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193. Constraints: . | 0 &lt;= s.length &lt;= 200 | s consists of English letters (lower-case and upper-case), digits (0-9), ‘ ‘, ‘+’, ‘-‘, and ‘.’. | . Solution: . class Solution { public int myAtoi(String s) { int result = 0; int i = 0; int n = s.length() - 1; if(n &lt; 0) return 0; // ignore leading space while(i &lt;= n &amp;&amp; s.charAt(i) == ' ') i++; //ignore leading letter // while(i &lt;= n &amp;&amp; Character.isLetter(s.charAt(i))) i++; if(i &gt; n) return result; int sign = 1; if(s.charAt(i) == '-') { sign = -1; i++; }else if(s.charAt(i) == '+') i++; if(i &gt; n) return result; char ch = s.charAt(i); while(i &lt;= n &amp;&amp; Character.isDigit(ch)){ int d = ch - '0'; if(result &gt; Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 &amp;&amp; d &gt; Integer.MAX_VALUE%10)) { return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } result = result * 10 + d; i++; if(i &lt;= n ) ch = s.charAt(i); } return result * sign; } } . ",
    "url": "https://1001anjan.github.io/problem-6-String%20to%20Integer%20(atoi)/",
    "relUrl": "/problem-6-String to Integer (atoi)/"
  },"618": {
    "doc": "Path Sum II",
    "title": "Path Sum II",
    "content": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references. A root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children. Example 1: . Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 Output: [[5,4,11,2],[5,8,4,5]] Explanation: There are two paths whose sum equals targetSum: 5 + 4 + 11 + 2 = 22 5 + 8 + 4 + 5 = 22 . Example 2: . Input: root = [1,2,3], targetSum = 5 Output: [] . Example 3: . Input: root = [1,2], targetSum = 0 Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 5000]. | -1000 &lt;= Node.val &lt;= 1000 | -1000 &lt;= targetSum &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processPathSum(root, ans, 0, targetSum, new ArrayList&lt;&gt;()); return ans; } public void processPathSum(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, int sum, int target, List&lt;Integer&gt; list){ if(root == null) return; sum += root.val; list.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == target){ ans.add(list); return; } processPathSum(root.left, ans, sum, target, new ArrayList&lt;&gt;(list)); processPathSum(root.right, ans, sum, target, new ArrayList&lt;&gt;(list)); } } . Optimise memory allocation . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processPathSum(root, ans, 0, targetSum, new ArrayList&lt;&gt;()); return ans; } public void processPathSum(TreeNode root, List&lt;List&lt;Integer&gt;&gt; ans, int sum, int target, List&lt;Integer&gt; list){ if(root == null) return; sum += root.val; if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum == target){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(list); l.add(root.val); ans.add(new ArrayList&lt;&gt;(l)); return; } list.add(root.val); processPathSum(root.left, ans, sum, target, list); processPathSum(root.right, ans, sum, target, list); list.remove(list.size() - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-60-Path%20Sum%20II/",
    "relUrl": "/problem-60-Path Sum II/"
  },"619": {
    "doc": "Counting Bits",
    "title": "Counting Bits",
    "content": "Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i. Example 1: . Input: n = 2 Output: [0,1,1] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 . Example 2: . Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 3 --&gt; 11 4 --&gt; 100 5 --&gt; 101 . Constraints: . | 0 &lt;= n &lt;= 105 | . Solution . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; ans[0] = 0; for(int i = 1; i &lt;= n;i++){ ans[i] = (i &amp;1) + ans[i/2]; } return ans; } } . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; for(int i=0; i&lt;n+1; i++){ ans[i] = count(Integer.toBinaryString(i)); } return ans; } public int count(String s){ int c = 0; for(int i=0; i&lt;s.length(); i++) if(s.charAt(i) == '1') c++; return c; } } . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; int[] dp = new int[n+1]; for(int i=0; i&lt;=n; i++) dp[i] = -1; for (int i=0; i&lt;=n; i++) { ans[i] = bits(i, dp); } return ans; } int bits(int n, int[] dp) { if (n == 0) return 0; if (n == 1) return 1; if (dp[n] != -1) return dp[n]; int rem, quo; quo = n / 2; rem = n % 2; return dp[n] = (rem + bits(quo, dp)); } } . ",
    "url": "https://1001anjan.github.io/problem-60-Counting-Bits/",
    "relUrl": "/problem-60-Counting-Bits/"
  },"620": {
    "doc": "Flatten Binary Tree to Linked List",
    "title": "Flatten Binary Tree to Linked List",
    "content": "Given the root of a binary tree, flatten the tree into a “linked list”: . The “linked list” should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null. The “linked list” should be in the same order as a pre-order traversal of the binary tree. Example 1: . Input: root = [1,2,5,3,4,null,6] Output: [1,null,2,null,3,null,4,null,5,null,6] . Example 2: . Input: root = [] Output: [] . Example 3: . Input: root = [0] Output: [0] . Constraints: . | The number of nodes in the tree is in the range [0, 2000]. | -100 &lt;= Node.val &lt;= 100 | . Follow up: Can you flatten the tree in-place (with O(1) extra space)? . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { TreeNode prev = null; public void flatten(TreeNode root) { if(root == null) return; flatten(root.right); flatten(root.left); root.right = prev; root.left = null; prev = root; } } . ",
    "url": "https://1001anjan.github.io/problem-61-Flatten%20Binary%20Tree%20to%20Linked%20List/",
    "relUrl": "/problem-61-Flatten Binary Tree to Linked List/"
  },"621": {
    "doc": "Power of Four",
    "title": "Power of Four",
    "content": "Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x. Example 1: . Input: n = 16 Output: true . Example 2: . Input: n = 5 Output: false . Example 3: . Input: n = 1 Output: true . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isPowerOfFour(int n) { if(n == 0) return false; while(n &gt; 1){ if(n%4 != 0) return false; n = n/4; } return n == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-61-a-Power-of-Four/",
    "relUrl": "/problem-61-a-Power-of-Four/"
  },"622": {
    "doc": "Reverse String",
    "title": "Reverse String",
    "content": "Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: . Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] . Example 2: . Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] . Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is a printable ascii character. | . Solution . class Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; char ch; while(i&lt;=j){ ch = s[i]; s[i] = s[j]; s[j] = ch; i++; j--; } } } . ",
    "url": "https://1001anjan.github.io/problem-61-b-Reverse-String/",
    "relUrl": "/problem-61-b-Reverse-String/"
  },"623": {
    "doc": "Sum Root to Leaf Numbers",
    "title": "Sum Root to Leaf Numbers",
    "content": "You are given the root of a binary tree containing digits from 0 to 9 only. Each root-to-leaf path in the tree represents a number. | For example, the root-to-leaf path 1 -&gt; 2 -&gt; 3 represents the number 123. Return the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer. | . A leaf node is a node with no children. Example 1: . Input: root = [1,2,3] Output: 25 Explanation: The root-to-leaf path 1-&gt;2 represents the number 12. The root-to-leaf path 1-&gt;3 represents the number 13. Therefore, sum = 12 + 13 = 25. Example 2: . Input: root = [4,9,0,5,1] Output: 1026 Explanation: The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495. The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491. The root-to-leaf path 4-&gt;0 represents the number 40. Therefore, sum = 495 + 491 + 40 = 1026. Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | 0 &lt;= Node.val &lt;= 9 | The depth of the tree will not exceed 10. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int sumNumbers(TreeNode root) { return processSumNumbers(root, 0, 0); } public int processSumNumbers(TreeNode head, int total, int currSum){ if(head == null) return 0; if(head.left == null &amp;&amp; head.right == null){ total += currSum * 10 + head.val; return total; } currSum = currSum * 10 + head.val; int t1 = processSumNumbers(head.left, total, currSum); int t2 = processSumNumbers(head.right, total, currSum); currSum -= head.val; return t1 + t2; } } . ",
    "url": "https://1001anjan.github.io/problem-62-Sum%20Root%20to%20Leaf%20Numbers/",
    "relUrl": "/problem-62-Sum Root to Leaf Numbers/"
  },"624": {
    "doc": "Palindrome Partitioning",
    "title": "Palindrome Partitioning",
    "content": "Given a string s, partition s such that every substring of the partition is a palindrome . Return all possible palindrome partitioning of s. Example 1: . Input: s = \"aab\" Output: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]] . Example 2: . Input: s = \"a\" Output: [[\"a\"]] . Constraints: . | 1 &lt;= s.length &lt;= 16 | s contains only lowercase English letters. | . Solution: . class Solution { public List&lt;List&lt;String&gt;&gt; partition(String s) { List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); processPartition(s, 0, ans, new ArrayList&lt;&gt;()); return ans; } public void processPartition(String s, int start, List&lt;List&lt;String&gt;&gt; ans, List&lt;String&gt; list){ if(start &gt;= s.length() ){ ans.add(new ArrayList&lt;&gt;(list)); } for(int i = start; i &lt; s.length(); i++){ String str = s.substring(start, i + 1); if(isPalindrome(str.toCharArray())){ list.add(str); processPartition(s, i + 1, ans, list); list.remove(list.size() - 1); } } } public boolean isPalindrome(char[] str){ int s = 0, e = str.length - 1; while(s &lt; e){ if(str[s++] != str[e--]) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-63-Palindrome%20Partitioning/",
    "relUrl": "/problem-63-Palindrome Partitioning/"
  },"625": {
    "doc": "Reverse Vowels of a String",
    "title": "Reverse Vowels of a String",
    "content": "Given a string s, reverse only all the vowels in the string and return it. The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases. Example 1: . Input: s = \"hello\" Output: \"holle\" . Example 2: . Input: s = \"leetcode\" Output: \"leotcede\" . Constraints: . | 1 &lt;= s.length &lt;= 3 * 105 | s consist of printable ASCII characters. | . Solution . class Solution { public String reverseVowels(String s) { char[] str = new char[s.length()]; str = s.toCharArray(); int i = 0; int j = s.length() - 1; char ch; while(i&lt;j){ while(i&lt;j &amp;&amp; !isVowel(str[i])) i++; while(i&lt;j &amp;&amp; !isVowel(str[j])) j--; if(i&lt;j){ ch = str[i]; str[i] = str[j]; str[j] = ch; i++; j--; } } return String.valueOf(str); } public boolean isVowel(char ch){ if(ch == 'A' || ch =='a' || ch == 'e' || ch == 'E' || ch == 'I' || ch =='i' || ch == 'O' || ch == 'o' || ch == 'u' || ch == 'U') return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-64-Reverse-Vowels-of-a-String/",
    "relUrl": "/problem-64-Reverse-Vowels-of-a-String/"
  },"626": {
    "doc": "Sort List",
    "title": "Sort List",
    "content": "Given the head of a linked list, return the list after sorting it in ascending order. Example 1: . Input: head = [4,2,1,3] Output: [1,2,3,4] . Example 2: . Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] . Example 3: . Input: head = [] Output: [] . Constraints: . | The number of nodes in the list is in the range [0, 5 * 10^4]. | -10^5 &lt;= Node.val &lt;= 10^5 | . Follow up: Can you sort the linked list in O(n logn) time and O(1) memory (i.e. constant space)? . Solution: . O(n*n) complexity . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null) return head; ListNode ptr = head, sortedList = null, qtr; while(ptr != null){ qtr = ptr; ptr = ptr.next; sortedList = insertSortedList(sortedList, qtr); } return sortedList; } public ListNode insertSortedList(ListNode list, ListNode node){ if(list == null){ list = node; list.next = null; return list; } // inserting as first node if(list.val &gt;= node.val){ node.next = list; list = node; return list; } // inserting to middle ListNode ptr = list; while(ptr.next != null){ if(ptr.next.val &gt; node.val){ node.next = ptr.next; ptr.next = node; return list; } ptr = ptr.next; } // inserting as end node ptr.next = node; node.next = null; return list; } } . Merge sort . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode sortList(ListNode head) { if(head == null || head.next == null) return head; ListNode slow = head, fast = head, prev = head; while(fast != null &amp;&amp; fast.next != null){ prev = slow; slow = slow.next; fast = fast.next.next; } prev.next = null; ListNode l1 = sortList(head); ListNode l2 = sortList(slow); return mergeList(l1, l2); } public ListNode mergeList(ListNode l1, ListNode l2){ ListNode dummyHead = new ListNode(), ptr= dummyHead; while(l1 != null &amp;&amp; l2 != null){ if(l1.val &lt; l2.val){ ptr.next = l1; l1 = l1.next; }else{ ptr.next = l2; l2 = l2.next; } ptr = ptr.next; } if(l1 != null){ ptr.next = l1; } if(l2 != null){ ptr.next = l2; } return dummyHead.next; } } . ",
    "url": "https://1001anjan.github.io/problem-64-Sort%20List/",
    "relUrl": "/problem-64-Sort List/"
  },"627": {
    "doc": "Insertion Sort List",
    "title": "Insertion Sort List",
    "content": "Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list’s head. The steps of the insertion sort algorithm: . Insertion sort iterates, consuming one input element each repetition and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there. It repeats until no input elements remain. The following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration. Example 1: . Input: head = [4,2,1,3] Output: [1,2,3,4] . Example 2: . Input: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] . Constraints: . | The number of nodes in the list is in the range [1, 5000]. | -5000 &lt;= Node.val &lt;= 5000 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode insertionSortList(ListNode head) { if(head == null || head.next == null) return head; ListNode ptr = head, sortedList = null, qtr; while(ptr != null){ qtr = ptr; ptr = ptr.next; sortedList = insertSortedList(sortedList, qtr); } return sortedList; } public ListNode insertSortedList(ListNode list, ListNode node){ if(list == null){ list = node; list.next = null; return list; } // inserting as first node if(list.val &gt;= node.val){ node.next = list; list = node; return list; } // inserting to middle ListNode ptr = list; while(ptr.next != null){ if(ptr.next.val &gt; node.val){ node.next = ptr.next; ptr.next = node; return list; } ptr = ptr.next; } // inserting as end node ptr.next = node; node.next = null; return list; } } . ",
    "url": "https://1001anjan.github.io/problem-65-Insertion%20Sort%20List/",
    "relUrl": "/problem-65-Insertion Sort List/"
  },"628": {
    "doc": "Intersection of Two Arrays",
    "title": "Intersection of Two Arrays",
    "content": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1: . Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] . Example 2: . Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution . class Solution { public int[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) { int [] output = new int[set1.size()]; int idx = 0; for (Integer s : set1) if (set2.contains(s)) output[idx++] = s; return Arrays.copyOf(output, idx); } public int[] intersection(int[] nums1, int[] nums2) { HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); for (Integer n : nums1) set1.add(n); HashSet&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for (Integer n : nums2) set2.add(n); if (set1.size() &lt; set2.size()) return set_intersection(set1, set2); else return set_intersection(set2, set1); } } . ",
    "url": "https://1001anjan.github.io/problem-65-Intersection-of-Two-Arrays/",
    "relUrl": "/problem-65-Intersection-of-Two-Arrays/"
  },"629": {
    "doc": "Find Peak Element",
    "title": "Find Peak Element",
    "content": "A peak element is an element that is strictly greater than its neighbors. Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks. You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array. You must write an algorithm that runs in O(log n) time. #####Example 1: . Input: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2: . Input: nums = [1,2,1,3,5,6,4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -2^31 &lt;= nums[i] &lt;= 2^31 - 1 | nums[i] != nums[i + 1] for all valid i. | . Solution: . class Solution { public int findPeakElement(int[] nums) { if(nums.length == 1) return 0; int prev = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length - 1; i++){ if(nums[i] &gt; prev &amp;&amp; nums[i] &gt; nums[i + 1]) return i; prev = nums[i]; } if(nums[nums.length - 2] &lt; nums[nums.length - 1]) return nums.length - 1; throw null; } } . class Solution { public int findPeakElement(int[] nums) { if (nums == null || nums.length == 1) return 0; int start = 0; int end = nums.length - 1; while (start + 1 &lt; end) { int mid = start + (end - start) / 2; if (mid - 1 &gt;= 0 &amp;&amp; mid + 1 &lt; nums.length){ if (nums[mid - 1] &lt; nums[mid] &amp;&amp; nums[mid + 1] &lt; nums[mid]) return mid; if (nums[mid] &lt; nums[mid - 1]) end = mid; else start = mid; } } if (nums[start] &gt; nums[end]) return start; if (nums[end] &gt; nums[start]) return end; return 0; } } . ",
    "url": "https://1001anjan.github.io/problem-66-Find%20Peak%20Element/",
    "relUrl": "/problem-66-Find Peak Element/"
  },"630": {
    "doc": "Intersection of Two Arrays II",
    "title": "Intersection of Two Arrays II",
    "content": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. Example 1: . Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] . Example 2: . Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution . class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int i = 0; int j = 0; int[] ans = new int[Math.min(nums1.length, nums2.length)]; int k = 0; while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length){ if(nums1[i] == nums2[j]){ ans[k] = nums1[i]; k++; i++; j++; }else if(nums1[i]&gt;nums2[j]) j++; else i++; } return Arrays.copyOf(ans,k); } } . ",
    "url": "https://1001anjan.github.io/problem-66-Intersection-of-Two-Arrays-II/",
    "relUrl": "/problem-66-Intersection-of-Two-Arrays-II/"
  },"631": {
    "doc": "Two Sum II - Input Array Is Sorted",
    "title": "Two Sum II - Input Array Is Sorted",
    "content": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length. Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2. The tests are generated such that there is exactly one solution. You may not use the same element twice. Your solution must use only constant extra space. Example 1: . Input: numbers = [2,7,11,15], target = 9 Output: [1,2] Explanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2]. Example 2: . Input: numbers = [2,3,4], target = 6 Output: [1,3] Explanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3]. Example 3: . Input: numbers = [-1,0], target = -1 Output: [1,2] Explanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2]. Constraints: . | 2 &lt;= numbers.length &lt;= 3 * 10^4 | -1000 &lt;= numbers[i] &lt;= 1000 | numbers is sorted in non-decreasing order. | -1000 &lt;= target &lt;= 1000 | The tests are generated such that there is exactly one solution. | . Solution: . class Solution { public int[] twoSum(int[] numbers, int target) { int i = 0, j = numbers.length - 1; while(i &lt; j){ if(numbers[i] + numbers[j] == target){ return new int[]{i + 1,j + 1}; } if(numbers[i] + numbers[j] &gt; target){ j --; }else{ i ++; } } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-67-Two%20Sum%20II%20-%20Input%20Array%20Is%20Sorted/",
    "relUrl": "/problem-67-Two Sum II - Input Array Is Sorted/"
  },"632": {
    "doc": "Valid Perfect Square",
    "title": "Valid Perfect Square",
    "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False. Follow up: Do not use any built-in library function such as sqrt. Example 1: . Input: num = 16 Output: true . Example 2: . Input: num = 14 Output: false . Constraints: . | 1 &lt;= num &lt;= 2^31 - 1 | . Solution . class Solution { public boolean isPerfectSquare(int num) { int start = 0; int end = num; if(num == 1) return true; while (start &lt;= end){ long mid = start + (end - start)/2; if(mid * mid == num) return true; if(num &gt; mid * mid) start = (int)mid + 1; if(num &lt; mid * mid) end = (int)mid - 1; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-67-Valid-Perfect-Square/",
    "relUrl": "/problem-67-Valid-Perfect-Square/"
  },"633": {
    "doc": "Min Stack",
    "title": "Min Stack",
    "content": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: . | MinStack() initializes the stack object. | void push(int val) pushes the element val onto the stack. | void pop() removes the element on the top of the stack. | int top() gets the top element of the stack. | int getMin() retrieves the minimum element in the stack. | You must implement a solution with O(1) time complexity for each function. | . Example 1: . Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 . Constraints: . | -2^31 &lt;= val &lt;= 2^31 - 1 | Methods pop, top and getMin operations will always be called on non-empty stacks. | At most 3 * 10^4 calls will be made to push, pop, top, and getMin. | . Solution: . class MinStack { Stack&lt;Integer[]&gt; stack; public MinStack() { stack = new Stack&lt;&gt;(); } public void push(int val) { if(stack.isEmpty()){ stack.push(new Integer[]{val, val}); }else{ stack.push(new Integer[]{val, Math.min(val, getMin())}); } } public void pop() { stack.pop(); } public int top() { return stack.peek()[0]; } public int getMin() { return stack.peek()[1]; } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ . class MinStack { private Node head; public void push(int x) { if (head == null) head = new Node(x, x, null); else head = new Node(x, Math.min(x, head.min), head); } public void pop() { head = head.next; } public int top() { return head.val; } public int getMin() { return head.min; } private class Node { int val; int min; Node next; private Node(int val, int min, Node next) { this.val = val; this.min = min; this.next = next; } } } . ",
    "url": "https://1001anjan.github.io/problem-68-Min%20Stack/",
    "relUrl": "/problem-68-Min Stack/"
  },"634": {
    "doc": "Guess Number Higher or Lower",
    "title": "Guess Number Higher or Lower",
    "content": "We are playing the Guess Game. The game is as follows: . I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: . | -1: Your guess is higher than the number I picked (i.e. num &gt; pick). | 1: Your guess is lower than the number I picked (i.e. num &lt; pick). | 0: your guess is equal to the number I picked (i.e. num == pick). | Return the number that I picked. | . Example 1: . Input: n = 10, pick = 6 Output: 6 . Example 2: . Input: n = 1, pick = 1 Output: 1 . Example 3: . Input: n = 2, pick = 1 Output: 1 . Constraints: . | 1 &lt;= n &lt;= 231 - 1 | 1 &lt;= pick &lt;= n | . Solution . Binary search . /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is higher than the picked number * 1 if num is lower than the picked number * otherwise return 0 * int guess(int num); */ public class Solution extends GuessGame { public int guessNumber(int n) { int s = 1; int e = n; int r; int mid = -1; while(true){ mid = (s+e)/2; r = guess(mid); if(r == 0) break;; if(r == 1){ s = mid+1; }else{ e = mid-1; } } return mid; } } . Ternary Search . ",
    "url": "https://1001anjan.github.io/problem-68-Guess-Number-Higher-or-Lower/",
    "relUrl": "/problem-68-Guess-Number-Higher-or-Lower/"
  },"635": {
    "doc": "Maximum Product Subarray",
    "title": "Maximum Product Subarray",
    "content": "Given an integer array nums, find a subarray that has the largest product, and return the product. The test cases are generated so that the answer will fit in a 32-bit integer. Example 1: . Input: nums = [2,3,-2,4] Output: 6 Explanation: [2,3] has the largest product 6. Example 2: . Input: nums = [-2,0,-1] Output: 0 Explanation: The result cannot be 2, because [-2,-1] is not a subarray. Constraints: . | 1 &lt;= nums.length &lt;= 2 * 10^4 | -10 &lt;= nums[i] &lt;= 10 | The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer. | . Solution: . class Solution { public int maxProduct(int[] nums) { int max = 1; int min = 1; int oldMax = 1; int ans = Integer.MIN_VALUE; for(int i = 0; i &lt; nums.length; i++){ max = Math.max(max * nums[i], Math.max(nums[i], min * nums[i])); min = Math.min(min * nums[i], Math.min(nums[i], oldMax * nums[i])); oldMax = max; ans = Math.max(ans, max); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-69-Maximum%20Product%20Subarray/",
    "relUrl": "/problem-69-Maximum Product Subarray/"
  },"636": {
    "doc": "Ransom Note",
    "title": "Ransom Note",
    "content": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. Example 1: . Input: ransomNote = \"a\", magazine = \"b\" Output: false . Example 2: . Input: ransomNote = \"aa\", magazine = \"ab\" Output: false . Example 3: . Input: ransomNote = \"aa\", magazine = \"aab\" Output: true . Constraints: . | 1 &lt;= ransomNote.length, magazine.length &lt;= 105 | ransomNote and magazine consist of lowercase English letters. | . Solution . class Solution { public boolean canConstruct(String ransomNote, String magazine) { if(ransomNote.length()&gt;magazine.length()) return false; Map&lt;Character,Integer&gt; m1 = new HashMap&lt;Character, Integer&gt;(); Map&lt;Character,Integer&gt; m2 = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt;ransomNote.length(); i++){ if(m1.containsKey(ransomNote.charAt(i))){ m1.put(ransomNote.charAt(i),(int)m1.get(ransomNote.charAt(i))+1); }else{ m1.put(ransomNote.charAt(i),1); } } for(int i = 0; i &lt;magazine.length(); i++){ if(m2.containsKey(magazine.charAt(i))){ m2.put(magazine.charAt(i),(int)m2.get(magazine.charAt(i))+1); }else{ m2.put(magazine.charAt(i),1); } } for(Map.Entry&lt;Character,Integer&gt; e : m1.entrySet()){ if(!m2.containsKey(e.getKey())) return false; else if((int)e.getValue() &gt; (int)m2.get(e.getKey())) return false; } return true; } } . Faster Solution . class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count=new int[26]; for(int i=0;i&lt;magazine.length();i++){ char ch=magazine.charAt(i); count[ch-'a']++; } for(int i=0;i&lt;ransomNote.length();i++){ char ch=ransomNote.charAt(i); if(--count[ch-'a']&lt;0){ return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-69-Ransom-Note/",
    "relUrl": "/problem-69-Ransom-Note/"
  },"637": {
    "doc": "Container With Most Water",
    "title": "Container With Most Water",
    "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example 1: . Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: . Input: height = [1,1] Output: 1 . Constraints: . | n == height.length | 2 &lt;= n &lt;= 10^5 | 0 &lt;= height[i] &lt;= 10^4 | . Solution: . class Solution { public int maxArea(int[] height) { int max = 0, s = 0, e = height.length - 1; while( s &lt; e){ int h; if(height[s] &gt; height[e]){ h = height[e]; max = Math.max(max, h * (e - s)); e--; }else{ h = height[s]; max = Math.max(max, h * (e - s)); s++; } } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-7-Container%20With%20Most%20Water/",
    "relUrl": "/problem-7-Container With Most Water/"
  },"638": {
    "doc": "Remove Duplicates from Sorted Array",
    "title": "Remove Duplicates from Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 1 &lt;= nums.length &lt;= 3 * 104 | -100 &lt;= nums[i] &lt;= 100 | nums is sorted in non-decreasing order. | . Solution . class Solution { public int removeDuplicates(int[] nums) { int i = 0; for(int j = 1; j&lt;nums.length; j++){ if(nums[j-1] == nums[j]) continue; nums[++i] = nums[j]; } return i+1; } } . ",
    "url": "https://1001anjan.github.io/problem-7-remove-duplicates-from-sorted-array/",
    "relUrl": "/problem-7-remove-duplicates-from-sorted-array/"
  },"639": {
    "doc": "First Unique Character in a String",
    "title": "First Unique Character in a String",
    "content": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Example 1: . Input: s = \"leetcode\" Output: 0 . Example 2: . Input: s = \"loveleetcode\" Output: 2 . Example 3: . Input: s = \"aabb\" Output: -1 . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of only lowercase English letters. | . Solution . class Solution { public int firstUniqChar(String s) { Map&lt;Character,Integer&gt; m = new HashMap&lt;Character,Integer&gt;(); for(int i=0; i&lt;s.length(); i++){ if(m.containsKey(s.charAt(i))) m.put(s.charAt(i),(int)m.get(s.charAt(i))+1); else m.put(s.charAt(i),1); } for(int i=0; i&lt;s.length(); i++){ if((int)m.get(s.charAt(i)) == 1) return i; } return -1; } } . Without hashMap . class Solution { public int firstUniqChar(String s) { int[] count = new int[26]; int n = s.length(); // build char count bucket : &lt;charIndex, count&gt; for (int i = 0; i &lt; n; i++) { int index = s.charAt(i) - 'a'; count[index]++; } // find the index for (int i = 0; i &lt; n; i++) { int index = s.charAt(i) - 'a'; if (count[index] == 1) { return i; } } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-70-First-Unique-Character-in-a-String/",
    "relUrl": "/problem-70-First-Unique-Character-in-a-String/"
  },"640": {
    "doc": "Reverse Words in a String",
    "title": "Reverse Words in a String",
    "content": "Given an input string s, reverse the order of the words. A word is defined as a sequence of non-space characters. The words in s will be separated by at least one space. Return a string of the words in reverse order concatenated by a single space. Note that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces. Example 1: . Input: s = \"the sky is blue\" Output: \"blue is sky the\" . Example 2: . Input: s = \" hello world \" Output: \"world hello\" Explanation: Your reversed string should not contain leading or trailing spaces. Example 3: . Input: s = \"a good example\" Output: \"example good a\" Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. Constraints: . | 1 &lt;= s.length &lt;= 10^4 | s contains English letters (upper-case and lower-case), digits, and spaces ‘ ‘. | There is at least one word in s. | . Follow-up: If the string data type is mutable in your language, can you solve it in-place with O(1) extra space? . Solution: . class Solution { public String reverseWords(String s) { String[] strs = s.trim().split(\"\\\\s+\"); StringBuilder sb = new StringBuilder(); for(int i = strs.length - 1; i &gt;= 0; i--){ sb.append(strs[i]).append(\" \"); } return sb.substring(0, sb.length() - 1).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-70-Reverse%20Words%20in%20a%20String/",
    "relUrl": "/problem-70-Reverse Words in a String/"
  },"641": {
    "doc": "Compare Version Numbers",
    "title": "Compare Version Numbers",
    "content": "Given two version numbers, version1 and version2, compare them. Version numbers consist of one or more revisions joined by a dot ‘.’. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers. To compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 &lt; 1. Return the following: . | If version1 &lt; version2, return -1. | If version1 &gt; version2, return 1. | Otherwise, return 0. | . Example 1: . Input: version1 = \"1.01\", version2 = \"1.001\" Output: 0 Explanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\". Example 2: . Input: version1 = \"1.0\", version2 = \"1.0.0\" Output: 0 Explanation: version1 does not specify revision 2, which means it is treated as \"0\". Example 3: . Input: version1 = \"0.1\", version2 = \"1.1\" Output: -1 Explanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 &lt; 1, so version1 &lt; version2. Constraints: . | 1 &lt;= version1.length, version2.length &lt;= 500 | version1 and version2 only contain digits and ‘.’. | version1 and version2 are valid version numbers. | All the given revisions in version1 and version2 can be stored in a 32-bit integer. | . Solution: . class Solution { public int compareVersion(String version1, String version2) { int m = version1.length(); int n = version2.length(); char[] v1 = version1.toCharArray(); char[] v2 = version2.toCharArray(); int i = 0, j = 0; while(i &lt; m || j &lt; n){ while(i &lt; m &amp;&amp; v1[i] == '0') i++; int value1 = 0; while(i &lt; m &amp;&amp; v1[i] != '.') value1 = value1*10 + (v1[i++] - '0'); while(j &lt; n &amp;&amp; v2[j] == '0') j++; int value2 = 0; while(j &lt; n &amp;&amp; v2[j] != '.') value2 = value2*10 + (v2[j++] - '0'); if(value1 &gt; value2) return 1; else if(value1 &lt; value2) return -1; i++; j++; } return 0; } } . ",
    "url": "https://1001anjan.github.io/problem-71-Compare%20Version%20Numbers/",
    "relUrl": "/problem-71-Compare Version Numbers/"
  },"642": {
    "doc": "Find the Difference",
    "title": "Find the Difference",
    "content": "You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. Example 1: . Input: s = \"abcd\", t = \"abcde\" Output: \"e\" Explanation: 'e' is the letter that was added. Example 2: . Input: s = \"\", t = \"y\" Output: \"y\" . Constraints: . | 0 &lt;= s.length &lt;= 1000 | t.length == s.length + 1 | s and t consist of lowercase English letters. | . Solution . class Solution { public char findTheDifference(String s, String t) { int ch[] = new int[26]; for(int i=0; i&lt;t.length(); i++){ ch[t.charAt(i) - 'a']++; } for(int i=0; i&lt;s.length(); i++){ ch[s.charAt(i) - 'a']--; } for(int i = 0; i&lt;26; i++){ if(ch[i] == 1) return (char)('a'+i); } return '1'; } } . Using XOR . class Solution { public char findTheDifference(String s, String t) { char res = 0; for(char ch: s.toCharArray()) { res ^= ch; } for(char ch: t.toCharArray()) { res ^= ch; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-71-Find-the-Difference/",
    "relUrl": "/problem-71-Find-the-Difference/"
  },"643": {
    "doc": "Find Minimum in Rotated Sorted Array",
    "title": "Find Minimum in Rotated Sorted Array",
    "content": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become: . | [4,5,6,7,0,1,2] if it was rotated 4 times. | [0,1,2,4,5,6,7] if it was rotated 7 times. | Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]]. | . Given the sorted rotated array nums of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time. Example 1: . Input: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2: . Input: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3: . Input: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. Constraints: . | n == nums.length | 1 &lt;= n &lt;= 5000 | -5000 &lt;= nums[i] &lt;= 5000 | All the integers of nums are unique. | nums is sorted and rotated between 1 and n times. | . Solution: . class Solution { public int findMin(int[] nums) { int s = 0, e = nums.length - 1; if(nums.length == 2) return nums[0] &lt; nums[1]? nums[0] : nums[1]; while(s &lt;= e){ if(e - s == 1) return nums[s] &lt; nums[e]? nums[s] : nums[e]; int mid = (s + e)/2; if(s == e) return nums[s]; if(mid == 0 || mid == nums.length - 1) return nums[mid]; if(nums[mid] &lt; nums[mid - 1] &amp;&amp; nums[mid] &lt; nums[mid + 1]) return nums[mid]; if(nums[s] &gt; nums[e]){ if(nums[mid] &gt; nums[s] &amp;&amp; nums[mid] &gt; nums[e]){ s = mid + 1; }else{ e = mid - -1; } }else{ if(nums[mid] &gt; nums[s] &amp;&amp; nums[mid] &lt; nums[e]){ e = mid - 1; }else{ s = mid + 1; } } } throw null; } } . class Solution { public int findMin(int[] nums) { int lo = 0, hi = nums.length - 1; while (lo &lt; hi) { int mid = (lo + hi) / 2; if (nums[mid] &lt; nums[hi]) { hi = mid; } else { lo = mid + 1; } } return nums[lo]; } } . ",
    "url": "https://1001anjan.github.io/problem-72-Find%20Minimum%20in%20Rotated%20Sorted%20Array/",
    "relUrl": "/problem-72-Find Minimum in Rotated Sorted Array/"
  },"644": {
    "doc": "Is Subsequence",
    "title": "Is Subsequence",
    "content": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not). Example 1: . Input: s = \"abc\", t = \"ahbgdc\" Output: true . Example 2: . Input: s = \"axc\", t = \"ahbgdc\" Output: false . Constraints: . | 0 &lt;= s.length &lt;= 100 | 0 &lt;= t.length &lt;= 104 | s and t consist only of lowercase English letters. | . Solution: . class Solution { public boolean isSubsequence(String s, String t) { int k = 0; int l = s.length(); if(l == 0) return true; for(int i = 0; i &lt; t.length(); i++){ if(t.charAt(i) == s.charAt(k)) k++; if(k == l) return true; } if(k &gt;= l) return true; return false; } } . class Solution { public boolean isSubsequence(String s, String t) { int i = 0, j = 0; int sLength = s.length(); int tLength = t.length(); while(i &lt; sLength &amp;&amp; j &lt; tLength){ if(s.charAt(i) == t.charAt(j)){ i++; } j++; } return i == sLength; } } . ",
    "url": "https://1001anjan.github.io/problem-72-Is-Subsequence/",
    "relUrl": "/problem-72-Is-Subsequence/"
  },"645": {
    "doc": "Reorder List",
    "title": "Reorder List",
    "content": "You are given the head of a singly linked-list. The list can be represented as: . L0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form: . L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list’s nodes. Only nodes themselves may be changed. Example 1: . Input: head = [1,2,3,4] Output: [1,4,2,3] . Example 2: . Input: head = [1,2,3,4,5] Output: [1,5,2,4,3] . Constraints: . | The number of nodes in the list is in the range [1, 5 * 10^4]. | 1 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public void reorderList(ListNode head) { if(head == null || head.next == null) return; // finding middle of the list 1-&gt;2-&gt;3-&gt;4-&gt;5 =&gt; 1-&gt;2 3-&gt;4-&gt;5 ListNode slow = head, fast = head, prev = head; while(fast != null &amp;&amp; fast.next != null){ prev = slow; slow = slow.next; fast = fast.next.next; } prev.next = null; // reverse the middle list 1-&gt;2 5-&gt;4-&gt;3 ListNode revList = null, ptr, qtr; while(slow != null){ ptr = slow.next; slow.next = revList; revList = slow; slow = ptr; } // reoder the list ptr = head; while(ptr.next != null){ qtr = revList.next; revList.next = ptr.next; ptr.next = revList; slow = ptr.next; ptr = ptr.next.next; revList = qtr; } ptr.next = revList; } } . ",
    "url": "https://1001anjan.github.io/problem-73-Reorder%20List/",
    "relUrl": "/problem-73-Reorder List/"
  },"646": {
    "doc": "Sum of Left Leaves",
    "title": "Sum of Left Leaves",
    "content": "Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of another node. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 24 Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2: . Input: root = [1] Output: 0 . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class NodeMap{ public TreeNode head; public char f; NodeMap(TreeNode t, char c){ head = t; f = c; } } class Solution { public int sumOfLeftLeaves(TreeNode root) { Stack&lt;NodeMap&gt; s = new Stack&lt;NodeMap&gt;(); NodeMap m = new NodeMap(root,'*'); s.push(m); int sum = 0; NodeMap t; while(!s.isEmpty()){ t = s.pop(); if(t.f == 'L' &amp;&amp; t.head.left == null &amp;&amp; t.head.right == null) sum = sum + t.head.val; if(t.head.left != null ) s.push(new NodeMap(t.head.left, 'L')); if(t.head.right != null) s.push(new NodeMap(t.head.right, 'R')); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-73-Sum-of-Left-Leaves/",
    "relUrl": "/problem-73-Sum-of-Left-Leaves/"
  },"647": {
    "doc": "Convert a Number to Hexadecimal",
    "title": "Convert a Number to Hexadecimal",
    "content": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself. Note: You are not allowed to use any built-in library method to directly solve this problem. Example 1: . Input: num = 26 Output: \"1a\" . Example 2: . Input: num = -1 Output: \"ffffffff\" . Constraints: . | -231 &lt;= num &lt;= 231 - 1 | . Solution: . class Solution { public String toHex(int num) { return Integer.toHexString(num); } } . ",
    "url": "https://1001anjan.github.io/problem-74-Convert-a-Number-to-Hexadecimal/",
    "relUrl": "/problem-74-Convert-a-Number-to-Hexadecimal/"
  },"648": {
    "doc": "Linked List Cycle II",
    "title": "Linked List Cycle II",
    "content": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter. Do not modify the linked list. Example 1: . Input: head = [3,2,0,-4], pos = 1 Output: tail connects to node index 1 Explanation: There is a cycle in the linked list, where tail connects to the second node. Example 2: . Input: head = [1,2], pos = 0 Output: tail connects to node index 0 Explanation: There is a cycle in the linked list, where tail connects to the first node. Example 3: . Input: head = [1], pos = -1 Output: no cycle Explanation: There is no cycle in the linked list. Constraints: . | The number of the nodes in the list is in the range [0, 10^4]. | -10^5 &lt;= Node.val &lt;= 10^5 | pos is -1 or a valid index in the linked-list. | . Follow up: Can you solve it using O(1) (i.e. constant) memory? . /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode detectCycle(ListNode head) { ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; if(slow == fast){ ListNode ptr = head; while(ptr != slow){ ptr = ptr.next; slow = slow.next; } return ptr; } } return null; } } . ",
    "url": "https://1001anjan.github.io/problem-74-Linked%20List%20Cycle%20II/",
    "relUrl": "/problem-74-Linked List Cycle II/"
  },"649": {
    "doc": "Longest Palindrome",
    "title": "Longest Palindrome",
    "content": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, “Aa” is not considered a palindrome here. Example 1: . Input: s = \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. Example 2: . Input: s = \"a\" Output: 1 . Example 3: . Input: s = \"bb\" Output: 2 . Constraints: . | 1 &lt;= s.length &lt;= 2000 | s consists of lowercase and/or uppercase English letters only. | . Solution . class Solution { public int longestPalindrome(String s) { Map&lt;Character, Integer&gt; m = new HashMap&lt;Character,Integer&gt;(); for(int i = 0; i&lt;s.length(); i++){ m.put(s.charAt(i), m.getOrDefault(s.charAt(i),0)+1); } int a = 0; for(int i : m.values()){ if(i%2 == 0){ a = a + i; }else if(i&gt;1){ a += i - 1; } } if(s.length() &gt; a) return a+1; return a; } } . Faster approach . class Solution { public int longestPalindrome(String s) { int[] count = new int[128]; for (char c: s.toCharArray()) count[c]++; int ans = 0; for (int v: count) { ans += v / 2 * 2; if (ans % 2 == 0 &amp;&amp; v % 2 == 1) ans++; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-75-Longest-Palindrome/",
    "relUrl": "/problem-75-Longest-Palindrome/"
  },"650": {
    "doc": "Populating Next Right Pointers in Each Node",
    "title": "Populating Next Right Pointers in Each Node",
    "content": "You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition: . struct Node { int val; Node *left; Node *right; Node *next; } . Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: . Input: root = [1,2,3,4,5,6,7] Output: [1,#,2,3,#,4,5,6,7,#] Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. #####Example 2: . Input: root = [] Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 212 - 1]. | -1000 &lt;= Node.val &lt;= 1000 | . Follow-up: . | You may only use constant extra space. | The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem. | . Solution: . /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { Node levelNode = root; while(levelNode != null){ Node ptr = levelNode; while(ptr != null){ if(ptr.left != null) ptr.left.next = ptr.right; if(ptr.right != null &amp;&amp; ptr.next != null) ptr.right.next = ptr.next.left; ptr = ptr.next; } levelNode = levelNode.left; } return root; } } . ",
    "url": "https://1001anjan.github.io/problem-75-Populating%20Next%20Right%20Pointers%20in%20Each%20Node/",
    "relUrl": "/problem-75-Populating Next Right Pointers in Each Node/"
  },"651": {
    "doc": "Populating Next Right Pointers in Each Node II",
    "title": "Populating Next Right Pointers in Each Node II",
    "content": "Given a binary tree . struct Node { int val; Node *left; Node *right; Node *next; } . Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Example 1: . Input: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level. Example 2: . Input: root = [] Output: [] . Constraints: . | The number of nodes in the tree is in the range [0, 6000]. | -100 &lt;= Node.val &lt;= 100 | . Follow-up: . | You may only use constant extra space. | The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem. | . Solution: . /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { Node levelNode = root; while(levelNode != null){ Node currNode = levelNode; while(currNode != null){ // connecting left node if(currNode.left != null){ if(currNode.right != null){ currNode.left.next = currNode.right; }else{ Node ptr = currNode.next; while(ptr != null){ if(ptr.left != null){ currNode.left.next = ptr.left; break; } if(ptr.right != null){ currNode.left.next = ptr.right; break; } ptr = ptr.next; } } } // connecting right node if(currNode.right != null &amp;&amp; currNode.next != null){ Node ptr = currNode.next; while(ptr != null){ if(ptr.left != null){ currNode.right.next = ptr.left; break; } if(ptr.right != null){ currNode.right.next = ptr.right; break; } ptr = ptr.next; } } // pointing next node in same level currNode = currNode.next; } // finding next level node while(levelNode != null &amp;&amp; levelNode.left == null &amp;&amp; levelNode.right == null) levelNode = levelNode.next; if(levelNode != null &amp;&amp; levelNode.left != null) levelNode = levelNode.left; else if(levelNode != null &amp;&amp; levelNode.right != null) levelNode = levelNode.right; } return root; } } . ",
    "url": "https://1001anjan.github.io/problem-76-Populating%20Next%20Right%20Pointers%20in%20Each%20Node%20II/",
    "relUrl": "/problem-76-Populating Next Right Pointers in Each Node II/"
  },"652": {
    "doc": "Third Maximum Number",
    "title": "Third Maximum Number",
    "content": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number. Example 1: . Input: nums = [3,2,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2. The third distinct maximum is 1. Example 2: . Input: nums = [1,2] Output: 2 Explanation: The first distinct maximum is 2. The second distinct maximum is 1. The third distinct maximum does not exist, so the maximum (2) is returned instead. Example 3: . Input: nums = [2,2,3,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2 (both 2's are counted together since they have the same value). The third distinct maximum is 1. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -231 &lt;= nums[i] &lt;= 231 - 1 | . Solution: . class Solution { public int thirdMax(int[] nums) { long max = Long.MIN_VALUE; long secondMax = max; long thirdMax = secondMax; for(int i = 0 ;i&lt;nums.length;i++){ if(nums[i]&gt;max){ thirdMax = secondMax; secondMax = max; max = nums[i]; } else if(nums[i]&lt;max &amp;&amp; nums[i]&gt;secondMax){ thirdMax = secondMax; secondMax = nums[i]; } else if(nums[i]&lt;secondMax &amp;&amp; nums[i]&gt;thirdMax){ thirdMax = nums[i]; } } return thirdMax==Long.MIN_VALUE ? (int) max : (int) thirdMax; } } . ",
    "url": "https://1001anjan.github.io/problem-76-Third-Maximum-Number/",
    "relUrl": "/problem-76-Third-Maximum-Number/"
  },"653": {
    "doc": "Add Strings",
    "title": "Add Strings",
    "content": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1: . Input: num1 = \"11\", num2 = \"123\" Output: \"134\" . Example 2: . Input: num1 = \"456\", num2 = \"77\" Output: \"533\" . Example 3: . Input: num1 = \"0\", num2 = \"0\" Output: \"0\" . Constraints: . | 1 &lt;= num1.length, num2.length &lt;= 104 | num1 and num2 consist of only digits. | num1 and num2 don’t have any leading zeros except for the zero itself. | . Solution: . class Solution { public String addStrings(String num1, String num2) { int c = 0; int v; int i = num1.length() - 1; int j = num2.length() - 1; StringBuilder sb = new StringBuilder(); while(i&gt;=0 &amp;&amp; j&gt;=0){ v = (num1.charAt(i) -48 + num2.charAt(j) -48 + c)%10; c = (num1.charAt(i) -48 + num2.charAt(j) -48 + c)/10; sb.append(v); i--; j--; } while(i&gt;=0){ v = (num1.charAt(i) -48 + c)%10; c = (num1.charAt(i) -48 + c)/10; sb.append(v); i--; } while(j&gt;=0){ v = (num2.charAt(j) -48 + c)%10; c = (num2.charAt(j) -48 + c)/10; sb.append(v); j--; } if(c&gt;=1) sb.append(c); return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-77-Add-Strings/",
    "relUrl": "/problem-77-Add-Strings/"
  },"654": {
    "doc": "Evaluate Reverse Polish Notation",
    "title": "Evaluate Reverse Polish Notation",
    "content": "Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are +, -, *, and /. Each operand may be an integer or another expression. Note that division between two integers should truncate toward zero. It is guaranteed that the given RPN expression is always valid. That means the expression would always evaluate to a result, and there will not be any division by zero operation. Example 1: . Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] Output: 9 Explanation: ((2 + 1) * 3) = 9 . Example 2: . Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] Output: 6 Explanation: (4 + (13 / 5)) = 6 . Example 3: . Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22 . Constraints: . | 1 &lt;= tokens.length &lt;= 10^4 | tokens[i] is either an operator: “+”, “-“, “*”, or “/”, or an integer in the range [-200, 200]. | . Solution: . class Solution { public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); for(String str : tokens){ switch(str){ case \"+\" : s.push(s.pop() + s.pop()); break; case \"-\" : int a = s.pop(); int b = s.pop(); s.push(b - a); break; case \"*\" : s.push(s.pop() * s.pop()); break; case \"/\" : a = s.pop(); b = s.pop(); s.push(b/a); break; default : s.push(Integer.parseInt(str)); } } return s.pop(); } } . ",
    "url": "https://1001anjan.github.io/problem-77-Evaluate%20Reverse%20Polish%20Notation/",
    "relUrl": "/problem-77-Evaluate Reverse Polish Notation/"
  },"655": {
    "doc": "Number of Segments in a String",
    "title": "Number of Segments in a String",
    "content": "Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters. Example 1: . Input: s = \"Hello, my name is John\" Output: 5 Explanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"] . Example 2: . Input: s = \"Hello\" Output: 1 . Constraints: . | 0 &lt;= s.length &lt;= 300 | s consists of lowercase and uppercase English letters, digits, or one of the following characters “!@#$%^&amp;*()_+-=’,.:”. | The only space character in s is ‘ ‘. | . Solution . class Solution { public int countSegments(String s) { if(s.length() == 0) return 0; String[] ar = s.split(\" \"); int len = ar.length; for(String st : ar){ if(st.length() == 0) len--; } return len; } } . ",
    "url": "https://1001anjan.github.io/problem-78-Number-of-Segments-in-a-String/",
    "relUrl": "/problem-78-Number-of-Segments-in-a-String/"
  },"656": {
    "doc": "Surrounded Regions",
    "title": "Surrounded Regions",
    "content": "Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’. A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region. Example 1: . Input: board = [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Output: [[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]] Explanation: Notice that an 'O' should not be flipped if: - It is on the border, or - It is adjacent to an 'O' that should not be flipped. The bottom 'O' is on the border, so it is not flipped. The other three 'O' form a surrounded region, so they are flipped. Example 2: . Input: board = [[\"X\"]] Output: [[\"X\"]] . Constraints: . | m == board.length | n == board[i].length | 1 &lt;= m, n &lt;= 200 | board[i][j] is ‘X’ or ‘O’. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-78-Surrounded%20Regions/",
    "relUrl": "/problem-78-Surrounded Regions/"
  },"657": {
    "doc": "Find All Numbers Disappeared in an Array",
    "title": "Find All Numbers Disappeared in an Array",
    "content": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Example 1: . Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] . Example 2: . Input: nums = [1,1] Output: [2] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 105 | 1 &lt;= nums[i] &lt;= n | . Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Solution: . class Solution { public List findDisappearedNumbers(int[] arr) { int i = 0; List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); while(i&lt;arr.length){ if(arr[i] == -1){ i++; continue; } if(arr[arr[i] -1] == -1){ i++; continue; }else if(arr[i] == i+1){ arr[i] = -1; i++; } else{ int t = arr[arr[i]-1]; arr[arr[i] -1] = -1; arr[i] = t; } } for(int k = 0; k&lt;arr.length; k++){ if(arr[k] != -1){ l.add(k+1); } } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-79-Find-All-Numbers-Disappeared-in-an-Array/",
    "relUrl": "/problem-79-Find-All-Numbers-Disappeared-in-an-Array/"
  },"658": {
    "doc": "LRU Cache",
    "title": "LRU Cache",
    "content": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement the LRUCache class: . | LRUCache(int capacity) Initialize the LRU cache with positive size capacity. | int get(int key) Return the value of the key if the key exists, otherwise return -1. | void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity. | . Example 1: . Input [\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4] Explanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4 . Constraints: . | 1 &lt;= capacity &lt;= 3000 | 0 &lt;= key &lt;= 10^4 | 0 &lt;= value &lt;= 10^5 | At most 2 * 105 calls will be made to get and put. | . Solution: . Time Limits exceeds . class LRUCache { Map&lt;Integer, Integer&gt; map; LinkedList&lt;Integer&gt; list ; int capacity; public LRUCache(int capacity) { map = new HashMap&lt;&gt;(); list = new LinkedList&lt;&gt;(); this.capacity = capacity; } public int get(int key) { Integer k = map.get(key); if(k == null) return -1; list.remove(new Integer(key)); list.addFirst(key); return k; } public void put(int key, int value) { if(get(key) == -1){ if(map.size() == capacity){ map.remove(list.removeLast()); } } else{ list.remove(new Integer(key)); } list.addFirst(key); map.put(key, value); } } /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ . using doubly linkedList . import java.util.HashMap; import java.util.Map; class LRUCache { private static class Node{ int key; int value; Node next; Node prev; Node(){} Node(int k, int v, Node n, Node p){ key = k; value = v; next = n; prev = p; } } private Map&lt;Integer, Node&gt; map; private Node head; private Node tail; private int capacity; public LRUCache(int capacity) { map = new HashMap&lt;&gt;(); head = tail = null; this.capacity = capacity; } public int get(int key) { Node node = map.get(key); if(node == null) return -1; moveNodeToBegining(node); return node.value; } public void put(int key, int value) { Node node = map.get(key); if(node != null){ node.value = value; moveNodeToBegining(node); }else{ node = new Node(key, value, null, null); addNode(node); if(capacity &lt; map.size()) removeNode(); } } private void addNode(Node node){ if(head == null &amp;&amp; tail == null){ head = tail = node; map.put(node.key, node); return; } node.next = head; head.prev = node; node.prev = null; head = node; map.put(node.key, node); } private void removeNode(){ if(head == tail &amp;&amp; head != null){ head = tail = null; return; } Node node = tail; tail = tail.prev; tail.next = null; map.remove(node.key); } private void moveNodeToBegining(Node node){ if(node == head) return; if(tail == node) tail = tail.prev; node.prev.next = node.next; if(node.next != null )node.next.prev = node.prev; node.next = head; head.prev = node; node.prev = null; head = node; } } . ",
    "url": "https://1001anjan.github.io/problem-79-LRU%20Cache/",
    "relUrl": "/problem-79-LRU Cache/"
  },"659": {
    "doc": "Integer to Roman",
    "title": "Integer to Roman",
    "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 . For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: . | I can be placed before V (5) and X (10) to make 4 and 9. | X can be placed before L (50) and C (100) to make 40 and 90. | C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. | . Example 1: . Input: num = 3 Output: \"III\" Explanation: 3 is represented as 3 ones. Example 2: . Input: num = 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 3: . Input: num = 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: . | 1 &lt;= num &lt;= 3999 | . Solution: . class Solution { public String intToRoman(int num) { StringBuilder sb = new StringBuilder(); // Comparator for sotring decending order TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;((a,b)-&gt;(b - a)); tm.put(1000,\"M\"); tm.put(900,\"CM\"); tm.put(500,\"D\"); tm.put(400,\"CD\"); tm.put(100,\"C\"); tm.put(90,\"XC\"); tm.put(50,\"L\"); tm.put(40,\"XL\"); tm.put(10,\"X\"); tm.put(9,\"IX\"); tm.put(5,\"V\"); tm.put(4,\"IV\"); tm.put(1,\"I\"); for(Map.Entry&lt;Integer,String&gt; entry : tm.entrySet()){ int key = entry.getKey(); while(num &gt;= key){ sb.append(entry.getValue()); num -= key; } } return sb.toString(); } } . class Solution { public static String intToRoman(int num) { String M[] = {\"\", \"M\", \"MM\", \"MMM\"}; String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}; String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}; return new StringBuilder() .append(M[num/1000]) .append(C[(num%1000)/100]) .append(X[(num%100)/10]) .append(I[num%10]).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-8-Integer%20to%20Roman/",
    "relUrl": "/problem-8-Integer to Roman/"
  },"660": {
    "doc": "Remove Element",
    "title": "Remove Element",
    "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i &lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 0 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 50 | 0 &lt;= val &lt;= 100 | . Solution . class Solution { public int removeElement(int[] nums, int val) { int i = 0; for(int j = 0; j&lt;nums.length; j++){ if(nums[j] == val) continue; nums[i++] = nums[j]; } return i; } } . ",
    "url": "https://1001anjan.github.io/problem-8-remove-element/",
    "relUrl": "/problem-8-remove-element/"
  },"661": {
    "doc": "Assign Cookies",
    "title": "Assign Cookies",
    "content": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Example 1: . Input: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2: . Input: g = [1,2], s = [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Constraints: . | 1 &lt;= g.length &lt;= 3 * 104 | 0 &lt;= s.length &lt;= 3 * 104 | 1 &lt;= g[i], s[j] &lt;= 231 - 1 | . Solution . class Solution { public int findContentChildren(int[] g, int[] s) { int c = 0; Arrays.sort(g); Arrays.sort(s); int k = 0; for(int i = 0; i&lt;s.length; i++){ if(k&lt;g.length &amp;&amp; g[k]&lt;=s[i]){ c++; k++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-80-Assign-Cookies/",
    "relUrl": "/problem-80-Assign-Cookies/"
  },"662": {
    "doc": "Unique Binary Search Trees II",
    "title": "Unique Binary Search Trees II",
    "content": "Given an integer n, return all the structurally unique BST’s (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order. Example 1: . Input: n = 3 Output: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]] . Example 2: . Input: n = 1 Output: [[1]] . Constraints: . | 1 &lt;= n &lt;= 8 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;TreeNode&gt; generateTrees(int n) { List&lt;TreeNode&gt;[] dp = new ArrayList[n + 1]; // base case dp[0] = new ArrayList&lt;&gt;(); dp[0].add(null); dp[1] = new ArrayList&lt;&gt;(); dp[1].add(new TreeNode(1)); // process dp for target number for(int i = 2; i &lt;= n; i++){ dp[i] = new ArrayList&lt;&gt;(); for(int j = 1; j &lt;= i; j++){ for(TreeNode leftNode : dp[j - 1]){ for(TreeNode rightNode : dp[i - j]){ TreeNode newNode = new TreeNode(j); newNode.left = leftNode; newNode.right = clone(rightNode, j); dp[i].add(newNode); } } } } return dp[n]; } static TreeNode clone(TreeNode node, int offset){ if(node == null) return null; TreeNode newNode = new TreeNode(node.val + offset); newNode.left = clone(node.left, offset); newNode.right = clone(node.right, offset); return newNode; } } . ",
    "url": "https://1001anjan.github.io/problem-80-Unique%20Binary%20Search%20Trees%20II/",
    "relUrl": "/problem-80-Unique Binary Search Trees II/"
  },"663": {
    "doc": "Hamming Distance",
    "title": "Hamming Distance",
    "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, return the Hamming distance between them. Example 1: . Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Example 2: . Input: x = 3, y = 1 Output: 1 . Constraints: . | 0 &lt;= x, y &lt;= 231 - 1 | . Solution . class Solution { public int hammingDistance(int x, int y) { int r = x ^ y; int c = 0; while(r&gt;0){ c = c + r%2; r = r/2; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-81-Hamming-Distance/",
    "relUrl": "/problem-81-Hamming-Distance/"
  },"664": {
    "doc": "Unique Binary Search Trees",
    "title": "Unique Binary Search Trees",
    "content": "Given an integer n, return the number of structurally unique BST’s (binary search trees) which has exactly n nodes of unique values from 1 to n. Example 1: . Input: n = 3 Output: 5 . Example 2: . Input: n = 1 Output: 1 . Constraints: . | 1 &lt;= n &lt;= 19 | . Solution: . class Solution { public int numTrees(int n) { int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; for(int i = 2; i &lt;= n; i++){ for(int j = 1; j &lt;= i; j++){ dp[i] += dp[j - 1] * dp[i - j]; } } return dp[n]; } } . ",
    "url": "https://1001anjan.github.io/problem-81-Unique%20Binary%20Search%20Trees/",
    "relUrl": "/problem-81-Unique Binary Search Trees/"
  },"665": {
    "doc": "Island Perimeter",
    "title": "Island Perimeter",
    "content": "You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example 1: . Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Explanation: The perimeter is the 16 yellow stripes in the image above. Example 2: . Input: grid = [[1]] Output: 4 . Example 3: . Input: grid = [[1,0]] Output: 4 . Constraints: . | row == grid.length | col == grid[i].length | 1 &lt;= row, col &lt;= 100 | grid[i][j] is 0 or 1. | There is exactly one island in grid. | . Solution . class Solution { public int islandPerimeter(int[][] grid) { int p = 0; for(int i = 0; i&lt;grid.length; i++){ for(int j = 0 ; j&lt;grid[0].length; j++){ if(grid[i][j] == 1){ if(i == 0) p++; if(j == 0) p++; if(i == grid.length - 1) p++; if(j == grid[0].length -1) p++; if(i&gt;0 &amp;&amp; grid[i-1][j] == 0) p++; if(i+1&lt;grid.length &amp;&amp; grid[i+1][j] == 0) p++; if(j&gt;0 &amp;&amp; grid[i][j-1] == 0) p++; if(j+1&lt;grid[0].length &amp;&amp; grid[i][j+1] == 0) p++; } } } return p; } } . ",
    "url": "https://1001anjan.github.io/problem-82-Island%20Perimeter/",
    "relUrl": "/problem-82-Island Perimeter/"
  },"666": {
    "doc": "Triangle",
    "title": "Triangle",
    "content": "Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row. Example 1: . Input: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] Output: 11 Explanation: The triangle looks like: 2 3 4 6 5 7 4 1 8 3 The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above). Example 2: . Input: triangle = [[-10]] Output: -10 . Constraints: . | 1 &lt;= triangle.length &lt;= 200 | triangle[0].length == 1 | triangle[i].length == triangle[i - 1].length + 1 | -10^4 &lt;= triangle[i][j] &lt;= 10^4 | . Follow up: Could you do this using only O(n) extra space, where n is the total number of rows in the triangle? . Solution: . Time Limit Exceeded . class Solution { int min = Integer.MAX_VALUE; public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { processTriangle(triangle, 0, 0, 0); return min; } public void processTriangle(List&lt;List&lt;Integer&gt;&gt; triangle, int pos, int sum, int level){ if(level &gt; triangle.size()) return; if(level == triangle.size()){ if(sum &lt; min) min = sum; return; } List&lt;Integer&gt; l = triangle.get(level); if(pos &lt; l.size()){ processTriangle(triangle, pos, sum + l.get(pos), level + 1); } if(pos + 1 &lt; l.size()){ processTriangle(triangle, pos + 1, sum + l.get(pos + 1), level + 1); } } } . Dynamic programming: . class Solution { public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) { int m = triangle.size(); // buttom row List&lt;Integer&gt; list = triangle.get(m - 1); int n = list.size(); int[] dp = new int[n]; // initializing buttom row for(int i = 0; i &lt; n ; i++) dp[i] = list.get(i); // processing dp for(int i = m - 2; i &gt;= 0; i--){ list = triangle.get(i); for(int j = 0; j &lt;= i; j++){ int v = list.get(j); dp[j] = Math.min(v + dp[j], v + dp[j + 1]); } } return dp[0]; } } . ",
    "url": "https://1001anjan.github.io/problem-82-Triangle/",
    "relUrl": "/problem-82-Triangle/"
  },"667": {
    "doc": "Best Time to Buy and Sell Stock II",
    "title": "Best Time to Buy and Sell Stock II",
    "content": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day. On each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day. Find and return the maximum profit you can achieve. Example 1: . Input: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2: . Input: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3: . Input: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. Constraints: . | 1 &lt;= prices.length &lt;= 3 * 10^4 | 0 &lt;= prices[i] &lt;= 10^4 | . Solution: . class Solution { public int maxProfit(int[] prices) { int profit = 0; if(prices.length == 1) return 0; int prevPrice = prices[0]; for(int i = 1; i &lt; prices.length; i++){ if(prices[i] &gt; prevPrice){ profit += prices[i] - prevPrice; } prevPrice = prices[i]; } return profit; } } . ",
    "url": "https://1001anjan.github.io/problem-83-Best%20Time%20to%20Buy%20and%20Sell%20Stock%20II/",
    "relUrl": "/problem-83-Best Time to Buy and Sell Stock II/"
  },"668": {
    "doc": "Number Complement",
    "title": "Number Complement",
    "content": "The complement of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation. | For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2. Given an integer num, return its complement. | . Example 1: . Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: . Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Constraints: . | 1 &lt;= num &lt; 231 | . Solution . class Solution { public int findComplement(int num) { int numberOfBits = (int)(Math.floor(Math.log(num) / Math.log(2))) + 1; return ((1 &lt;&lt; numberOfBits) - 1) ^ num; } } . Faster solution . class Solution { public int findComplement(int num) { int mask = 0; while(mask &lt; num) mask = mask &lt;&lt; 1 | 1; int ans = (~ num) &amp; mask ; return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-83-Number-Complement/",
    "relUrl": "/problem-83-Number-Complement/"
  },"669": {
    "doc": "Clone Graph",
    "title": "Clone Graph",
    "content": "Given a reference of a node in a connected undirected graph. Return a deep copy (clone) of the graph. Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors. class Node { public int val; public List&lt;Node&gt; neighbors; } . Test case format: . | For simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list. | An adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph. | The given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph. | . Example 1: . Input: adjList = [[2,4],[1,3],[2,4],[1,3]] Output: [[2,4],[1,3],[2,4],[1,3]] Explanation: There are 4 nodes in the graph. 1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). 3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4). 4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3). Example 2: . Input: adjList = [[]] Output: [[]] Explanation: Note that the input contains one empty list. The graph consists of only one node with val = 1 and it does not have any neighbors. Example 3: . Input: adjList = [] Output: [] Explanation: This an empty graph, it does not have any nodes. Constraints: . | The number of nodes in the graph is in the range [0, 100]. | 1 &lt;= Node.val &lt;= 100 | Node.val is unique for each node. | There are no repeated edges and no self-loops in the graph. | The Graph is connected and all nodes can be visited starting from the given node. | . Solution: . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; neighbors; public Node() { val = 0; neighbors = new ArrayList&lt;Node&gt;(); } public Node(int _val) { val = _val; neighbors = new ArrayList&lt;Node&gt;(); } public Node(int _val, ArrayList&lt;Node&gt; _neighbors) { val = _val; neighbors = _neighbors; } } */ class Solution { public Node cloneGraph(Node node) { if(node == null) return null; Set&lt;Integer&gt; visited = new HashSet&lt;&gt;(); Map&lt;Integer, Node&gt; map = new HashMap&lt;&gt;(); Stack&lt;Node&gt; stack = new Stack(); stack.push(node); Node res = new Node(node.val); map.put(node.val, res); visited.add(node.val); while(!stack.isEmpty()){ Node n = stack.pop(); Node keyNode = map.get(n.val); for(Node t : n.neighbors){ if(visited.add(t.val)) stack.push(t); Node v = map.get(t.val); if(v == null){ Node newNode = new Node(t.val); keyNode.neighbors.add(newNode); map.put(t.val, newNode); }else{ keyNode.neighbors.add(v); } } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-84-Clone%20Graph/",
    "relUrl": "/problem-84-Clone Graph/"
  },"670": {
    "doc": "Max Consecutive Ones",
    "title": "Max Consecutive Ones",
    "content": "Given a binary array nums, return the maximum number of consecutive 1’s in the array. Example 1: . Input: nums = [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Example 2: . Input: nums = [1,0,1,1,0,1] Output: 2 . Constraints: . | 1 &lt;= nums.length &lt;= 105 | nums[i] is either 0 or 1. | . Solution . class Solution { public int findMaxConsecutiveOnes(int[] nums) { int m = 0; int p = 0; int i = 0; while(i&lt;nums.length){ if(nums[i] == 0) { i++; continue; } while(i&lt;nums.length &amp;&amp; nums[i] == 1){ m++; i++; } if(m&gt;p){ p = m; } m = 0; } return p; } } . ",
    "url": "https://1001anjan.github.io/problem-84-Max-Consecutive-Ones/",
    "relUrl": "/problem-84-Max-Consecutive-Ones/"
  },"671": {
    "doc": "Fraction to Recurring Decimal",
    "title": "Fraction to Recurring Decimal",
    "content": "Given two integers representing the numerator and denominator of a fraction, return the fraction in string format. If the fractional part is repeating, enclose the repeating part in parentheses. If multiple answers are possible, return any of them. It is guaranteed that the length of the answer string is less than 104 for all the given inputs. Example 1: . Input: numerator = 1, denominator = 2 Output: \"0.5\" . Example 2: . Input: numerator = 2, denominator = 1 Output: \"2\" . Example 3: . Input: numerator = 4, denominator = 333 Output: \"0.(012)\" . Constraints: . | -2^31 &lt;= numerator, denominator &lt;= 2^31 - 1 | denominator != 0 | . Solution: . class Solution { public String fractionToDecimal(int numerator, int denominator) { if(denominator == 0) throw null; if(numerator == 0) return \"0\"; StringBuilder sb = new StringBuilder(); // checking sign of the result if one part is negetive sb.append(((numerator &gt; 0) ^ (denominator &gt; 0)) ? \"-\" : \"\"); long n = Math.abs((long) numerator); long d = Math.abs((long) denominator); sb.append(n/d); n %= d; if(n == 0) return sb.toString(); sb.append(\".\"); Map&lt;Long, Integer&gt; map = new HashMap&lt;&gt;(); map.put(n, sb.length()); while(n != 0){ n *= 10; sb.append(n / d); n %= d; if(map.containsKey(n)){ sb.insert(map.get(n),\"(\"); sb.append(\")\"); return sb.toString(); }else{ map.put(n, sb.length()); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-85-Fraction%20to%20Recurring%20Decimal/",
    "relUrl": "/problem-85-Fraction to Recurring Decimal/"
  },"672": {
    "doc": "License Key Formatting",
    "title": "License Key Formatting",
    "content": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k. We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key. Example 1: . Input: s = \"5F3Z-2e-9-w\", k = 4 Output: \"5F3Z-2E9W\" Explanation: The string s has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed. Example 2: . Input: s = \"2-5g-3-J\", k = 2 Output: \"2-5G-3J\" Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of English letters, digits, and dashes ‘-‘. | 1 &lt;= k &lt;= 104 | . Solution . class Solution { public String licenseKeyFormatting(String s, int k) { StringBuilder sb = new StringBuilder(); int count = 0; for(int i = s.length()-1;i&gt;=0;i--){ if(s.charAt(i) != '-'){ if(count == k){ count = 0; sb = sb.append(\"-\"); } sb = sb.append(Character.toUpperCase(s.charAt(i))); count++; } } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-85-License-Key-Formatting/",
    "relUrl": "/problem-85-License-Key-Formatting/"
  },"673": {
    "doc": "Construct the Rectangle",
    "title": "Construct the Rectangle",
    "content": "A web developer needs to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: . The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible. Return an array [L, W] where L and W are the length and width of the web page you designed in sequence. Example 1: . Input: area = 4 Output: [2,2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Example 2: . Input: area = 37 Output: [37,1] . Example 3: . Input: area = 122122 Output: [427,286] . Constraints: . | 1 &lt;= area &lt;= 107 | . Solution . class Solution { public int[] constructRectangle(int area) { for(int i = (int)Math.sqrt(area);i&gt;0;i--){ if(area%i == 0){ return new int[]{area/i,i}; } } return null; } } . ",
    "url": "https://1001anjan.github.io/problem-86-Construct-the-Rectangle/",
    "relUrl": "/problem-86-Construct-the-Rectangle/"
  },"674": {
    "doc": "Word Break",
    "title": "Word Break",
    "content": "Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words. Note that the same word in the dictionary may be reused multiple times in the segmentation. Example 1: . Input: s = \"leetcode\", wordDict = [\"leet\",\"code\"] Output: true Explanation: Return true because \"leetcode\" can be segmented as \"leet code\". Example 2: . Input: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"] Output: true Explanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\". Note that you are allowed to reuse a dictionary word. Example 3: . Input: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"] Output: false . Constraints: . | 1 &lt;= s.length &lt;= 300 | 1 &lt;= wordDict.length &lt;= 1000 | 1 &lt;= wordDict[i].length &lt;= 20 | s and wordDict[i] consist of only lowercase English letters. | All the strings of wordDict are unique. | . Solution . Time Limit Exceeded . class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { return processWordBreak(s, 0, wordDict); } public boolean processWordBreak(String s, int index, List&lt;String&gt; words){ if(index &gt;= s.length()) return true; for(String str : words){ if(index + str.length() &lt;= s.length() &amp;&amp; s.substring(index, index + str.length()).equals(str)){ if(processWordBreak(s, index + str.length(), words)) return true; } } return false; } } . Dynamic Programming . class Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { int n = s.length(); boolean[] dp = new boolean[n + 1]; Set&lt;String&gt; set = new HashSet&lt;&gt;(wordDict); dp[0] = true; for(int i = 1; i &lt;= n; i++){ for(int j = 0; j &lt;= i; j++){ if(dp[j] &amp;&amp; set.contains(s.substring(j,i))){ dp[i] = true; break; } } } return dp[n]; } } . ",
    "url": "https://1001anjan.github.io/problem-86-Word%20Break/",
    "relUrl": "/problem-86-Word Break/"
  },"675": {
    "doc": "Factorial Trailing Zeroes",
    "title": "Factorial Trailing Zeroes",
    "content": "Given an integer n, return the number of trailing zeroes in n!. Note that n! = n * (n - 1) * (n - 2) * … * 3 * 2 * 1. Example 1: . Input: n = 3 Output: 0 Explanation: 3! = 6, no trailing zero. Example 2: . Input: n = 5 Output: 1 Explanation: 5! = 120, one trailing zero. Example 3: . Input: n = 0 Output: 0 . Constraints: . | 0 &lt;= n &lt;= 10^4 | . Solution: . 0 is the product of 2 and 5. In n!, we need to know how many 2 and 5, and the number of zeros is the minimum of the number of 2 and the number of 5. Since multiple of 2 is more than multiple of 5, the number of zeros is dominant by the number of 5. Here we expand . 2147483647! . =2 * 3 * ...* 5 ... *10 ... 15* ... * 25 ... * 50 ... * 125 ... * 250... =2 * 3 * ...* 5 ... * (5^1*2)...(5^1*3)...*(5^2*1)...*(5^2*2)...*(5^3*1)...*(5^3*2)... (Equation 1) . We just count the number of 5 in Equation 1. Multiple of 5 provides one 5, multiple of 25 provides two 5 and so on. Note the duplication: multiple of 25 is also multiple of 5, so multiple of 25 only provides one extra 5. Here is the basic solution: . return n/5 + n/25 + n/125 + n/625 + n/3125+...; . class Solution { public int trailingZeroes(int n) { int count = 0; while(n &gt; 0){ count += n/5; n /= 5; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-87-Factorial%20Trailing%20Zeroes/",
    "relUrl": "/problem-87-Factorial Trailing Zeroes/"
  },"676": {
    "doc": "Teemo Attacking",
    "title": "Teemo Attacking",
    "content": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned. Example 1: . Input: timeSeries = [1,4], duration = 2 Output: 4 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5. Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total. Example 2: . Input: timeSeries = [1,2], duration = 2 Output: 3 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3. Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total. Constraints: . | 1 &lt;= timeSeries.length &lt;= 104 | 0 &lt;= timeSeries[i], duration &lt;= 107 | timeSeries is sorted in non-decreasing order. | . Solution: . class Solution { public int findPoisonedDuration(int[] timeSeries, int duration) { int n = timeSeries.length; if (n == 0) return 0; int total = 0; for(int i = 0; i &lt; n - 1; ++i) total += Math.min(timeSeries[i + 1] - timeSeries[i], duration); return total + duration; } } . ",
    "url": "https://1001anjan.github.io/problem-87-Teemo-Attacking/",
    "relUrl": "/problem-87-Teemo-Attacking/"
  },"677": {
    "doc": "Binary Search Tree Iterator",
    "title": "Binary Search Tree Iterator",
    "content": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST): . | BSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST. | boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false. | int next() Moves the pointer to the right, then returns the number at the pointer. Notice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST. | . You may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called. Example 1: . Input [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"] [[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []] Output [null, 3, 7, true, 9, true, 15, true, 20, false] Explanation BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]); bSTIterator.next(); // return 3 bSTIterator.next(); // return 7 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 9 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 15 bSTIterator.hasNext(); // return True bSTIterator.next(); // return 20 bSTIterator.hasNext(); // return False . Constraints: . | The number of nodes in the tree is in the range [1, 10^5]. | 0 &lt;= Node.val &lt;= 10^6 | At most 105 calls will be made to hasNext, and next. | . Follow up: . Could you implement next() and hasNext() to run in average O(1) time and use O(h) memory, where h is the height of the tree? . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class BSTIterator { Stack&lt;TreeNode&gt; stack; public BSTIterator(TreeNode root) { stack = new Stack(); TreeNode ptr = root; while(ptr != null){ stack.push(ptr); ptr = ptr.left; } } public int next() { // since next() call always valid TreeNode node = stack.pop(); if(node.right != null){ TreeNode ptr = node.right; while(ptr != null){ stack.push(ptr); ptr = ptr.left; } } return node.val; } public boolean hasNext() { return !stack.isEmpty(); } } /** * Your BSTIterator object will be instantiated and called as such: * BSTIterator obj = new BSTIterator(root); * int param_1 = obj.next(); * boolean param_2 = obj.hasNext(); */ . ",
    "url": "https://1001anjan.github.io/problem-88-Binary%20Search%20Tree%20Iterator/",
    "relUrl": "/problem-88-Binary Search Tree Iterator/"
  },"678": {
    "doc": "Next Greater Element I",
    "title": "Next Greater Element I",
    "content": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above. Example 1: . Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: . Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints: . | 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 104 | All integers in nums1 and nums2 are unique. | All the integers of nums1 also appear in nums2. | . Follow up: Could you find an O(nums1.length + nums2.length) solution? . Solution: . class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int[] ans = new int[nums1.length]; boolean f = false; for(int i = 0; i&lt;nums1.length; i++){ f = false; for(int j = 0; j&lt;nums2.length; j++){ if(nums1[i] == nums2[j]){ for(int k = j+1; k&lt;nums2.length; k++){ if(nums2[k] &gt; nums2[j]){ ans[i] = nums2[k]; f = true; break; } if(k == nums2.length) { ans[i] = -1; } } if(f) break; else ans[i] = -1; } } } return ans; } } . class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int resGreater[]=new int[nums2.length-1]; resGreater=nextGreaterElementRight(nums2); HashMap&lt;Integer,Integer&gt; hm=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums2.length;i++){ hm.put(nums2[i],resGreater[i]); } int result[]=new int[nums1.length]; for(int i=0;i&lt;nums1.length;i++){ result[i]=hm.get(nums1[i]); } return result; } public int[] nextGreaterElementRight(int[] nums1){ int res[]=new int[nums1.length]; Stack&lt;Integer&gt; st=new Stack&lt;Integer&gt;(); st.push(nums1[nums1.length-1]); res[nums1.length-1]=-1; for(int i=nums1.length-2;i&gt;=0;i--){ int res1=0; while(!st.isEmpty()&amp;&amp;nums1[i]&gt;st.peek()){ st.pop(); } if(!st.isEmpty()&amp;&amp;nums1[i]&lt;st.peek()){ res1=st.peek(); res[i]=res1; st.push(nums1[i]); } else if(st.isEmpty()){ res[i]=-1; st.push(nums1[i]); } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-88-Next-Greater-Element-I/",
    "relUrl": "/problem-88-Next-Greater-Element-I/"
  },"679": {
    "doc": "Keyboard Row",
    "title": "Keyboard Row",
    "content": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below. In the American keyboard: . | the first row consists of the characters “qwertyuiop”, | the second row consists of the characters “asdfghjkl”, and | the third row consists of the characters “zxcvbnm”. | . Example 1: . Input: words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"] Output: [\"Alaska\",\"Dad\"] . Example 2: . Input: words = [\"omk\"] Output: [] . Example 3: . Input: words = [\"adsdf\",\"sfd\"] Output: [\"adsdf\",\"sfd\"] . Constraints: . | 1 &lt;= words.length &lt;= 20 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of English letters (both lowercase and uppercase). | . class Solution { public String[] findWords(String[] words) { ArrayList&lt;String&gt; str = new ArrayList&lt;String&gt;(); String[] keys = new String[3]; keys[0] = \"QqWwEeRrTtYyUuIiOoPp\"; keys[1] = \"AaSsDdFfGgHhJjKkLl\"; keys[2] = \"ZzXxCcVvBbNnMm\"; for(String word : words){ char ch = word.charAt(0); int key = -1; if(keys[0].contains(String.valueOf(ch))) key = 0; if(keys[1].contains(String.valueOf(ch))) key = 1; if(keys[2].contains(String.valueOf(ch))) key = 2; if(key != -1){ int i=1; for(; i&lt;word.length(); i++){ if(!keys[key].contains(String.valueOf(word.charAt(i)))) break; } if(i == word.length()) str.add(word); } } return str.toArray(new String[str.size()]); } } . ",
    "url": "https://1001anjan.github.io/problem-89-Keyboard-Row/",
    "relUrl": "/problem-89-Keyboard-Row/"
  },"680": {
    "doc": "Largest Number",
    "title": "Largest Number",
    "content": "Given a list of non-negative integers nums, arrange them such that they form the largest number and return it. Since the result may be very large, so you need to return a string instead of an integer. Example 1: . Input: nums = [10,2] Output: \"210\" . Example 2: . Input: nums = [3,30,34,5,9] Output: \"9534330\" . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 10^9 | . Solution: . class Solution { public String largestNumber(int[] nums) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int n : nums) list.add(n); Collections.sort(list, (a, b) -&gt; { String a1 = String.valueOf(a) + String.valueOf(b); String b1 = String.valueOf(b) + String.valueOf(a); return b1.compareTo(a1); }); // after sorting if first element is 0 if(list.get(0) == 0) return \"0\"; StringBuilder sb = new StringBuilder(); for(int n : list) sb.append(n); return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-89-Largest%20Number/",
    "relUrl": "/problem-89-Largest Number/"
  },"681": {
    "doc": "3Sum",
    "title": "3Sum",
    "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: . Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2: . Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3: . Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. Constraints: . | 3 &lt;= nums.length &lt;= 3000 | -10^5 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; ans = new HashSet&lt;&gt;(); Arrays.sort(nums); System.out.println(); for(int i = 0; i &lt; nums.length - 1; i++){ int l = i + 1; int u = nums.length - 1; while(l &lt; u){ int s = nums[l] + nums[u] + nums[i]; if(s == 0){ ans.add(Arrays.asList(nums[i], nums[l], nums[u])); l++; u--; }else if(s &gt; 0){ u--; }else{ l++; } } } return new ArrayList(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-9-3Sum/",
    "relUrl": "/problem-9-3Sum/"
  },"682": {
    "doc": "Implement strStr()",
    "title": "Implement strStr()",
    "content": "Implement strStr(). Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Clarification: . What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Example 1: . Input: haystack = \"hello\", needle = \"ll\" Output: 2 . Example 2: . Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 . Constraints: . | 1 &lt;= haystack.length, needle.length &lt;= 104 | haystack and needle consist of only lowercase English characters. | . Solution . class Solution { public int strStr(String haystack, String needle) { if(needle.equals(\"\") || needle == null) return 0; int j = 0; int res = -1; for(int i=0; i&lt;haystack.length(); i++){ if(haystack.charAt(i) == needle.charAt(j)){ if(j == 0){ res = i; } j++; if(j == needle.length()) return res; }else{ if(res != -1){ i = res; } res = -1; j = 0; } } if(j != needle.length()) return -1; return res; } } . ",
    "url": "https://1001anjan.github.io/problem-9-implement-strStr/",
    "relUrl": "/problem-9-implement-strStr/"
  },"683": {
    "doc": "Find Mode in Binary Search Tree",
    "title": "Find Mode in Binary Search Tree",
    "content": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: . The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: . Input: root = [1,null,2,2] Output: [2] . Example 2: . Input: root = [0] Output: [0] . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -105 &lt;= Node.val &lt;= 105 | . Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Solution: . class Solution { private TreeNode pre = null; private int max = 1; private int cnt = 1; // counts for leftmost node self public int[] findMode(TreeNode root) { List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); inOrder(root, nums); int[] arr = new int[nums.size()]; for (int i = 0; i &lt; nums.size(); i++) arr[i] = nums.get(i); return arr; } private void inOrder(TreeNode root, List&lt;Integer&gt; nums) { if (root == null) { return; } // in-order traversal, left-root-right inOrder(root.left, nums); // if consecutive integers are the same if (pre != null) { cnt = (pre.val == root.val) ? cnt + 1 : 1; } // if current value's frequency is larger than the max one if (cnt &gt; max) { max = cnt; nums.clear(); nums.add(root.val); } else if (cnt == max) { // frequency equals, add current root value nums.add(root.val); } pre = root; // update pre node inOrder(root.right, nums); // in-order } } . class Solution { TreeNode pre = null; int max = 1; int count = 1; public int[] findMode(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traverseInorder(root, list); return list.stream().mapToInt(i-&gt;i).toArray(); } public void traverseInorder(TreeNode root, List&lt;Integer&gt; list){ if(root == null) return; traverseInorder(root.left, list); if(pre != null){ count = (pre.val == root.val)? count+1: 1; } if(count&gt;max){ max = count; list.clear(); list.add(root.val); }else if(count == max){ list.add(root.val); } pre = root; traverseInorder(root.right, list); } } . ",
    "url": "https://1001anjan.github.io/problem-90-Find-Mode-in-Binary-Search-Tree/",
    "relUrl": "/problem-90-Find-Mode-in-Binary-Search-Tree/"
  },"684": {
    "doc": "Repeated DNA Sequences",
    "title": "Repeated DNA Sequences",
    "content": "The DNA sequence is composed of a series of nucleotides abbreviated as ‘A’, ‘C’, ‘G’, and ‘T’. | For example, “ACGAATTCCG” is a DNA sequence. When studying DNA, it is useful to identify repeated sequences within the DNA. | . Given a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. Example 1: . Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\" Output: [\"AAAAACCCCC\",\"CCCCCAAAAA\"] . Example 2: . Input: s = \"AAAAAAAAAAAAA\" Output: [\"AAAAAAAAAA\"] . Constraints: . | 1 &lt;= s.length &lt;= 10^5 | s[i] is either ‘A’, ‘C’, ‘G’, or ‘T’. | . Solution: . class Solution { public List&lt;String&gt; findRepeatedDnaSequences(String s) { Set seen = new HashSet(), repeated = new HashSet(); for (int i = 0; i + 9 &lt; s.length(); i++) { String ten = s.substring(i, i + 10); if (!seen.add(ten)) repeated.add(ten); } return new ArrayList(repeated); } } . ",
    "url": "https://1001anjan.github.io/problem-90-Repeated%20DNA%20Sequences/",
    "relUrl": "/problem-90-Repeated DNA Sequences/"
  },"685": {
    "doc": "Base 7",
    "title": "Base 7",
    "content": "Given an integer num, return a string of its base 7 representation. Example 1: . Input: num = 100 Output: \"202\" . Example 2: . Input: num = -7 Output: \"-10\" . Constraints: . | -107 &lt;= num &lt;= 107 | . Solution: . class Solution { public String convertToBase7(int num) { if(num == 0) return \"0\"; boolean sign = false; if(num&lt;0){ num = num*-1; sign = true; } StringBuffer sb = new StringBuffer(); int base7 = 0; while(num&gt;0){ sb.append(num%7) ; num = num/7; } if(sign) return \"-\" + sb.reverse().toString(); else return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-91-Base-7/",
    "relUrl": "/problem-91-Base-7/"
  },"686": {
    "doc": "Rotate Array",
    "title": "Rotate Array",
    "content": "Given an array, rotate the array to the right by k steps, where k is non-negative. Example 1: . Input: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] . Example 2: . Input: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] . Constraints: . | 1 &lt;= nums.length &lt;= 10^5 | -2^31 &lt;= nums[i] &lt;= 2^31 - 1 | 0 &lt;= k &lt;= 10^5 | . Follow up: . | Try to come up with as many solutions as you can. There are at least three different ways to solve this problem. | Could you do it in-place with O(1) extra space? | . Solution: . System.arraycopy(src, srcpos, dest, destpos, len) . class Solution { public void rotate(int[] nums, int k) { k = k % nums.length; int[] arr = new int[k]; System.arraycopy(nums, nums.length - k, arr, 0, k); System.arraycopy(nums, 0, nums, k, nums.length - k); System.arraycopy(arr, 0, nums, 0, k); } } . class Solution { public void rotate(int[] nums, int k) { k %= nums.length; reverse(nums, 0, nums.length - 1); reverse(nums, 0, k - 1); reverse(nums, k, nums.length - 1); } public void reverse(int[] nums, int start, int end) { while (start &lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; } } } . ",
    "url": "https://1001anjan.github.io/problem-91-Rotate%20Array/",
    "relUrl": "/problem-91-Rotate Array/"
  },"687": {
    "doc": "House Robber",
    "title": "House Robber",
    "content": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. Example 1: . Input: nums = [1,2,3,1] Output: 4 Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. Example 2: . Input: nums = [2,7,9,3,1] Output: 12 Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 400 | . Solution: . class Solution { public int rob(int[] nums) { int[][] dp = new int[nums.length + 1][2]; // dp[i][0] means if we dont rob ithe house and dp[i][1] if we rob ith house for(int i = 1; i &lt;= nums.length; i++){ dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]); dp[i][1] = nums[i - 1] + dp[i - 1][0]; } return Math.max(dp[nums.length][0], dp[nums.length][1]); } } . Converting the solution to O(1) space . class Solution { public int rob(int[] nums) { int prevNo = 0; // the max value if previous hous is not robbed int prevYes = 0; // the max value if previous hous is robbed for(int n : nums){ int temp = prevNo; prevNo = Math.max(prevNo, prevYes); prevYes = temp + n; } return Math.max(prevNo, prevYes); } } . ",
    "url": "https://1001anjan.github.io/problem-92-House%20Robber/",
    "relUrl": "/problem-92-House Robber/"
  },"688": {
    "doc": "Relative Ranks",
    "title": "Relative Ranks",
    "content": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique. The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank: . | The 1st place athlete’s rank is “Gold Medal”. | The 2nd place athlete’s rank is “Silver Medal”. | The 3rd place athlete’s rank is “Bronze Medal”. | For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete’s rank is “x”). | . Return an array answer of size n where answer[i] is the rank of the ith athlete. Example 1: . Input: score = [5,4,3,2,1] Output: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2: . Input: score = [10,3,8,9,4] Output: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints: . | n == score.length | 1 &lt;= n &lt;= 104 | 0 &lt;= score[i] &lt;= 106 | All the values in score are unique. | . Solution: . class Solution { public String[] findRelativeRanks(int[] score) { String[] result = new String[score.length]; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int i: score) temp.add(i); Collections.sort(temp, Collections.reverseOrder()); int index; for(int i = 0; i&lt;score.length; i++){ index = temp.indexOf(score[i]); if(index == 0){ result[i] = \"Gold Medal\"; }else if(index == 1){ result[i] = \"Silver Medal\"; }else if(index == 2){ result[i] = \"Bronze Medal\"; }else{ result[i] = String.valueOf(index+1); } } return result; } } . class Solution { public String[] findRelativeRanks(int[] score) { int a[]=new int[score.length]; for(int i=0;i&lt;score.length;i++){ a[i]=score[i]; } Arrays.sort(score); String ans[]=new String[score.length]; for(int i=score.length;i&gt;0;i--){ String rank=GetRank(score,i); int index=Search(a,score[i-1]); ans[index]=rank; } return ans; } static String GetRank(int score[],int pos){ if(pos==score.length){ return \"Gold Medal\"; } else if(pos==score.length-1){ return \"Silver Medal\"; } else if(pos==score.length-2){ return \"Bronze Medal\"; } else { int a=score.length-pos+1; String s=Integer.toString(a); return s; } } static int Search(int a[],int target){ for(int i=0;i&lt;a.length;i++){ if(target==a[i]){ return i; } } return -1; } } . class Solution { public String[] findRelativeRanks(int[] score) { final String GOLD = \"Gold Medal\"; final String SILVER = \"Silver Medal\"; final String BRONZE = \"Bronze Medal\"; final String[] result = new String[score.length]; PriorityQueue&lt;Integer[]&gt; pq = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr2[0] - arr1[0]); for (int i = 0; i &lt; score.length; i++) { pq.add(new Integer[]{score[i], i}); } int k = 1; while (!pq.isEmpty()) { if (k &lt;= 3) { if (k == 1) result[pq.poll()[1]] = GOLD; if (k == 2) result[pq.poll()[1]] = SILVER; if (k == 3) result[pq.poll()[1]] = BRONZE; } else{ result[pq.poll()[1]] = String.valueOf(k); } k++; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-92-Relative-Ranks/",
    "relUrl": "/problem-92-Relative-Ranks/"
  },"689": {
    "doc": "Binary Tree Right Side View",
    "title": "Binary Tree Right Side View",
    "content": "Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom. Example 1: . Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] . Example 2: . Input: root = [1,null,3] Output: [1,3] . Example 3: . Input: root = [] Output: [] . A useful test case for this problem would be: . Input: root = [1,2,3,null,5,6,null,4] . Constraints: . | The number of nodes in the tree is in the range [0, 100]. | -100 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); q.offer(root); while(!q.isEmpty()){ Queue&lt;TreeNode&gt; q1 = new LinkedList&lt;&gt;(); int size = q.size(); for(int i = 1; i &lt; size; i++){ TreeNode n = q.poll(); if(n.left != null) q1.offer(n.left); if(n.right != null) q1.offer(n.right); } TreeNode n = q.poll(); if(n == null) break; res.add(n.val); if(n.left != null) q1.offer(n.left); if(n.right != null) q1.offer(n.right); q = q1; } return res; } } . The core idea of this algorithm: . 1.Each depth of the tree only select one node. | View depth is current size of result list. public class Solution { public List&lt;Integer&gt; rightSideView(TreeNode root) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); rightView(root, result, 0); return result; } public void rightView(TreeNode curr, List&lt;Integer&gt; result, int currDepth){ if(curr == null){ return; } if(currDepth == result.size()){ result.add(curr.val); } rightView(curr.right, result, currDepth + 1); rightView(curr.left, result, currDepth + 1); } } . | . ",
    "url": "https://1001anjan.github.io/problem-93-Binary%20Tree%20Right%20Side%20View/",
    "relUrl": "/problem-93-Binary Tree Right Side View/"
  },"690": {
    "doc": "Perfect Number",
    "title": "Perfect Number",
    "content": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false. Example 1: . Input: num = 28 Output: true Explanation: 28 = 1 + 2 + 4 + 7 + 14 1, 2, 4, 7, and 14 are all divisors of 28. Example 2: . Input: num = 7 Output: false . Constraints: . | 1 &lt;= num &lt;= 108 | . Solution: . class Solution { public boolean checkPerfectNumber(int num) { int sum = 0; for(int i = 1; i&lt;=num/2; i++){ if(num%i == 0) sum += i; if(sum&gt;num) return false; } if(sum == num) return true; return false; } } . https://leetcode.com/problems/perfect-number/solution/ . class Solution { public boolean checkPerfectNumber(int num) { if (num &lt;= 0) { return false; } int sum = 0; for (int i = 1; i * i &lt;= num; i++) { if (num % i == 0) { sum += i; if (i * i != num) { sum += num / i; } } } return sum - num == num; } } . ",
    "url": "https://1001anjan.github.io/problem-93-Perfect-Number/",
    "relUrl": "/problem-93-Perfect-Number/"
  },"691": {
    "doc": "Fibonacci Number",
    "title": "Fibonacci Number",
    "content": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, . F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). Example 1: . Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: . Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: . Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: . | 0 &lt;= n &lt;= 30 | . Solution . class Solution { public int fib(int n) { if(n == 0) return 0; if(n == 1) return 1; return fib(n-1) + fib(n-2); } } . class Solution { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public int fib(int n) { if(map.containsKey(n)) return map.get(n); if(n == 0) return 0; if(n == 1) return 1; map.put(n,fib(n-1) + fib(n-2)); return map.get(n); } } . ",
    "url": "https://1001anjan.github.io/problem-94-Fibonacci-Number/",
    "relUrl": "/problem-94-Fibonacci-Number/"
  },"692": {
    "doc": "Number of Islands",
    "title": "Number of Islands",
    "content": "Given an m x n 2D binary grid grid which represents a map of ‘1’s (land) and ‘0’s (water), return the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: . Input: grid = [ [\"1\",\"1\",\"1\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"1\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"0\",\"0\"] ] Output: 1 . Example 2: . Input: grid = [ [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"1\",\"1\",\"0\",\"0\",\"0\"], [\"0\",\"0\",\"1\",\"0\",\"0\"], [\"0\",\"0\",\"0\",\"1\",\"1\"] ] Output: 3 . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m, n &lt;= 300 | grid[i][j] is ‘0’ or ‘1’. | . Solution: . class Solution { public int numIslands(char[][] grid) { int count = 0; for(int i = 0; i &lt; grid.length; i++){ for(int j = 0; j &lt; grid[0].length; j++){ if(grid[i][j] == '1'){ dfsFill(grid, i, j); count++; } } } return count; } public void dfsFill(char[][] grid, int i, int j){ if(i &gt;=0 &amp;&amp; i &lt; grid.length &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; grid[0].length &amp;&amp; grid[i][j] == '1'){ grid[i][j] = '0'; dfsFill(grid, i, j - 1); dfsFill(grid, i, j + 1); dfsFill(grid, i - 1, j); dfsFill(grid, i + 1, j); } } } . ",
    "url": "https://1001anjan.github.io/problem-94-Number%20of%20Islands/",
    "relUrl": "/problem-94-Number of Islands/"
  },"693": {
    "doc": "Bitwise AND of Numbers Range",
    "title": "Bitwise AND of Numbers Range",
    "content": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive. Example 1: . Input: left = 5, right = 7 Output: 4 . Example 2: . Input: left = 0, right = 0 Output: 0 . Example 3: . Input: left = 1, right = 2147483647 Output: 0 . Constraints: . | 0 &lt;= left &lt;= right &lt;= 2^31 - 1 | . Solution: . class Solution { public int rangeBitwiseAnd(int left, int right) { while(left &lt; right) right = right &amp; (right - 1); return right; } } . ",
    "url": "https://1001anjan.github.io/problem-95-Bitwise%20AND%20of%20Numbers%20Range/",
    "relUrl": "/problem-95-Bitwise AND of Numbers Range/"
  },"694": {
    "doc": "Detect Capital",
    "title": "Detect Capital",
    "content": "We define the usage of capitals in a word to be right when one of the following cases holds: . | All letters in this word are capitals, like “USA”. | All letters in this word are not capitals, like “leetcode”. | Only the first letter in this word is capital, like “Google”. | Given a string word, return true if the usage of capitals in it is right. | . Example 1: . Input: word = \"USA\" Output: true . Example 2: . Input: word = \"FlaG\" Output: false . Constraints: . | 1 &lt;= word.length &lt;= 100 | word consists of lowercase and uppercase English letters. | . Solution: . class Solution { public boolean detectCapitalUse(String word) { if(Character.isUpperCase(word.charAt(0))){ String s1 = word.toUpperCase(); if(word.equals(s1)) return true; s1 = word.charAt(0) + word.substring(1,word.length()).toLowerCase(); if(word.equals(s1)) return true; return false; }else{ String s1 = word.toLowerCase(); if(word.equals(s1)) return true; return false; } } } . class Solution { public boolean detectCapitalUse(String word) { return word.matches(\"[A-Z]*|.[a-z]*\"); } } . Faster . class Solution { public boolean detectCapitalUse(String word) { int n = word.length(); if (n == 1) { return true; } // case 1: All capital if (Character.isUpperCase(word.charAt(0)) &amp;&amp; Character.isUpperCase(word.charAt(1))) { for (int i = 2; i &lt; n; i++) { if (Character.isLowerCase(word.charAt(i))) { return false; } } // case 2 and case 3 } else { for (int i = 1; i &lt; n; i++) { if (Character.isUpperCase(word.charAt(i))) { return false; } } } // if pass one of the cases return true; } } . ",
    "url": "https://1001anjan.github.io/problem-95-Detect-Capital/",
    "relUrl": "/problem-95-Detect-Capital/"
  },"695": {
    "doc": "Count Primes",
    "title": "Count Primes",
    "content": "Given an integer n, return the number of prime numbers that are strictly less than n. Example 1: . Input: n = 10 Output: 4 Explanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7. Example 2: . Input: n = 0 Output: 0 . Example 3: . Input: n = 1 Output: 0 . Constraints: . | 0 &lt;= n &lt;= 5 * 10^6 | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-96-Count%20Primes/",
    "relUrl": "/problem-96-Count Primes/"
  },"696": {
    "doc": "Minimum Absolute Difference in BST",
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 104]. | 0 &lt;= Node.val &lt;= 105 | . Solution . ",
    "url": "https://1001anjan.github.io/problem-96-Minimum-Absolute-Difference-in-BST/",
    "relUrl": "/problem-96-Minimum-Absolute-Difference-in-BST/"
  },"697": {
    "doc": "Implement Trie (Prefix Tree)",
    "title": "Implement Trie (Prefix Tree)",
    "content": "A trie (pronounced as “try”) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker. Implement the Trie class: . | Trie() Initializes the trie object. | void insert(String word) Inserts the string word into the trie. | boolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise. | boolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise. | . Example 1: . Input [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] Output [null, null, true, false, true, null, true] Explanation Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // return True trie.search(\"app\"); // return False trie.startsWith(\"app\"); // return True trie.insert(\"app\"); trie.search(\"app\"); // return True . Constraints: . | 1 &lt;= word.length, prefix.length &lt;= 2000 | word and prefix consist only of lowercase English letters. | At most 3 * 10^4 calls in total will be made to insert, search, and startsWith. | . Solution: . class Trie { private static class TreeNode{ boolean exists; TreeNode[] children = new TreeNode[26]; } private TreeNode root; public Trie() { root = new TreeNode(); } public void insert(String word) { TreeNode node = root; for(int i = 0; i &lt; word.length(); i++){ int id = word.charAt(i) - 'a'; if(node.children[id] == null) node.children[id] = new TreeNode(); node = node.children[id]; } node.exists = true; } public boolean search(String word) { TreeNode node = root; for(int i = 0; i &lt; word.length(); i++){ int id = word.charAt(i) - 'a'; if(node.children[id] == null) return false; node = node.children[id]; } return node.exists; } public boolean startsWith(String prefix) { TreeNode node = root; for(int i = 0; i &lt; prefix.length(); i++){ int id = prefix.charAt(i) - 'a'; if(node.children[id] == null) return false; node = node.children[id]; } for(int i = 0; i &lt; 26; i++){ if(node.children[i] != null) return true; } return node.exists; } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ . ",
    "url": "https://1001anjan.github.io/problem-97-Implement%20Trie%20(Prefix%20Tree)/",
    "relUrl": "/problem-97-Implement Trie (Prefix Tree)/"
  },"698": {
    "doc": "Reverse String II",
    "title": "Reverse String II",
    "content": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. f there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. Example 1: . Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" . Example 2: . Input: s = \"abcd\", k = 2 Output: \"bacd\" . Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of only lowercase English letters. | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public String reverseStr(String s, int k) { int p = 0; char [] str = s.toCharArray(); while(p&lt;str.length){ // if reverse segment int l = p; int u = p + k -1; if(u &gt;= str.length) u = str.length - 1; while(l&lt;u){ char ch = str[l]; str[l] = str[u]; str[u] = ch; l++; u--; } p = p + 2*k; } return new String(str); } } . ",
    "url": "https://1001anjan.github.io/problem-97-Reverse-String-II/",
    "relUrl": "/problem-97-Reverse-String-II/"
  },"699": {
    "doc": "Diameter of Binary Tree",
    "title": "Diameter of Binary Tree",
    "content": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: . Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: . Input: root = [1,2] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -100 &lt;= Node.val &lt;= 100 | . Solution: . class Solution { public int diameterOfBinaryTree(TreeNode root) { // here we are using diameter array as reference to store value and not a diameter int variable to store the value int[] diameter = new int[1]; helper(root,diameter); return diameter[0]; } public int helper(TreeNode root, int[] diameter){ if(root == null) return 0; int leftHeight = helper(root.left,diameter); int rightHeight = helper(root.right,diameter); // checking whether the previous diameter is max or new diameter is max diameter[0] = Math.max(diameter[0],leftHeight + rightHeight); // here returning the max height which can either be left one or right one by adding current node as well return 1 + Math.max(leftHeight , rightHeight); } } . ",
    "url": "https://1001anjan.github.io/problem-98-Diameter-of-Binary-Tree/",
    "relUrl": "/problem-98-Diameter-of-Binary-Tree/"
  },"700": {
    "doc": "Minimum Size Subarray Sum",
    "title": "Minimum Size Subarray Sum",
    "content": "Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead. Example 1: . Input: target = 7, nums = [2,3,1,2,4,3] Output: 2 Explanation: The subarray [4,3] has the minimal length under the problem constraint. Example 2: . Input: target = 4, nums = [1,4,4] Output: 1 . Example 3: . Input: target = 11, nums = [1,1,1,1,1,1,1,1] Output: 0 . Constraints: . | 1 &lt;= target &lt;= 10^9 | 1 &lt;= nums.length &lt;= 10^5 | 1 &lt;= nums[i] &lt;= 10^4 | . Follow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)). Solution: . class Solution { public int minSubArrayLen(int target, int[] nums) { int min = Integer.MAX_VALUE; int currSum = 0; int i = 0, j = 0; while(j &lt; nums.length){ currSum += nums[j]; while(currSum &gt;= target &amp;&amp; i &lt; nums.length){ min = Math.min(min, j - i + 1); currSum -= nums[i++]; } j++; } return min == Integer.MAX_VALUE? 0 : min; } } . ",
    "url": "https://1001anjan.github.io/problem-98-Minimum%20Size%20Subarray%20Sum/",
    "relUrl": "/problem-98-Minimum Size Subarray Sum/"
  },"701": {
    "doc": "Design Add and Search Words Data Structure",
    "title": "Design Add and Search Words Data Structure",
    "content": "Design a data structure that supports adding new words and finding if a string matches any previously added string. Implement the WordDictionary class: . | WordDictionary() Initializes the object. | void addWord(word) Adds word to the data structure, it can be matched later. | bool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots ‘.’ where dots can be matched with any letter. | . Example: . Input [\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"] [[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]] Output [null,null,null,null,false,true,true,true] Explanation WordDictionary wordDictionary = new WordDictionary(); wordDictionary.addWord(\"bad\"); wordDictionary.addWord(\"dad\"); wordDictionary.addWord(\"mad\"); wordDictionary.search(\"pad\"); // return False wordDictionary.search(\"bad\"); // return True wordDictionary.search(\".ad\"); // return True wordDictionary.search(\"b..\"); // return True . Constraints: . | 1 &lt;= word.length &lt;= 25 | word in addWord consists of lowercase English letters. | word in search consist of ‘.’ or lowercase English letters. | There will be at most 3 dots in word for search queries. | At most 10^4 calls will be made to addWord and search. | . Solution . class WordDictionary { private static class TreeNode{ boolean exists; TreeNode[] children = new TreeNode[26]; } private TreeNode root; public WordDictionary() { root = new TreeNode(); } public void addWord(String word) { TreeNode node = root; for(int i = 0; i &lt; word.length(); i++){ int id = word.charAt(i) - 'a'; if(node.children[id] == null) node.children[id] = new TreeNode(); node = node.children[id]; } node.exists = true; } public boolean search(String word) { return search(word, 0, root); } private boolean search(String word, int start, TreeNode node){ if(start &gt;= word.length()) return node.exists; char ch = word.charAt(start); if(start == word.length() - 1){ if(ch == '.'){ for(int i = 0; i &lt; 26; i++){ if(node.children[i] != null &amp;&amp; node.children[i].exists) return true; } return false; }else{ int id = ch - 'a'; TreeNode n = node.children[id]; if(n == null) return false; return n.exists; } } if(ch == '.'){ for(int i = 0; i &lt; 26; i++){ if(node.children[i] != null &amp;&amp; search(word, start + 1, node.children[i])) return true; } }else{ int i = ch - 'a'; if(node.children[i] != null &amp;&amp; search(word, start + 1, node.children[i])) return true; } return false; } } /** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * boolean param_2 = obj.search(word); */ . ",
    "url": "https://1001anjan.github.io/problem-99-Design%20Add%20and%20Search%20Words%20Data%20Structure/",
    "relUrl": "/problem-99-Design Add and Search Words Data Structure/"
  },"702": {
    "doc": "Student Attendance Record I",
    "title": "Student Attendance Record I",
    "content": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: . | ‘A’: Absent. | ‘L’: Late. | ‘P’: Present. The student is eligible for an attendance award if they meet both of the following criteria: . | The student was absent (‘A’) for strictly fewer than 2 days total. | The student was never late (‘L’) for 3 or more consecutive days. | Return true if the student is eligible for an attendance award, or false otherwise. | . Example 1: . Input: s = \"PPALLP\" Output: true Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days. Example 2: . Input: s = \"PPALLL\" Output: false Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s[i] is either ‘A’, ‘L’, or ‘P’. | . Solution: . class Solution { public boolean checkRecord(String s) { int abs = 0; int late = 0; int i = 0; while(i&lt;s.length()){ char ch = s.charAt(i); if(ch == 'A') abs++; if(ch == 'L'){ late++; i++; while(i&lt;s.length()){ ch = s.charAt(i); if(ch != 'L'){ i--; break; }else{ late++; i++; } } if(late&gt;=3) return false; late = 0; } i++; } if(abs&gt;=2 ) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-99-Student-Attendance-Record-I/",
    "relUrl": "/problem-99-Student-Attendance-Record-I/"
  },"703": {
    "doc": "Access application.yml property in springBoot app",
    "title": "Access application.yml property in springBoot app",
    "content": "In a Spring Boot application, you can access properties defined in the application.yml file by using the @Value annotation and specifying the property key. For example, if you have a property app.name defined in the application.yml file, you can access its value in a controller class like this: . @Value(\"${app.name}\") private String appName; . You can also use the @ConfigurationProperties annotation on a class to bind the properties in the application.yml file to that class. For example, if you have the following properties defined in the application.yml file: . app: name: MyApp version: 1.0 . You can create a class like this: . @ConfigurationProperties(prefix = \"app\") public class AppProperties { private String name; private String version; //getters and setters } . And then autowire it in your controller or service class: . @Autowired private AppProperties appProperties; . You can then access the properties using this object. String appName = appProperties.getName(); String appVersion = appProperties.getVersion(); . Note that for @ConfigurationProperties you’ll need to enable it by adding the following annotation in your configuration class or main class . @EnableConfigurationProperties(AppProperties.class) . Can we use @value in java interface? . No, you cannot use the @Value annotation in a Java interface. The @Value annotation is used to inject a property value into a field, constructor or setter method, and it can only be used on a class or bean. Since an interface is not a class or bean, it cannot be used to hold state, therefore it is not possible to use @Value annotation on interface. It’s worth noting that interfaces in Java do not have any implementation, they only define method signatures. And Spring uses @Value annotation to set the value of a field in a specific instance of a class, which is not possible for interfaces. If you want to share some properties across multiple classes, you can use the @ConfigurationProperties annotation on a class and autowire it in other classes. Alternatively, you can use Environment object to access the property values, or use PropertySourcesPlaceholderConfigurer for XML based configuration. How to access application.conf properties in spring boot . In Spring Boot, you can access properties defined in the application.conf file by using the @Value annotation and specifying the property key. For example, if you have a property app.name defined in the application.conf file, you can access its value in a controller class like this: . @Value(\"${app.name}\") private String appName; . You can also use the @ConfigurationProperties annotation on a class to bind the properties in the application.conf file to that class. For example, if you have the following properties defined in the application.conf file: . app { name = \"MyApp\" version = \"1.0\" } . You can create a class like this: . @ConfigurationProperties(prefix = \"app\") public class AppProperties { private String name; private String version; //getters and setters } . And then autowire it in your controller or service class: . @Autowired private AppProperties appProperties; . You can then access the properties using this object. String appName = appProperties.getName(); String appVersion = appProperties.getVersion(); . In order to use application.conf you need to configure the application to use it, the most common way of doing this is by adding the following dependency in your pom.xml file: . &lt;dependency&gt; &lt;groupId&gt;com.typesafe&lt;/groupId&gt; &lt;artifactId&gt;config&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; . And then, you need to configure the application to look for the application.conf file in the classpath, by adding this to your application.properties or application.yml file: . spring.config.name=application spring.config.location=classpath: . Note that for @ConfigurationProperties you’ll need to enable it by adding the following annotation in your configuration class or main class . @EnableConfigurationProperties(AppProperties.class) . Example of @EnableConfigurationProperties(AppConfig.class) . Here is an example of how to use the @EnableConfigurationProperties annotation to enable a configuration class called AppConfig: . @Configuration @EnableConfigurationProperties(AppConfig.class) public class AppConfig { @Value(\"${app.name}\") private String appName; public String getAppName() { return appName; } } . In this example, the @EnableConfigurationProperties annotation is used on the AppConfig class to indicate that it should be used as a source for configuration properties. The @Value annotation is used to inject a property called app.name from the application.properties file. You can then autowire this configuration class in other beans. @Autowired AppConfig appConfig; . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-1-How-to-access%20application_yml%20property%20in%20springBoot%20app/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-1-How-to-access%20application_yml%20property%20in%20springBoot%20app/"
  },"704": {
    "doc": "implement multiple",
    "title": "Implement multiple",
    "content": "In Spring Boot, you can implement multiple listeners for Kafka by creating multiple methods and annotating them with @KafkaListener. Each method should have a unique topic and group id. For example: . @KafkaListener(topics = \"topic1\", groupId = \"group1\") public void listenTopic1(String message) { // handle message for topic1 } @KafkaListener(topics = \"topic2\", groupId = \"group2\") public void listenTopic2(String message) { // handle message for topic2 } . You can also configure multiple listeners by creating multiple Kafka listener container factories and configuring them with different group ids and concurrency. @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory1() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); factory.getContainerProperties().setPollTimeout(3000); return factory; } . You can then annotate your listener methods with the appropriate container factory bean. @KafkaListener(topics = \"topic1\", containerFactory = \"kafkaListenerContainerFactory1\") public void listenTopic1(String message) { // handle message for topic1 } . Here’s a sample example in Spring Boot to implement multiple listeners for Kafka: . @SpringBootApplication public class KafkaMultipleListenersExample { @Value(\"${kafka.bootstrap-servers}\") private String bootstrapServers; public static void main(String[] args) { SpringApplication.run(KafkaMultipleListenersExample.class, args); } @Bean public Map&lt;String, Object&gt; consumerConfigs() { Map&lt;String, Object&gt; props = new HashMap&lt;&gt;(); props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers); props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class); return props; } @Bean public ConsumerFactory&lt;String, String&gt; consumerFactory() { return new DefaultKafkaConsumerFactory&lt;&gt;(consumerConfigs()); } @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory1() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(3); return factory; } @Bean public KafkaListenerContainerFactory&lt;ConcurrentMessageListenerContainer&lt;String, String&gt;&gt; kafkaListenerContainerFactory2() { ConcurrentKafkaListenerContainerFactory&lt;String, String&gt; factory = new ConcurrentKafkaListenerContainerFactory&lt;&gt;(); factory.setConsumerFactory(consumerFactory()); factory.setConcurrency(2); return factory; } @KafkaListener(topics = \"topic1\", containerFactory = \"kafkaListenerContainerFactory1\") public void listenTopic1(String message) { System.out.println(\"Received message from topic1: \" + message); } @KafkaListener(topics = \"topic2\", containerFactory = \"kafkaListenerContainerFactory2\") public void listenTopic2(String message) { System.out.println(\"Received message from topic2: \" + message); } } . In this example, we have two listener methods listenTopic1 and listenTopic2 each for a different topic. Each of these methods is annotated with @KafkaListener and configured to use a different Kafka listener container factory kafkaListenerContainerFactory1 and kafkaListenerContainerFactory2 respectively. These container factories are created and configured using the kafkaListenerContainerFactory1 and kafkaListenerContainerFactory2 methods. In Spring Boot, the Kafka consumer is automatically managed by the framework, so you do not need to explicitly shut it down when the application stops. When the application context is closed, for example, when the application is shut down or restarted, the consumer is automatically closed and all its resources are cleaned up. However, if you need to manually shut down the consumer in a controlled manner, you can use the KafkaListenerEndpointRegistry to get a reference to the listener container and stop it. Here’s an example: . @Autowired private KafkaListenerEndpointRegistry kafkaListenerEndpointRegistry; ... @PreDestroy public void stopKafkaConsumer() { kafkaListenerEndpointRegistry.stop(); } . In this example, the stopKafkaConsumer method annotated with @PreDestroy is called when the application is shut down, and it stops the Kafka consumer using the KafkaListenerEndpointRegistry. Difference between kafka poll and kafka listener . The difference between using the Kafka consumer poll method and the Kafka listener in Spring Boot is in the way that messages are consumed from a Kafka topic. Kafka Consumer Poll: The poll method is a low-level API that allows you to manually poll for messages from a Kafka topic. You have to manage the consumer offsets and handle the consumer rebalance events yourself. You also have to handle threading, batching, and error handling yourself. Example: . public void pollKafka() { Consumer&lt;String, String&gt; consumer = createConsumer(); while (true) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); for (ConsumerRecord&lt;String, String&gt; record : records) { System.out.println(\"Received message: \" + record.value()); } } } . Kafka Listener: The Kafka listener in Spring Boot provides a higher-level abstraction on top of the poll method. The listener automatically manages the consumer offsets and handles the consumer rebalance events for you. The framework also provides built-in support for batch processing, error handling, and concurrency control. Example: . @KafkaListener(topics = \"topic\") public void listen(String message) { System.out.println(\"Received message: \" + message); } . In general, the Kafka listener is easier to use and provides more features compared to the poll method, making it the preferred choice for most use cases in a Spring Boot application. Note1 . The poll mechanism in Kafka is a low-level API that allows you to manually poll for messages from a Kafka topic. You have to manage the consumer offsets, handle the consumer rebalance events, handle threading, batching, and error handling yourself. Here are some use cases where using the poll mechanism might be appropriate: . Custom processing logic: When you need to implement custom processing logic that is not supported by the Kafka listener, you might choose to use the poll mechanism. For example, if you need to process messages in a specific order, you might use the poll method to implement the custom logic. Real-time streaming: When you need to process messages in real-time, you might choose to use the poll mechanism. This allows you to have full control over the polling frequency and the processing of messages. Legacy applications: If you have an existing application that uses the poll mechanism, you might continue to use it instead of switching to the Kafka listener. Performance optimization: If you have specific performance requirements and need to fine-tune the polling frequency and batch size, you might choose to use the poll mechanism. In general, the poll mechanism is more complex and requires more manual work compared to the Kafka listener, but it offers more control and flexibility over the consumption of messages from a Kafka topic . Note 2 . Spring Framework managed Kafka listener is best suited for simple to moderate data processing and can handle the load with its automatic partition assignment and offset management. On the other hand, the Kafka Consumer API with manual poll approach provides more control and customization over the consumption process, making it suitable for more complex and large scale data processing scenarios. Ultimately, the choice between these two approaches should be based on the specific requirements of your use case and the trade-off between ease of use and customization. ",
    "url": "https://1001anjan.github.io/docs/Kafka/Quick%20Notes/qn-1-Implement%20multiple/#implement-multiple",
    "relUrl": "/docs/Kafka/Quick%20Notes/qn-1-Implement%20multiple/#implement-multiple"
  },"705": {
    "doc": "implement multiple",
    "title": "implement multiple",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Kafka/Quick%20Notes/qn-1-Implement%20multiple/",
    "relUrl": "/docs/Kafka/Quick%20Notes/qn-1-Implement%20multiple/"
  },"706": {
    "doc": "Kafka consumer",
    "title": "Kafka consumer",
    "content": "@PostConstruct . @PostConstruct is a JSR-250 annotation that indicates a method should be executed after the object has been instantiated and all dependencies have been injected. In other words, it is used to indicate a method that should be executed after the object is constructed and initialized. It is commonly used in Spring to execute any necessary initializations after the dependencies have been injected. The method annotated with @PostConstruct is guaranteed to be called only once in the life cycle of an object. @PreDestroy . @PreDestroy is a JSR-250 annotation that indicates a method should be executed before the object is destroyed by the container. It is commonly used in Spring to perform any necessary cleanup or resource release before the object is destroyed. The method annotated with @PreDestroy is guaranteed to be called only once in the life cycle of an object. Kafka consumer wakeup method . The wakeup method is used in Apache Kafka Consumer API to interrupt the consumer’s fetch loop and cause it to throw a WakeupException. This can be useful in situations where you want to shut down a consumer gracefully, without waiting for the poll loop to complete. For example, you may have a scenario where you want to stop consuming messages from a topic and perform some cleanup actions. You can call the wakeup method on the consumer instance in another thread, which will interrupt the poll method and allow you to perform your cleanup logic before closing the consumer. Here’s an example implementation: . private final Consumer&lt;String, String&gt; consumer; private volatile boolean shutdown = false; public void runConsumer() { try { while (!shutdown) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); // process the records } } catch (WakeupException e) { if (!shutdown) { throw e; } } finally { consumer.close(); } } public void shutdown() { shutdown = true; consumer.wakeup(); } . In this example, the runConsumer method polls for messages from a Kafka topic and processes them. The shutdown method sets the shutdown flag to true and calls wakeup on the consumer instance, which will interrupt the poll method and allow for clean shutdown of the consumer. consumerThreadPool.shutdown() is used to stop the execution of tasks in a thread pool. It stops accepting new tasks, but waits for the running tasks to complete. When all running tasks are completed, the thread pool is considered shut down. In your case, you would use this method to stop the thread pool that is executing the consumer’s polling loop. After that, you would call consumer.wakeup() to interrupt the polling loop and trigger a WakeupException, allowing you to perform any necessary cleanup logic before closing the consumer. Here’s an example implementation: . private final ExecutorService consumerThreadPool; private final Consumer&lt;String, String&gt; consumer; private volatile boolean shutdown = false; public void runConsumer() { try { while (!shutdown) { ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(100)); // process the records } } catch (WakeupException e) { if (!shutdown) { throw e; } } finally { consumer.close(); } } public void shutdown() { shutdown = true; consumer.wakeup(); consumerThreadPool.shutdown(); } . In this example, the shutdown method sets the shutdown flag to true and calls consumerThreadPool.shutdown() to stop the consumer’s thread pool, and then calls consumer.wakeup() to interrupt the poll method and trigger a WakeupException. This allows you to perform any necessary cleanup logic before closing the consumer. ",
    "url": "https://1001anjan.github.io/docs/Kafka/Quick%20Notes/qn-2-annotation/",
    "relUrl": "/docs/Kafka/Quick%20Notes/qn-2-annotation/"
  },"707": {
    "doc": "Spring reactor vs computable future",
    "title": "Spring reactor vs computable future",
    "content": "Spring Reactor and Computable Futures are both reactive programming frameworks. Spring Reactor is part of the Spring framework, a Java-based framework for building web applications. Reactor provides a reactive programming model for building applications that are responsive, resilient, and scalable. It integrates with the Spring ecosystem and provides a foundation for building reactive applications with the Spring framework. Computable Futures is a Java library for building asynchronous and non-blocking applications using Java’s CompletableFuture API. It provides a set of convenient utility methods for working with CompletableFuture objects and supports functional composition and error handling. In summary, both frameworks provide support for reactive programming, but Spring Reactor is more focused on integration with the Spring framework while Computable Futures focuses on utilizing the CompletableFuture API. Choices . The best choice between Spring Reactor and Computable Futures depends on the specific needs of a project. If you are building a Java-based web application and want to use a reactive programming model, Spring Reactor is a good choice as it is integrated with the Spring framework and provides a comprehensive solution for building reactive applications. If you want to use the CompletableFuture API for building asynchronous and non-blocking applications, Computable Futures might be a better choice. It provides a set of convenient utility methods for working with CompletableFuture objects, and supports functional composition and error handling. Ultimately, the best choice depends on the requirements of your specific project, so it’s important to consider the features, benefits, and limitations of both frameworks before making a decision. Some use cases for Spring Reactor and Computable Futures are: . Spring Reactor: . | Building web applications that need to handle high levels of concurrency and handle a large number of requests efficiently. | Applications that need to process and aggregate data from multiple sources in real-time. | Building microservices architecture and reactive systems. | . Computable Futures: . | Applications that need to perform multiple independent operations in parallel and want to process the results as soon as they become available. | Applications that need to perform long-running operations asynchronously to improve responsiveness. | Applications that need to handle errors and exceptions during the execution of asynchronous operations. | . Note: These are just examples and there may be other use cases that are better suited to a specific framework. It’s important to consider the specific requirements of a project before deciding which framework to use. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-2spring%20reactor%20vs%20computable%20future/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-2spring%20reactor%20vs%20computable%20future/"
  },"708": {
    "doc": "Neo4j Health check",
    "title": "Neo4j Health check",
    "content": "@Configuration public class Neo4jHealthIndicator extends AbstractHealthIndicator { @Autowired Neo4jService neo4jService; @Override protected void doHealthCheck(Health.Builder builder) throws Exception { List&lt;Record&gt; statement = neo4jService.runStatement(\"CALL dbms.queryJmx('org.neo4j:*')\", null); if (statement != null &amp;&amp; statement.size() &gt; 0) { builder.up(); } else { builder.down(); } } } . You need to implement Neo4jService to communicate with Neo4j database. This can be covered in the separate post. AbstractHealthIndicator can found in the Spring Actuator library . Using Spring reactor . @Component public class Neo4jHealthIndicator implements ReactiveHealthIndicator { private final Neo4jService neo4jService; public Neo4jHealthIndicator(Neo4jService neo4jService) { this.neo4jService = neo4jService; } @Override public Mono&lt;Health&gt; health() { return Mono.fromSupplier(() -&gt; neo4jService.runStatement(\"CALL dbms.queryJmx('org.neo4j:*')\", null)) .flatMap(statement -&gt; { if (statement != null &amp;&amp; statement.size() &gt; 0) { return Mono.just(Health.up().build()); } else { return Mono.just(Health.down().build()); } }).onErrorResume(e -&gt; Mono.just(Health.down().withException(e).build())); } } . Mono.fromSupplier . Mono.fromSupplier is a factory method in the Reactor framework used to create a Mono from a java.util.function.Supplier. It allows you to lazily produce a single item that will be emitted by the returned Mono when subscribed to. The Supplier is a functional interface that can be implemented to provide a value. The Mono.fromSupplier method takes a Supplier as an argument and returns a Mono that, when subscribed to, will call the Supplier to produce a value. The value produced by the Supplier is then emitted as the single item in the reactive stream. In the code snippet, the Mono.fromSupplier method is used to wrap the result of the call to neo4jService.runStatement in a Mono. This allows the result of the call to be transformed using the flatMap method. @Configuration public class Neo4jHealthIndicator extends ReactiveHealthIndicator { private final Neo4jService neo4jService; public Neo4jHealthIndicator(Neo4jService neo4jService) { this.neo4jService = neo4jService; } @Override public Mono&lt;Health&gt; health() { return Mono.defer(() -&gt; { return neo4jService.runStatement(\"CALL dbms.queryJmx('org.neo4j:*')\", null) .flatMap(statement -&gt; { if (statement != null &amp;&amp; statement.size() &gt; 0) { return Health.up().build(); } else { return Health.down().build(); } }); }); } } . Mono.defer . Mono.defer is a factory method in the Reactor framework used to delay the creation of a Mono until it is subscribed to. When a Mono created with Mono.defer is subscribed to, the function passed to Mono.defer is executed and its result is used to produce the Mono. This allows for creating a new Mono every time it is subscribed to, ensuring that its behavior is up-to-date. Difference between Mono.fromSupplier and Mono.defer . Mono.fromSupplier and Mono.defer are both factory methods used to create a Mono in the Reactor framework. The main difference between them is when the supplier passed to Mono.fromSupplier is executed and when the deferred computation passed to Mono.defer is executed. Mono.fromSupplier executes the supplier immediately when the Mono is created, while Mono.defer delays the execution of the deferred computation until the Mono is subscribed to. In other words, Mono.fromSupplier executes the supplier as soon as the Mono is created, whereas Mono.defer executes the deferred computation each time the Mono is subscribed to. This allows Mono.defer to produce up-to-date values each time it is subscribed to. In the code snippet, Mono.defer was used because the behavior of the health check needs to be updated each time it is executed. Using Mono.fromSupplier would have resulted in the same value being emitted each time the Mono is subscribed to, which would not reflect the current state of the health check. Sample Rest controller . @RestController public class AdminController { private static final Logger LOGGER = LoggerFactory.getLogger(AdminController.class); @GetMapping(value = \"/health\") public Mono&lt;ResponseEntity&lt;Void&gt;&gt; getHealth() { LOGGER.info(\"AdminController: health api called!\"); return Mono.just(new ResponseEntity&lt;&gt;(HttpStatus.OK)); } } . @RestController public class AdminController { private static final Logger LOGGER = LoggerFactory.getLogger(AdminController.class); @GetMapping(value = \"/health\") public ResponseEntity&lt;Void&gt; getHealth(){ LOGGER.info(\"AdminController: health api called!\"); return new ResponseEntity&lt;&gt;(HttpStatus.OK); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-3Neo4j-health-check/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-3Neo4j-health-check/"
  },"709": {
    "doc": "Add Swagger to a Spring Boot project",
    "title": "Add Swagger to a Spring Boot project",
    "content": "To add Swagger to a Spring Boot project in Java, you can follow these steps: . | Add the following dependencies to your pom.xml file: | . &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; . | Create a SwaggerConfig.java file with the following content: ```java import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.ApiInfoBuilder; import springfox.documentation.builders.PathSelectors; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; | . @Configuration @EnableSwagger2 public class SwaggerConfig { @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build() .apiInfo(apiInfo()); } . private ApiInfo apiInfo() { return new ApiInfoBuilder() .title(\"API Documentation\") .description(\"API for your Spring Boot application\") .version(\"1.0\") .build(); } } ``` 3. Start your Spring Boot application and access the Swagger UI at `http://localhost:8080/swagger-ui.html`. Note: The URLs and versions may differ based on your setup. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-4-add%20Swagger%20to%20a%20Spring%20Boot%20project/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-4-add%20Swagger%20to%20a%20Spring%20Boot%20project/"
  },"710": {
    "doc": "Health Check PostGress SQL",
    "title": "Health Check PostGress SQL",
    "content": "A health check in Spring Boot is a way to monitor the status of your application’s components and dependencies, such as a PostgreSQL database. To perform a health check on a PostgreSQL database, you can create a custom health indicator in your Spring Boot application that connects to the database and checks its status. Here is an example of how you could implement this: . | Add the following dependency to your build.gradle or pom.xml file to include the PostgreSQL JDBC driver: | . dependencies { implementation 'org.postgresql:postgresql:42.2.14' } . | Create a new class that implements the HealthIndicator interface: ```java import org.springframework.boot.actuate.health.Health; import org.springframework.boot.actuate.health.HealthIndicator; import org.springframework.stereotype.Component; | . import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; . @Component public class PostgresHealthIndicator implements HealthIndicator { . @Override public Health health() { try { Class.forName(\"org.postgresql.Driver\"); Connection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost:5432/postgres\", \"postgres\", \"password\"); connection.close(); return Health.up().build(); } catch (ClassNotFoundException | SQLException e) { return Health.down().build(); } } } ``` . | In the health method, you can connect to the PostgreSQL database using the JDBC driver, and return a Health.up().build() if the connection is successful. If the connection fails, return Health.down().build() to indicate that the database is not healthy. | . You can access the health status of the database by visiting the /actuator/health endpoint in your application. Note: You should customize the JDBC connection string, username, and password in the code to match your PostgreSQL database configuration. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-5-Health_check-postgress/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-5-Health_check-postgress/"
  },"711": {
    "doc": "Health Check AMQP",
    "title": "Health check AMQP",
    "content": "import com.rabbitmq.client.Channel; import com.rabbitmq.client.GetResponse; import com.signify.flexc.dataanalytics.amqp.AmqpClient; import org.springframework.boot.actuate.health.AbstractHealthIndicator; import org.springframework.boot.actuate.health.Health; import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty; import org.springframework.context.annotation.Configuration; @Configuration @ConditionalOnProperty(value=\"health.amqp.enabled\", havingValue = \"true\", matchIfMissing = true) public class AmqpHealthIndicator extends AbstractHealthIndicator { private AmqpClient amqpClient; public AmqpHealthIndicator(AmqpClient amqpClient){ this.amqpClient = amqpClient; } @Override protected void doHealthCheck(Health.Builder builder) throws Exception { Channel channel = amqpClient.getAmqpChannel(); channel.queueDeclare(\"health_check_queue\", false, false, false, null); channel.basicPublish(\"\", \"health_check_queue\", null, \"health_check\".getBytes()); GetResponse response = channel.basicGet(\"health_check_queue\", true); if (response != null) { Health.up().build(); }else { Health.down().build(); } } } . @Service public class AmqpClient { private static final Logger logger = LoggerFactory.getLogger(AmqpClient.class); private static final int PoolSize = 5; private ConnectionFactory factory; private Connection connection; private ExecutorService channelsExecutor; private ThreadLocal&lt;Channel&gt; channelsThreadLocal; @Value(\"${amqp.uri}\") public String AmqpUri; @PostConstruct public void AmqpClient() throws IOException, TimeoutException, URISyntaxException, NoSuchAlgorithmException, KeyManagementException { factory = new ConnectionFactory(); factory.setUri(AmqpUri); factory.setAutomaticRecoveryEnabled(true); connection = factory.newConnection(); channelsExecutor = Executors.newFixedThreadPool(PoolSize); channelsThreadLocal = new ThreadLocal&lt;Channel&gt;() { @Override protected Channel initialValue() { Channel channel = null; try { channel = connection.createChannel(); } catch (IOException e) { e.printStackTrace(); } return channel; } }; } public Channel getAmqpChannel(){ return channelsThreadLocal.get(); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-6-health-check-amqp/#health-check-amqp",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-6-health-check-amqp/#health-check-amqp"
  },"712": {
    "doc": "Health Check AMQP",
    "title": "Health Check AMQP",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/qn-6-health-check-amqp/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/qn-6-health-check-amqp/"
  },"713": {
    "doc": "Quick Notes",
    "title": "Quick Notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Kafka/Quick%20Notes/quickNotes/",
    "relUrl": "/docs/Kafka/Quick%20Notes/quickNotes/"
  },"714": {
    "doc": "Quick Notes",
    "title": "Quick Notes",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Quick%20Notes/quickNotes/",
    "relUrl": "/docs/SpringBoot/Quick%20Notes/quickNotes/"
  },"715": {
    "doc": "Spring Reactor",
    "title": "Spring Reactor",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/springReactor/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/springReactor/"
  },"716": {
    "doc": "Spring Boot",
    "title": "Spring Boot",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/springboot/",
    "relUrl": "/docs/SpringBoot/springboot/"
  },"717": {
    "doc": "Getting Started Spring Reactor",
    "title": "Getting Started Spring Reactor",
    "content": "Mono . Mono in Spring Reactor is a reactive programming type representing a stream of zero or one element. It is part of the Reactive Streams specification and is used in Spring Reactor to handle non-blocking and asynchronous processing of data. It can be used to return a single value, error or completion signal to the subscriber. With Mono, you can create, compose, and manipulate reactive streams of data in a non-blocking manner, making it a great fit for modern, asynchronous systems. Here’s a simple example of how to use Mono in Spring Boot: . @RestController public class ExampleController { @GetMapping(\"/example\") public Mono&lt;String&gt; exampleEndpoint() { return Mono.just(\"Hello from Spring Boot!\"); } } . In this example, the exampleEndpoint method returns a Mono object containing a single string value “Hello from Spring Boot!”. When this endpoint is called, the returned Mono will emit the string to the subscriber, which in this case will be sent as the response to the HTTP request. You can also use Mono to handle more complex scenarios, such as making asynchronous API calls, processing and transforming data, and handling errors. Mono.just . Mono.just is a factory method used to create a Mono that emits a single item. It is a convenient way to wrap a single value into a reactive stream that can be processed asynchronously. For example, you can use Mono.just to return a single string, number, or object as the response to an HTTP request: . @GetMapping(\"/example\") public Mono&lt;String&gt; exampleEndpoint() { return Mono.just(\"Hello from Spring Boot!\"); } . In this example, the Mono.just method is used to create a Mono containing the string “Hello from Spring Boot!”. When this endpoint is called, the Mono will emit the string to the subscriber, which in this case will be sent as the response to the HTTP request. You can also use Mono.just to create a Mono that emits a custom object, like this: . @GetMapping(\"/user\") public Mono&lt;User&gt; getUser() { User user = new User(\"John Doe\", \"john.doe@example.com\"); return Mono.just(user); } . In this example, a User object is created and wrapped in a Mono using Mono.just. When this endpoint is called, the Mono will emit the User object to the subscriber, which in this case will be sent as the response to the HTTP request. Flux . To send a list of objects as the response to an HTTP request in Spring Boot, you can use the Flux type. Flux is a reactive type that represents a stream of zero or more elements. It is also part of the Reactive Streams specification and is used in Spring Reactor to handle non-blocking and asynchronous processing of data. Here’s an example of how to send a list of User objects as the response to an HTTP request: . @GetMapping(\"/users\") public Flux&lt;User&gt; getUsers() { List&lt;User&gt; users = Arrays.asList( new User(\"John Doe\", \"john.doe@example.com\"), new User(\"Jane Doe\", \"jane.doe@example.com\"), new User(\"Jim Smith\", \"jim.smith@example.com\") ); return Flux.fromIterable(users); } . In this example, a list of User objects is created and wrapped in a Flux using the Flux.fromIterable method. When this endpoint is called, the Flux will emit each User object to the subscriber, one by one, as a stream of data. The subscriber will receive the list of User objects as the response to the HTTP request. Flux.fromIterable . Flux.fromIterable is a factory method used to create a Flux from an Iterable object, such as a List. It allows you to wrap an Iterable object into a reactive stream that can be processed asynchronously. For example, if you have a list of User objects and you want to send this list as the response to an HTTP request, you can use Flux.fromIterable to wrap the list in a Flux, like this: . @GetMapping(\"/users\") public Flux&lt;User&gt; getUsers() { List&lt;User&gt; users = Arrays.asList( new User(\"John Doe\", \"john.doe@example.com\"), new User(\"Jane Doe\", \"jane.doe@example.com\"), new User(\"Jim Smith\", \"jim.smith@example.com\") ); return Flux.fromIterable(users); } . In this example, the Flux.fromIterable method is used to create a Flux containing the list of User objects. When this endpoint is called, the Flux will emit each User object to the subscriber, one by one, as a stream of data. The subscriber will receive the list of User objects as the response to the HTTP request. Flux.fromIterable is a convenient way to wrap an Iterable object into a reactive stream, allowing you to process its elements asynchronously and non-blockingly. Note: . In Spring Boot, the service layer is typically responsible for implementing the business logic of your application. Here’s an example of a simple service layer implementation: . @Service public class UserService { private final UserRepository userRepository; public UserService(UserRepository userRepository) { this.userRepository = userRepository; } public Flux&lt;User&gt; getAllUsers() { return userRepository.findAll(); } public Mono&lt;User&gt; getUserById(String id) { return userRepository.findById(id); } public Mono&lt;User&gt; createUser(User user) { return userRepository.save(user); } public Mono&lt;Void&gt; deleteUser(String id) { return userRepository.deleteById(id); } } . In this example, the UserService class is annotated with @Service, which is a stereotype annotation indicating that this class is a service layer component. The service layer component is responsible for implementing the business logic of the application. The UserService class has a constructor that takes a UserRepository as an argument. The UserRepository is an interface that extends ReactiveCrudRepository, which provides basic CRUD operations for reactive data access. The UserService class provides several methods that implement the business logic of the application, such as getAllUsers, which returns a list of all users, getUserById, which returns a single user by its ID, createUser, which creates a new user, and deleteUser, which deletes a user by its ID. In this example, the methods return reactive types, such as Flux or Mono, to represent asynchronous and non-blocking data processing. The reactive types are returned by the methods of the UserRepository interface, which is used by the service layer to access the data stored in the database. Note 2: . Here’s an example of a service layer method that makes multiple HTTP requests and combines the results into a custom object: . @Service public class UserService { private final WebClient webClient; public UserService(WebClient webClient) { this.webClient = webClient; } public Mono&lt;UserProfile&gt; getUserProfile(String userId) { return Mono.zip( webClient.get().uri(\"/user/{userId}\", userId).retrieve().bodyToMono(User.class), webClient.get().uri(\"/user/{userId}/posts\", userId).retrieve().bodyToFlux(Post.class), webClient.get().uri(\"/user/{userId}/comments\", userId).retrieve().bodyToFlux(Comment.class), (user, posts, comments) -&gt; { UserProfile userProfile = new UserProfile(user, posts, comments); return userProfile; } ); } } . In this example, the UserService class has a constructor that takes a WebClient as an argument. The WebClient is a reactive HTTP client provided by Spring Webflux that allows you to make non-blocking HTTP requests. The getUserProfile method makes three HTTP requests to different endpoints using the WebClient. The first request is to retrieve the user information, the second request is to retrieve the posts made by the user, and the third request is to retrieve the comments made by the user. The Mono.zip method is used to combine the results of the three HTTP requests into a custom UserProfile object. The zip method takes three Monos as arguments and returns a single Mono that contains the result of combining the three Monos. In this case, the result of the zip method is a Mono that contains a UserProfile object, which is created by the lambda expression passed as the fourth argument to the zip method. When the getUserProfile method is called, it makes three asynchronous HTTP requests, combines the results of the requests into a UserProfile object, and returns the UserProfile as a Mono. This allows the service layer to make multiple HTTP requests and combine the results into a custom object in a non-blocking and asynchronous manner. Note 3: . Here’s an example of a service layer method that calls one HTTP request, then based on the result, calls another HTTP request, and finally returns the result: . @Service public class UserService { private final WebClient webClient; private final AnotherService anotherService; public UserService(WebClient webClient, AnotherService anotherService) { this.webClient = webClient; this.anotherService = anotherService; } public Mono&lt;Result&gt; getResult(String userId) { return webClient.get().uri(\"/user/{userId}\", userId).retrieve().bodyToMono(User.class) .flatMap(user -&gt; anotherService.getData(user.getData()) .flatMap(data -&gt; webClient.get().uri(\"/user/{userId}/data\", user.getData()).retrieve().bodyToMono(Data.class) .map(data -&gt; { Result result = new Result(user, data); return result; }) ) ); } } . In this example, the UserService class has a constructor that takes a WebClient and another AnotherService as arguments. The WebClient is a reactive HTTP client provided by Spring Webflux that allows you to make non-blocking HTTP requests. The AnotherService is another service that provides some business logic. The getResult method makes one HTTP request to retrieve the user information using the WebClient. The result of the first HTTP request is a Mono containing the user information. The flatMap operator is used to chain the second HTTP request and the call to the AnotherService. The second HTTP request is made using the flatMap operator and the user.getData() method, which retrieves the data from the first HTTP request. The result of the second HTTP request is a Mono containing the data. The AnotherService.getData method is called using the flatMap operator, and the result is a Mono containing the data processed by the AnotherService. The third HTTP request is made using the flatMap operator and the user.getData() method, which retrieves the data from the first HTTP request. The result of the third HTTP request is a Mono containing the data. The map operator is used to combine the results of the three steps into a single Result object . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-1-getting-start/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-1-getting-start/"
  },"718": {
    "doc": "Reactor Operator",
    "title": "Reactor Operator",
    "content": "Here is a list of some of the most commonly used reactive operators in Spring Reactor: . | map - transforms the elements emitted by a reactive type into another type. | flatMap - transforms a Mono into another Mono by applying a function to each element in the source Mono. | flatMapMany - transforms a Mono into a Flux by applying a function to each element in the source Mono and concatenating the resulting Flux with the Flux emitted by other elements. | filter - filters elements emitted by a reactive type based on a given predicate. | zipWith - combines elements emitted by two reactive types into a single stream by applying a function to each pair of elements. | reduce - reduces a Flux into a single value by applying a binary operator to each element. | take - limits the number of elements emitted by a reactive type. | first - returns the first element emitted by a reactive type. | last - returns the last element emitted by a reactive type. | doOnNext - performs an action for each element emitted by a reactive type. | doOnError - performs an action when an error occurs in a reactive type. | onErrorResume - returns a fallback reactive type if an error occurs in the source reactive type. | onErrorReturn - returns a default value if an error occurs in a reactive type. | retry - retries a reactive type if an error occurs. | . This is not an exhaustive list and there are many more operators available in Spring Reactor. These operators can be combined in various ways to build complex reactive processing pipelines. flatMap . flatMap is a reactive stream operator in Spring Reactor that transforms the elements emitted by a source Publisher into multiple Publishers and then flattens the elements from those into a single stream of values. You can use flatMap when you have a reactive stream and you need to perform an operation on each element that results in a stream of values, and then you want to flatten the results of those streams into a single stream of values. For example, you can use flatMap to perform multiple database queries for each item in a stream and then combine the results into a single stream of values. Here is a simple example that demonstrates how to use flatMap in Spring Reactor: . import reactor.core.publisher.Flux; public class FlatMapExample { public static void main(String[] args) { Flux&lt;String&gt; source = Flux.just(\"A\", \"B\", \"C\", \"D\", \"E\"); source.flatMap(s -&gt; Flux.fromArray(s.split(\"\"))) .subscribe(System.out::println); } } . In this example, the flatMap operator transforms the source Flux, which emits 5 strings, into multiple Flux instances that emit individual characters from each string. The resulting Flux is then flattened into a single stream of characters, which are printed to the console. The output of this program would be: . A B C D E . Here’s an example of using flatMap in a Spring Boot application: . import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; @RestController public class FlatMapExampleController { @GetMapping(\"/words\") public Flux&lt;String&gt; getWords() { return Flux.just(\"Hello\", \"World\") .flatMap(word -&gt; Flux.fromArray(word.split(\"\"))); } } . n this example, the getWords method returns a Flux of strings representing the characters in the words “Hello” and “World”. The flatMap operator is used to split each word into its individual characters and return a Flux of those characters. When you access the endpoint /words, you will receive a stream of characters representing the two words. For example: . H e l l o W o r l d . flatMap is used to transform a reactive stream into another stream that contains the values of the inner streams created by the flatMap operation. It allows you to perform an operation on each item in a reactive stream that results in another stream, and then combines all of the inner streams into a single stream of values. Here are some common use cases for flatMap: . | Asynchronous operations: When you need to perform an asynchronous operation on each item in a reactive stream, you can use flatMap to turn the results of that operation into another stream and then flatten the results. | Transformation of data: If you have a reactive stream of data and you need to perform some operation on each item that results in a new set of data, you can use flatMap to transform the data and create a new stream of values. | Parallel processing: If you have a reactive stream and you need to perform an operation on each item in parallel, you can use flatMap to split the stream into multiple streams and then combine the results. | Event-driven processing: If you have a reactive stream of events and you need to perform an operation on each event that results in another stream of events, you can use flatMap to flatten the results into a single stream of events. | . In summary, flatMap is a powerful operator that enables you to perform operations on reactive streams, create new streams, and flatten the results into a single stream of values. The map operator . The map operator is a reactive stream operator in Reactive Programming that is used to transform the elements of a reactive stream into new elements. The map operator applies a function to each element in a reactive stream and returns a new reactive stream that contains the results of the function applied to each element. Here is a simple example that demonstrates how to use the map operator: . import reactor.core.publisher.Flux; public class MapExample { public static void main(String[] args) { Flux&lt;Integer&gt; source = Flux.just(1, 2, 3, 4, 5); source.map(i -&gt; i * 2) .subscribe(System.out::println); } } . In this example, the map operator takes a Flux of integers and applies a function that multiplies each integer by 2. The resulting Flux is then subscribed to and the results are printed to the console. The output of this program would be: . 2 4 6 8 10 . So, the map operator is used to transform the elements of a reactive stream into new elements using a function. The function is applied to each element in the stream and the results are returned in a new reactive stream. The main difference between flatMap and map . The main difference between flatMap and map is the structure of the resulting reactive stream. The map operator transforms the elements of a reactive stream into new elements using a function. The function is applied to each element in the stream and the results are returned in a new reactive stream. The resulting reactive stream has the same number of elements as the original stream. The flatMap operator, on the other hand, transforms each element of a reactive stream into a new reactive stream using a function, and then combines all the inner streams into a single reactive stream of values. The resulting reactive stream can have a different number of elements than the original stream. Here is an example that demonstrates the difference between flatMap and map: . import reactor.core.publisher.Flux; public class MapAndFlatMapExample { public static void main(String[] args) { Flux&lt;String&gt; source = Flux.just(\"A\", \"B\", \"C\", \"D\", \"E\"); source.map(s -&gt; s.split(\"\")) .subscribe(System.out::println); source.flatMap(s -&gt; Flux.fromArray(s.split(\"\"))) .subscribe(System.out::println); } } . In this example, the first subscribe call uses the map operator to split each string in the source Flux into an array of characters. The resulting Flux is a stream of arrays of characters. The second subscribe call uses the flatMap operator to split each string in the source Flux into an array of characters and then flatten the resulting streams into a single stream of characters. The output of this program would be: . [A] [B] [C] [D] [E] A B C D E . Here is an example of using flatMap in a Spring Boot application: . import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; @RestController public class FlatMapExampleController { @GetMapping(\"/flatmap\") public Flux&lt;String&gt; getFlattenedStrings() { Flux&lt;String&gt; source = Flux.just(\"A\", \"B\", \"C\", \"D\", \"E\"); return source.flatMap(s -&gt; Flux.fromArray(s.split(\"\"))); } } . In this example, a REST endpoint is defined using the @RestController annotation. The getFlattenedStrings method returns a Flux of strings that have been transformed using the flatMap operator. The flatMap operator splits each string in the source Flux into an array of characters and then flattens the resulting streams into a single stream of characters. The endpoint can be accessed using a web client such as curl or a browser, and the result will be a stream of flattened characters. Here is an example of a method that returns a Mono in Spring Boot: . import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class VoidExampleController { @PostMapping(\"/void\") public Mono&lt;Void&gt; doSomething() { // Perform some action here return Mono.empty(); } } . In this example, a REST endpoint is defined using the @RestController annotation. The doSomething method returns a Mono&lt;Void&gt;, indicating that the endpoint does not return any data. The Mono.empty() method is used to create an empty Mono that represents a Void type. The @PostMapping annotation is used to specify that this endpoint should be accessed using an HTTP POST request. When this endpoint is accessed, it will perform some action and return a Void type, indicating that no data is returned. The .when and .then methods . The .when and .then methods in Spring Reactor are used to perform operations based on the results of a reactive stream. The .when method is used to conditionally perform an operation based on the value of a reactive stream. For example, you can use the .when method to perform an operation only when a certain condition is met. The .then method is used to perform an operation after a reactive stream has completed. For example, you can use the .then method to perform an action after a stream of data has been processed. Here is an example of using the .when and .then methods in Spring Reactor: . import reactor.core.publisher.Mono; Mono&lt;Integer&gt; source = Mono.just(10); source.when(s -&gt; s &gt; 5) .then(s -&gt; System.out.println(\"Value is greater than 5\")) .thenEmpty(Mono.empty()); . In this example, the source Mono contains a single value of 10. The .when method is used to perform a conditional operation based on the value of the source stream. In this case, the condition is that the value should be greater than 5. If the condition is met, the .then method is used to print a message to the console. The .thenEmpty method is used to complete the reactive stream and return an empty Mono. Here is an example of using the .when and .then methods in a Spring Boot application: . import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class WhenThenExampleController { @GetMapping(\"/when-then\") public Mono&lt;Void&gt; doSomething() { Mono&lt;Integer&gt; source = Mono.just(10); return source.when(s -&gt; s &gt; 5) .then(s -&gt; System.out.println(\"Value is greater than 5\")) .thenEmpty(Mono.empty()); } } . In this example, a REST endpoint is defined using the @RestController annotation. The doSomething method returns a Mono&lt;Void&gt;, indicating that the endpoint does not return any data. The source Mono contains a single value of 10. The .when method is used to perform a conditional operation based on the value of the source stream. In this case, the condition is that the value should be greater than 5. If the condition is met, the .then method is used to print a message to the console. The .thenEmpty method is used to complete the reactive stream and return an empty Mono. The endpoint can be accessed using an HTTP GET request to /when-then. When the endpoint is accessed, the doSomething method will be executed and the reactive stream will be processed, printing a message to the console if the value is greater than 5. A functional interface is an interface in Java . A functional interface is an interface in Java that has exactly one abstract method. Functional interfaces are used in Java 8 and later to create functional programming constructs, such as lambda expressions and method references. Here’s an example of how to use a functional interface in Java: . import java.util.function.Consumer; public class Example { public static void main(String[] args) { Consumer&lt;String&gt; printString = s -&gt; System.out.println(s); printString.accept(\"Hello World\"); } } . In this example, the Consumer interface is a functional interface defined in the java.util.function package. It has a single abstract method void accept(T t). A lambda expression is used to create an instance of the Consumer interface, which is then assigned to the variable printString. The accept method of the Consumer interface is then used to print the string “Hello World” to the console. You can use functional interfaces in conjunction with lambda expressions and method references to create concise and readable code, especially when working with streams and reactive programming constructs in Java. Here’s an example of how to use functional interfaces in a Spring Boot application: . import java.util.function.Function; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Mono; @RestController public class FunctionExampleController { @GetMapping(\"/square/{number}\") public Mono&lt;Integer&gt; squareNumber(@PathVariable int number) { Function&lt;Integer, Integer&gt; square = x -&gt; x * x; return Mono.just(square.apply(number)); } } . In this example, a REST endpoint is defined using the @RestController annotation. The squareNumber method takes a number as a path variable, squares it using a Function and returns the result as a Mono. The Function interface is a functional interface defined in the java.util.function package. It has a single abstract method R apply(T t), where R is the return type and T is the input type. In the example, a lambda expression is used to create an instance of the Function interface, which is then assigned to the variable square. The apply method of the Function interface is then used to square the number passed as an argument to the endpoint. There are several advantages of using functional interfaces in Java: . | Increased readability: Functional interfaces and lambda expressions can make your code more concise and readable, especially when working with streams and reactive programming constructs. | Improved performance: Using functional interfaces and lambda expressions can improve the performance of your code, especially when working with parallel streams or reactive programming. | Simplified code: Functional interfaces allow you to define functionality as a single abstract method, which can simplify your code and make it easier to understand. | Improved flexibility: By using functional interfaces, you can create a more flexible codebase that is easier to maintain and extend. For example, you can define an interface with a single abstract method, and then provide different implementations of that method for different use cases. | Better type inference: Java 8 and later versions support improved type inference, which allows the compiler to automatically determine the types of arguments and return values when working with functional interfaces and lambda expressions. | . Overall, functional interfaces and lambda expressions are a powerful tool for creating concise and readable code in Java, and can help you write better and more performant code, especially when working with streams and reactive programming constructs. import java.util.function.Function; import java.util.function.Supplier; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import reactor.core.publisher.Flux; import reactor.core.publisher.Mono; @RestController public class ComplexExampleController { @GetMapping(\"/employee/{id}\") public Mono&lt;Employee&gt; getEmployee(@PathVariable String id) { // First, we retrieve the employee data Mono&lt;EmployeeData&gt; employeeData = retrieveEmployeeData(id); // Then, we use flatMap to retrieve the employee's department Mono&lt;Department&gt; department = employeeData.flatMap(data -&gt; retrieveDepartment(data.getDepartmentId())); // Finally, we use map to create the final Employee object return Mono.zip(employeeData, department, this::createEmployee); } private Mono&lt;EmployeeData&gt; retrieveEmployeeData(String id) { return Mono.just(new EmployeeData(id, \"John Doe\", \"123456\")); } private Mono&lt;Department&gt; retrieveDepartment(String departmentId) { return Mono.just(new Department(departmentId, \"IT\")); } private Employee createEmployee(EmployeeData employeeData, Department department) { return new Employee(employeeData.getId(), employeeData.getName(), department.getName()); } @GetMapping(\"/employees\") public Flux&lt;Employee&gt; getAllEmployees() { // First, we retrieve a list of employee IDs Flux&lt;String&gt; employeeIds = retrieveEmployeeIds(); // Then, we use flatMap to retrieve the data for each employee Flux&lt;EmployeeData&gt; employeeData = employeeIds.flatMap(this::retrieveEmployeeData); // Next, we use map to retrieve the departments for each employee Flux&lt;Department&gt; departments = employeeData.flatMap(data -&gt; retrieveDepartment(data.getDepartmentId())); // Finally, we use map to create the final Employee objects return Flux.zip(employeeData, departments, this::createEmployee); } private Flux&lt;String&gt; retrieveEmployeeIds() { return Flux.just(\"1\", \"2\", \"3\", \"4\"); } private static class EmployeeData { private String id; private String name; private String departmentId; public EmployeeData(String id, String name, String departmentId) { this.id = id; this.name = name; this.departmentId = departmentId; } public String getId() { return id; } public String getName() { return name; } public String getDepartmentId() { return departmentId; } } private static class Department { private String id; private String name; } } . Mono.supplier . Mono.supplier is a static method in the Reactor library that creates a new Mono from a Supplier instance. A Supplier is a functional interface defined in the Java standard library that represents a supplier of results. It has a single abstract method, get, that returns a result of a specified type. When using Mono.supplier, the Supplier instance is used to generate the data that will be emitted by the Mono. The get method of the Supplier is called when the Mono is subscribed to, and the result is emitted as a single item. Here’s an example of using Mono.supplier to create a Mono that emits the result of a Supplier: . Supplier&lt;String&gt; stringSupplier = () -&gt; \"Hello, World!\"; Mono&lt;String&gt; helloWorld = Mono.fromSupplier(stringSupplier); . In this example, the stringSupplier instance is a Supplier that returns the string \"Hello, World!\". The Mono.fromSupplier method is used to create a Mono that emits the result of the stringSupplier when subscribed to. @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users/{id}\") public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUserById(@PathVariable Long id) { return Mono.fromSupplier(() -&gt; userService.findById(id)) .map(user -&gt; ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } } . In this example, the UserController class is a REST controller that retrieves a user by ID and returns the result as a Mono of ResponseEntity&lt;User&gt;. The userService.findById method is used to retrieve the user from a database, and it returns the result as an optional. The Mono.fromSupplier method is used to create a Mono from a Supplier that retrieves the user from the database. The map operator is used to map the optional to a ResponseEntity with a 200 status code if the user is found, or a 404 status code if the user is not found. The defaultIfEmpty operator is used to provide the default value of ResponseEntity.notFound().build() if the optional is empty. Note 1: . If you don’t use Mono.supplier, you would need to use a different method to create a Mono that emits the result of a method or operation that returns a value. For example, if you have a method that returns a User object, you could create a Mono from the result of that method using the Mono.just method: . @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users/{id}\") public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUserById(@PathVariable Long id) { User user = userService.findById(id); return Mono.just(ResponseEntity.ok(user)); } } . In this example, the userService.findById method is used to retrieve the user from the database, and the Mono.just method is used to create a Mono that emits the result as a single item. Note that this approach assumes that the user is always present and doesn’t handle the case where the user is not found. Another option is to use the Mono.defer method, which creates a Mono that evaluates the provided Mono supplier only when the Mono is subscribed to: . @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users/{id}\") public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUserById(@PathVariable Long id) { return Mono.defer(() -&gt; { User user = userService.findById(id); return Mono.just(ResponseEntity.ok(user)); }); } } . In this example, the Mono.defer method is used to create a Mono that evaluates the Mono.just method only when the Mono is subscribed to. This approach allows you to defer the evaluation of the method that retrieves the user until the Mono is subscribed to, which can be useful in certain scenarios. Mono.just and Mono.supplier are two methods used to create a Mono in Spring Reactor. Mono.just is used to create a Mono that emits a single item. The item is specified as an argument when calling the Mono.just method: . Mono&lt;String&gt; mono = Mono.just(\"Hello\"); . Mono.supplier is used to create a Mono that emits the result of a method or operation that returns a value. The method or operation is specified as a Supplier when calling the Mono.supplier method: . Mono&lt;String&gt; mono = Mono.fromSupplier(() -&gt; \"Hello\"); . In general, Mono.just is used when you have a value that is known at the time of creation and Mono.supplier is used when the value is not known until the Mono is subscribed to. This can be useful in scenarios where you want to defer the evaluation of a method or operation until the Mono is subscribed to, for example, when making a network request. There is a similar method in Flux as Mono.supplier, it’s called Flux.from. Flux.from is used to create a Flux that emits the elements of an Iterable, Array, or Publisher. It can be used as a way to create a Flux that emits the results of a method or operation that returns multiple values: . Flux&lt;String&gt; flux = Flux.fromIterable(Arrays.asList(\"Hello\", \"world\")); . Flux&lt;Integer&gt; flux = Flux.fromArray(new Integer[] {1, 2, 3}); . In general, Flux.from is used when you have a collection of values that is known at the time of creation. Like Mono.supplier, it is also useful in scenarios where you want to defer the evaluation of a method or operation until the Flux is subscribed to, for example, when making a network request that returns multiple values. Here’s an example of how you can call a method that returns a List of objects using Flux in Spring Reactor: . public List&lt;Object&gt; getObjectList() { return Arrays.asList(new Object(), new Object(), new Object()); } ... Flux&lt;Object&gt; objectFlux = Flux.fromIterable(getObjectList()); . In this example, the getObjectList method returns a List of Object instances. To use this method with Flux, you can call Flux.fromIterable and pass in the result of getObjectList as the argument. This creates a Flux that emits each of the objects in the List. Here’s an example of how you can use Flux in a Spring Boot application: . @RestController public class MyController { @GetMapping(\"/objects\") public Flux&lt;Object&gt; getObjects() { return Flux.fromIterable(getObjectList()); } private List&lt;Object&gt; getObjectList() { return Arrays.asList(new Object(), new Object(), new Object()); } } . Here’s an example of how you can use Mono and Flux to make multiple database calls in a Spring Boot application: . @RestController public class MyController { private final UserRepository userRepository; private final OrderRepository orderRepository; public MyController(UserRepository userRepository, OrderRepository orderRepository) { this.userRepository = userRepository; this.orderRepository = orderRepository; } @GetMapping(\"/user/{id}\") public Mono&lt;User&gt; getUser(@PathVariable String id) { return userRepository.findById(id); } @GetMapping(\"/user/{id}/orders\") public Flux&lt;Order&gt; getUserOrders(@PathVariable String id) { return userRepository.findById(id) .flatMapMany(user -&gt; orderRepository.findByUserId(user.getId())); } } . In this example, we have a RestController with two endpoints. The getUser endpoint takes an id parameter and returns a single User instance from the database using the UserRepository. The getUserOrders endpoint takes an id parameter and returns a stream of Order instances from the database using the OrderRepository. The getUserOrders endpoint makes two database calls: first, it retrieves a single User instance using UserRepository.findById, and then it retrieves a stream of Order instances using OrderRepository.findByUserId, passing in the id of the User instance. The flatMapMany operator is used to flatten the Mono&lt;User&gt; returned by UserRepository.findById into a Flux&lt;Order&gt;. This allows us to make two database calls and return the results as a single stream. flatMapMany . flatMapMany is a reactive operator that is used in Spring Reactor to convert a reactive type into another reactive type. It is used in combination with Mono to convert a Mono&lt;T&gt; into a Flux&lt;R&gt; by applying a function to each element emitted by the source Mono, and returning the elements as a Flux. The function passed to flatMapMany takes the single T emitted by the source Mono and returns a Flux&lt;R&gt; which represents a stream of values of type R. The resulting Flux&lt;R&gt; is then concatenated with the Flux emitted by other elements. The flatMapMany operator is useful when you want to perform an operation on each element of a reactive type, and return the results as a different reactive type. This can be useful when you want to make multiple database calls or perform other types of operations that return a stream of values. By using flatMapMany, you can chain these operations together and return a single stream of values to the client. The difference between flatMap and flatMapMany . The main difference between flatMap and flatMapMany in Spring Reactor is that flatMap is used to transform a Mono into another Mono, while flatMapMany is used to transform a Mono into a Flux. flatMap takes a function that maps a single value emitted by the source Mono into another Mono. The resulting Mono is then merged into the original Mono stream, so that the elements of the two Mono streams are interleaved in the resulting stream. flatMapMany takes a function that maps a single value emitted by the source Mono into a Flux. The resulting Flux is then concatenated with the Flux emitted by other elements in the source Mono. In summary, flatMap is used when you want to perform a single operation on each element of a reactive type and return the result as a different reactive type, while flatMapMany is used when you want to perform multiple operations on each element of a reactive type and return the results as a stream of values. Here is an example of using the filter operator in Spring Boot: . @Service public class UserService { public Flux&lt;User&gt; getAllUsers() { return Flux.just( new User(1, \"John Doe\"), new User(2, \"Jane Doe\"), new User(3, \"Jim Smith\"), new User(4, \"Sarah Johnson\") ); } } @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users\") public Flux&lt;User&gt; getUsers() { return userService.getAllUsers() .filter(user -&gt; user.getId() % 2 == 0) .map(user -&gt; { user.setName(user.getName().toUpperCase()); return user; }); } } . In this example, the UserService returns a Flux of User objects. The UserController then filters the users with an even id and maps the filtered users to return their names in uppercase. The filtered and transformed users are then returned as a Flux. Here is an example of using the subscribe method in Spring Boot: . @Service public class UserService { public Flux&lt;User&gt; getAllUsers() { return Flux.just( new User(1, \"John Doe\"), new User(2, \"Jane Doe\"), new User(3, \"Jim Smith\"), new User(4, \"Sarah Johnson\") ); } } @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users\") public void getUsers() { userService.getAllUsers() .filter(user -&gt; user.getId() % 2 == 0) .map(user -&gt; { user.setName(user.getName().toUpperCase()); return user; }) .subscribe(user -&gt; { System.out.println(\"Received user: \" + user); }, error -&gt; { System.err.println(\"Error occured: \" + error); }, () -&gt; { System.out.println(\"All users received\"); }); } } . In this example, the UserService returns a Flux of User objects. The UserController then filters the users with an even id, maps the filtered users to return their names in uppercase, and subscribes to the Flux. When each user is received, it is printed to the console. In case of an error, the error is printed to the error console. Finally, when all users are received, a message is printed to the console indicating that all users have been received. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-2-reactor%20operator/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-2-reactor%20operator/"
  },"719": {
    "doc": "Reactor Operator II",
    "title": "Reactor Operator II",
    "content": "Here is an example of using the zipWith operator in Spring Boot: . @Service public class OrderService { public Flux&lt;Order&gt; getOrders() { return Flux.just( new Order(1, \"Order 1\"), new Order(2, \"Order 2\"), new Order(3, \"Order 3\"), new Order(4, \"Order 4\") ); } public Flux&lt;OrderItem&gt; getOrderItems(int orderId) { if (orderId == 1) { return Flux.just( new OrderItem(1, \"Item 1\"), new OrderItem(2, \"Item 2\"), new OrderItem(3, \"Item 3\") ); } else if (orderId == 2) { return Flux.just( new OrderItem(4, \"Item 4\"), new OrderItem(5, \"Item 5\") ); } else if (orderId == 3) { return Flux.just( new OrderItem(6, \"Item 6\"), new OrderItem(7, \"Item 7\"), new OrderItem(8, \"Item 8\"), new OrderItem(9, \"Item 9\") ); } else { return Flux.just( new OrderItem(10, \"Item 10\"), new OrderItem(11, \"Item 11\"), new OrderItem(12, \"Item 12\") ); } } } @RestController public class OrderController { private final OrderService orderService; public OrderController(OrderService orderService) { this.orderService = orderService; } @GetMapping(\"/orders\") public void getOrders() { orderService.getOrders() .flatMap(order -&gt; orderService.getOrderItems(order.getId()) .collectList() .map(orderItems -&gt; { order.setOrderItems(orderItems); return order; })) .subscribe(order -&gt; { System.out.println(\"Received order: \" + order); }, error -&gt; { System.err.println(\"Error occured: \" + error); }, () -&gt; { System.out.println(\"All orders received\"); }); } } . In this example, the OrderService returns a Flux of Order objects and has a method getOrderItems which returns a Flux of OrderItem objects for a given orderId. The OrderController then flatmaps the Order objects to fetch the corresponding OrderItem objects using the getOrderItems method. The OrderItem objects are then collected into a List and used to set the OrderItem list for the Order object. Finally, the updated Order objects are subscribed to and printed to the console. In case of an error, the error is printed to the error console. Finally, when all orders are received, a message is printed to the console indicating that all orders have been received. The collectList operator . The collectList operator in Spring Reactor can be used to gather the elements of a Flux or Mono into a single List. This operator can be useful when you need to gather all elements of a reactive stream into a single, non-reactive data structure, or when you need to pass a collection of elements to another method that only accepts a single argument. It is important to note that the collectList operator will block the processing of the reactive stream until all elements have been emitted, so it should only be used in cases where it is acceptable for processing to wait for all elements to be available. In general, you should use collectList when you need to collect all elements of a reactive stream into a single, non-reactive data structure for further processing, or when you need to pass a collection of elements to another method that only accepts a single argument. Here’s an example in Spring Boot that demonstrates how to handle the elements of a Flux without using the collectList operator: . @RestController public class MyController { @GetMapping(\"/example\") public Flux&lt;String&gt; example() { return Flux.just(\"A\", \"B\", \"C\") .map(str -&gt; \"Element: \" + str) .doOnNext(System.out::println); } } . In this example, we are using a Flux to emit the elements “A”, “B”, and “C”. We are then using the map operator to transform each element into a string with the format \"Element: X\", where X is the original element. Finally, we are using the doOnNext operator to print each transformed element as it is emitted. Without using collectList, this example demonstrates how to handle the elements of a reactive stream as they are emitted, without blocking processing or gathering all elements into a single data structure. The reduce operator . The reduce operator is a reactive programming operator used to aggregate the elements of a reactive stream into a single value. It works by applying a BiFunction to each element of the stream, starting with an initial value, and accumulating the result into a single value. The BiFunction takes two arguments: the accumulated value and the current element, and returns a new accumulated value. The final value is returned as a Mono or Single after all elements have been processed. For example, if we have a Flux of integers, we can use the reduce operator to find the sum of all elements in the stream: . Flux.just(1, 2, 3) .reduce(0, (sum, next) -&gt; sum + next) .subscribe(sum -&gt; System.out.println(\"Sum: \" + sum)); . This code would produce the output Sum: 6. The reduce operator is useful for aggregating the elements of a reactive stream into a single value, such as summing numbers, concatenating strings, or finding the maximum or minimum value in a stream. Here’s an example in Spring Boot that demonstrates how to use the reduce operator: . @RestController public class MyController { @GetMapping(\"/example\") public Mono&lt;String&gt; example() { return Flux.just(\"A\", \"B\", \"C\") .reduce(\"\", (agg, next) -&gt; agg + next) .map(str -&gt; \"Reduced string: \" + str); } } . In this example, we are using a Flux to emit the elements “A”, “B”, and “C”. We are then using the reduce operator to concatenate all elements into a single string. The reduce operator takes two arguments: an initial value and a BiFunction that describes how to accumulate the elements. In this case, we are starting with an empty string “” and concatenating each element to the accumulated string. Finally, we are using the map operator to transform the reduced string into a new string with the format \"Reduced string: X\", where X is the reduced string. This example demonstrates how to use the reduce operator to aggregate the elements of a reactive stream into a single value, in this case by concatenating the elements into a single string. The doOnNext operator . The doOnNext operator is a reactive programming operator used to perform an action for each element in a reactive stream before it is delivered to the Subscriber. It allows you to side-effect or modify the elements in the stream before they reach their final destination. For example, you can use the doOnNext operator to log each element in a Flux before it is processed by the next operator or delivered to the subscriber: . Flux.just(1, 2, 3) .doOnNext(element -&gt; System.out.println(\"Element: \" + element)) .subscribe(System.out::println); . This code would produce the output: . Element: 1 1 Element: 2 2 Element: 3 3 . Here’s an example using the doOnNext operator in a Spring Boot application: . @RestController public class ExampleController { private final ReactiveUserRepository repository; public ExampleController(ReactiveUserRepository repository) { this.repository = repository; } @GetMapping(\"/users\") public Mono&lt;List&lt;User&gt;&gt; getUsers() { return repository.findAll() .doOnNext(user -&gt; System.out.println(\"User fetched: \" + user.getUsername())) .collectList(); } } . In this example, we have a RestController that returns a Mono of a List of User objects, fetched from a reactive UserRepository. The doOnNext operator is used to log each User object as it is fetched from the repository. Finally, the collectList operator is used to collect all the elements in the stream into a single List. Here’s an example of how the UserRepository might be implemented: . public interface ReactiveUserRepository extends ReactiveCrudRepository&lt;User, Long&gt; { } . This UserRepository extends ReactiveCrudRepository from Spring Data, providing reactive CRUD operations for User objects. doOnError operator . doOnError is an operator in the Spring Reactor library that allows you to perform some action whenever an error occurs in the stream. The action can be any side-effect, such as logging, updating a database, or sending a notification. For example, you can use the doOnError operator to log an error message when an exception occurs: . Mono.error(new RuntimeException(\"Error occurred\")) .doOnError(e -&gt; System.out.println(\"Error: \" + e.getMessage())) .subscribe(); . In this example, a Mono with a runtime exception is created, and the doOnError operator is used to log the error message whenever an error occurs in the stream. The subscribe method is used to trigger the stream, which will result in the exception being thrown and the error message being logged. Note that the doOnError operator does not prevent the error from propagating through the stream. It simply allows you to perform some action before the error is propagated to the next operator or to the subscribe method. Here is an example using the doOnError operator in a Spring Boot application: . Consider a scenario where we have an API endpoint that returns a Mono of a user’s details, based on their username. If the user is not found, we want to log a warning message, and return an error response to the client. Here’s how you could implement this in Spring Boot: . @RestController public class UserController { private final UserService userService; public UserController(UserService userService) { this.userService = userService; } @GetMapping(\"/users/{username}\") public Mono&lt;ResponseEntity&lt;User&gt;&gt; getUserDetails(@PathVariable String username) { return userService.getUserDetails(username) .doOnError(e -&gt; log.warn(\"User not found: \" + username)) .map(user -&gt; ResponseEntity.ok(user)) .defaultIfEmpty(ResponseEntity.notFound().build()); } } . In this example, the getUserDetails method returns a Mono of a ResponseEntity that contains the user details. The userService.getUserDetails(username) method returns a Mono of a User object. If an error occurs (for example, if the user is not found), the doOnError operator is used to log a warning message. Next, the map operator is used to convert the User object into a ResponseEntity with a 200 OK status code. Finally, the defaultIfEmpty operator is used to return a 404 Not Found response if the Mono is empty (i.e., if the user is not found). The defaultIfEmpty operator . The defaultIfEmpty operator is used to provide a default value if a reactive stream is empty. It means if the reactive stream doesn’t emit any items, the defaultIfEmpty operator will emit a specified default value. This operator is useful in cases where we want to provide a default value when the reactive stream is empty. For example, in case of an empty database result, we can use this operator to emit a default value instead of an empty stream. doOnErrorReturn operator . doOnErrorReturn is an operator in the Reactor library of the Spring framework that allows you to specify a fallback value to be returned in case an error occurs during the processing of a reactive stream. It can be used to catch exceptions thrown during the processing of the reactive stream and instead of propagating the error, a specified fallback value can be returned. The operator takes as an argument a function that specifies the fallback value to be returned in case of an error. This operator is useful in scenarios where we want to handle specific exceptions and return a fallback value instead of propagating the error. Here’s a simple example of using the doOnErrorReturn operator in a Spring Boot application: . @RestController public class ExampleController { private final ReactiveMongoTemplate template; public ExampleController(ReactiveMongoTemplate template) { this.template = template; } @GetMapping(\"/data\") public Mono&lt;String&gt; getData() { return template.findById(\"someId\", Data.class) .map(Data::getValue) .doOnErrorReturn(\"Fallback value\") .flatMap(value -&gt; Mono.just(\"Processed value: \" + value)); } } . In this example, the controller is fetching data from a MongoDB database using a ReactiveMongoTemplate. The findById method returns a Mono that emits the data. The map operator is used to extract the value field from the data. The doOnErrorReturn operator is used to specify a fallback value in case the findById method throws an error. Finally, the flatMap operator is used to process the value and return a Mono that emits the processed value as a string. The doOnErrorReturn operator allows you to specify a fallback value that will be returned in case of an error, without having to manually handle the error in a catch block. The doOnErrorResume operator . The doOnErrorResume operator is a reactive programming operator that allows you to specify an alternative source to continue the processing of a reactive stream in case of an error. This operator takes a Function as an argument that maps the error to a new Publisher or Mono that will be used as a replacement for the original source. The new source will continue the emission of the reactive stream. Here’s a simple example of using the doOnErrorResume operator in a Spring Boot application: . @RestController public class ExampleController { private final ReactiveMongoTemplate template; public ExampleController(ReactiveMongoTemplate template) { this.template = template; } @GetMapping(\"/data\") public Mono&lt;String&gt; getData() { return template.findById(\"someId\", Data.class) .map(Data::getValue) .doOnErrorResume(error -&gt; Mono.just(\"Fallback value\")) .flatMap(value -&gt; Mono.just(\"Processed value: \" + value)); } } . In this example, the controller is fetching data from a MongoDB database using a ReactiveMongoTemplate. The findById method returns a Mono that emits the data. The map operator is used to extract the value field from the data. The doOnErrorResume operator is used to specify an alternative source in case the findById method throws an error. The doOnErrorResume operator takes a Function that maps the error to a new Mono that emits the fallback value. Finally, the flatMap operator is used to process the value and return a Mono that emits the processed value as a string. The doOnErrorResume operator allows you to continue the processing of the reactive stream in case of an error by specifying a new source to replace the original source, which failed. This can be useful in situations where you want to continue processing with a default value in case of an error, without having to manually handle the error in a catch block. Difference between doOnErrorResume and doOnErrorReturn . The doOnErrorResume and doOnErrorReturn operators are both used to handle errors in a reactive stream. However, there’s a difference in how they handle errors: . | doOnErrorResume: This operator takes a Function as an argument that maps the error to a new Publisher or Mono that will be used as a replacement for the original source. The new source will continue the emission of the reactive stream. In other words, doOnErrorResume resumes the stream processing with a new source in case of an error. | doOnErrorReturn: This operator takes a fallback value as an argument that will be returned in case of an error. The reactive stream will emit the fallback value and terminate. In other words, doOnErrorReturn returns a fallback value in case of an error and terminates the stream. | . So, the main difference between doOnErrorResume and doOnErrorReturn is that doOnErrorResume resumes the stream processing with a new source, while doOnErrorReturn returns a fallback value and terminates the stream. Choose between the two based on whether you want to continue processing the stream or not in case of an error. The first, last, and take operators . The first, last, and take operators are operators in the Reactor library for processing reactive streams in Spring. | first: The first operator returns the first element in a reactive stream, or an empty Mono if the stream is empty. | last: The last operator returns the last element in a reactive stream, or an empty Mono if the stream is empty. | take: The take operator returns the first n elements in a reactive stream. If the stream contains fewer than n elements, all elements in the stream will be returned. | . These operators are used to limit the number of elements that are processed in a reactive stream, and to retrieve specific elements from a reactive stream. Here’s an example of using the first, last, and take operators in a Spring Boot application: . @RestController public class ExampleController { private final ReactiveMongoTemplate template; public ExampleController(ReactiveMongoTemplate template) { this.template = template; } @GetMapping(\"/data/first\") public Mono&lt;Data&gt; getFirstData() { return template.find(Query.empty(), Data.class) .first(); } @GetMapping(\"/data/last\") public Mono&lt;Data&gt; getLastData() { return template.find(Query.empty(), Data.class) .last(); } @GetMapping(\"/data/take/{n}\") public Flux&lt;Data&gt; getTakeData(@PathVariable int n) { return template.find(Query.empty(), Data.class) .take(n); } } .retry() .retry is a method in the Reactor library that can be used to automatically retry a failed Mono or Flux sequence. It can be used to handle temporary errors or timeouts by retrying the sequence a specified number of times before giving up and completing the sequence with an error. Here’s an example of how to use the .retry method: . Flux.just(1, 2, 3) .map(i -&gt; { if (i == 2) { throw new RuntimeException(\"error\"); } return i; }) .retry(1) .subscribe(System.out::println, System.err::println); . In this example, the Flux is generating numbers from 1 to 3. If the number is 2, it throws a RuntimeException with the message \"error\". The .retry method is then used to retry the sequence once in case of an error. So, when the number 2 is encountered and an error is thrown, the sequence is retried and this time it will produce the number 3 and complete successfully. The result will be the numbers 1 and 3 printed to the console. ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-3-Spring%20Operator%202/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-3-Spring%20Operator%202/"
  },"720": {
    "doc": "Bottlenecks in Spring Reactor",
    "title": "Bottlenecks in Spring Reactor",
    "content": "There are several ways to handle bottlenecks in Spring Reactor: . | Parallel Processing: Use the parallel operator to divide the stream into multiple parallel streams and process elements in parallel. This can help distribute the load and reduce the time taken to process elements. | Batching: Use the buffer operator to group elements into batches and process them in bulk. This can help reduce the overhead of processing individual elements and improve performance. | Backpressure: Use the onBackpressureBuffer or onBackpressureDrop operators to handle cases where the rate of incoming elements exceeds the rate of processing. The onBackpressureBuffer operator buffers incoming elements until they can be processed, while the onBackpressureDrop operator drops elements if the rate of incoming elements exceeds the rate of processing. | Scheduling: Use the subscribeOn operator to specify the scheduler that should be used to process elements. You can use a different scheduler for different stages of the stream to ensure that the processing can be optimized based on the requirements of each stage. | Caching: Use the cache operator to cache the results of a reactive stream. This can help reduce the overhead of processing elements that have already been processed, and improve performance. | . In addition to these strategies, it’s also important to monitor the performance of your reactive streams and adjust the configuration of your application to ensure that it can handle the load. This may involve adjusting the number of threads, adjusting the buffer sizes, or adjusting the configuration of your schedulers. Here’s an example of using parallel processing, batching, and scheduling in a Spring Boot application to handle a bottleneck scenario: . @RestController public class ExampleController { private final ReactiveMongoTemplate template; public ExampleController(ReactiveMongoTemplate template) { this.template = template; } @GetMapping(\"/data/parallel\") public Flux&lt;Data&gt; getDataParallel() { return template.find(Query.empty(), Data.class) .parallel(8) .runOn(Schedulers.parallel()) .buffer(1024) .flatMap(dataList -&gt; { // Do some processing on dataList return Flux.fromIterable(dataList); }); } } . In this example, the controller has an endpoint /data/parallel that returns a reactive stream of Data objects. The reactive stream is created using the template.find method to fetch data from a MongoDB database. The parallel operator is used to divide the stream into 8 parallel streams to process elements in parallel. The runOn operator is used to specify the Schedulers.parallel scheduler, which is optimized for parallel processing. The buffer operator is used to group elements into batches of 1024, so that elements can be processed in bulk. Finally, the flatMap operator is used to do some processing on each batch of elements, and return the processed elements as a reactive stream. By using parallel processing, batching, and scheduling, this code can handle a bottleneck scenario by distributing the load, reducing the overhead of processing elements, and optimizing the processing of elements based on the requirements of each stage. Here’s an example of using the onBackpressureBuffer operator to handle backpressure in a Spring Boot application: . @RestController public class ExampleController { private final Flux&lt;Integer&gt; hotFlux; public ExampleController() { this.hotFlux = Flux.create(sink -&gt; { for (int i = 0; i &lt; 10000; i++) { sink.next(i); } sink.complete(); }); } @GetMapping(\"/data\") public Flux&lt;Integer&gt; getData() { return hotFlux.onBackpressureBuffer(1024); } } . In this example, the controller has an endpoint /data that returns a reactive stream of integers. The hotFlux is created using the Flux.create method, and it generates a stream of 10,000 integers. The onBackpressureBuffer operator is used to handle cases where the rate of incoming elements exceeds the rate of processing. In this example, the buffer size is set to 1024, so that incoming elements are buffered until they can be processed. By using the onBackpressureBuffer operator, this code can handle a backpressure scenario by buffering incoming elements and ensuring that the reactive stream can continue to process elements even if the rate of incoming elements exceeds the rate of processing. Here’s an example of using the onBackpressureDrop operator to handle backpressure in a Spring Boot application: . @RestController public class ExampleController { private final Flux&lt;Integer&gt; hotFlux; public ExampleController() { this.hotFlux = Flux.create(sink -&gt; { for (int i = 0; i &lt; 10000; i++) { sink.next(i); } sink.complete(); }); } @GetMapping(\"/data\") public Flux&lt;Integer&gt; getData() { return hotFlux.onBackpressureDrop(i -&gt; { // Log dropped element System.out.println(\"Dropped element: \" + i); }); } } . In this example, the controller has an endpoint /data that returns a reactive stream of integers. The hotFlux is created using the Flux.create method, and it generates a stream of 10,000 integers. The onBackpressureDrop operator is used to handle cases where the rate of incoming elements exceeds the rate of processing. In this example, the operator is configured to drop incoming elements and log a message for each dropped element. By using the onBackpressureDrop operator, this code can handle a backpressure scenario by dropping incoming elements and ensuring that the reactive stream can continue to process elements even if the rate of incoming elements exceeds the rate of processing. A scheduler in Spring Reactor . A scheduler in Spring Reactor is a component that is responsible for executing tasks asynchronously. It provides a mechanism for scheduling the execution of reactive streams and other tasks, such as timer-based operations, event handling, and task scheduling. Schedulers in Spring Reactor can be used to control the concurrency and parallelism of reactive streams, as well as to perform other operations such as error handling, backpressure handling, and resource management. The Scheduler interface in Spring Reactor provides methods for scheduling the execution of tasks, such as schedule, schedulePeriodically, and dispose. There are also several built-in scheduler implementations in Spring Reactor, such as the Schedulers.boundedElastic and Schedulers.parallel schedulers. When creating a reactive stream in Spring Reactor, you can specify which scheduler to use for executing tasks. This allows you to control the concurrency and parallelism of the stream, and to ensure that tasks are executed in the correct order. For example, you can use the subscribeOn operator to specify the scheduler to use for executing a stream: . Flux.just(1, 2, 3) .subscribeOn(Schedulers.boundedElastic()) .subscribe(System.out::println); . In this example, the subscribeOn operator is used to specify that the stream should be executed on the Schedulers.boundedElastic scheduler. Compare Schedulers.boundedElastic and Schedulers.parallel . Schedulers.boundedElastic and Schedulers.parallel are two different scheduler implementations in Spring Reactor. Schedulers.boundedElastic is a scheduler that creates a new thread for each task and is suitable for IO-bound and non-blocking tasks. It uses a dynamic pool of threads that can grow or shrink based on the rate of incoming tasks. This scheduler is useful for scenarios where the rate of incoming tasks can vary dynamically, as it can adapt to the changing load. Schedulers.parallel is a scheduler that uses a fixed-size pool of threads to execute tasks in parallel. It is suitable for CPU-bound tasks that require a large number of threads to achieve maximum performance. This scheduler is useful for scenarios where the rate of incoming tasks is known in advance and is constant, as it provides predictable performance. In general, Schedulers.boundedElastic is a good choice for IO-bound tasks, while Schedulers.parallel is a good choice for CPU-bound tasks. However, the choice of scheduler ultimately depends on the specific requirements of your application and the nature of the tasks you need to perform. You can use the subscribeOn operator in Spring Reactor to specify which scheduler to use for executing a reactive stream. For example: . Flux.just(1, 2, 3) .subscribeOn(Schedulers.boundedElastic()) .subscribe(System.out::println); . In this example, the subscribeOn operator is used to specify that the stream should be executed on the Schedulers.boundedElastic scheduler. Here is an example of how you can send a 202 Accepted response in a Spring Boot application while executing a task in the background: . Here is an example of how you can send a response immediately in a Spring Boot application while executing a task in the background: . @RestController public class ExampleController { @GetMapping(\"/background-task\") public Mono&lt;String&gt; executeBackgroundTask() { return Mono.fromCallable(() -&gt; { // Simulate a long-running task try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } return \"Task completed\"; }).subscribeOn(Schedulers.elastic()) .doOnSubscribe(subscription -&gt; { // Send immediate response to client return Mono.just(\"Task started\").subscribe(System.out::println); }); } } . In this example, the endpoint /background-task returns a reactive stream represented by the Mono class. The fromCallable method is used to create a Mono that executes a callable task, in this case a long-running task that simulates a delay of 5 seconds. The subscribeOn operator is used to specify that the task should be executed on the Schedulers.elastic scheduler, which is a scheduler that creates a new thread for each task and is suitable for IO-bound and non-blocking tasks. The doOnSubscribe operator is used to specify an action that should be performed when a client subscribes to the stream. In this case, the action sends an immediate response to the client with the message \"Task started\". To test this example, you can send a request to the /background-task endpoint and observe that the response is sent immediately, while the task is executed in the background. Here is an example of how you can send a 202 Accepted response in a Spring Boot application while executing a task in the background: . @RestController public class ExampleController { @GetMapping(\"/background-task\") public Mono&lt;Void&gt; executeBackgroundTask() { return Mono.fromRunnable(() -&gt; { // Simulate a long-running task try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } }).subscribeOn(Schedulers.elastic()) .doOnSubscribe(subscription -&gt; { // Send immediate response to client return ServerResponse.accepted().build().subscribe(); }); } } . In this example, the endpoint /background-task returns a reactive stream represented by the Mono class. The fromRunnable method is used to create a Mono that executes a runnable task, in this case a long-running task that simulates a delay of 5 seconds. The subscribeOn operator is used to specify that the task should be executed on the Schedulers.elastic scheduler, which is a scheduler that creates a new thread for each task and is suitable for IO-bound and non-blocking tasks. The doOnSubscribe operator is used to specify an action that should be performed when a client subscribes to the stream. In this case, the action sends an immediate 202 Accepted response to the client. This is done by creating a ServerResponse object with the accepted method and then calling the build method to build the response. The subscribe method is then called to send the response. To test this example, you can send a request to the /background-task endpoint and observe that the response is sent immediately with the 202 Accepted status code, while the task is executed in the background. Compare Schedulers.elastic and Schedulers.boundedElastic . Schedulers.elastic() and Schedulers.boundedElastic() are both schedulers provided by Spring Reactor that can be used to execute tasks asynchronously. However, they have some differences: . | Thread Pool Size: Schedulers.elastic() creates a new thread for each task, while Schedulers.boundedElastic() uses a bounded thread pool with a fixed number of threads. | Resource utilization: Schedulers.elastic() can potentially consume a large amount of resources if there are many tasks, as it creates a new thread for each task. On the other hand, Schedulers.boundedElastic() has a fixed number of threads and will queue tasks if all threads are busy, making it more suitable for use-cases where the number of tasks is expected to be large. | Performance: Schedulers.elastic() has lower overhead compared to Schedulers.boundedElastic(), as it does not need to manage a thread pool. However, it can potentially slow down other tasks if there are too many tasks running concurrently. Schedulers.boundedElastic() may have higher overhead, but it can provide better performance by managing the number of tasks and ensuring that they are executed in a timely manner. | . In general, you should choose Schedulers.elastic() if you have a small number of tasks or if you want to minimize overhead, and Schedulers.boundedElastic() if you have a large number of tasks or if you need to ensure that tasks are executed in a timely manner. Note: . To configure the pool size for Schedulers.boundedElastic(), you can use the .create() method and specify the number of threads in the thread pool. Here’s an example: . Scheduler boundedElasticScheduler = Schedulers.boundedElastic() .create(10); // specify the number of threads in the pool . In this example, the thread pool size is set to 10, which means that at most 10 tasks can be executed concurrently. Any additional tasks will be queued until a thread becomes available. Compare Mono.fromRunnable and Mono.fromCallable: . Mono.fromRunnable and Mono.fromCallable are both factory methods in Spring Reactor that can be used to create a Mono from a Runnable and Callable respectively. Here’s a comparison between the two: . | Return type: Mono.fromRunnable returns a Mono&lt;Void&gt;, meaning that it does not produce any value. On the other hand, Mono.fromCallable returns a Mono&lt;T&gt;, where T is the type of the value returned by the Callable. | Exception handling: Mono.fromRunnable does not allow for the capture of exceptions thrown by the Runnable. However, exceptions thrown by the Callable can be captured and returned as a MonoError. | Use case: Mono.fromRunnable is best suited for use-cases where you only need to run a side-effect and do not care about the result. Mono.fromCallable is best suited for use-cases where you need to perform a computation and return the result. | . @RestController public class ExampleController { @GetMapping(\"/example\") public Mono&lt;String&gt; example() { Callable&lt;String&gt; callable = () -&gt; { if (Math.random() &lt; 0.5) { throw new IllegalStateException(\"Random error\"); } return \"Hello World\"; }; return Mono.fromCallable(callable) .onErrorResume(e -&gt; Mono.just(\"Error Occurred\")); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-4-bottlenecks%20in%20Spring%20Reactor/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-4-bottlenecks%20in%20Spring%20Reactor/"
  },"721": {
    "doc": "Spring Reactor WebClient",
    "title": "Spring Reactor WebClient",
    "content": "Here’s an example of how you can use the Spring Reactor WebClient to perform an HTTP GET request: . @RestController public class ExampleController { private final WebClient webClient = WebClient.create(\"https://jsonplaceholder.typicode.com\"); @GetMapping(\"/example\") public Mono&lt;String&gt; example() { return webClient.get() .uri(\"/posts/1\") .retrieve() .bodyToMono(Map.class) .map(m -&gt; (String) m.get(\"title\")) .onErrorResume(e -&gt; Mono.just(\"Error Occurred\")); } } . Here’s an example of how you could create a WebClient bean in Spring Boot and reuse it in multiple controllers: . @Configuration public class WebClientConfig { @Bean public WebClient webClient() { return WebClient.create(\"https://jsonplaceholder.typicode.com\"); } } @RestController public class ExampleController1 { private final WebClient webClient; public ExampleController1(WebClient webClient) { this.webClient = webClient; } @GetMapping(\"/example1\") public Mono&lt;String&gt; example1() { return webClient.get() .uri(\"/posts/1\") .retrieve() .bodyToMono(Map.class) .map(m -&gt; (String) m.get(\"title\")) .onErrorResume(e -&gt; Mono.just(\"Error Occurred\")); } } @RestController public class ExampleController2 { private final WebClient webClient; public ExampleController2(WebClient webClient) { this.webClient = webClient; } @GetMapping(\"/example2\") public Mono&lt;String&gt; example2() { return webClient.get() .uri(\"/posts/2\") .retrieve() .bodyToMono(Map.class) .map(m -&gt; (String) m.get(\"title\")) .onErrorResume(e -&gt; Mono.just(\"Error Occurred\")); } } . Here’s an example of how you could handle different response codes using Spring Boot’s WebClient: . @RestController public class ExampleController { private final WebClient webClient; public ExampleController(WebClient webClient) { this.webClient = webClient; } @GetMapping(\"/example\") public Mono&lt;String&gt; example() { return webClient.get() .uri(\"/posts/1\") .retrieve() .onStatus(HttpStatus::is4xxClientError, response -&gt; Mono.just(\"Bad Request\")) .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.just(\"Server Error\")) .bodyToMono(Map.class) .map(m -&gt; (String) m.get(\"title\")) .onErrorResume(e -&gt; Mono.just(\"Error Occurred\")); } } . Sending ResponseEntity . @RestController public class ExampleController { private final WebClient webClient; public ExampleController(WebClient webClient) { this.webClient = webClient; } @GetMapping(\"/example\") public Mono&lt;ResponseEntity&lt;String&gt;&gt; example() { return webClient.get() .uri(\"/posts/1\") .retrieve() .onStatus(HttpStatus::is4xxClientError, response -&gt; Mono.just(ResponseEntity.badRequest().body(\"Bad Request\"))) .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Server Error\"))) .bodyToMono(Map.class) .map(m -&gt; (String) m.get(\"title\")) .map(title -&gt; ResponseEntity.ok(title)) .onErrorResume(e -&gt; Mono.just(ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(\"Error Occurred\"))); } } . Here is an example of using .retry in Spring Boot with a WebClient to call a REST API: . @Service public class RetryExampleService { private final WebClient webClient; public RetryExampleService(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder.baseUrl(\"https://api.example.com\").build(); } public Mono&lt;Response&gt; retryGetRequest(String path) { return webClient.get().uri(path) .retrieve() .onStatus(HttpStatus::is5xxServerError, response -&gt; Mono.error(new RetryableException(\"Error\"))) .bodyToMono(Response.class) .retryWhen(Retry.backoff(3, Duration.ofSeconds(2))); } } @RestController @RequestMapping(\"/retry\") public class RetryExampleController { private final RetryExampleService service; public RetryExampleController(RetryExampleService service) { this.service = service; } @GetMapping(\"/{path}\") public Mono&lt;Response&gt; getData(@PathVariable String path) { return service.retryGetRequest(path); } } . Here is an example of how to return an error when a timeout occurs in a WebClient in Spring Boot: . @Service public class TimeoutExampleService { private final WebClient webClient; public TimeoutExampleService(WebClient.Builder webClientBuilder) { this.webClient = webClientBuilder.baseUrl(\"https://api.example.com\").build(); } public Mono&lt;Response&gt; getDataWithTimeout(String path) { return webClient.get().uri(path) .retrieve() .bodyToMono(Response.class) .timeout(Duration.ofSeconds(5), Mono.error(new TimeoutException(\"Timeout occurred\"))); } } @RestController @RequestMapping(\"/timeout\") public class TimeoutExampleController { private final TimeoutExampleService service; public TimeoutExampleController(TimeoutExampleService service) { this.service = service; } @GetMapping(\"/{path}\") public Mono&lt;Response&gt; getData(@PathVariable String path) { return service.getDataWithTimeout(path); } } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-5-Spring%20Reactor%20WebClient/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-5-Spring%20Reactor%20WebClient/"
  },"722": {
    "doc": "Sample Example",
    "title": "Sample Example",
    "content": "Here is an example of a Spring Reactor implementation using WebClient, PostgreSQL with iBatis . @Service public class WebClientPostgresService { private final WebClient webClient; private final SqlSessionFactory sqlSessionFactory; public WebClientPostgresService(WebClient.Builder webClientBuilder, DataSource dataSource) { this.webClient = webClientBuilder.baseUrl(\"https://api.example.com\").build(); this.sqlSessionFactory = new SqlSessionFactoryBuilder().build(new PooledDataSource(dataSource)); } public Mono&lt;Response&gt; getDataWithRetryAndTimeout(String path) { return webClient.get().uri(path) .retrieve() .bodyToMono(Response.class) .retryBackoff(3, Duration.ofSeconds(1), Duration.ofSeconds(5)) .timeout(Duration.ofSeconds(5), Mono.error(new TimeoutException(\"Timeout occurred\"))) .subscribeOn(Schedulers.elastic()); } public Mono&lt;Integer&gt; insertData(Data data) { return Mono.fromCallable(() -&gt; { try (SqlSession session = sqlSessionFactory.openSession()) { DataMapper mapper = session.getMapper(DataMapper.class); return mapper.insert(data); } }).subscribeOn(Schedulers.parallel()); } } @RestController @RequestMapping(\"/data\") public class WebClientPostgresController { private final WebClientPostgresService service; public WebClientPostgresController(WebClientPostgresService service) { this.service = service; } @GetMapping(\"/{path}\") public Mono&lt;Response&gt; getData(@PathVariable String path) { return service.getDataWithRetryAndTimeout(path); } @PostMapping public Mono&lt;Integer&gt; insertData(@RequestBody Data data) { return service.insertData(data); } } . In this example, we have a WebClientPostgresService that uses a WebClient to call a REST API and a SqlSessionFactory to connect to a PostgreSQL database using iBatis. The getDataWithRetryAndTimeout method is used to retrieve data from the API and applies a retry logic with a backoff of 3 attempts, an initial duration of 1 second, and a max duration of 5 seconds. It also applies a timeout of 5 seconds and returns a TimeoutException if the request takes longer than 5 seconds to complete. The method also uses the Schedulers.elastic scheduler to run the task in a separate thread. The insertData method is used to insert data into the PostgreSQL database using iBatis. It returns a Mono that represents the result of the insert operation. The method uses the Schedulers.parallel scheduler to run the task in a separate thread. The WebClientPostgresController is a REST endpoint that uses the WebClientPostgresService to retrieve data from the API and insert data into the database. The /data/ . Create a configuration class for MyBatis: . @Configuration @MapperScan(\"com.example.mapper\") public class MyBatisConfig { @Bean public DataSource dataSource() { // Configuration for the database connection pool, such as setting the maximum number of connections. return DataSourceBuilder.create() .driverClassName(\"org.postgresql.Driver\") .url(\"jdbc:postgresql://localhost:5432/mydatabase\") .username(\"user\") .password(\"password\") .build(); } @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception { SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); return sessionFactory.getObject(); } } . Create a DAO interface with the desired operations: . @Mapper public interface UserMapper { @Select(\"SELECT * FROM users WHERE id = #{id}\") User getUserById(@Param(\"id\") int id); // Add other operations } . Inject the SqlSessionFactory and the DAO into your service class: . @Service public class UserService { @Autowired private SqlSessionFactory sqlSessionFactory; @Autowired private UserMapper userMapper; public User getUserById(int id) { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { return userMapper.getUserById(id); } } public Mono&lt;Integer&gt; insert(Person person) { return Mono.fromCallable(() -&gt; { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { sqlSession.insert(\"insertPerson\", person); sqlSession.commit(); return 1; } }); } // Add other methods } . Inject the UserService into your controller class: . @RestController public class UserController { @Autowired private UserService userService; @GetMapping(\"/users/{id}\") public User getUserById(@PathVariable int id) { return userService.getUserById(id); } // Add other methods } . ",
    "url": "https://1001anjan.github.io/docs/SpringBoot/Spring%20Reactor/sr-6-Sample%20Example/",
    "relUrl": "/docs/SpringBoot/Spring%20Reactor/sr-6-Sample%20Example/"
  },"723": {
    "doc": "Terraform",
    "title": "PaaS using terraform",
    "content": "All contents and pictures on this website come from the Internet and are updated regularly every week. They are for personal study and research only, and should not be used for commercial purposes. Thank you for your cooperation. ",
    "url": "https://1001anjan.github.io/docs/Terraform/terraform/#paas-using-terraform",
    "relUrl": "/docs/Terraform/terraform/#paas-using-terraform"
  },"724": {
    "doc": "Terraform",
    "title": "Terraform",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Terraform/terraform/",
    "relUrl": "/docs/Terraform/terraform/"
  }
}
