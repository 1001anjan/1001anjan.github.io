{"0": {
    "doc": "Collection",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. What is a Framework? . A framework is a set of classes and interfaces which provide a ready-made architecture. In order to implement a new feature or a class, there is no need to define a framework. Advantages of the Collection Framework: . | Consistent API | Reduces programming effort | Increases program speed and quality | . Hierarchy of the Collection Framework: . ",
    "url": "https://1001anjan.github.io/docs/java/collection#ui-components",
    "relUrl": "/docs/java/collection#ui-components"
  },"1": {
    "doc": "Collection",
    "title": "Collection",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/java/collection",
    "relUrl": "/docs/java/collection"
  },"2": {
    "doc": "Configuration",
    "title": "Configuration",
    "content": "Just the Docs has some specific configuration parameters that can be defined in your Jekyll site’s _config.yml file. ",
    "url": "https://1001anjan.github.io/docs/configuration/",
    "relUrl": "/docs/configuration/"
  },"3": {
    "doc": "Configuration",
    "title": "Table of contents",
    "content": ". | Site logo | Search | Aux links | Heading anchor links | Footer content | Color scheme | Google Analytics | Document collections | . View this site’s _config.yml file as an example. ",
    "url": "https://1001anjan.github.io/docs/configuration/#table-of-contents",
    "relUrl": "/docs/configuration/#table-of-contents"
  },"4": {
    "doc": "Configuration",
    "title": "Site logo",
    "content": "# Set a path/url to a logo that will be displayed instead of the title logo: \"/assets/images/just-the-docs.png\" . ",
    "url": "https://1001anjan.github.io/docs/configuration/#site-logo",
    "relUrl": "/docs/configuration/#site-logo"
  },"5": {
    "doc": "Configuration",
    "title": "Search",
    "content": "# Enable or disable the site search # Supports true (default) or false search_enabled: true search: # Split pages into sections that can be searched individually # Supports 1 - 6, default: 2 heading_level: 2 # Maximum amount of previews per search result # Default: 3 previews: 3 # Maximum amount of words to display before a matched word in the preview # Default: 5 preview_words_before: 5 # Maximum amount of words to display after a matched word in the preview # Default: 10 preview_words_after: 10 # Set the search token separator # Default: /[\\s\\-/]+/ # Example: enable support for hyphenated search words tokenizer_separator: /[\\s/]+/ # Display the relative url in search results # Supports true (default) or false rel_url: true # Enable or disable the search button that appears in the bottom right corner of every page # Supports true or false (default) button: false . ",
    "url": "https://1001anjan.github.io/docs/configuration/#search",
    "relUrl": "/docs/configuration/#search"
  },"6": {
    "doc": "Configuration",
    "title": "Aux links",
    "content": "# Aux links for the upper right navigation aux_links: \"Just the Docs on GitHub\": - \"//github.com/just-the-docs/just-the-docs\" # Makes Aux links open in a new tab. Default is false aux_links_new_tab: false . ",
    "url": "https://1001anjan.github.io/docs/configuration/#aux-links",
    "relUrl": "/docs/configuration/#aux-links"
  },"7": {
    "doc": "Configuration",
    "title": "Heading anchor links",
    "content": "# Heading anchor links appear on hover over h1-h6 tags in page content # allowing users to deep link to a particular heading on a page. # # Supports true (default) or false heading_anchors: true . ",
    "url": "https://1001anjan.github.io/docs/configuration/#heading-anchor-links",
    "relUrl": "/docs/configuration/#heading-anchor-links"
  },"8": {
    "doc": "Configuration",
    "title": "Footer content",
    "content": "# Footer content # appears at the bottom of every page's main content # Note: The footer_content option is deprecated and will be removed in a future major release. Please use `_includes/footer_custom.html` for more robust markup / liquid-based content. footer_content: \"Copyright &amp;copy; 2017-2020 Patrick Marsceill. Distributed by an &lt;a href=\\\"https://github.com/just-the-docs/just-the-docs/tree/main/LICENSE.txt\\\"&gt;MIT license.&lt;/a&gt;\" # Footer last edited timestamp last_edit_timestamp: true # show or hide edit time - page must have `last_modified_date` defined in the frontmatter last_edit_time_format: \"%b %e %Y at %I:%M %p\" # uses ruby's time format: https://ruby-doc.org/stdlib-2.7.0/libdoc/time/rdoc/Time.html # Footer \"Edit this page on GitHub\" link text gh_edit_link: true # show or hide edit this page link gh_edit_link_text: \"Edit this page on GitHub.\" gh_edit_repository: \"https://github.com/just-the-docs/just-the-docs\" # the github URL for your repo gh_edit_branch: \"main\" # the branch that your docs is served from # gh_edit_source: docs # the source that your files originate from gh_edit_view_mode: \"tree\" # \"tree\" or \"edit\" if you want the user to jump into the editor immediately . note: footer_content is deprecated, but still supported. For a better experience we have moved this into an include called _includes/footer_custom.html which will allow for robust markup / liquid-based content. | the “page last modified” data will only display if a page has a key called last_modified_date, formatted in some readable date format | last_edit_time_format uses Ruby’s DateTime formatter; see examples and more information at this link. | gh_edit_repository is the URL of the project’s GitHub repository | gh_edit_branch is the branch that the docs site is served from; defaults to main | gh_edit_source is the source directory that your project files are stored in (should be the same as site.source) | gh_edit_view_mode is \"tree\" by default, which brings the user to the github page; switch to \"edit\" to bring the user directly into editing mode | . ",
    "url": "https://1001anjan.github.io/docs/configuration/#footer-content",
    "relUrl": "/docs/configuration/#footer-content"
  },"9": {
    "doc": "Configuration",
    "title": "Color scheme",
    "content": "# Color scheme supports \"light\" (default) and \"dark\" color_scheme: dark . Preview dark color scheme . See Customization for more information. ",
    "url": "https://1001anjan.github.io/docs/configuration/#color-scheme",
    "relUrl": "/docs/configuration/#color-scheme"
  },"10": {
    "doc": "Configuration",
    "title": "Google Analytics",
    "content": "# Google Analytics Tracking (optional) # e.g, UA-1234567-89 ga_tracking: UA-5555555-55 ga_tracking_anonymize_ip: true # Use GDPR compliant Google Analytics settings (true by default) . ",
    "url": "https://1001anjan.github.io/docs/configuration/#google-analytics",
    "relUrl": "/docs/configuration/#google-analytics"
  },"11": {
    "doc": "Configuration",
    "title": "Document collections",
    "content": "By default, the navigation and search include normal pages. Instead, you can also use Jekyll collections which group documents semantically together. For example, put all your documentation files in the _docs folder and create the docs collection: . # Define Jekyll collections collections: # Define a collection named \"docs\", its documents reside in the \"_docs\" directory docs: permalink: \"/:collection/:path/\" output: true just_the_docs: # Define which collections are used in just-the-docs collections: # Reference the \"docs\" collection docs: # Give the collection a name name: Documentation # Exclude the collection from the navigation # Supports true or false (default) nav_exclude: false # Exclude the collection from the search # Supports true or false (default) search_exclude: false . You can reference multiple collections. This creates categories in the navigation with the configured names. collections: docs: permalink: \"/:collection/:path/\" output: true tutorials: permalink: \"/:collection/:path/\" output: true just_the_docs: collections: docs: name: Documentation tutorials: name: Tutorials . ",
    "url": "https://1001anjan.github.io/docs/configuration/#document-collections",
    "relUrl": "/docs/configuration/#document-collections"
  },"12": {
    "doc": "Customization",
    "title": "Customization",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/customization/",
    "relUrl": "/docs/customization/"
  },"13": {
    "doc": "Customization",
    "title": "Table of contents",
    "content": ". | Color schemes | Custom schemes . | Define a custom scheme | Use a custom scheme | Switchable custom scheme | . | Override and completely custom styles | . ",
    "url": "https://1001anjan.github.io/docs/customization/#table-of-contents",
    "relUrl": "/docs/customization/#table-of-contents"
  },"14": {
    "doc": "Customization",
    "title": "Color schemes",
    "content": "New . Just the Docs supports two color schemes: light (default), and dark. To enable a color scheme, set the color_scheme parameter in your site’s _config.yml file: . Example . # Color scheme supports \"light\" (default) and \"dark\" color_scheme: dark . Preview dark color scheme . ",
    "url": "https://1001anjan.github.io/docs/customization/#color-schemes",
    "relUrl": "/docs/customization/#color-schemes"
  },"15": {
    "doc": "Customization",
    "title": "Custom schemes",
    "content": "Define a custom scheme . You can add custom schemes. If you want to add a scheme named foo (can be any name) just add a file _sass/color_schemes/foo.scss (replace foo by your scheme name) where you override theme variables to change colors, fonts, spacing, etc. Available variables are listed in the _variables.scss file. For example, to change the link color from the purple default to blue, include the following inside your scheme file: . Example . $link-color: $blue-000; . Note: Editing the variables directly in _sass/support/variables.scss is not recommended and can cause other dependencies to fail. Please use scheme files. Use a custom scheme . To use the custom color scheme, only set the color_scheme parameter in your site’s _config.yml file: . color_scheme: foo . Switchable custom scheme . If you want to be able to change the scheme dynamically, for example via javascript, just add a file assets/css/just-the-docs-foo.scss (replace foo by your scheme name) with the following content: . --- --- {% include css/just-the-docs.scss.liquid color_scheme=\"foo\" %} . This allows you to switch the scheme via the following javascript. jtd.setTheme(\"foo\") . ",
    "url": "https://1001anjan.github.io/docs/customization/#custom-schemes",
    "relUrl": "/docs/customization/#custom-schemes"
  },"16": {
    "doc": "Customization",
    "title": "Override and completely custom styles",
    "content": "For styles that aren’t defined as variables, you may want to modify specific CSS classes. Additionally, you may want to add completely custom CSS specific to your content. To do this, put your styles in the file _sass/custom/custom.scss. This will allow for all overrides to be kept in a single file, and for any upstream changes to still be applied. For example, if you’d like to add your own styles for printing a page, you could add the following styles. Example . // Print-only styles. @media print { .side-bar, .page-header { display: none; } .main-content { max-width: auto; margin: 1em; } } . ",
    "url": "https://1001anjan.github.io/docs/customization/#override-and-completely-custom-styles",
    "relUrl": "/docs/customization/#override-and-completely-custom-styles"
  },"17": {
    "doc": "Data Structure",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure/#ui-components",
    "relUrl": "/docs/data-structure/data-structure/#ui-components"
  },"18": {
    "doc": "Data Structure",
    "title": "Data Structure",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure/",
    "relUrl": "/docs/data-structure/data-structure/"
  },"19": {
    "doc": "Data Structure Easy Set 1",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/#ui-components",
    "relUrl": "/docs/data-structure/ds-easy-set-1/#ui-components"
  },"20": {
    "doc": "Data Structure Easy Set 1",
    "title": "Data Structure Easy Set 1",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/",
    "relUrl": "/docs/data-structure/ds-easy-set-1/"
  },"21": {
    "doc": "Data Structure Easy Set 10",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-10#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-10#ui-components"
  },"22": {
    "doc": "Data Structure Easy Set 10",
    "title": "Data Structure Easy Set 10",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-10",
    "relUrl": "/docs/data-structure/data-structure-easy-set-10"
  },"23": {
    "doc": "Data Structure Easy Set 11",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-11#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-11#ui-components"
  },"24": {
    "doc": "Data Structure Easy Set 11",
    "title": "Data Structure Easy Set 11",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-11",
    "relUrl": "/docs/data-structure/data-structure-easy-set-11"
  },"25": {
    "doc": "Data Structure Easy Set 12",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-12#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-12#ui-components"
  },"26": {
    "doc": "Data Structure Easy Set 12",
    "title": "Data Structure Easy Set 12",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-12",
    "relUrl": "/docs/data-structure/data-structure-easy-set-12"
  },"27": {
    "doc": "Data Structure Easy Set 13",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-13#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-13#ui-components"
  },"28": {
    "doc": "Data Structure Easy Set 13",
    "title": "Data Structure Easy Set 13",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-13",
    "relUrl": "/docs/data-structure/data-structure-easy-set-13"
  },"29": {
    "doc": "Data Structure Easy Set 14",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-14#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-14#ui-components"
  },"30": {
    "doc": "Data Structure Easy Set 14",
    "title": "Data Structure Easy Set 14",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-14",
    "relUrl": "/docs/data-structure/data-structure-easy-set-14"
  },"31": {
    "doc": "Data Structure Easy Set 2",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-2#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-2#ui-components"
  },"32": {
    "doc": "Data Structure Easy Set 2",
    "title": "Data Structure Easy Set 2",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-2",
    "relUrl": "/docs/data-structure/data-structure-easy-set-2"
  },"33": {
    "doc": "Data Structure Easy Set 3",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-3#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-3#ui-components"
  },"34": {
    "doc": "Data Structure Easy Set 3",
    "title": "Data Structure Easy Set 3",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-3",
    "relUrl": "/docs/data-structure/data-structure-easy-set-3"
  },"35": {
    "doc": "Data Structure Easy Set 4",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-4#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-4#ui-components"
  },"36": {
    "doc": "Data Structure Easy Set 4",
    "title": "Data Structure Easy Set 4",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-4",
    "relUrl": "/docs/data-structure/data-structure-easy-set-4"
  },"37": {
    "doc": "Data Structure Easy Set 5",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-5#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-5#ui-components"
  },"38": {
    "doc": "Data Structure Easy Set 5",
    "title": "Data Structure Easy Set 5",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-5",
    "relUrl": "/docs/data-structure/data-structure-easy-set-5"
  },"39": {
    "doc": "Data Structure Easy Set 6",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-6#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-6#ui-components"
  },"40": {
    "doc": "Data Structure Easy Set 6",
    "title": "Data Structure Easy Set 6",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-6",
    "relUrl": "/docs/data-structure/data-structure-easy-set-6"
  },"41": {
    "doc": "Data Structure Easy Set 7",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-7#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-7#ui-components"
  },"42": {
    "doc": "Data Structure Easy Set 7",
    "title": "Data Structure Easy Set 7",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-7",
    "relUrl": "/docs/data-structure/data-structure-easy-set-7"
  },"43": {
    "doc": "Data Structure Easy Set 8",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-8#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-8#ui-components"
  },"44": {
    "doc": "Data Structure Easy Set 8",
    "title": "Data Structure Easy Set 8",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-8",
    "relUrl": "/docs/data-structure/data-structure-easy-set-8"
  },"45": {
    "doc": "Data Structure Easy Set 9",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-9#ui-components",
    "relUrl": "/docs/data-structure/data-structure-easy-set-9#ui-components"
  },"46": {
    "doc": "Data Structure Easy Set 9",
    "title": "Data Structure Easy Set 9",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/data-structure-easy-set-9",
    "relUrl": "/docs/data-structure/data-structure-easy-set-9"
  },"47": {
    "doc": "Data Structure Medium Set 1",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-1/#ui-components",
    "relUrl": "/docs/data-structure/ds-medium-set-1/#ui-components"
  },"48": {
    "doc": "Data Structure Medium Set 1",
    "title": "Data Structure Medium Set 1",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-medium-set-1/",
    "relUrl": "/docs/data-structure/ds-medium-set-1/"
  },"49": {
    "doc": "Markdown kitchen sink",
    "title": "Header 1",
    "content": "This is a normal paragraph following a header. GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere. ",
    "url": "https://1001anjan.github.io/docs/index-test/#header-1",
    "relUrl": "/docs/index-test/#header-1"
  },"50": {
    "doc": "Markdown kitchen sink",
    "title": "Header 2",
    "content": "This is a blockquote following a header. When something is important enough, you do it even if the odds are not in your favor. Header 3 . // Javascript code with syntax highlighting. var fun = function lang(l) { dateformat.i18n = require('./lang/' + l) return true; } . # Ruby code with syntax highlighting GitHubPages::Dependencies.gems.each do |gem, version| s.add_dependency(gem, \"= #{version}\") end . Header 4 with code not transformed . | This is an unordered list following a header. | This is an unordered list following a header. | This is an unordered list following a header. | . Header 5 . | This is an ordered list following a header. | This is an ordered list following a header. | This is an ordered list following a header. | . Header 6 . | head1 | head two | three | . | ok | good swedish fish | nice | . | out of stock | good and plenty | nice | . | ok | good oreos | hmm | . | ok | good zoute drop | yumm | . There’s a horizontal rule below this. Here is an unordered list: . | Item foo | Item bar | Item baz | Item zip | . And an ordered list: . | Item one | Item two | Item three | Item four | . And a nested list: . | level 1 item . | level 2 item | level 2 item . | level 3 item | level 3 item | . | . | level 1 item . | level 2 item | level 2 item | level 2 item | . | level 1 item . | level 2 item | level 2 item | . | level 1 item | . Nesting an ol in ul in an ol . | level 1 item (ul) . | level 2 item (ol) | level 2 item (ol) . | level 3 item (ul) | level 3 item (ul) | . | . | level 1 item (ul) . | level 2 item (ol) | level 2 item (ol) . | level 3 item (ul) | level 3 item (ul) | . | level 4 item (ol) | level 4 item (ol) . | level 3 item (ul) | level 3 item (ul) | . | . | level 1 item (ul) | . And a task list . | Hello, this is a TODO item | Hello, this is another TODO item | Goodbye, this item is done | . Small image . Large image . “Wroclaw University Library digitizing rare archival texts” by j_cadmus is marked with CC BY 2.0. Definition lists can be used with HTML syntax. Name Godzilla Born 1952 Birthplace Japan Color Green Multiple description terms and values . Term Brief description of Term Longer Term Longer description of Term, possibly more than one line Term First description of Term, possibly more than one line Second description of Term, possibly more than one line . Term1 Term2 Single description of Term1 and Term2, possibly more than one line Term1 Term2 First description of Term1 and Term2, possibly more than one line Second description of Term1 and Term2, possibly more than one line . More code . Long, single-line code blocks should not wrap. They should horizontally scroll if they are too long. This line should be long enough to demonstrate this. The final element. ",
    "url": "https://1001anjan.github.io/docs/index-test/#header-2",
    "relUrl": "/docs/index-test/#header-2"
  },"51": {
    "doc": "Markdown kitchen sink",
    "title": "Markdown kitchen sink",
    "content": "Text can be bold, italic, or strikethrough. Link to another page. There should be whitespace between paragraphs. There should be whitespace between paragraphs. We recommend including a README, or a file with information about your project. ",
    "url": "https://1001anjan.github.io/docs/index-test/",
    "relUrl": "/docs/index-test/"
  },"52": {
    "doc": "Home",
    "title": "Learning with Anjan.",
    "content": "Just the Docs gives your documentation a jumpstart with a responsive that is easily customizable. Get started now View it on GitHub . ",
    "url": "https://1001anjan.github.io/#learning-with-anjan",
    "relUrl": "/#learning-with-anjan"
  },"53": {
    "doc": "Home",
    "title": "Getting started",
    "content": "Dependencies . Just the Docs is built for Jekyll, a static site generator. View the quick start guide for more information. Just the Docs requires no special plugins and can run on GitHub Pages’ standard Jekyll compiler. The Jekyll SEO Tag plugin is included by default (no need to run any special installation) to inject SEO and open graph metadata on docs pages. For information on how to configure SEO and open graph metadata visit the Jekyll SEO Tag usage guide. Quick start: Use as a GitHub Pages remote theme . | Add Just the Docs to your Jekyll site’s _config.yml as a remote theme | . remote_theme: just-the-docs/just-the-docs . You must have GitHub Pages enabled on your repo, one or more Markdown files, and a _config.yml file. See an example repository . Local installation: Use the gem-based theme . | Install the Ruby Gem $ gem install just-the-docs . # .. or add it to your your Jekyll site’s Gemfile gem \"just-the-docs\" . | Add Just the Docs to your Jekyll site’s _config.yml theme: \"just-the-docs\" . | Optional: Initialize search data (creates search-data.json) $ bundle exec just-the-docs rake search:init . | Run you local Jekyll server $ jekyll serve . # .. or if you're using a Gemfile (bundler) $ bundle exec jekyll serve . | Point your web browser to http://localhost:4000 | . If you’re hosting your site on GitHub Pages, set up GitHub Pages and Jekyll locally so that you can more easily work in your development environment. Configure Just the Docs . | See configuration options | . ",
    "url": "https://1001anjan.github.io/#getting-started",
    "relUrl": "/#getting-started"
  },"54": {
    "doc": "Home",
    "title": "About the project",
    "content": "Just the Docs is © 2017-2022 by Patrick Marsceill. License . Just the Docs is distributed by an MIT license. Contributing . When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change. Read more about becoming a contributor in our GitHub repo. Thank you to the contributors of Just the Docs! . Code of Conduct . Just the Docs is committed to fostering a welcoming community. View our Code of Conduct on our GitHub repository. ",
    "url": "https://1001anjan.github.io/#about-the-project",
    "relUrl": "/#about-the-project"
  },"55": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "https://1001anjan.github.io/",
    "relUrl": "/"
  },"56": {
    "doc": "Java",
    "title": "UI Components",
    "content": "To make it as easy as possible to write documentation in plain Markdown, most UI components are styled using default Markdown elements with few additional CSS classes needed. ",
    "url": "https://1001anjan.github.io/docs/Java/java/#ui-components",
    "relUrl": "/docs/Java/java/#ui-components"
  },"57": {
    "doc": "Java",
    "title": "Java",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/Java/java/",
    "relUrl": "/docs/Java/java/"
  },"58": {
    "doc": "Navigation Structure",
    "title": "Navigation Structure",
    "content": ". | Navigation Structure . | Main navigation | Ordering pages . | Example | . | Excluding pages . | Example | . | Pages with children . | Example | Child pages . | Example | . | Auto-generating Table of Contents . | Example | . | Children with children . | Example | . | . | Auxiliary Links . | Example | . | In-page navigation with Table of Contents . | Example | Collapsible Table of Contents | . | . | . ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/",
    "relUrl": "/docs/navigation-structure/"
  },"59": {
    "doc": "Navigation Structure",
    "title": "Main navigation",
    "content": "The main navigation for your Just the Docs site is on the left side of the page at large screens and on the top (behind a tap) on small screens. The main navigation can be structured to accommodate a multi-level menu system (pages with children and grandchildren). By default, all pages will appear as top level pages in the main nav unless a parent page is defined (see Pages with Children). ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#main-navigation",
    "relUrl": "/docs/navigation-structure/#main-navigation"
  },"60": {
    "doc": "Navigation Structure",
    "title": "Ordering pages",
    "content": "To specify a page order, you can use the nav_order parameter in your pages’ YAML front matter. Example . --- layout: default title: Customization nav_order: 4 --- . The parameter values determine the order of the top-level pages, and of child pages with the same parent. You can reuse the same parameter values (e.g., integers starting from 1) for the child pages of different parents. The parameter values can be numbers (integers, floats) and/or strings. When you omit nav_order parameters, they default to the titles of the pages, which are ordered alphabetically. Pages with numerical nav_order parameters always come before those with strings or default nav_order parameters. If you want to make the page order independent of the page titles, you can set explicit nav_order parameters on all pages. By default, all Capital letters come before all lowercase letters; you can add nav_sort: case_insensitive in the configuration file to ignore the case. Enclosing strings in quotation marks is optional. Note for users of previous versions: nav_sort: case_insensitive previously affected the ordering of numerical nav_order parameters: e.g., 10 came before 2. Also, all pages with explicit nav_order parameters previously came before all pages with default parameters. Both were potentially confusing, and they have now been eliminated. ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#ordering-pages",
    "relUrl": "/docs/navigation-structure/#ordering-pages"
  },"61": {
    "doc": "Navigation Structure",
    "title": "Excluding pages",
    "content": "For specific pages that you do not wish to include in the main navigation, e.g. a 404 page or a landing page, use the nav_exclude: true parameter in the YAML front matter for that page. Example . --- layout: default title: 404 nav_exclude: true --- . The nav_exclude parameter does not affect the auto-generating list of child pages, which you can use to access pages excluded from the main navigation. Pages with no title are automatically excluded from the navigation. ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#excluding-pages",
    "relUrl": "/docs/navigation-structure/#excluding-pages"
  },"62": {
    "doc": "Navigation Structure",
    "title": "Pages with children",
    "content": "Sometimes you will want to create a page with many children (a section). First, it is recommended that you keep pages that are related in a directory together… For example, in these docs, we keep all of the written documentation in the ./docs directory and each of the sections in subdirectories like ./docs/ui-components and ./docs/utilities. This gives us an organization like: . +-- .. |-- (Jekyll files) |-- docs |-- ui-components | |-- index.md (parent page) | |-- buttons.md | |-- code.md | |-- labels.md | |-- tables.md | +-- typography.md | |-- utilities | |-- index.md (parent page) | |-- color.md | |-- layout.md | |-- responsive-modifiers.md | +-- typography.md | |-- (other md files, pages with no children) | +-- .. |-- (Jekyll files) +-- .. On the parent pages, add this YAML front matter parameter: . | has_children: true (tells us that this is a parent page) | . Example . --- layout: default title: UI Components nav_order: 2 has_children: true --- . Here we’re setting up the UI Components landing page that is available at /docs/ui-components, which has children and is ordered second in the main nav. Child pages . On child pages, simply set the parent: YAML front matter to whatever the parent’s page title is and set a nav order (this number is now scoped within the section). Example . --- layout: default title: Buttons parent: UI Components nav_order: 2 --- . The Buttons page appears as a child of UI Components and appears second in the UI Components section. Auto-generating Table of Contents . By default, all pages with children will automatically append a Table of Contents which lists the child pages after the parent page’s content. To disable this auto Table of Contents, set has_toc: false in the parent page’s YAML front matter. Example . --- layout: default title: UI Components nav_order: 2 has_children: true has_toc: false --- . Children with children . Child pages can also have children (grandchildren). This is achieved by using a similar pattern on the child and grandchild pages. | Add the has_children attribute to the child | Add the parent and grand_parent attribute to the grandchild | . Example . --- layout: default title: Buttons parent: UI Components nav_order: 2 has_children: true --- . --- layout: default title: Buttons Child Page parent: Buttons grand_parent: UI Components nav_order: 1 --- . This would create the following navigation structure: . +-- .. |-- UI Components |-- .. | |-- Buttons | |-- Button Child Page | |-- .. | +-- .. ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#pages-with-children",
    "relUrl": "/docs/navigation-structure/#pages-with-children"
  },"63": {
    "doc": "Navigation Structure",
    "title": "Auxiliary Links",
    "content": "To add auxiliary links to your site (in the upper right on all pages), add it to the aux_links configuration option in your site’s _config.yml file. Example . # Aux links for the upper right navigation aux_links: \"Just the Docs on GitHub\": - \"//github.com/just-the-docs/just-the-docs\" . ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#auxiliary-links",
    "relUrl": "/docs/navigation-structure/#auxiliary-links"
  },"64": {
    "doc": "Navigation Structure",
    "title": "In-page navigation with Table of Contents",
    "content": "To generate a Table of Contents on your docs pages, you can use the {:toc} method from Kramdown, immediately after an &lt;ol&gt; in Markdown. This will automatically generate an ordered list of anchor links to various sections of the page based on headings and heading levels. There may be occasions where you’re using a heading and you don’t want it to show up in the TOC, so to skip a particular heading use the {: .no_toc } CSS class. Example . # Navigation Structure {: .no_toc } ## {: .no_toc .text-delta } 1. TOC {:toc} . This example skips the page name heading (#) from the TOC, as well as the heading for the Table of Contents itself (##) because it is redundant, followed by the table of contents itself. To get an unordered list, replace 1. TOC above by - TOC. Collapsible Table of Contents . The Table of Contents can be made collapsible using the &lt;details&gt; and &lt;summary&gt; elements , as in the following example. The attribute open (expands the Table of Contents by default) and the styling with {: .text-delta } are optional. &lt;details open markdown=\"block\"&gt; &lt;summary&gt; &lt;/summary&gt; {: .text-delta } 1. TOC {:toc} &lt;/details&gt; . The result is shown at the top of this page ({:toc} can be used only once on each page). ",
    "url": "https://1001anjan.github.io/docs/navigation-structure/#in-page-navigation-with-table-of-contents",
    "relUrl": "/docs/navigation-structure/#in-page-navigation-with-table-of-contents"
  },"65": {
    "doc": "Odd Even Linked List",
    "title": "Odd Even Linked List",
    "content": "Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list. The first node is considered odd, and the second node is even, and so on. Note that the relative order inside both the even and odd groups should remain as it was in the input. You must solve the problem in O(1) extra space complexity and O(n) time complexity. Example 1: . Input: head = [1,2,3,4,5] Output: [1,3,5,2,4] . Example 2: . Input: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4] . Constraints: . | The number of nodes in the linked list is in the range [0, 104]. | -10^6 &lt;= Node.val &lt;= 10^6 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode oddEvenList(ListNode head) { if(head == null) return head; ListNode oddList, evenList, ptr, qtr; // create first node oddList = ptr = head; head = head.next; if(head == null) return oddList; evenList = qtr = head; head = head.next; boolean f = true; while(head != null){ if(f){ ptr.next = head; ptr = head; }else{ qtr.next = head; qtr = head; } head = head.next; f = !f; } ptr.next = evenList; qtr.next = null; return oddList; } } . ",
    "url": "https://1001anjan.github.io/problem-1-Odd%20Even%20Linked%20List/",
    "relUrl": "/problem-1-Odd Even Linked List/"
  },"66": {
    "doc": "Two Sum",
    "title": "1. Two Sum",
    "content": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: . Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2: . Input: nums = [3,2,4], target = 6 Output: [1,2] . Example 3: . Input: nums = [3,3], target = 6 Output: [0,1] . Constraints: . 2 &lt;= nums.length &lt;= 104 -109 &lt;= nums[i] &lt;= 109 -109 &lt;= target &lt;= 109 . Only one valid answer exists. Solution . Time Complexity: O(n) Space Complexity: O(n) . class Solution { public int[] twoSum(int[] nums, int target) { HashMap&lt;Integer, Integer&gt; map = new HashMap(); int [] result = new int[2]; result[0] = -1; result[1] = -1; for(int i=0; i&lt;nums.length; i++){ if(map.containsKey(target - nums[i])){ result[0] = map.get(target - nums[i]); result[1] = i; }else{ map.put(nums[i],i); } } return result; } } . Related solution . Since elements are not sorted, we can sort the list in O(nlog(n)) complexity. Space complexity O(1) . class Solution { public boolean twoSum(int[] nums, int target) { Arrays.sort(nums); int i = 0; int j = nums.length - 1; while(i&lt;j){ if(nums[i] + nums[j] == target){ return true; } if(nums[i] + nums[j] &gt; target){ j--; }else{ i++; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-1-two-sum/#1-two-sum",
    "relUrl": "/problem-1-two-sum/#1-two-sum"
  },"67": {
    "doc": "Two Sum",
    "title": "Two Sum",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-1-two-sum/",
    "relUrl": "/problem-1-two-sum/"
  },"68": {
    "doc": "3Sum Closest",
    "title": "3Sum Closest",
    "content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example 1: . Input: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Example 2: . Input: nums = [0,0,0], target = 1 Output: 0 Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0). Constraints: . | 3 &lt;= nums.length &lt;= 500 | -1000 &lt;= nums[i] &lt;= 1000 | -10^4 &lt;= target &lt;= 10^4 | . Solution: . class Solution { public int threeSumClosest(int[] nums, int target) { int diff = Integer.MAX_VALUE, z = nums.length - 1; int ans = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 1 &amp;&amp; diff != 0; i++){ int l = i + 1, u = z; while(l &lt; u){ int s = nums[i] + nums[l] + nums[u]; int d = target - s; if(Math.abs(d) &lt; Math.abs(diff)){ diff = d; ans = s; } if(s &lt; target){ l++; }else{ u--; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-10-3Sum%20Closest/",
    "relUrl": "/problem-10-3Sum Closest/"
  },"69": {
    "doc": "Search Insert Position",
    "title": "Search Insert Position",
    "content": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order. You must write an algorithm with O(log n) runtime complexity. Example 1: . Input: nums = [1,3,5,6], target = 5 Output: 2 . Example 2: . Input: nums = [1,3,5,6], target = 2 Output: 1 . Example 3: . Input: nums = [1,3,5,6], target = 7 Output: 4 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums contains distinct values sorted in ascending order. | -104 &lt;= target &lt;= 104 | . Solution . class Solution { public int searchInsert(int[] nums, int target) { if(nums == null || nums.length == 0) return 0; int i = 0; // start index int j = nums.length-1; // last index while(i&lt;=j){ int mid = (i + j)/2; // middle index if(nums[mid] == target) return mid; // stop iterating when get target in our array else if(nums[mid] &lt; target) i = mid + 1; // goto right-half in array else j = mid - 1; // goto left half in array } return i; } } . ",
    "url": "https://1001anjan.github.io/problem-10-search-insert-position/",
    "relUrl": "/problem-10-search-insert-position/"
  },"70": {
    "doc": "Reverse Words in a String III",
    "title": "Reverse Words in a String III",
    "content": "Given a string s, reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1: . Input: s = \"Let's take LeetCode contest\" Output: \"s'teL ekat edoCteeL tsetnoc\" . Example 2: . Input: s = \"God Ding\" Output: \"doG gniD\" . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | s contains printable ASCII characters. | s does not contain any leading or trailing spaces. | There is at least one word in s. | All the words in s are separated by a single space. | . Solution: . class Solution { public String reverseWords(String s) { char[] str = s.toCharArray(); int i = 0; while(i&lt;str.length){ if(str[i] != ' '){ int l = i; int u = i; while(u&lt;str.length){ if(str[u] == ' ') break; u++; } i = u; u--; while(l&lt;u){ char ch = str[l]; str[l] = str[u]; str[u] = ch; l++; u--; } }else i++; } return new String(str); } } . public class Solution { public String reverseWords(String s) { String words[] = s.split(\" \"); StringBuilder res=new StringBuilder(); for (String word: words) res.append(new StringBuffer(word).reverse().toString() + \" \"); return res.toString().trim(); } } . ",
    "url": "https://1001anjan.github.io/problem-100-Reverse-Words-in-a-String-III/",
    "relUrl": "/problem-100-Reverse-Words-in-a-String-III/"
  },"71": {
    "doc": "Maximum Depth of N-ary Tree",
    "title": "Maximum Depth of N-ary Tree",
    "content": "Given a n-ary tree, find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Nary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples). Example 1: . Input: root = [1,null,3,2,4,null,5,6] Output: 3 . Example 2: . Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: 5 . Constraints: . | The total number of nodes is in the range [0, 104]. | The depth of the n-ary tree is less than or equal to 1000. | . Solution: . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; */ class Solution { public int maxDepth(Node root) { if(root == null) return 0; int dp = 1; for(Node node : root.children){ dp = Math.max(dp, maxDepth(node) + 1); } return dp; } } . ",
    "url": "https://1001anjan.github.io/problem-101-Maximum-Depth-of-N-ary-Tree/",
    "relUrl": "/problem-101-Maximum-Depth-of-N-ary-Tree/"
  },"72": {
    "doc": "Array Partition I",
    "title": "Array Partition I",
    "content": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), …, (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum. Example 1: . Input: nums = [1,4,3,2] Output: 4 Explanation: All possible pairings (ignoring the ordering of elements) are: 1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3 2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3 3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4 So the maximum possible sum is 4. Example 2: . Input: nums = [6,2,6,5,1,2] Output: 9 Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9. Constraints: . | 1 &lt;= n &lt;= 104 | nums.length == 2 * n | -104 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int arrayPairSum(int[] nums) { int max = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i = i+2) max += nums[i]; return max; } } . Counting sort : . https://leetcode.com/problems/array-partition-i/solution/ . class Solution { final static int K = 10000; public int arrayPairSum(int[] nums) { // Store the frequency of each element int[] elementToCount = new int[2 * K + 1]; for (int element : nums) { // Add K to element to offset negative values elementToCount[element + K]++; } // Initialize sum to zero int maxSum = 0; boolean isEvenIndex = true; for (int element = 0; element &lt;= 2 * K; element++) { while (elementToCount[element] &gt; 0) { // Add element if it is at even position maxSum += (isEvenIndex ? element - K : 0); // Flip the value (one to zero or zero to one) isEvenIndex = !isEvenIndex; // Decrement the frequency count elementToCount[element]--; } } return maxSum; } } . ",
    "url": "https://1001anjan.github.io/problem-102-Array-Partition-I/",
    "relUrl": "/problem-102-Array-Partition-I/"
  },"73": {
    "doc": "Binary Tree Tilt",
    "title": "Binary Tree Tilt",
    "content": "Given the root of a binary tree, return the sum of every tree node’s tilt. The tilt of a tree node is the absolute difference between the sum of all left subtree node values and all right subtree node values. If a node does not have a left child, then the sum of the left subtree node values is treated as 0. The rule is similar if the node does not have a right child. Example 1: . Input: root = [1,2,3] Output: 1 Explanation: Tilt of node 2 : |0-0| = 0 (no children) Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 1 : |2-3| = 1 (left subtree is just left child, so sum is 2; right subtree is just right child, so sum is 3) Sum of every tilt : 0 + 0 + 1 = 1 . Example 2: . Input: root = [4,2,9,3,5,null,7] Output: 15 Explanation: Tilt of node 3 : |0-0| = 0 (no children) Tilt of node 5 : |0-0| = 0 (no children) Tilt of node 7 : |0-0| = 0 (no children) Tilt of node 2 : |3-5| = 2 (left subtree is just left child, so sum is 3; right subtree is just right child, so sum is 5) Tilt of node 9 : |0-7| = 7 (no left child, so sum is 0; right subtree is just right child, so sum is 7) Tilt of node 4 : |(3+5+2)-(9+7)| = |10-16| = 6 (left subtree values are 3, 5, and 2, which sums to 10; right subtree values are 9 and 7, which sums to 16) Sum of every tilt : 0 + 0 + 0 + 2 + 7 + 6 = 15 . Example 3: . Input: root = [21,7,14,1,1,2,2,3,3] Output: 9 . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int totalTilt = 0; public int findTilt(TreeNode root) { this.totalTilt = 0; calculateTilt(root); return this.totalTilt; } public int calculateTilt(TreeNode root){ if(root == null) return 0; int leftTilt = calculateTilt(root.left); int rightTilt = calculateTilt(root.right); this.totalTilt += Math.abs(leftTilt - rightTilt); // return the sum of values starting from this node. return root.val + leftTilt + rightTilt; } } . ",
    "url": "https://1001anjan.github.io/problem-103-Binary-Tree-Tilt/",
    "relUrl": "/problem-103-Binary-Tree-Tilt/"
  },"74": {
    "doc": "Reshape the Matrix",
    "title": "Reshape the Matrix",
    "content": "In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data. You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix. The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were. If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: . Input: mat = [[1,2],[3,4]], r = 1, c = 4 Output: [[1,2,3,4]] . Example 2: . Input: mat = [[1,2],[3,4]], r = 2, c = 4 Output: [[1,2],[3,4]] . Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= m, n &lt;= 100 | -1000 &lt;= mat[i][j] &lt;= 1000 | 1 &lt;= r, c &lt;= 300 | . Solution: . class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int m = mat.length; int n = mat[0].length; if(m*n != r*c) return mat; int[][] result = new int[r][c]; int k,l; k = l = 0; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ result[k][l] = mat[i][j]; l++; if(l == c){ l = 0; k++; } } } return result; } } . class Solution { public int[][] matrixReshape(int[][] mat, int r, int c) { int m = mat.length; int n = mat[0].length; if((m*n)!=(r*c)) return mat; int reshape[][] = new int[r][c]; for(int i=0;i&lt;(m*n);i++){ reshape[i/c][i%c]=mat[i/n][i%n]; } return reshape; } } . ",
    "url": "https://1001anjan.github.io/problem-104-Reshape-the-Matrix/",
    "relUrl": "/problem-104-Reshape-the-Matrix/"
  },"75": {
    "doc": "Subtree of Another Tree",
    "title": "Subtree of Another Tree",
    "content": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node’s descendants. The tree tree could also be considered as a subtree of itself. Example 1: . Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true . Example 2: . Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false . Constraints: . | The number of nodes in the root tree is in the range [1, 2000]. | The number of nodes in the subRoot tree is in the range [1, 1000]. | -104 &lt;= root.val &lt;= 104 | -104 &lt;= subRoot.val &lt;= 104 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { Stack&lt;TreeNode&gt; s1 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;&gt;(); Stack&lt;TreeNode&gt; s3 = new Stack&lt;&gt;(); s1.push(root); int count = countNode(subRoot); System.out.println(\"Count: \"+count); while(!s1.isEmpty()){ TreeNode node = s1.pop(); if(node.val == subRoot.val){ TreeNode sub = subRoot; s2.clear(); s3.clear(); s2.push(node); s3.push(sub); int c = 0; while(!s3.isEmpty()){ TreeNode n1 = s3.pop(); if(s2.isEmpty()) break; TreeNode n2 = s2.pop(); if(n1.val != n2.val) break; if(n1.left != null){ if(n2.left == null) break; s3.push(n1.left); s2.push(n2.left); } if(n1.left == null &amp;&amp; n2.left != null) break; if(n1.right != null){ if(n2.right == null) break; s3.push(n1.right); s2.push(n2.right); } if(n1.right == null &amp;&amp; n2.right != null) break; c++; } if(c == count) return true; } if(node.left != null) s1.push(node.left); if(node.right != null) s1.push(node.right); } return false; } public int countNode(TreeNode head){ if(head == null) return 0; return 1 + countNode(head.left) + countNode(head.right); } } . Hash solution . The main idea of this solution is that every subtree of root can be hashed. The general technique is called Merkle Tree Hashing. Consider a tree with a root value of v. Recursively hash the left and right subtree (storing their hashes in a global list - in my code the ArrayList hashes). In my code, my hash combiner function is (v + LB + R * BB)%M. | B is the base of the hash, M is the mod of the hash. | L and R are the hashes of the left and right subtrees, which can be calculated recursively via DFS. After we compute the hashes of all subtrees of root, we can check to see if any of them equal the hash of subRoot. | . The time complexity is O(N) because our DFS processes each node of the tree. At each step, the actual hashing is O(1). The space complexity is O(N) because we store the hashes of each node. class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { Merkle mht = new Merkle(root); long H = (new Merkle(subRoot)).hash(); for (long h: mht.hashes) { if (h==H) return true; } return false; } static class Merkle { long B = 20051L; long M = 1000000007L; ArrayList&lt;Long&gt; hashes; public Merkle(TreeNode t) { hashes = new ArrayList&lt;Long&gt;(); dfs(t); } //hash of the entire tree long hash() { return hashes.get(hashes.size()-1); } //left is *B, right is *B^2 long dfs(TreeNode t) { long H = t.val+10004; if (t.left != null) { H += dfs(t.left)*B; } if (t.right != null) { H += dfs(t.right)*B*B; } H %= M; hashes.add(H); return H; } } } . Recursive . class Solution { public boolean isSubtree(TreeNode root, TreeNode subRoot) { if(root == null){ return false; }else if(isSameTree(root, subRoot)){ //checking if they overlap each other or not return true; }else if(isSubtree(root.left, subRoot)){ //checking on left child of root if subTree matches there return true; }else{ //checking on right child of root if subTree matches there return isSubtree(root.right, subRoot); } } public boolean isSameTree(TreeNode root, TreeNode subRoot){ if(root == null || subRoot == null){ return root == null &amp;&amp; subRoot == null; }else if(root.val == subRoot.val){ //if val is same at both nodes, then only we will check forward if(isSameTree(root.left, subRoot.left) == false){ //now checking left part of both of them return false; } //now checking right part of both of them return isSameTree(root.right, subRoot.right); }else{ return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-105-Subtree-of-Another-Tree/",
    "relUrl": "/problem-105-Subtree-of-Another-Tree/"
  },"76": {
    "doc": "N-ary Tree Preorder Traversal",
    "title": "N-ary Tree Preorder Traversal",
    "content": "Given the root of an n-ary tree, return the preorder traversal of its nodes’ values. Nary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples) . Example 1: . Input: root = [1,null,3,2,4,null,5,6] Output: [1,3,5,6,2,4] . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | 0 &lt;= Node.val &lt;= 104 | The height of the n-ary tree is less than or equal to 1000. | . Solution . /* // Definition for a Node. class Node { public int val; public List&lt;Node&gt; children; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, List&lt;Node&gt; _children) { val = _val; children = _children; } }; */ class Solution { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); public List&lt;Integer&gt; preorder(Node root) { if(root == null) return list; list.add(root.val); for(Node n : root.children) preorder(n); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-106-N-ary-Tree-Preorder-Traversal/",
    "relUrl": "/problem-106-N-ary-Tree-Preorder-Traversal/"
  },"77": {
    "doc": "Longest Harmonious Subsequence",
    "title": "Longest Harmonious Subsequence",
    "content": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1. Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences. A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Example 1: . Input: nums = [1,3,2,2,5,2,3,7] Output: 5 Explanation: The longest harmonious subsequence is [3,2,2,2,3]. Example 2: . Input: nums = [1,2,3,4] Output: 2 . Example 3: . Input: nums = [1,1,1,1] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 2 * 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution: . public class Solution { public int findLHS(int[] nums) { HashMap &lt; Integer, Integer &gt; map = new HashMap &lt; &gt; (); int res = 0; for (int num: nums) { map.put(num, map.getOrDefault(num, 0) + 1); } for (int key: map.keySet()) { if (map.containsKey(key + 1)) res = Math.max(res, map.get(key) + map.get(key + 1)); } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-107-Longest-Harmonious-Subsequence/",
    "relUrl": "/problem-107-Longest-Harmonious-Subsequence/"
  },"78": {
    "doc": "Construct String from Binary Tree",
    "title": "Construct String from Binary Tree",
    "content": "Given the root of a binary tree, construct a string consisting of parenthesis and integers from a binary tree with the preorder traversal way, and return it. Omit all the empty parenthesis pairs that do not affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: . Input: root = [1,2,3,4] Output: \"1(2(4))(3)\" Explanation: Originally, it needs to be \"1(2(4)())(3()())\", but you need to omit all the unnecessary empty parenthesis pairs. And it will be \"1(2(4))(3)\" . Example 2: . Input: root = [1,2,3,null,4] Output: \"1(2()(4))(3)\" Explanation: Almost the same as the first example, except we cannot omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public String tree2str(TreeNode root) { if(root == null) return \"\"; if(root.left == null &amp;&amp; root.right == null) return root.val + \"\"; if(root.right == null) return root.val+\"(\"+tree2str(root.left)+\")\"; return root.val+\"(\"+tree2str(root.left)+\")(\"+tree2str(root.right)+\")\"; } } . Non-recursive: . public class Solution { public String tree2str(TreeNode t) { if (t == null) return \"\"; Stack &lt; TreeNode &gt; stack = new Stack &lt; &gt; (); stack.push(t); Set &lt; TreeNode &gt; visited = new HashSet &lt; &gt; (); StringBuilder s = new StringBuilder(); while (!stack.isEmpty()) { t = stack.peek(); if (visited.contains(t)) { stack.pop(); s.append(\")\"); } else { visited.add(t); s.append(\"(\" + t.val); if (t.left == null &amp;&amp; t.right != null) s.append(\"()\"); if (t.right != null) stack.push(t.right); if (t.left != null) stack.push(t.left); } } return s.substring(1, s.length() - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-108-Construct-String-from-Binary-Tree/",
    "relUrl": "/problem-108-Construct-String-from-Binary-Tree/"
  },"79": {
    "doc": "Merge Two Binary Trees",
    "title": "Merge Two Binary Trees",
    "content": "You are given two binary trees root1 and root2. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree. Return the merged tree. Note: The merging process must start from the root nodes of both trees. Example 1: . Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] Output: [3,4,5,5,4,null,7] . Example 2: . Input: root1 = [1], root2 = [1,2] Output: [2,2] . Constraints: . | The number of nodes in both trees is in the range [0, 2000]. | -104 &lt;= Node.val &lt;= 104 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if(root1 == null) return root2; if(root2 == null) return root1; root1.val = root1.val + root2.val; root1.left = mergeTrees(root1.left,root2.left); root1.right = mergeTrees(root1.right,root2.right); return root1; } } . Non-recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { if(root1 == null) return root2; if(root2 == null) return root1; Stack&lt;TreeNode&gt; s1 = new Stack&lt;TreeNode&gt;(); Stack&lt;TreeNode&gt; s2 = new Stack&lt;TreeNode&gt;(); TreeNode h1, h2; h1 = root1; h2 = root2; s1.push(h1); s2.push(h2); while(!s1.isEmpty() &amp;&amp; !s2.isEmpty()){ h1 = s1.pop(); h2 = s2.pop(); h1.val = h1.val + h2.val; if(h1.left != null &amp;&amp; h2.left != null){ s1.push(h1.left); s2.push(h2.left); } if(h1.right !=null &amp;&amp; h2.right != null){ s1.push(h1.right); s2.push(h2.right); } if(h1.left == null &amp;&amp; h2.left != null){ h1.left = h2.left; h2.left = null; } if(h1.right == null &amp;&amp; h2.right != null){ h1.right = h2.right; h2.right = null; } } return root1; } } . ",
    "url": "https://1001anjan.github.io/problem-109-Merge-Two-Binary-Trees/",
    "relUrl": "/problem-109-Merge-Two-Binary-Trees/"
  },"80": {
    "doc": "Letter Combinations of a Phone Number",
    "title": "Letter Combinations of a Phone Number",
    "content": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. Example 1: . Input: digits = \"23\" Output: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] . Example 2: . Input: digits = \"\" Output: [] . Example 3: . Input: digits = \"2\" Output: [\"a\",\"b\",\"c\"] . Constraints: . | 0 &lt;= digits.length &lt;= 4 | digits[i] is a digit in the range [‘2’, ‘9’]. | . Solution: . class Solution { String[] mp = {\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; public List&lt;String&gt; letterCombinations(String digits) { int n = digits.length(); if(n == 0) return new ArrayList&lt;String&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); if(n == 1){ for(char ch : mp[Character.getNumericValue(digits.charAt(0))].toCharArray()){ result.add(String.valueOf(ch)); } return result; } List&lt;String&gt; ans = letterCombinations(digits.substring(1,n)); for(char ch : mp[Character.getNumericValue(digits.charAt(0))].toCharArray()){ for(String s : ans){ result.add(ch+s); } } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-11-Letter%20Combinations%20of%20a%20Phone%20Number/",
    "relUrl": "/problem-11-Letter Combinations of a Phone Number/"
  },"81": {
    "doc": "Maximum Subarray",
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. A subarray is a contiguous part of an array. Example 1: . Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: . Input: nums = [1] Output: 1 . Example 3: . Input: nums = [5,4,-1,7,8] Output: 23 . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -104 &lt;= nums[i] &lt;= 104 | . Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. class Solution { public int maxSubArray(int[] nums) { int prevSum = nums[0]; int currentSum = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if(currentSum + nums[i]&lt; nums[i]){ currentSum = nums[i]; }else{ currentSum += nums[i]; } prevSum = Math.max(prevSum, currentSum); } return Math.max(prevSum, currentSum); } } . ",
    "url": "https://1001anjan.github.io/problem-11-maximum-subarray/",
    "relUrl": "/problem-11-maximum-subarray/"
  },"82": {
    "doc": "Maximum Product of Three Numbers",
    "title": "Maximum Product of Three Numbers",
    "content": "Given an integer array nums, find three numbers whose product is maximum and return the maximum product. Example 1: . Input: nums = [1,2,3] Output: 6 . Example 2: . Input: nums = [1,2,3,4] Output: 24 . Example 3: . Input: nums = [-1,-2,-3] Output: -6 . Constraints: . | 3 &lt;= nums.length &lt;= 104 | -1000 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); return Math.max(nums[0] * nums[1] * nums[nums.length - 1], nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3]); } } . public class Solution { public int maximumProduct(int[] nums) { int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE; int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE; for (int n: nums) { if (n &lt;= min1) { min2 = min1; min1 = n; } else if (n &lt;= min2) { // n lies between min1 and min2 min2 = n; } if (n &gt;= max1) { // n is greater than max1, max2 and max3 max3 = max2; max2 = max1; max1 = n; } else if (n &gt;= max2) { // n lies betweeen max1 and max2 max3 = max2; max2 = n; } else if (n &gt;= max3) { // n lies betwen max2 and max3 max3 = n; } } return Math.max(min1 * min2 * max1, max1 * max2 * max3); } } . ",
    "url": "https://1001anjan.github.io/problem-110-Maximum-Product-of-Three-Numbers/",
    "relUrl": "/problem-110-Maximum-Product-of-Three-Numbers/"
  },"83": {
    "doc": "Average of Levels in Binary Tree",
    "title": "Average of Levels in Binary Tree",
    "content": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2: . Input: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -231 &lt;= Node.val &lt;= 231 - 1 | . Solution: . BFS . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Double&gt; averageOfLevels(TreeNode root) { List&lt;Double&gt; result = new ArrayList&lt;Double&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()){ Queue&lt;TreeNode&gt; tempQueue = new LinkedList&lt;TreeNode&gt;(); double count = 0; double sum = 0; while(!queue.isEmpty()){ TreeNode node = queue.remove(); sum += node.val; count++; if(node.left != null) tempQueue.add(node.left); if(node.right != null) tempQueue.add(node.right); } queue = tempQueue; result.add(sum/count); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-111-Average-of-Levels-in-Binary-Tree/",
    "relUrl": "/problem-111-Average-of-Levels-in-Binary-Tree/"
  },"84": {
    "doc": "Maximum Average Subarray I",
    "title": "Maximum Average Subarray I",
    "content": "You are given an integer array nums consisting of n elements, and an integer k. Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted. Example 1: . Input: nums = [1,12,-5,-6,50,3], k = 4 Output: 12.75000 Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75 . Example 2: . Input: nums = [5], k = 1 Output: 5.00000 . Constraints: . | n == nums.length | 1 &lt;= k &lt;= n &lt;= 105 | -104 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public double findMaxAverage(int[] nums, int k) { double sum = 0; for(int i=0; i&lt;k; i++) sum += nums[i]; double res = sum; for(int i=k; i&lt;nums.length; i++){ sum += nums[i] - nums[i-k]; res = Math.max(res,sum); } return res/k; } } . ",
    "url": "https://1001anjan.github.io/problem-112-Maximum-Average-Subarray-I/",
    "relUrl": "/problem-112-Maximum-Average-Subarray-I/"
  },"85": {
    "doc": "Set Mismatch",
    "title": "Set Mismatch",
    "content": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: . Input: nums = [1,2,2,4] Output: [2,3] . Example 2: . Input: nums = [1,1] Output: [1,2] . Constraints: . | 2 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int[] findErrorNums(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); Set&lt;Integer&gt; res = new HashSet&lt;Integer&gt;(); int index = 0; // finding duplipactes for(int n: nums){ if(set.contains(n)){ res.add(n); }else{ set.add(n); } } // finding missing elements for(int i = 1; i&lt;=nums.length; i++){ if(!set.contains(i)) res.add(i); } int[] ans = new int[res.size()]; for(int n: res){ ans[index++] = n; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-113-Set-Mismatch/",
    "relUrl": "/problem-113-Set-Mismatch/"
  },"86": {
    "doc": "Two Sum IV - Input is a BST",
    "title": "Two Sum IV - Input is a BST",
    "content": "Given the root of a Binary Search Tree and a target number k, return true if there exist two elements in the BST such that their sum is equal to the given target. Example 1: . Input: root = [5,3,6,2,4,null,7], k = 9 Output: true . Example 2: . Input: root = [5,3,6,2,4,null,7], k = 28 Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -104 &lt;= Node.val &lt;= 104 | root is guaranteed to be a valid binary search tree. | -105 &lt;= k &lt;= 105 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean findTarget(TreeNode root, int k) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); // set.add(root.val); while(!queue.isEmpty()){ TreeNode node = queue.remove(); if(set.contains(k - node.val)){ return true; } set.add(node.val); if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-114-Two-Sum-IV-Input-is-a-BST/",
    "relUrl": "/problem-114-Two-Sum-IV-Input-is-a-BST/"
  },"87": {
    "doc": "Robot Return to Origin",
    "title": "Robot Return to Origin",
    "content": "There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. You are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are ‘R’ (right), ‘L’ (left), ‘U’ (up), and ‘D’ (down). Return true if the robot returns to the origin after it finishes all of its moves, or false otherwise. Note: The way that the robot is “facing” is irrelevant. ‘R’ will always make the robot move to the right once, ‘L’ will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. Example 1: . Input: moves = \"UD\" Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: . Input: moves = \"LL\" Output: false Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves. Constraints: . | 1 &lt;= moves.length &lt;= 2 * 104 | moves only contains the characters ‘U’, ‘D’, ‘L’ and ‘R’. | . Solution: . class Solution { public boolean judgeCircle(String moves) { int l,r,u,d; l = r = u = d = 0; for(int i=0; i&lt;moves.length(); i++){ if(moves.charAt(i) == 'R') r++; else if(moves.charAt(i) == 'D') d++; else if(moves.charAt(i) == 'U') u++; else l++; } return (r == l &amp;&amp; d == u) ; } } . ",
    "url": "https://1001anjan.github.io/problem-115-Robot-Return-to-Origin/",
    "relUrl": "/problem-115-Robot-Return-to-Origin/"
  },"88": {
    "doc": "Second Minimum Node In a Binary Tree",
    "title": "Second Minimum Node In a Binary Tree",
    "content": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds. Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree. If no such second minimum value exists, output -1 instead. Example 1: . Input: root = [2,2,5,null,null,5,7] Output: 5 Explanation: The smallest value is 2, the second smallest value is 5. Example 2: . Input: root = [2,2,2] Output: -1 Explanation: The smallest value is 2, but there isn't any second smallest value. Constraints: . | The number of nodes in the tree is in the range [1, 25]. | 1 &lt;= Node.val &lt;= 231 - 1 | root.val == min(root.left.val, root.right.val) for each internal node of the tree. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int findSecondMinimumValue(TreeNode root) { Long min1,min2; min1 = min2 = Long.MAX_VALUE; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); while(!queue.isEmpty()){ TreeNode node = queue.remove(); if(min1&gt;node.val &amp;&amp; min2&gt;node.val){ min2 = min1; min1 = Long.valueOf(node.val); }else if(min2&gt;node.val &amp;&amp; node.val != min1){ min2 = Long.valueOf(node.val); } if(node.left != null) queue.add(node.left); if(node.right != null) queue.add(node.right); } System.out.println(min1+\" \"+min2); if(Long.MAX_VALUE == min2) return -1; return min2.intValue(); } } . ",
    "url": "https://1001anjan.github.io/problem-116-Second-Minimum-Node-In-a-Binary-Tree/",
    "relUrl": "/problem-116-Second-Minimum-Node-In-a-Binary-Tree/"
  },"89": {
    "doc": "Longest Continuous Increasing Subsequence",
    "title": "Longest Continuous Increasing Subsequence",
    "content": "Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing. A continuous increasing subsequence is defined by two indices l and r (l &lt; r) such that it is [nums[l], nums[l + 1], …, nums[r - 1], nums[r]] and for each l &lt;= i &lt; r, nums[i] &lt; nums[i + 1]. Example 1: . Input: nums = [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5] with length 3. Even though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element 4. Example 2: . Input: nums = [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly increasing. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution: . class Solution { public int findLengthOfLCIS(int[] nums) { int currCount = 1; int prevCount = 1; for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&lt;nums[i]) currCount++; else{ prevCount = Math.max(prevCount, currCount); currCount = 1; } } return Math.max(prevCount, currCount); } } . ",
    "url": "https://1001anjan.github.io/problem-117-Longest-Continuous-Increasing-Subsequence/",
    "relUrl": "/problem-117-Longest-Continuous-Increasing-Subsequence/"
  },"90": {
    "doc": "Valid Palindrome II",
    "title": "Valid Palindrome II",
    "content": "Given a string s, return true if the s can be palindrome after deleting at most one character from it. Example 1: . Input: s = \"aba\" Output: true . Example 2: . Input: s = \"abca\" Output: true Explanation: You could delete the character 'c'. Example 3: . Input: s = \"abc\" Output: false . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of lowercase English letters. | . Solution: . class Solution { private boolean checkPalindrome(String s, int i, int j) { while (i &lt; j) { if (s.charAt(i) != s.charAt(j)) { return false; } i++; j--; } return true; } public boolean validPalindrome(String s) { int i = 0; int j = s.length() - 1; while (i &lt; j) { // Found a mismatched pair - try both deletions if (s.charAt(i) != s.charAt(j)) { return (checkPalindrome(s, i, j - 1) || checkPalindrome(s, i + 1, j)); } i++; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-118-Valid-Palindrome-II/",
    "relUrl": "/problem-118-Valid-Palindrome-II/"
  },"91": {
    "doc": "Binary Number with Alternating Bits",
    "title": "Binary Number with Alternating Bits",
    "content": "Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values. Example 1: . Input: n = 5 Output: true Explanation: The binary representation of 5 is: 101 . Example 2: . Input: n = 7 Output: false Explanation: The binary representation of 7 is: 111. Example 3: . Input: n = 11 Output: false Explanation: The binary representation of 11 is: 1011. Constraints: . | 1 &lt;= n &lt;= 231 - 1 | . Solution: . class Solution { public boolean hasAlternatingBits(int n) { int curr = n%2; n = n/2; while(n&gt;0){ if(curr == n%2) return false; curr = n%2; n = n/2; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-119-Binary-Number-with-Alternating-Bits/",
    "relUrl": "/problem-119-Binary-Number-with-Alternating-Bits/"
  },"92": {
    "doc": "Length of Last Word",
    "title": "Length of Last Word",
    "content": "Given a string s consisting of words and spaces, return the length of the last word in the string. A word is a maximal substring consisting of non-space characters only. Example 1: . Input: s = \"Hello World\" Output: 5 Explanation: The last word is \"World\" with length 5. Example 2: . Input: s = \" fly me to the moon \" Output: 4 Explanation: The last word is \"moon\" with length 4. Example 3: . Input: s = \"luffy is still joyboy\" Output: 6 Explanation: The last word is \"joyboy\" with length 6. Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of only English letters and spaces ‘ ‘. | There will be at least one word in s. | . Solution . class Solution { public int lengthOfLastWord(String s) { int l = 0; s = s.trim(); for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) == ' ') break; l++; } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-12-length-of-last-word/",
    "relUrl": "/problem-12-length-of-last-word/"
  },"93": {
    "doc": "Remove Nth Node From End of List",
    "title": "Remove Nth Node From End of List",
    "content": "Given the head of a linked list, remove the nth node from the end of the list and return its head. Example 1: . Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] . Example 2: . Input: head = [1], n = 1 Output: [] . Example 3: . Input: head = [1,2], n = 1 Output: [1] . Constraints: . | The number of nodes in the list is sz. | 1 &lt;= sz &lt;= 30 | 0 &lt;= Node.val &lt;= 100 | 1 &lt;= n &lt;= sz | . Follow up: Could you do this in one pass? . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode ptr, qtr; // Corner cases if(head.next == null) return null; // Since n &gt;=1 ptr = qtr = head; while(n &gt; 0){ qtr = qtr.next; n --; } // Traversing to the end node while(qtr != null &amp;&amp; qtr.next != null){ ptr = ptr.next; qtr = qtr.next; } if(qtr == null){ ptr = head.next; head = null; return ptr; } // deleting node qtr = ptr.next; ptr.next = qtr.next; return head; } } . ",
    "url": "https://1001anjan.github.io/problem-12-Remove%20Nth%20Node%20From%20End%20of%20List/",
    "relUrl": "/problem-12-Remove Nth Node From End of List/"
  },"94": {
    "doc": "Search in a Binary Search Tree",
    "title": "Search in a Binary Search Tree",
    "content": "You are given the root of a binary search tree (BST) and an integer val. Find the node in the BST that the node’s value equals val and return the subtree rooted with that node. If such a node does not exist, return null. Example 1: . Input: root = [4,2,7,1,3], val = 2 Output: [2,1,3] . Example 2: . Input: root = [4,2,7,1,3], val = 5 Output: [] . Constraints: . | The number of nodes in the tree is in the range [1, 5000]. | 1 &lt;= Node.val &lt;= 107 | root is a binary search tree. | 1 &lt;= val &lt;= 107 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode searchBST(TreeNode root, int val) { if(root == null) return null; if(root.val == val) return root; if(root.val&gt;val) return searchBST(root.left, val); else return searchBST(root.right, val); } } . ",
    "url": "https://1001anjan.github.io/problem-120-Search-in-a-Binary-Search-Tree/",
    "relUrl": "/problem-120-Search-in-a-Binary-Search-Tree/"
  },"95": {
    "doc": "Binary Search",
    "title": "Binary Search",
    "content": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1. You must write an algorithm with O(log n) runtime complexity. Example 1: . Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 . Example 2: . Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt; nums[i], target &lt; 104 | All the integers in nums are unique. | nums is sorted in ascending order. | . Solution: . class Solution { public int search(int[] nums, int target) { int l = 0; int u = nums.length - 1; while(l&lt;=u){ int mid = (l+u)/2; if(nums[mid] == target) return mid; if(nums[mid]&gt;target) u = mid - 1; else l = mid + 1; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-121-Binary-Search/",
    "relUrl": "/problem-121-Binary-Search/"
  },"96": {
    "doc": "Design HashSet",
    "title": "Design HashSet",
    "content": "Design a HashSet without using any built-in hash table libraries. Implement MyHashSet class: . | void add(key) Inserts the value key into the HashSet. | bool contains(key) Returns whether the value key exists in the HashSet or not. | void remove(key) Removes the value key in the HashSet. If key does not exist in the HashSet, do nothing. | . Example 1: . Input [\"MyHashSet\", \"add\", \"add\", \"contains\", \"contains\", \"add\", \"contains\", \"remove\", \"contains\"] [[], [1], [2], [1], [3], [2], [2], [2], [2]] Output [null, null, null, true, false, null, true, null, false] . Explanation . MyHashSet myHashSet = new MyHashSet(); myHashSet.add(1); // set = [1] myHashSet.add(2); // set = [1, 2] myHashSet.contains(1); // return True myHashSet.contains(3); // return False, (not found) myHashSet.add(2); // set = [1, 2] myHashSet.contains(2); // return True myHashSet.remove(2); // set = [1] myHashSet.contains(2); // return False, (already removed) . Constraints: . | 0 &lt;= key &lt;= 106 | At most 104 calls will be made to add, remove, and contains. | . Solution: . class MyHashSet { private boolean [] data; public MyHashSet() { data = new boolean[1000001]; } public void add(int key) { data[key] = true; } public void remove(int key) { data[key] = false; } public boolean contains(int key) { return data[key]; } } /** * Your MyHashSet object will be instantiated and called as such: * MyHashSet obj = new MyHashSet(); * obj.add(key); * obj.remove(key); * boolean param_3 = obj.contains(key); */ . ",
    "url": "https://1001anjan.github.io/problem-122-Design-HashSet/",
    "relUrl": "/problem-122-Design-HashSet/"
  },"97": {
    "doc": "Design HashMap",
    "title": "Design HashMap",
    "content": "Design a HashMap without using any built-in hash table libraries. Implement the MyHashMap class: . | MyHashMap() initializes the object with an empty map. | void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value. | int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key. | void remove(key) removes the key and its corresponding value if the map contains the mapping for the key. | . Example 1: . Input [\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"] [[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]] Output [null, null, null, 1, -1, null, 1, null, -1] . Explanation . MyHashMap myHashMap = new MyHashMap(); myHashMap.put(1, 1); // The map is now [[1,1]] myHashMap.put(2, 2); // The map is now [[1,1], [2,2]] myHashMap.get(1); // return 1, The map is now [[1,1], [2,2]] myHashMap.get(3); // return -1 (i.e., not found), The map is now [[1,1], [2,2]] myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value) myHashMap.get(2); // return 1, The map is now [[1,1], [2,1]] myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]] myHashMap.get(2); // return -1 (i.e., not found), The map is now [[1,1]] . Constraints: . | 0 &lt;= key, value &lt;= 106 | At most 104 calls will be made to put, get, and remove. | . Solution: . class MyHashMap { int data[]; public MyHashMap() { data = new int[1000001]; Arrays.fill(data,-1); } public void put(int key, int value) { data[key] = value; } public int get(int key) { return data[key]; } public void remove(int key) { data[key] = -1; } } /** * Your MyHashMap object will be instantiated and called as such: * MyHashMap obj = new MyHashMap(); * obj.put(key,value); * int param_2 = obj.get(key); * obj.remove(key); */ . ",
    "url": "https://1001anjan.github.io/problem-123-Design-HashMap/",
    "relUrl": "/problem-123-Design-HashMap/"
  },"98": {
    "doc": "Find Pivot Index",
    "title": "Find Pivot Index",
    "content": "Given an array of integers nums, calculate the pivot index of this array. The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index’s right. If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array. Return the leftmost pivot index. If no such index exists, return -1. Example 1: . Input: nums = [1,7,3,6,5,6] Output: 3 Explanation: The pivot index is 3. Left sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 Right sum = nums[4] + nums[5] = 5 + 6 = 11 . Example 2: . Input: nums = [1,2,3] Output: -1 Explanation: There is no index that satisfies the conditions in the problem statement. Example 3: . Input: nums = [2,1,-1] Output: 0 Explanation: The pivot index is 0. Left sum = 0 (no elements to the left of index 0) Right sum = nums[1] + nums[2] = 1 + -1 = 0 . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -1000 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int pivotIndex(int[] nums) { int sum = 0, leftsum = 0; for (int x: nums) sum += x; for (int i = 0; i &lt; nums.length; ++i) { if (leftsum == sum - leftsum - nums[i]) return i; leftsum += nums[i]; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-124-Find-Pivot-Index/",
    "relUrl": "/problem-124-Find-Pivot-Index/"
  },"99": {
    "doc": "Self Dividing Numbers",
    "title": "Self Dividing Numbers",
    "content": "A self-dividing number is a number that is divisible by every digit it contains. For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0. A self-dividing number is not allowed to contain the digit zero. Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right]. Example 1: . Input: left = 1, right = 22 Output: [1,2,3,4,5,6,7,8,9,11,12,15,22] . Example 2: . Input: left = 47, right = 85 Output: [48,55,66,77] . Constraints: . | 1 &lt;= left &lt;= right &lt;= 104 | . Solution: . class Solution { public List&lt;Integer&gt; selfDividingNumbers(int left, int right) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); while(left&lt;=right){ if(isSelfDividingNumber(left)) result.add(left); left++; } return result; } public boolean isSelfDividingNumber(int num){ int n = num; while(n&gt;0){ int d = n%10; if(d == 0 || num%d&gt;0) return false; n = n/10; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-125-Self-Dividing-Numbers/",
    "relUrl": "/problem-125-Self-Dividing-Numbers/"
  },"100": {
    "doc": "Find Smallest Letter Greater Than Target",
    "title": "Find Smallest Letter Greater Than Target",
    "content": "Given a characters array letters that is sorted in non-decreasing order and a character target, return the smallest character in the array that is larger than target. Note that the letters wrap around. For example, if target == ‘z’ and letters == [‘a’, ‘b’], the answer is ‘a’. Example 1: . Input: letters = [\"c\",\"f\",\"j\"], target = \"a\" Output: \"c\" . Example 2: . Input: letters = [\"c\",\"f\",\"j\"], target = \"c\" Output: \"f\" . Example 3: . Input: letters = [\"c\",\"f\",\"j\"], target = \"d\" Output: \"f\" . Constraints: . | 2 &lt;= letters.length &lt;= 104 | letters[i] is a lowercase English letter. | letters is sorted in non-decreasing order. | letters contains at least two different characters. | target is a lowercase English letter. | . Solution: . class Solution { public char nextGreatestLetter(char[] letters, char target) { for(int i = 0; i&lt;letters.length; i++){ if(letters[i]&gt;target) return letters[i]; } return letters[0]; } } . Binary search . class Solution { public char nextGreatestLetter(char[] letters, char target) { int lo = 0, hi = letters.length; while (lo &lt; hi) { int mi = lo + (hi - lo) / 2; if (letters[mi] &lt;= target) lo = mi + 1; else hi = mi; } return letters[lo % letters.length]; } } . ",
    "url": "https://1001anjan.github.io/problem-126-Find-Smallest-Letter-Greater-Than-Target/",
    "relUrl": "/problem-126-Find-Smallest-Letter-Greater-Than-Target/"
  },"101": {
    "doc": "Largest Number At Least Twice of Others",
    "title": "Largest Number At Least Twice of Others",
    "content": "You are given an integer array nums where the largest integer is unique. Determine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise. Example 1: . Input: nums = [3,6,1,0] Output: 1 Explanation: 6 is the largest integer. For every other number in the array x, 6 is at least twice as big as x. The index of value 6 is 1, so we return 1. Example 2: . Input: nums = [1,2,3,4] Output: -1 Explanation: 4 is less than twice the value of 3, so we return -1. Constraints: . | 1 &lt;= nums.length &lt;= 50 | 0 &lt;= nums[i] &lt;= 100 | The largest element in nums is unique. | . Solution: . class Solution { public int dominantIndex(int[] nums) { int max = nums[0]; int index = 0; for(int i =0; i&lt;nums.length; i++){ if(max&lt;nums[i]) { max = nums[i]; index = i; } } for(int i=0; i&lt;nums.length; i++){ if(i != index &amp;&amp; max&lt;nums[i]*2) return -1; } return index; } } . ",
    "url": "https://1001anjan.github.io/problem-127-Largest-Number-At-Least-Twice-of-Others/",
    "relUrl": "/problem-127-Largest-Number-At-Least-Twice-of-Others/"
  },"102": {
    "doc": "Prime Number of Set Bits in Binary Representation",
    "title": "Prime Number of Set Bits in Binary Representation",
    "content": "Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation. Recall that the number of set bits an integer has is the number of 1’s present when written in binary. For example, 21 written in binary is 10101, which has 3 set bits. Example 1: . Input: left = 6, right = 10 Output: 4 Explanation: 6 -&gt; 110 (2 set bits, 2 is prime) 7 -&gt; 111 (3 set bits, 3 is prime) 8 -&gt; 1000 (1 set bit, 1 is not prime) 9 -&gt; 1001 (2 set bits, 2 is prime) 10 -&gt; 1010 (2 set bits, 2 is prime) 4 numbers have a prime number of set bits. Example 2: . Input: left = 10, right = 15 Output: 5 Explanation: 10 -&gt; 1010 (2 set bits, 2 is prime) 11 -&gt; 1011 (3 set bits, 3 is prime) 12 -&gt; 1100 (2 set bits, 2 is prime) 13 -&gt; 1101 (3 set bits, 3 is prime) 14 -&gt; 1110 (3 set bits, 3 is prime) 15 -&gt; 1111 (4 set bits, 4 is not prime) 5 numbers have a prime number of set bits. Constraints: . | 1 &lt;= left &lt;= right &lt;= 106 | 0 &lt;= right - left &lt;= 104 | . Solution: . class Solution { public int countPrimeSetBits(int left, int right) { int count = 0; for(int i = left; i&lt;=right; i++){ int count1s = countBits(i); if(count1s&gt;0 &amp;&amp; isPrime(count1s)){ count++; } } return count; } public int countBits(int k){ int answer=0; while(k!=0){ answer++; k=k&amp;(k-1); } return answer; } public boolean isPrime(int num){ if(num == 1) return false; if(num == 2 || num == 3) return true; for(int i = 2; i&lt;=Math.sqrt(num); i++){ if(num%i == 0) return false; } return true; } } . class Solution { public int countPrimeSetBits(int left, int right) { int ans=0; Integer[]arr=new Integer[]{2,3,5,7,11,13,17,19}; Set&lt;Integer&gt;set=new HashSet&lt;&gt;(Arrays.asList(arr)); //System.out.println(set); for(int i=left;i&lt;=right;i++){ int count=count(i); if(set.contains(count))ans++; } return ans; } int count(int x){ int count=0; while(x!=0){ x-=(x&amp;-x); count++; } return count; } } . class Solution { public int countPrimeSetBits(int left, int right) { int cnt=0; for(int i=left;i&lt;=right;i++) if(isPrime(Integer.bitCount(i))) cnt++; return cnt; } public static boolean isPrime(int num) { if(num&lt;=1) return false; for(int i=2;(i*i)&lt;=num;i++) if((num%i)==0) return false; return true; } } . class Solution { public int countPrimeSetBits(int left, int right) { HashSet&lt;Integer&gt;prime=new HashSet&lt;&gt;(); prime.add(2); prime.add(3); prime.add(5); prime.add(7); prime.add(11); prime.add(13); prime.add(17); prime.add(19); prime.add(23); prime.add(29); prime.add(31); int cnt=0; for(int i=left;i&lt;=right;i++) if(prime.contains(Integer.bitCount(i))) cnt++; return cnt; } } . ",
    "url": "https://1001anjan.github.io/problem-128-Prime-Number-of-Set-Bits-in-Binary-Representation/",
    "relUrl": "/problem-128-Prime-Number-of-Set-Bits-in-Binary-Representation/"
  },"103": {
    "doc": "Number of Lines To Write String",
    "title": "Number of Lines To Write String",
    "content": "You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of ‘a’, widths[1] is the width of ‘b’, and so on. You are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s. Return an array result of length 2 where: . | result[0] is the total number of lines. | result[1] is the width of the last line in pixels. | . Example 1: . Input: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\" Output: [3,60] Explanation: You can write s as follows: abcdefghij // 100 pixels wide klmnopqrst // 100 pixels wide uvwxyz // 60 pixels wide There are a total of 3 lines, and the last line is 60 pixels wide. Example 2: . Input: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\" Output: [2,4] Explanation: You can write s as follows: bbbcccdddaa // 98 pixels wide a // 4 pixels wide There are a total of 2 lines, and the last line is 4 pixels wide. Constraints: . | widths.length == 26 | 2 &lt;= widths[i] &lt;= 10 | 1 &lt;= s.length &lt;= 1000 | s contains only lowercase English letters. | . Solution: . class Solution { public int[] numberOfLines(int[] widths, String s) { int lines = 1; int lastWidth = 0; for(char ch : s.toCharArray()){ lastWidth += widths[ch-'a']; if(lastWidth&gt;100){ lines++; lastWidth = widths[ch-'a']; } } return new int[]{lines,lastWidth}; } } . ",
    "url": "https://1001anjan.github.io/problem-129-Number-of-Lines-To-Write-String/",
    "relUrl": "/problem-129-Number-of-Lines-To-Write-String/"
  },"104": {
    "doc": "Generate Parentheses",
    "title": "Generate Parentheses",
    "content": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. Example 1: . Input: n = 3 Output: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] . Example 2: . Input: n = 1 Output: [\"()\"] . Constraints: . | 1 &lt;= n &lt;= 8 | . Solution: . class Solution { public List&lt;String&gt; generateParenthesis(int n){ if(n == 1){ return new ArrayList(Arrays.asList(\"()\")); } List&lt;String&gt; list = generateParenthesis(n - 1); Set&lt;String&gt; ans = new HashSet&lt;&gt;(); for(String str : list){ for(int i = 0; i &lt; str.length(); i++){ if(str.charAt(i) == '('){ ans.add(str.substring(0, i + 1)+\"()\"+str.substring(i + 1, str.length())); } } ans.add(str+\"()\"); } return new ArrayList(ans); } } . class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; ans = new ArrayList(); if (n == 0) { ans.add(\"\"); } else { for (int c = 0; c &lt; n; ++c) for (String left: generateParenthesis(c)) for (String right: generateParenthesis(n-1-c)) ans.add(\"(\" + left + \")\" + right); } return ans; } } . class Solution { public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; combinations = new ArrayList(); generateAll(new char[2 * n], 0, combinations); return combinations; } public void generateAll(char[] current, int pos, List&lt;String&gt; result) { if (pos == current.length) { if (valid(current)) result.add(new String(current)); } else { current[pos] = '('; generateAll(current, pos+1, result); current[pos] = ')'; generateAll(current, pos+1, result); } } public boolean valid(char[] current) { int balance = 0; for (char c: current) { if (c == '(') balance++; else balance--; if (balance &lt; 0) return false; } return (balance == 0); } } . ",
    "url": "https://1001anjan.github.io/problem-13-Generate%20Parentheses/",
    "relUrl": "/problem-13-Generate Parentheses/"
  },"105": {
    "doc": "Plus One",
    "title": "Plus One",
    "content": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0’s. Increment the large integer by one and return the resulting array of digits. Example 1: . Input: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]. Example 2: . Input: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]. Example 3: . Input: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]. Constraints: . | 1 &lt;= digits.length &lt;= 100 | 0 &lt;= digits[i] &lt;= 9 | digits does not contain any leading 0’s. | . Solution . class Solution { public int[] plusOne(int[] digits) { for(int i=digits.length-1; i&gt;=0; i--){ if(digits[i] &lt; 9){ digits[i] = digits[i] + 1; break; }else{ digits[i] = 0; } } if(digits[0] == 0){ int[] updatedDigits = new int[digits.length+1]; updatedDigits[0] = 1; for(int i=0; i&lt;digits.length; i++){ updatedDigits[i+1] = digits[i]; } return updatedDigits; } return digits; } } . Other . class Solution { public int[] plusOne(int[] digits) { int []result = new int[digits.length+1]; result[digits.length] = (digits[digits.length-1]+1)%10; int c = (digits[digits.length-1]+1)/10; digits[digits.length-1] = (digits[digits.length-1]+1)%10; int c1 = c; for(int i = digits.length-2; i&gt;=0; i--){ result[i+1] = (digits[i]+c1)%10; c = (digits[i]+c)/10; digits[i] = (digits[i]+c1)%10; c1 = c; } result[0] = c; if(c&gt;0){ return result; } return digits; } } . ",
    "url": "https://1001anjan.github.io/problem-13-plus-one/",
    "relUrl": "/problem-13-plus-one/"
  },"106": {
    "doc": "Shortest Distance to a Character",
    "title": "Shortest Distance to a Character",
    "content": "Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s. The distance between two indices i and j is abs(i - j), where abs is the absolute value function. Example 1: . Input: s = \"loveleetcode\", c = \"e\" Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character 'e' appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of 'e' for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of 'e' for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the 'e' at index 3 and the 'e' at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of 'e' for index 8 is at index 6, so the distance is abs(8 - 6) = 2. Example 2: . Input: s = \"aaab\", c = \"b\" Output: [3,2,1,0] . Constraints: . | 1 &lt;= s.length &lt;= 104 | s[i] and c are lowercase English letters. | It is guaranteed that c occurs at least once in s. | . Solution: . class Solution { public int[] shortestToChar(String s, char c) { int[] ans = new int[s.length()]; int index = Integer.MAX_VALUE; // Scan left to right for(int i=0; i&lt;s.length(); i++){ if(s.charAt(i) == c) index = i; ans[i] = Math.abs(index - i); } // Scan right to left for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) == c) index = i; ans[i] = Math.min(ans[i], Math.abs(index - i)); } return ans; } } . class Solution { public int[] shortestToChar(String S, char C) { TreeSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); //add all indexes of C into tree set for(int i = 0;i &lt; S.length();i++) if(S.charAt(i) == C) set.add(i); int[] result = new int[S.length()]; for(int i = 0;i &lt; S.length();i++){ if(!set.contains(i)){ Integer left = set.floor(i); Integer right = set.ceiling(i); if(left == null) left = Integer.MAX_VALUE; if (right == null) right = Integer.MAX_VALUE; result[i] = Math.min(Math.abs(left - i),Math.abs(right -i )); }else{ result[i] = 0; } } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-130-Shortest-Distance-to-a-Character/",
    "relUrl": "/problem-130-Shortest-Distance-to-a-Character/"
  },"107": {
    "doc": "Goat Latin",
    "title": "Goat Latin",
    "content": "You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: . | If a word begins with a vowel (‘a’, ‘e’, ‘i’, ‘o’, or ‘u’), append “ma” to the end of the word. ** For example, the word “apple” becomes “applema”. | If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add “ma”. ** For example, the word “goat” becomes “oatgma”. | Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1. ** For example, the first word gets “a” added to the end, the second word gets “aa” added to the end, and so on. | . Return the final sentence representing the conversion from sentence to Goat Latin. Example 1: . Input: sentence = \"I speak Goat Latin\" Output: \"Imaa peaksmaaa oatGmaaaa atinLmaaaaa\" . Example 2: . Input: sentence = \"The quick brown fox jumped over the lazy dog\" Output: \"heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa\" . Constraints: . | 1 &lt;= sentence.length &lt;= 150 | sentence consists of English letters and spaces. | sentence has no leading or trailing spaces. | All the words in sentence are separated by a single space. | . Solution: . class Solution { public String toGoatLatin(String sentence) { StringBuilder sb = new StringBuilder(); StringBuilder suf = new StringBuilder(); suf.append('a'); String[] words = sentence.split(\"\\\\s+\"); for(String s : words){ if(isVowel(s.charAt(0))){ sb.append(s); }else{ sb.append(s.substring(1,s.length())); sb.append(s.charAt(0)); } sb.append(\"ma\"); sb.append(suf); sb.append(\" \"); suf.append(\"a\"); } return sb.toString().trim(); } public boolean isVowel(char c){ switch(c){ case 'a','e','i','o','u','A','E','I','O','U': return true; default: return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-131-Goat-Latin/",
    "relUrl": "/problem-131-Goat-Latin/"
  },"108": {
    "doc": "Positions of Large Groups",
    "title": "Positions of Large Groups",
    "content": "In a string s of lowercase letters, these letters form consecutive groups of the same character. For example, a string like s = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z”, and “yy”. A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, “xxxx” has the interval [3,6]. A group is considered large if it has 3 or more characters. Return the intervals of every large group sorted in increasing order by start index. Example 1: . Input: s = \"abbxxxxzzy\" Output: [[3,6]] Explanation: \"xxxx\" is the only large group with start index 3 and end index 6. Example 2: . Input: s = \"abc\" Output: [] Explanation: We have groups \"a\", \"b\", and \"c\", none of which are large groups. Example 3: . Input: s = \"abcdddeeeeaabbbcd\" Output: [[3,5],[6,9],[12,14]] Explanation: The large groups are \"ddd\", \"eeee\", and \"bbb\". Constraints: . | 1 &lt;= s.length &lt;= 1000 | s contains lowercase English letters only. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; largeGroupPositions(String s) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList(); int l = 0; int u = 0; for(int i=1; i&lt;s.length(); i++){ if(s.charAt(i-1) == s.charAt(i)){ u++; }else{ if(u - l +1 &gt;= 3){ ans.add(Arrays.asList(new Integer[]{l, u})); } l = u = i; } } if(u - l +1 &gt;= 3){ ans.add(Arrays.asList(new Integer[]{l, u})); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-132-Positions-of-Large-Groups/",
    "relUrl": "/problem-132-Positions-of-Large-Groups/"
  },"109": {
    "doc": "Flipping an Image",
    "title": "Flipping an Image",
    "content": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1,1,0] horizontally results in [0,1,1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0,1,1] results in [1,0,0]. Example 1: . Input: image = [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] . Example 2: . Input: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] . Constraints: . | n == image.length | n == image[i].length | 1 &lt;= n &lt;= 20 | images[i][j] is either 0 or 1. | . Solution: . class Solution { public int[][] flipAndInvertImage(int[][] image) { int m = image.length; int n = image[0].length; // flip image for(int i=0; i&lt;m; i++){ int s = 0; int e = n - 1; while(s&lt;e){ int t = image[i][s]; image[i][s] = image[i][e]; image[i][e] = t; s++; e--; } } // Invert image for(int i=0; i&lt;m; i++) for(int j=0; j&lt;n; j++) if(image[i][j] == 1) image[i][j] = 0; else image[i][j] = 1; return image; } } . class Solution { public int[][] flipAndInvertImage(int[][] A) { int C = A[0].length; for (int[] row: A) for (int i = 0; i &lt; (C + 1) / 2; ++i) { int tmp = row[i] ^ 1; row[i] = row[C - 1 - i] ^ 1; row[C - 1 - i] = tmp; } return A; } } . ",
    "url": "https://1001anjan.github.io/problem-133-Flipping-an-Image/",
    "relUrl": "/problem-133-Flipping-an-Image/"
  },"110": {
    "doc": "Backspace String Compare",
    "title": "Backspace String Compare",
    "content": "Given two strings s and t, return true if they are equal when both are typed into empty text editors. ‘#’ means a backspace character. Note that after backspacing an empty text, the text will continue empty. Example 1: . Input: s = \"ab#c\", t = \"ad#c\" Output: true Explanation: Both s and t become \"ac\". Example 2: . Input: s = \"ab##\", t = \"c#d#\" Output: true Explanation: Both s and t become \"\". Example 3: . Input: s = \"a#c\", t = \"b\" Output: false Explanation: s becomes \"c\" while t becomes \"b\". Constraints: . | 1 &lt;= s.length, t.length &lt;= 200 | s and t only contain lowercase letters and ‘#’ characters. | . Solution: . class Solution { public boolean backspaceCompare(String s, String t) { return processBackspace(s).equals(processBackspace(t)); } public String processBackspace(String s){ StringBuilder sb = new StringBuilder(); int c = 0; for(int i = s.length()-1; i&gt;=0; i--){ if(s.charAt(i) != '#'){ if(c&gt;0){ c--; }else{ sb.append(s.charAt(i)); } }else{ c++; } } return sb.toString(); } } . class Solution { public boolean backspaceCompare(String S, String T) { return build(S).equals(build(T)); } public String build(String S) { Stack&lt;Character&gt; ans = new Stack(); for (char c: S.toCharArray()) { if (c != '#') ans.push(c); else if (!ans.empty()) ans.pop(); } return String.valueOf(ans); } } . class Solution { public boolean backspaceCompare(String S, String T) { int i = S.length() - 1, j = T.length() - 1; int skipS = 0, skipT = 0; while (i &gt;= 0 || j &gt;= 0) { // While there may be chars in build(S) or build (T) while (i &gt;= 0) { // Find position of next possible char in build(S) if (S.charAt(i) == '#') {skipS++; i--;} else if (skipS &gt; 0) {skipS--; i--;} else break; } while (j &gt;= 0) { // Find position of next possible char in build(T) if (T.charAt(j) == '#') {skipT++; j--;} else if (skipT &gt; 0) {skipT--; j--;} else break; } // If two actual characters are different if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; S.charAt(i) != T.charAt(j)) return false; // If expecting to compare char vs nothing if ((i &gt;= 0) != (j &gt;= 0)) return false; i--; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-134-Backspace-String-Compare/",
    "relUrl": "/problem-134-Backspace-String-Compare/"
  },"111": {
    "doc": "Buddy Strings",
    "title": "Buddy Strings",
    "content": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false. Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j]. For example, swapping at indices 0 and 2 in “abcd” results in “cbad”. Example 1: . Input: s = \"ab\", goal = \"ba\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal. Example 2: . Input: s = \"ab\", goal = \"ab\" Output: false Explanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal. Example 3: . Input: s = \"aa\", goal = \"aa\" Output: true Explanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal. Constraints: . | 1 &lt;= s.length, goal.length &lt;= 2 * 104 | s and goal consist of lowercase letters. | . Solution: . class Solution { public boolean buddyStrings(String s, String goal) { if(s.length() != goal.length()) return false; if(s.equals(goal)){ int[] arr = new int[26]; for(char c: s.toCharArray()){ arr[c-'a']++; } for(int i=0; i&lt;26;i++){ if(arr[i]&gt;1) return true; } return false; }else{ int first = -1; int second = -1; for(int i=0; i&lt;s.length(); i++){ if(s.charAt(i) != goal.charAt(i)){ if(first == -1) first = i; else if(second == -1) second = i; else return false; } } if(second == -1) return false; return s.charAt(first) == goal.charAt(second) &amp;&amp; s.charAt(second) == goal.charAt(first); } } } . ",
    "url": "https://1001anjan.github.io/problem-135-Buddy-Strings/",
    "relUrl": "/problem-135-Buddy-Strings/"
  },"112": {
    "doc": "Lemonade Change",
    "title": "Lemonade Change",
    "content": "At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5. Note that you do not have any change in hand at first. Given an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise. Example 1: . Input: bills = [5,5,5,10,20] Output: true Explanation: From the first 3 customers, we collect three $5 bills in order. From the fourth customer, we collect a $10 bill and give back a $5. From the fifth customer, we give a $10 bill and a $5 bill. Since all customers got correct change, we output true. Example 2: . Input: bills = [5,5,10,10,20] Output: false Explanation: From the first two customers in order, we collect two $5 bills. For the next two customers in order, we collect a $10 bill and give back a $5 bill. For the last customer, we can not give the change of $15 back because we only have two $10 bills. Since not every customer received the correct change, the answer is false. Constraints: . | 1 &lt;= bills.length &lt;= 105 | bills[i] is either 5, 10, or 20. | . Solution: . class Solution { public boolean lemonadeChange(int[] bills) { int count5 = 0; int count10 = 0; int count20 = 0; for(int i=0; i&lt;bills.length; i++){ if(bills[i] == 5) { count5++; }else if(bills[i] == 10){ if(count5 == 0) return false; count5--; count10++; }else if(bills[i] == 20){ if(count5 == 0) return false; if(count10&gt;=1){ count10--; count5--; }else{ if(count5&gt;=3) count5 = count5 - 3; else return false; } } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-136-Lemonade-Change/",
    "relUrl": "/problem-136-Lemonade-Change/"
  },"113": {
    "doc": "Transpose Matrix",
    "title": "Transpose Matrix",
    "content": "Given a 2D integer array matrix, return the transpose of matrix. The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix’s row and column indices. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[1,4,7],[2,5,8],[3,6,9]] . Example 2: . Input: matrix = [[1,2,3],[4,5,6]] Output: [[1,4],[2,5],[3,6]] . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 1000 | 1 &lt;= m * n &lt;= 105 | -109 &lt;= matrix[i][j] &lt;= 109 | . Solution: . class Solution { public int[][] transpose(int[][] matrix) { int [][] t = new int[matrix[0].length][matrix.length]; for(int i=0; i&lt;matrix.length; i++) for(int j=0; j&lt;matrix[0].length; j++) t[j][i] = matrix[i][j]; return t; } } . ",
    "url": "https://1001anjan.github.io/problem-137-Transpose-Matrix/",
    "relUrl": "/problem-137-Transpose-Matrix/"
  },"114": {
    "doc": "Binary Gap",
    "title": "Binary Gap",
    "content": "Given a positive integer n, find and return the longest distance between any two adjacent 1’s in the binary representation of n. If there are no two adjacent 1’s, return 0. Two 1’s are adjacent if there are only 0’s separating them (possibly no 0’s). The distance between two 1’s is the absolute difference between their bit positions. For example, the two 1’s in “1001” have a distance of 3. Example 1: . Input: n = 22 Output: 2 Explanation: 22 in binary is \"10110\". The first adjacent pair of 1's is \"10110\" with a distance of 2. The second adjacent pair of 1's is \"10110\" with a distance of 1. The answer is the largest of these two distances, which is 2. Note that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined. Example 2: . Input: n = 8 Output: 0 Explanation: 8 in binary is \"1000\". There are not any adjacent pairs of 1's in the binary representation of 8, so we return 0. Example 3: . Input: n = 5 Output: 2 Explanation: 5 in binary is \"101\". Constraints: . | 1 &lt;= n &lt;= 109 | . class Solution { public int binaryGap(int n) { int prevMax = 0; String bits = Integer.toBinaryString(n); int s = 0; int e = 0; boolean f = false; for(int i=0; i&lt;bits.length(); i++){ if(bits.charAt(i) == '1'){ if(!f){ s = i; f = true; }else{ e = i; prevMax = Math.max(prevMax, e-s); s = i; } } } return prevMax; } } . class Solution { public int binaryGap(int N) { int last = -1, ans = 0; for (int i = 0; i &lt; 32; ++i) if (((N &gt;&gt; i) &amp; 1) &gt; 0) { if (last &gt;= 0) ans = Math.max(ans, i - last); last = i; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-138-Binary-Gap/",
    "relUrl": "/problem-138-Binary-Gap/"
  },"115": {
    "doc": "Leaf-Similar Trees",
    "title": "Leaf-Similar Trees",
    "content": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence. For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8). Two binary trees are considered leaf-similar if their leaf value sequence is the same. Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar. Example 1: . Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8] Output: true . Example 2: . Input: root1 = [1,2,3], root2 = [1,3,2] Output: false . Constraints: . | The number of nodes in each tree will be in the range [1, 200]. | Both of the given trees will have values in the range [0, 200]. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean leafSimilar(TreeNode root1, TreeNode root2) { List&lt;Integer&gt; l1 = new ArrayList&lt;&gt;(); List&lt;Integer&gt; l2 = new ArrayList&lt;&gt;(); dfs(root1,l1); dfs(root2,l2); return l1.equals(l2); } public void dfs(TreeNode head, List&lt;Integer&gt; l){ if(head == null) return; if(head.left == null &amp;&amp; head.right == null) l.add(head.val); dfs(head.left,l); dfs(head.right,l); } } . ",
    "url": "https://1001anjan.github.io/problem-139-Leaf-Similar-Trees/",
    "relUrl": "/problem-139-Leaf-Similar-Trees/"
  },"116": {
    "doc": "Add Binary",
    "title": "Add Binary",
    "content": "Given two binary strings a and b, return their sum as a binary string. Example 1: . Input: a = \"11\", b = \"1\" Output: \"100\" . Example 2: . Input: a = \"1010\", b = \"1011\" Output: \"10101\" . Constraints: . | 1 &lt;= a.length, b.length &lt;= 104 | a and b consist only of ‘0’ or ‘1’ characters. | Each string does not contain leading zeros except for the zero itself. | . Solution . class Solution { public String addBinary(String a, String b) { int reminder = 0; int i = a.length() - 1; int j = b.length() - 1; int p1, p2, sum; StringBuilder sb = new StringBuilder(); while(i &gt;= 0 || j &gt;= 0 || reminder&gt;0){ p1 = i&gt;=0? a.charAt(i)-48: 0; p2 = j&gt;=0? b.charAt(j)-48: 0; sum = (p1+p2+reminder)%2; sb.append(sum); reminder = (p1+p2+reminder)/2; j--; i--; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-14-add-binary/",
    "relUrl": "/problem-14-add-binary/"
  },"117": {
    "doc": "Swap Nodes in Pairs",
    "title": "Swap Nodes in Pairs",
    "content": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list’s nodes (i.e., only nodes themselves may be changed.) . Example 1: . Input: head = [1,2,3,4] Output: [2,1,4,3] . Example 2: . Input: head = [] Output: [] . Example 3: . Input: head = [1] Output: [1] . Constraints: . | The number of nodes in the list is in the range [0, 100]. | 0 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode swapPairs(ListNode head) { // corner cases if(head == null || head.next == null ) return head; // swapping head ListNode ptr, qtr; ptr = head; qtr = head.next; head = qtr; ptr.next = qtr.next; qtr.next = ptr; // swapping remaining node ptr = head.next; if(ptr.next == null) return head; ListNode mtr = ptr.next; qtr = mtr.next; while(qtr != null){ ptr.next = qtr; mtr.next = qtr.next; qtr.next = mtr; ptr = mtr; if(ptr.next == null) return head; mtr = ptr.next; if(mtr == null) return head; qtr = mtr.next; } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-14-Swap%20Nodes%20in%20Pairs/",
    "relUrl": "/problem-14-Swap Nodes in Pairs/"
  },"118": {
    "doc": "Middle of the Linked List",
    "title": "Middle of the Linked List",
    "content": "Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node. Example 1: . Input: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2: . Input: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one. Constraints: . | The number of nodes in the list is in the range [1, 100]. | 1 &lt;= Node.val &lt;= 100 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode middleNode(ListNode head) { ListNode slow, fast; slow = fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow; } } . ",
    "url": "https://1001anjan.github.io/problem-140-Middle-of-the-Linked-List/",
    "relUrl": "/problem-140-Middle-of-the-Linked-List/"
  },"119": {
    "doc": "Uncommon Words from Two Sentences",
    "title": "Uncommon Words from Two Sentences",
    "content": "A sentence is a string of single-space separated words where each word consists only of lowercase letters. A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence. Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order. Example 1: . Input: s1 = \"this apple is sweet\", s2 = \"this apple is sour\" Output: [\"sweet\",\"sour\"] . Example 2: . Input: s1 = \"apple apple\", s2 = \"banana\" Output: [\"banana\"] . Constraints: . | 1 &lt;= s1.length, s2.length &lt;= 200 | s1 and s2 consist of lowercase English letters and spaces. | s1 and s2 do not have leading or trailing spaces. | All the words in s1 and s2 are separated by a single space. | . Solution: . class Solution { public String[] uncommonFromSentences(String s1, String s2) { Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); for(String w : s1.split(\"\\\\s+\")){ map.put(w,map.getOrDefault(w,0)+1); } for(String w : s2.split(\"\\\\s+\")){ map.put(w,map.getOrDefault(w,0)+1); } List&lt;String&gt; ans = new ArrayList&lt;&gt;(); for(String s: map.keySet()){ if(map.get(s) == 1) ans.add(s); } return ans.toArray(new String[ans.size()]); } } . class Solution { public String[] uncommonFromSentences(String A, String B) { Map&lt;String, Integer&gt; count = new HashMap(); for (String word: A.split(\" \")) count.put(word, count.getOrDefault(word, 0) + 1); for (String word: B.split(\" \")) count.put(word, count.getOrDefault(word, 0) + 1); List&lt;String&gt; ans = new LinkedList(); for (String word: count.keySet()) if (count.get(word) == 1) ans.add(word); return ans.toArray(new String[ans.size()]); } } . ",
    "url": "https://1001anjan.github.io/problem-141-Uncommon-Words-from-Two-Sentences/",
    "relUrl": "/problem-141-Uncommon-Words-from-Two-Sentences/"
  },"120": {
    "doc": "Monotonic Array",
    "title": "Monotonic Array",
    "content": "An array is monotonic if it is either monotone increasing or monotone decreasing. An array nums is monotone increasing if for all i &lt;= j, nums[i] &lt;= nums[j]. An array nums is monotone decreasing if for all i &lt;= j, nums[i] &gt;= nums[j]. Given an integer array nums, return true if the given array is monotonic, or false otherwise. Example 1: . Input: nums = [1,2,2,3] Output: true . Example 2: . Input: nums = [6,5,4,4] Output: true . Example 3: . Input: nums = [1,3,2] Output: false . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -105 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public boolean isMonotonic(int[] nums) { if(nums[0]&lt;=nums[nums.length-1]){ for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&gt;nums[i]) return false; } }else{ for(int i=1; i&lt;nums.length; i++){ if(nums[i-1]&lt;nums[i]) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-142-Monotonic-Array/",
    "relUrl": "/problem-142-Monotonic-Array/"
  },"121": {
    "doc": "Increasing Order Search Tree",
    "title": "Increasing Order Search Tree",
    "content": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child. Example 1: . Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9] Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9] . Example 2: . Input: root = [5,1,7] Output: [1,null,5,null,7] . Constraints: . | The number of nodes in the given tree will be in the range [1, 100]. | 0 &lt;= Node.val &lt;= 1000 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { TreeNode t = new TreeNode(); TreeNode next; public TreeNode increasingBST(TreeNode root) { if(root == null) return null; next = t; inOrderTraversal(root); return t.right; } public void inOrderTraversal(TreeNode head){ if(head == null) return; inOrderTraversal(head.left); next.right = head; next = head; next.left = null; inOrderTraversal(head.right); } } . ",
    "url": "https://1001anjan.github.io/problem-143-Increasing-Order-Search-Tree/",
    "relUrl": "/problem-143-Increasing-Order-Search-Tree/"
  },"122": {
    "doc": "Sort Array By Parity",
    "title": "Sort Array By Parity",
    "content": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers. Return any array that satisfies this condition. Example 1: . Input: nums = [3,1,2,4] Output: [2,4,3,1] Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Example 2: . Input: nums = [0] Output: [0] . Constraints: . | 1 &lt;= nums.length &lt;= 5000 | 0 &lt;= nums[i] &lt;= 5000 | . Solution: . class Solution { public int[] sortArrayByParity(int[] nums) { int s = 0; int e = nums.length - 1; while(s&lt;e){ // find odd number from left to right while(s&lt;e &amp;&amp; nums[s]%2 == 0) s++; // find even number from right to left while(s&lt;e &amp;&amp; nums[e]%2 != 0) e--; if(s&lt;e){ int t = nums[s]; nums[s] = nums[e]; nums[e] = t; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-144-Sort-Array-By-Parity/",
    "relUrl": "/problem-144-Sort-Array-By-Parity/"
  },"123": {
    "doc": "Reverse Only Letters",
    "title": "Reverse Only Letters",
    "content": "Given a string s, reverse the string according to the following rules: . All the characters that are not English letters remain in the same position. All the English letters (lowercase or uppercase) should be reversed. Return s after reversing it. Example 1: . Input: s = \"ab-cd\" Output: \"dc-ba\" . Example 2: . Input: s = \"a-bC-dEf-ghIj\" Output: \"j-Ih-gfE-dCba\" . Example 3: . Input: s = \"Test1ng-Leet=code-Q!\" Output: \"Qedo1ct-eeLg=ntse-T!\" . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of characters with ASCII values in the range [33, 122]. | s does not contain ‘\"’ or ‘\\’. | . Solution: . class Solution { public String reverseOnlyLetters(String str) { char[] chars = str.toCharArray(); int s = 0; int e = chars.length - 1; while(s&lt;e){ // find letters left to right while(s&lt;e &amp;&amp; !Character.isLetter(chars[s])) s++; // find letters right to left while(s&lt;e &amp;&amp; !Character.isLetter(chars[e])) e--; if(s&lt;e){ char c = chars[s]; chars[s] = chars[e]; chars[e] = c; } s++; e--; } return new String(chars); } } . ",
    "url": "https://1001anjan.github.io/problem-145-Reverse-Only-Letters/",
    "relUrl": "/problem-145-Reverse-Only-Letters/"
  },"124": {
    "doc": "Sort Array By Parity II",
    "title": "Sort Array By Parity II",
    "content": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even. Sort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even. Return any answer array that satisfies this condition. Example 1: . Input: nums = [4,2,5,7] Output: [4,5,2,7] Explanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted. Example 2: . Input: nums = [2,3] Output: [2,3] . Constraints: . | 2 &lt;= nums.length &lt;= 2 * 104 | nums.length is even. | Half of the integers in nums are even. | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int[] sortArrayByParityII(int[] nums) { int e = 0; int o = 1; while(e&lt;nums.length){ while(e&lt;nums.length &amp;&amp; nums[e]%2 == 0) e += 2; while(o&lt;nums.length &amp;&amp; nums[o]%2 != 0) o += 2; if(e&lt;nums.length &amp;&amp; o&lt;nums.length){ int t = nums[e]; nums[e] = nums[o]; nums[o] = t; } e += 2; o += 2; } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-146-Sort-Array-By-Parity-II/",
    "relUrl": "/problem-146-Sort-Array-By-Parity-II/"
  },"125": {
    "doc": "Long Pressed Name",
    "title": "Long Pressed Name",
    "content": "Your friend is typing his name into a keyboard. Sometimes, when typing a character c, the key might get long pressed, and the character will be typed 1 or more times. You examine the typed characters of the keyboard. Return True if it is possible that it was your friends name, with some characters (possibly none) being long pressed. Example 1: . Input: name = \"alex\", typed = \"aaleex\" Output: true Explanation: 'a' and 'e' in 'alex' were long pressed. Example 2: . Input: name = \"saeed\", typed = \"ssaaedd\" Output: false Explanation: 'e' must have been pressed twice, but it was not in the typed output. Constraints: . | 1 &lt;= name.length, typed.length &lt;= 1000 | name and typed consist of only lowercase English letters. | . Solution: . class Solution { public boolean isLongPressedName(String name, String typed) { int i = 0; int j = 0; while(i&lt;name.length() &amp;&amp; j&lt;typed.length()){ System.out.println(\"i\"+i+\" j: \"+j); if(name.charAt(i) == typed.charAt(j)){ i++; j++; }else{ if(j == 0) break; if(typed.charAt(j-1) != typed.charAt(j)) break; while(j&lt;typed.length() &amp;&amp; typed.charAt(j-1) == typed.charAt(j)) j++; } } while(j != 0 &amp;&amp; j&lt;typed.length() &amp;&amp; typed.charAt(j-1) == typed.charAt(j)) j++; return i == name.length() &amp;&amp; j == typed.length(); } } . ",
    "url": "https://1001anjan.github.io/problem-147-Long-Pressed-Name/",
    "relUrl": "/problem-147-Long-Pressed-Name/"
  },"126": {
    "doc": "Unique Email Addresses",
    "title": "Unique Email Addresses",
    "content": "Every valid email consists of a local name and a domain name, separated by the ‘@’ sign. Besides lowercase letters, the email may contain one or more ‘.’ or ‘+’. | For example, in “alice@leetcode.com”, “alice” is the local name, and “leetcode.com” is the domain name. If you add periods ‘.’ between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names. | For example, “alice.z@leetcode.com” and “alicez@leetcode.com” forward to the same email address. If you add a plus ‘+’ in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names. | For example, “m.y+name@email.com” will be forwarded to “my@email.com”. It is possible to use both of these rules at the same time. | . Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails. Example 1: . Input: emails = [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"] Output: 2 Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails. Example 2: . Input: emails = [\"a@leetcode.com\",\"b@leetcode.com\",\"c@leetcode.com\"] Output: 3 . Constraints: . | 1 &lt;= emails.length &lt;= 100 | 1 &lt;= emails[i].length &lt;= 100 | emails[i] consist of lowercase English letters, ‘+’, ‘.’ and ‘@’. | Each emails[i] contains exactly one ‘@’ character. | All local and domain names are non-empty. | Local names do not start with a ‘+’ character. | Domain names end with the “.com” suffix. | . Solution: . class Solution { public int numUniqueEmails(String[] emails) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String e : emails){ StringBuilder sb = new StringBuilder(); boolean p = true; boolean d = false; for(char c: e.toCharArray()){ if(p &amp;&amp; Character.isLetter(c)){ sb.append(c); }else if(d &amp;&amp; c == '.'){ sb.append(c); }else if(c == '+'){ p = false; }else if(c == '@') { sb.append(c); p = true; d = true; } } set.add(sb.toString()); } return set.size(); } } . simple but slow . class Solution { public int numUniqueEmails(String[] emails) { Set&lt;String&gt; set = new HashSet&lt;String&gt;(); int count=0; for(String email: emails) { String[] parts = email.split(\"\\\\@\"); String[] local = parts[0].split(\"\\\\+\"); set.add(local[0].replace(\".\",\"\")+\"@\"+(parts[1])); } return set.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-148-Unique-Email-Addresses/",
    "relUrl": "/problem-148-Unique-Email-Addresses/"
  },"127": {
    "doc": "Number of Recent Calls",
    "title": "Number of Recent Calls",
    "content": "You have a RecentCounter class which counts the number of recent requests within a certain time frame. Implement the RecentCounter class: . | RecentCounter() Initializes the counter with zero recent requests. | int ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t]. It is guaranteed that every call to ping uses a strictly larger value of t than the previous call. | . Example 1: . Input [\"RecentCounter\", \"ping\", \"ping\", \"ping\", \"ping\"] [[], [1], [100], [3001], [3002]] Output [null, 1, 2, 3, 3] Explanation RecentCounter recentCounter = new RecentCounter(); recentCounter.ping(1); // requests = [1], range is [-2999,1], return 1 recentCounter.ping(100); // requests = [1, 100], range is [-2900,100], return 2 recentCounter.ping(3001); // requests = [1, 100, 3001], range is [1,3001], return 3 recentCounter.ping(3002); // requests = [1, 100, 3001, 3002], range is [2,3002], return 3 . Constraints: . | 1 &lt;= t &lt;= 109 | Each test case will call ping with strictly increasing values of t. | At most 104 calls will be made to ping. | . Solution: . class RecentCounter { LinkedList&lt;Integer&gt; slideWindow; public RecentCounter() { this.slideWindow = new LinkedList&lt;Integer&gt;(); } public int ping(int t) { // step 1). append the current call this.slideWindow.addLast(t); // step 2). invalidate the outdated pings while (this.slideWindow.getFirst() &lt; t - 3000) this.slideWindow.removeFirst(); return this.slideWindow.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-149-Number-of-Recent-Calls/",
    "relUrl": "/problem-149-Number-of-Recent-Calls/"
  },"128": {
    "doc": "Find the Index of the First Occurrence in a String",
    "title": "Find the Index of the First Occurrence in a String",
    "content": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Example 1: . Input: haystack = \"sadbutsad\", needle = \"sad\" Output: 0 Explanation: \"sad\" occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: . Input: haystack = \"leetcode\", needle = \"leeto\" Output: -1 Explanation: \"leeto\" did not occur in \"leetcode\", so we return -1. Constraints: . | 1 &lt;= haystack.length, needle.length &lt;= 104 | haystack and needle consist of only lowercase English characters. | . Solution: . class Solution { public int strStr(String haystack, String needle) { return haystack.indexOf(needle); } } . class Solution { public int strStr(String haystack, String needle) { int i = 0, j = 0; int n1 = haystack.length(); int n2 = needle.length(); while(i &lt;= n1 - n2){ if(i &lt;= n1 - n2 &amp;&amp; haystack.charAt(i) != needle.charAt(0)) i++; int k = i; while(k &lt; n1 &amp;&amp; j &lt; n2 &amp;&amp; haystack.charAt(k) == needle.charAt(j)){ k ++; j ++; } if(j == n2) return i; j = 0; i++; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-15-Find%20the%20Index%20of%20the%20First%20Occurrence%20in%20a%20String/",
    "relUrl": "/problem-15-Find the Index of the First Occurrence in a String/"
  },"129": {
    "doc": "Sqrt(x)",
    "title": "Sqrt(x)",
    "content": "Given a non-negative integer x, compute and return the square root of x. Since the return type is an integer, the decimal digits are truncated, and only the integer part of the result is returned. Note: You are not allowed to use any built-in exponent function or operator, such as pow(x, 0.5) or x ** 0.5. Example 1: . Input: x = 4 Output: 2 . Example 2: . Input: x = 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. Constraints: . | 0 &lt;= x &lt;= 231 - 1 | . Solution . class Solution { public int mySqrt(int x) { if(x&lt;2) return x; int start = 2; int end = x/2; int mid = (start+end)/2; long res; while(start &lt;= end){ res = (long)mid*mid; if(res == x) return mid; if(res&gt;x) end = mid - 1; else start = mid + 1; mid = (start+end)/2; } return mid; } } . ",
    "url": "https://1001anjan.github.io/problem-15-sqrt/",
    "relUrl": "/problem-15-sqrt/"
  },"130": {
    "doc": "Range Sum of BST",
    "title": "Range Sum of BST",
    "content": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high]. Example 1: . Input: root = [10,5,15,3,7,null,18], low = 7, high = 15 Output: 32 Explanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32. Example 2: . Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10 Output: 23 Explanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23. Constraints: . | The number of nodes in the tree is in the range [1, 2 * 104]. | 1 &lt;= Node.val &lt;= 105 | 1 &lt;= low &lt;= high &lt;= 105 | All Node.val are unique. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int sum = 0; public int rangeSumBST(TreeNode root, int low, int high) { dfs(root,low,high); return this.sum; } public void dfs(TreeNode head, int low, int high){ if(head == null) return; if(head.val&gt;=low) dfs(head.left,low,high); if(head.val&lt;=high) dfs(head.right,low,high); if(head.val&gt;=low &amp;&amp; head.val&lt;=high) this.sum += head.val; } } . ",
    "url": "https://1001anjan.github.io/problem-150-Range-Sum-of-BST/",
    "relUrl": "/problem-150-Range-Sum-of-BST/"
  },"131": {
    "doc": "Valid Mountain Array",
    "title": "Valid Mountain Array",
    "content": "Given an array of integers arr, return true if and only if it is a valid mountain array. Recall that arr is a mountain array if and only if: . | arr.length &gt;= 3 | There exists some i with 0 &lt; i &lt; arr.length - 1 such that: . | arr[0] &lt; arr[1] &lt; … &lt; arr[i - 1] &lt; arr[i] | arr[i] &gt; arr[i + 1] &gt; … &gt; arr[arr.length - 1] | . | . Example 1: . Input: arr = [2,1] Output: false . Example 2: . Input: arr = [3,5,5] Output: false . Example 3: . Input: arr = [0,3,2,1] Output: true . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public boolean validMountainArray(int[] arr) { if(arr.length&lt;3) return false; int i = 1; while(i&lt;arr.length &amp;&amp; arr[i-1]&lt;arr[i]) i++; if(i == 1 || i == arr.length) return false; i--; while(i&lt;arr.length-1 &amp;&amp; arr[i]&gt;arr[i+1]) i++; return i == arr.length-1; } } . ",
    "url": "https://1001anjan.github.io/problem-151-Valid-Mountain-Array/",
    "relUrl": "/problem-151-Valid-Mountain-Array/"
  },"132": {
    "doc": "Delete Columns to Make Sorted",
    "title": "Delete Columns to Make Sorted",
    "content": "You are given an array of n strings strs, all of the same length. The strings can be arranged such that there is one on each line, making a grid. For example, strs = [“abc”, “bce”, “cae”] can be arranged as: . abc bce cae . You want to delete the columns that are not sorted lexicographically. In the above example (0-indexed), columns 0 (‘a’, ‘b’, ‘c’) and 2 (‘c’, ‘e’, ‘e’) are sorted while column 1 (‘b’, ‘c’, ‘a’) is not, so you would delete column 1. Return the number of columns that you will delete. Example 1: . Input: strs = [\"cba\",\"daf\",\"ghi\"] Output: 1 Explanation: The grid looks as follows: cba daf ghi Columns 0 and 2 are sorted, but column 1 is not, so you only need to delete 1 column. Example 2: . Input: strs = [\"a\",\"b\"] Output: 0 Explanation: The grid looks as follows: a b Column 0 is the only column and is sorted, so you will not delete any columns. Example 3: . Input: strs = [\"zyx\",\"wvu\",\"tsr\"] Output: 3 Explanation: The grid looks as follows: zyx wvu tsr All 3 columns are not sorted, so you will delete all 3. Constraints: . | n == strs.length | 1 &lt;= n &lt;= 100 | 1 &lt;= strs[i].length &lt;= 1000 | strs[i] consists of lowercase English letters. | . Solution: . class Solution { public int minDeletionSize(String[] strs) { int c = 0; for(int i=0;i&lt;strs[0].length(); i++){ char ch = strs[0].charAt(i); for(int j = 1; j&lt;strs.length; j++){ if(ch&gt;strs[j].charAt(i)){ c++; break; } ch = strs[j].charAt(i); } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-152-Delete-Columns-to-Make-Sorted/",
    "relUrl": "/problem-152-Delete-Columns-to-Make-Sorted/"
  },"133": {
    "doc": "N-Repeated Element in Size 2N Array",
    "title": "N-Repeated Element in Size 2N Array",
    "content": "You are given an integer array nums with the following properties: . | nums.length == 2 * n. | nums contains n + 1 unique elements. | Exactly one element of nums is repeated n times. | . Return the element that is repeated n times. Example 1: . Input: nums = [1,2,3,3] Output: 3 . Example 2: . Input: nums = [2,1,2,5,3,2] Output: 2 . Example 3: . Input: nums = [5,1,5,2,5,3,5,4] Output: 5 . Constraints: . | 2 &lt;= n &lt;= 5000 | nums.length == 2 * n | 0 &lt;= nums[i] &lt;= 104 | nums contains n + 1 unique elements and one of them is repeated exactly n times. | . Solution: . class Solution { public int repeatedNTimes(int[] nums) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int n:nums) map.put(n,map.getOrDefault(n,0) + 1); for(int n: map.keySet()) // since others elemements are unique if(map.get(n)&gt;1) return n; throw null; } } . If we ever find a repeated element, it must be the answer. Let’s call this answer the major element. Consider all subarrays of length 4. There must be a major element in at least one such subarray. This is because either: . | There is a major element in a length 2 subarray, or; | Every length 2 subarray has exactly 1 major element, which means that a length 4 subarray that begins at a major element will have 2 major elements. Thus, we only have to compare elements with their neighbors that are distance 1, 2, or 3 away. class Solution { public int repeatedNTimes(int[] nums) { for(int k = 1; k&lt;=3; k++){ for(int i=0; i&lt;nums.length-k; i++) if(nums[i] == nums[i+k]) return nums[i]; } throw null; } } . | . ",
    "url": "https://1001anjan.github.io/problem-153-N-Repeated-Element-in-Size-2N-Array/",
    "relUrl": "/problem-153-N-Repeated-Element-in-Size-2N-Array/"
  },"134": {
    "doc": "Univalued Binary Tree",
    "title": "Univalued Binary Tree",
    "content": "A binary tree is uni-valued if every node in the tree has the same value. Given the root of a binary tree, return true if the given tree is uni-valued, or false otherwise. Example 1: . Input: root = [1,1,1,1,1,null,1] Output: true . Example 2: . Input: root = [2,2,2,5,2] Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 100]. | 0 &lt;= Node.val &lt; 100 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isUnivalTree(TreeNode root) { Stack&lt;TreeNode&gt; stack = new Stack(); stack.push(root); int val = root.val; while(!stack.isEmpty()){ TreeNode node = stack.pop(); if(val != node.val) return false; if(node.left != null) stack.push(node.left); if(node.right != null) stack.push(node.right); } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-154-Univalued-Binary-Tree/",
    "relUrl": "/problem-154-Univalued-Binary-Tree/"
  },"135": {
    "doc": "Largest Perimeter Triangle",
    "title": "Largest Perimeter Triangle",
    "content": "Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0. Example 1: . Input: nums = [2,1,2] Output: 5 . Example 2: . Input: nums = [1,2,1] Output: 0 . Constraints: . | 3 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 106 | . Solution: . class Solution { public int largestPerimeter(int[] nums) { Arrays.sort(nums); for(int i=nums.length-3; i&gt;=0; i--){ if(nums[i] + nums[i+1] &gt; nums[i+2]) return nums[i] + nums[i+1] + nums[i+2]; } return 0; } } . ",
    "url": "https://1001anjan.github.io/problem-155-Largest-Perimeter-Triangle/",
    "relUrl": "/problem-155-Largest-Perimeter-Triangle/"
  },"136": {
    "doc": "Squares of a Sorted Array",
    "title": "Squares of a Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order. Example 1: . Input: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2: . Input: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121] . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums is sorted in non-decreasing order. | . Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach? . Solution: . class Solution { public int[] sortedSquares(int[] nums) { int[] ans = new int[nums.length]; int s = 0; int e = nums.length - 1; int i = e; while(i&gt;=0){ if(Math.abs(nums[s])&gt;Math.abs(nums[e])) ans[i--] = nums[s]*nums[s++]; else ans[i--] = nums[e]*nums[e--]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-156-Squares-of-a-Sorted%20Array/",
    "relUrl": "/problem-156-Squares-of-a-Sorted Array/"
  },"137": {
    "doc": "Add to Array-Form of Integer",
    "title": "Add to Array-Form of Integer",
    "content": "The array-form of an integer num is an array representing its digits in left to right order. | For example, for num = 1321, the array form is [1,3,2,1]. Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k. | . Example 1: . Input: num = [1,2,0,0], k = 34 Output: [1,2,3,4] Explanation: 1200 + 34 = 1234 . Example 2: . Input: num = [2,7,4], k = 181 Output: [4,5,5] Explanation: 274 + 181 = 455 . Example 3: . Input: num = [2,1,5], k = 806 Output: [1,0,2,1] Explanation: 215 + 806 = 1021 . Constraints: . | 1 &lt;= num.length &lt;= 104 | 0 &lt;= num[i] &lt;= 9 | num does not contain any leading zeros except for the zero itself. | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public List&lt;Integer&gt; addToArrayForm(int[] nums, int k) { LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;(); int c = 0; int i = nums.length - 1; while(k&gt;0 || i&gt;=0){ int d = k%10; if(i&gt;=0){ ans.addFirst((nums[i] + d + c)%10); c = (nums[i] + d + c)/10; i--; }else{ ans.addFirst((d+c)%10); c = (d + c)/10; } k = k/10; } if(c&gt;0) ans.addFirst(c); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-157-Add-to-Array-Form-of-Integer/",
    "relUrl": "/problem-157-Add-to-Array-Form-of-Integer/"
  },"138": {
    "doc": "Cousins in Binary Tree",
    "title": "Cousins in Binary Tree",
    "content": "Given the root of a binary tree with unique values and the values of two different nodes of the tree x and y, return true if the nodes corresponding to the values x and y in the tree are cousins, or false otherwise. Two nodes of a binary tree are cousins if they have the same depth with different parents. Note that in a binary tree, the root node is at the depth 0, and children of each depth k node are at the depth k + 1. Example 1: . Input: root = [1,2,3,4], x = 4, y = 3 Output: false . Example 2: . Input: root = [1,2,3,null,4,null,5], x = 5, y = 4 Output: true . Example 3: . Input: root = [1,2,3,null,4], x = 2, y = 3 Output: false . Constraints: . | The number of nodes in the tree is in the range [2, 100]. | 1 &lt;= Node.val &lt;= 100 | Each node has a unique value. | x != y | x and y are exist in the tree. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isCousins(TreeNode root, int x, int y) { if(root == null || root.val == x || root.val == y) return false; Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;(); q.add(root); while(!q.isEmpty()){ int size = q.size(); int x1 = -1; int y1 = -1; TreeNode p1, p2; p1 = p2 = null; Queue&lt;TreeNode&gt; q1 = new LinkedList&lt;&gt;(); for(int i = 1; i&lt;=size; i++){ TreeNode t = q.poll(); if(t.left != null &amp;&amp; t.left.val == x){ x1= x; p1 = t; }else if(t.left != null &amp;&amp; t.left.val == y){ y1= y; p2 = t; } if(t.right != null &amp;&amp; t.right.val == x){ x1 = x; p1 = t; } else if(t.right != null &amp;&amp; t.right.val == y){ y1 = y; p2 = t; } if(x1 == x &amp;&amp; y1== y &amp;&amp; p1 != p2) return true; if(t.left != null) q1.add(t.left); if(t.right != null) q1.add(t.right); } q = q1; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-158-Cousins-in-Binary-Tree/",
    "relUrl": "/problem-158-Cousins-in-Binary-Tree/"
  },"139": {
    "doc": "Cousins in Binary Tree",
    "title": "Find the Town Judge",
    "content": "In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge. If the town judge exists, then: . | The town judge trusts nobody. | Everybody (except for the town judge) trusts the town judge. | There is exactly one person that satisfies properties 1 and 2. | . You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. Example 1: . Input: n = 2, trust = [[1,2]] Output: 2 . Example 2: . Input: n = 3, trust = [[1,3],[2,3]] Output: 3 . Example 3: . Input: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 . Constraints: . | 1 &lt;= n &lt;= 1000 | 0 &lt;= trust.length &lt;= 104 | trust[i].length == 2 | All the pairs of trust are unique. | ai != bi | 1 &lt;= ai, bi &lt;= n | . Solution: . class Solution { public int findJudge(int n, int[][] trust) { boolean[] s = new boolean[n]; int[] c = new int[n]; for(int i=0; i&lt;trust.length; i++){ s[trust[i][0]-1] = true; c[trust[i][1]-1]++; } for(int i=0; i&lt;n; i++) if(!s[i] &amp;&amp; c[i] == n-1) return i+1; return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-159-Cousins-in-Binary-Tree/#find-the-town-judge",
    "relUrl": "/problem-159-Cousins-in-Binary-Tree/#find-the-town-judge"
  },"140": {
    "doc": "Cousins in Binary Tree",
    "title": "Cousins in Binary Tree",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-159-Cousins-in-Binary-Tree/",
    "relUrl": "/problem-159-Cousins-in-Binary-Tree/"
  },"141": {
    "doc": "Climbing Stairs",
    "title": "Climbing Stairs",
    "content": "You are climbing a staircase. It takes n steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? . Example 1: . Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top. 1. 1 step + 1 step 2. 2 steps . Example 2: . Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top. 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step . Constraints: . | 1 &lt;= n &lt;= 45 | . Solution . class Solution { public int climbStairs(int n) { if(n &lt;= 2) return n; int[] dp = new int[n+1]; dp[1] = 1; dp[2] = 2; for(int i = 3; i &lt;= n; i++) dp[i] = dp[i-1] + dp[i-2]; return dp[n]; } } . Recursion . class Solution { HashMap&lt;Integer, Integer&gt; map = new HashMap(); public int climbStairs(int n) { if(map.containsKey(n)) return map.get(n); if(n == 1){ map.put(1, 1); return 1; } if(n == 2) { map.put(2, 2); return 2; } int x = climbStairs(n-1) + climbStairs(n-2); map.put(n,x); return map.get(n); } } . ",
    "url": "https://1001anjan.github.io/problem-16-climbing-stairs/",
    "relUrl": "/problem-16-climbing-stairs/"
  },"142": {
    "doc": "Divide Two Integers",
    "title": "Divide Two Integers",
    "content": "Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator. The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2. Return the quotient after dividing dividend by divisor. Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For this problem, if the quotient is strictly greater than 231 - 1, then return 231 - 1, and if the quotient is strictly less than -231, then return -231. Example 1: . Input: dividend = 10, divisor = 3 Output: 3 Explanation: 10/3 = 3.33333.. which is truncated to 3. Example 2: . Input: dividend = 7, divisor = -3 Output: -2 Explanation: 7/-3 = -2.33333.. which is truncated to -2. Constraints: . | -2^31 &lt;= dividend, divisor &lt;= 2^31 - 1 | divisor != 0 | . Solution: . class Solution { public int divide(int dividend, int divisor) { //Reduce the problem to positive long integer to make it easier. //Use long to avoid integer overflow cases. int sign = 1; if ((dividend &gt; 0 &amp;&amp; divisor &lt; 0) || (dividend &lt; 0 &amp;&amp; divisor &gt; 0)) sign = -1; long ldividend = Math.abs((long) dividend); long ldivisor = Math.abs((long) divisor); //Take care the edge cases. if (ldivisor == 0) return Integer.MAX_VALUE; if ((ldividend == 0) || (ldividend &lt; ldivisor)) return 0; long lans = ldivide(ldividend, ldivisor); int ans; if (lans &gt; Integer.MAX_VALUE){ //Handle overflow. ans = (sign == 1)? Integer.MAX_VALUE : Integer.MIN_VALUE; } else { ans = (int) (sign * lans); } return ans; } private long ldivide(long ldividend, long ldivisor) { // Recursion exit condition if (ldividend &lt; ldivisor) return 0; // Find the largest multiple so that (divisor * multiple &lt;= dividend), // whereas we are moving with stride 1, 2, 4, 8, 16...2^n for performance reason. // Think this as a binary search. long sum = ldivisor; long multiple = 1; while ((sum+sum) &lt;= ldividend) { sum += sum; multiple += multiple; } //Look for additional value for the multiple from the reminder (dividend - sum) recursively. return multiple + ldivide(ldividend - sum, ldivisor); } } . ",
    "url": "https://1001anjan.github.io/problem-16-Divide%20Two%20Integers/",
    "relUrl": "/problem-16-Divide Two Integers/"
  },"143": {
    "doc": "Find Common Characters",
    "title": "Find Common Characters",
    "content": "Given a string array words, return an array of all characters that show up in all strings within the words (including duplicates). You may return the answer in any order. Example 1: . Input: words = [\"bella\",\"label\",\"roller\"] Output: [\"e\",\"l\",\"l\"] . Example 2: . Input: words = [\"cool\",\"lock\",\"cook\"] Output: [\"c\",\"o\"] . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); Map&lt;Character, Integer&gt; m1 = new HashMap&lt;&gt;(); // constracting first word for(char c : words[0].toCharArray()) m1.put(c,m1.getOrDefault(c,0)+1); for(int i = 1; i &lt; words.length; i++){ Map&lt;Character, Integer&gt; m2 = new HashMap&lt;&gt;(); for(char c : words[i].toCharArray()) m2.put(c,m2.getOrDefault(c,0)+1); // find common char and store min value or remove uncommon Map&lt;Character, Integer&gt; m3 = new HashMap&lt;&gt;(); for(char c : m2.keySet()){ if(m1.containsKey(c)) m3.put(c,Math.min(m1.get(c),m2.get(c))); } m1 = m3; } // constract ans for(char c : m1.keySet()){ for(int i = 1; i&lt;= m1.get(c); i++) ans.add(String.valueOf(c)); } return ans; } } . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); for(char ch = 'a'; ch &lt;= 'z'; ch++) { int minCountOfCh = Integer.MAX_VALUE; for(String word : words) { int currChCount = 0; for(char currCh : word.toCharArray()) { if(currCh == ch) { currChCount++; } } minCountOfCh = Math.min(minCountOfCh, currChCount); } for(int i = 0; i &lt; minCountOfCh; i++) { res.add(String.valueOf(ch)); } } return res; } } . class Solution { public List&lt;String&gt; commonChars(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] freq = new int[26]; Arrays.fill(freq, Integer.MAX_VALUE); for (String s : words) { int[] temp = new int[26]; for (int i = 0; i &lt; s.length(); i++) { int index = (int) s.charAt(i) - 'a'; temp[index]++; } for (int i = 0; i &lt; 26; i++) { freq[i] = Math.min(temp[i], freq[i]); } } for (int i = 0; i &lt; 26; i++) { while (freq[i]-- &gt; 0) { System.out.print(i + \" \"); char c = (char) (i + 97); ans.add(\"\" + c); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-160-Find-Common-Characters/",
    "relUrl": "/problem-160-Find-Common-Characters/"
  },"144": {
    "doc": "Maximize Sum Of Array After K Negations",
    "title": "Maximize Sum Of Array After K Negations",
    "content": "Given an integer array nums and an integer k, modify the array in the following way: . | choose an index i and replace nums[i] with -nums[i]. You should apply this process exactly k times. You may choose the same index i multiple times. | . Return the largest possible sum of the array after modifying it in this way. Example 1: . Input: nums = [4,2,3], k = 1 Output: 5 Explanation: Choose index 1 and nums becomes [4,-2,3]. Example 2: . Input: nums = [3,-1,0,2], k = 3 Output: 6 Explanation: Choose indices (1, 2, 2) and nums becomes [3,1,0,2]. Example 3: . Input: nums = [2,-3,-1,5,-4], k = 2 Output: 13 Explanation: Choose indices (1, 4) and nums becomes [2,3,-1,5,4]. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -100 &lt;= nums[i] &lt;= 100 | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); int i = 0; // checking for negetive elements while(i&lt;k &amp;&amp; i&lt;nums.length &amp;&amp; nums[i]&lt;0){ nums[i] *=-1; i++; } if(i == nums.length){ if(k%2 == 0) nums[nums.length-1] *=-1; }else{ k = k - i; // checking if positive element if(i&lt;nums.length &amp;&amp; nums[i] &gt; 0){ // check if we have previous postive element if(i&gt;0 &amp;&amp; nums[i-1]&gt;0 &amp;&amp; nums[i-1]&lt;nums[i] &amp;&amp; k%2 == 1) nums[i-1] *= -1; else if(k%2 == 1) nums[i] *= -1; } } int sum = 0; for(int n : nums) sum +=n; return sum; } } . Using mean heap but slower than previous . class Solution { public int largestSumAfterKNegations(int[] nums, int k) { PriorityQueue&lt;Integer&gt;pq=new PriorityQueue&lt;&gt;((a,b)-&gt;a-b); int sum=0; for(int i:nums){ pq.add(i); } while(k&gt;0){ int x=pq.poll(); pq.add(-x); k--; } while(pq.size()&gt;0){ sum+=pq.poll(); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Maximize-Sum-Of-Array-After-K-Negations/",
    "relUrl": "/problem-161-Maximize-Sum-Of-Array-After-K-Negations/"
  },"145": {
    "doc": "Complement of Base 10 Integer",
    "title": "Complement of Base 10 Integer",
    "content": "The complement of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation. | For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2. Given an integer n, return its complement. | . Example 1: . Input: n = 5 Output: 2 Explanation: 5 is \"101\" in binary, with complement \"010\" in binary, which is 2 in base-10. Example 2: . Input: n = 7 Output: 0 Explanation: 7 is \"111\" in binary, with complement \"000\" in binary, which is 0 in base-10. Example 3: . Input: n = 10 Output: 5 Explanation: 10 is \"1010\" in binary, with complement \"0101\" in binary, which is 5 in base-10. Constraints: . | 0 &lt;= n &lt; 109 | . Solution: . class Solution { public int bitwiseComplement(int num) { if(num == 0) return 1; int mask = 0; while(mask &lt; num) mask = mask &lt;&lt; 1 | 1; return (~ num) &amp; mask ; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Complement-of-Base-10-Integer/",
    "relUrl": "/problem-161-Complement-of-Base-10-Integer/"
  },"146": {
    "doc": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "title": "Partition Array Into Three Parts With Equal Sum",
    "content": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums. Formally, we can partition the array if we can find indexes i + 1 &lt; j with (arr[0] + arr[1] + … + arr[i] == arr[i + 1] + arr[i + 2] + … + arr[j - 1] == arr[j] + arr[j + 1] + … + arr[arr.length - 1]) . Example 1: . Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1] Output: true Explanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 . Example 2: . Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1] Output: false . Example 3: . Input: arr = [3,3,6,5,-2,2,5,1,-9,4] Output: true Explanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 . Constraints: . | 3 &lt;= arr.length &lt;= 5 * 104 | -104 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public boolean canThreePartsEqualSum(int[] arr) { int sum = 0; for(int n : arr) sum += n; if(sum % 3 != 0) return false; int parts = sum/3; int count = 0; sum = 0; for(int i=0; i&lt;arr.length; i++){ sum += arr[i]; if(sum == parts){ count ++; sum = 0; } } return count &gt;= 3; } } . ",
    "url": "https://1001anjan.github.io/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/#partition-array-into-three-parts-with-equal-sum",
    "relUrl": "/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/#partition-array-into-three-parts-with-equal-sum"
  },"147": {
    "doc": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "title": "Partition-Array-Into-Three-Parts-With-Equal-Sum",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/",
    "relUrl": "/problem-161-Partition-Array-Into-Three-Parts-With-Equal-Sum/"
  },"148": {
    "doc": "Binary Prefix Divisible By 5",
    "title": "Binary Prefix Divisible By 5",
    "content": "You are given a binary array nums (0-indexed). We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit). | For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5. Return an array of booleans answer where answer[i] is true if xi is divisible by 5. | . Example 1: . Input: nums = [0,1,1] Output: [true,false,false] Explanation: The input numbers in binary are 0, 01, 011; which are 0, 1, and 3 in base-10. Only the first number is divisible by 5, so answer[0] is true. Example 2: . Input: nums = [1,1,1] Output: [false,false,false] . Constraints: . | 1 &lt;= nums.length &lt;= 105 | nums[i] is either 0 or 1. | . Solution: . class Solution { public List&lt;Boolean&gt; prefixesDivBy5(int[] nums) { List&lt;Boolean&gt; ans = new LinkedList&lt;&gt;(); long n = 0; for(int i=0; i&lt;nums.length; i++) ans.add((n = (n &lt;&lt; 1 | nums[i]) % 5) == 0); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-164-Binary-Prefix-Divisible-By-5/",
    "relUrl": "/problem-164-Binary-Prefix-Divisible-By-5/"
  },"149": {
    "doc": "Sum of Root To Leaf Binary Numbers",
    "title": "Sum of Root To Leaf Binary Numbers",
    "content": "You are given the root of a binary tree where each node has a value 0 or 1. Each root-to-leaf path represents a binary number starting with the most significant bit. For example, if the path is 0 -&gt; 1 -&gt; 1 -&gt; 0 -&gt; 1, then this could represent 01101 in binary, which is 13. For all leaves in the tree, consider the numbers represented by the path from the root to that leaf. Return the sum of these numbers. The test cases are generated so that the answer fits in a 32-bits integer. Example 1: . Input: root = [1,0,1,0,1,0,1] Output: 22 Explanation: (100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22 . Example 2: . Input: root = [0] Output: 0 . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | Node.val is 0 or 1. | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { int leafSum; public int sumRootToLeaf(TreeNode root) { this.leafSum = 0; inorderTraverse(root,0); return this.leafSum; } public void inorderTraverse(TreeNode head, int currSum){ if(head != null){ if(head.left == null &amp;&amp; head.right == null){ leafSum += currSum &lt;&lt; 1 | head.val; } currSum = currSum &lt;&lt; 1 | head.val; inorderTraverse(head.left,currSum); inorderTraverse(head.right,currSum); } } } . Morris Preorder Traversal. The idea of Morris preorder traversal is simple: to use no space but to traverse the tree. Must check: https://leetcode.com/problems/sum-of-root-to-leaf-binary-numbers/ . ",
    "url": "https://1001anjan.github.io/problem-165-Sum-of-Root-To-Leaf-Binary-Numbers/",
    "relUrl": "/problem-165-Sum-of-Root-To-Leaf-Binary-Numbers/"
  },"150": {
    "doc": "Divisor Game",
    "title": "Divisor Game",
    "content": "Alice and Bob take turns playing a game, with Alice starting first. Initially, there is a number n on the chalkboard. On each player’s turn, that player makes a move consisting of: . | Choosing any x with 0 &lt; x &lt; n and n % x == 0. | Replacing the number n on the chalkboard with n - x. Also, if a player cannot make a move, they lose the game. | . Return true if and only if Alice wins the game, assuming both players play optimally. Example 1: . Input: n = 2 Output: true Explanation: Alice chooses 1, and Bob has no more moves. Example 2: . Input: n = 3 Output: false Explanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves. Constraints: . | 1 &lt;= n &lt;= 1000 | . Solution: . class Solution { public boolean divisorGame(int n) { return n%2 == 0; } } . ",
    "url": "https://1001anjan.github.io/problem-166-Divisor-Game/",
    "relUrl": "/problem-166-Divisor-Game/"
  },"151": {
    "doc": "Valid Boomerang",
    "title": "Valid Boomerang",
    "content": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang. A boomerang is a set of three points that are all distinct and not in a straight line. Example 1: . Input: points = [[1,1],[2,3],[3,2]] Output: true . Example 2: . Input: points = [[1,1],[2,2],[3,3]] Output: false . Constraints: . | points.length == 3 | points[i].length == 2 | 0 &lt;= xi, yi &lt;= 100 | . Solution: Area of a triangle . class Solution { public boolean isBoomerang(int[][] points) { double a, b, c, d, area; a=points[0][0]-points[1][0]; b=points[1][0]-points[2][0]; c=points[0][1]-points[1][1]; d=points[1][1]-points[2][1]; area=0.5*((a*d)-(b*c)); return area!=0; } } . ",
    "url": "https://1001anjan.github.io/problem-167-Valid-Boomerang/",
    "relUrl": "/problem-167-Valid-Boomerang/"
  },"152": {
    "doc": "Last Stone Weight",
    "title": "Last Stone Weight",
    "content": "You are given an array of integers stones where stones[i] is the weight of the ith stone. We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is: . | If x == y, both stones are destroyed, and | If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x. At the end of the game, there is at most one stone left. | . Return the weight of the last remaining stone. If there are no stones left, return 0. Example 1: . Input: stones = [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone. Example 2: . Input: stones = [1] Output: 1 . Constraints: . | 1 &lt;= stones.length &lt;= 30 | 1 &lt;= stones[i] &lt;= 1000 | . Solution: . class Solution { public int lastStoneWeight(int[] stones) { Queue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for(int n : stones) q.add(n); while(q.size() &gt; 1){ int x = q.poll(); int y = q.poll(); if(x != y) q.add(Math.abs(x - y)); } if(q.size() == 0) return 0; return q.poll(); } } . ",
    "url": "https://1001anjan.github.io/problem-168-Last-Stone-Weight/",
    "relUrl": "/problem-168-Last-Stone-Weight/"
  },"153": {
    "doc": "Remove All Adjacent Duplicates In String",
    "title": "Remove All Adjacent Duplicates In String",
    "content": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them. We repeatedly make duplicate removals on s until we no longer can. Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique. Example 1: . Input: s = \"abbaca\" Output: \"ca\" Explanation: For example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move. The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\". Example 2: . Input: s = \"azxxzy\" Output: \"ay\" . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of lowercase English letters. | . Solution: . class Solution { public String removeDuplicates(String s) { StringBuilder sb = new StringBuilder(); sb.append(s.charAt(0)); for(int i=1; i&lt;s.length(); i++){ if(sb.length()&gt;0 &amp;&amp; sb.charAt(sb.length()-1) == s.charAt(i)){ // sb.delete(sb.length()-1, sb.length()); sb.deleteCharAt(sb.length()-1); }else{ sb.append(s.charAt(i)); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-169-Remove-All-Adjacent-Duplicates-In-String/",
    "relUrl": "/problem-169-Remove-All-Adjacent-Duplicates-In-String/"
  },"154": {
    "doc": "Next Permutation",
    "title": "Next Permutation",
    "content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order. | For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1]. The next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order). | For example, the next permutation of arr = [1,2,3] is [1,3,2]. | Similarly, the next permutation of arr = [2,3,1] is [3,1,2]. | While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement. | Given an array of integers nums, find the next permutation of nums. | . The replacement must be in place and use only constant extra memory. Example 1: . Input: nums = [1,2,3] Output: [1,3,2] . Example 2: . Input: nums = [3,2,1] Output: [1,2,3] . Example 3: . Input: nums = [1,1,5] Output: [1,5,1] . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public void nextPermutation(int[] nums) { int i = nums.length - 2; while(i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1] ) i --; if(i &gt;= 0){ int j = nums.length - 1; while(j &gt;=0 &amp;&amp; nums[i] &gt;= nums[j]) j--; swap(nums, i, j); } reverse(nums, i + 1); } public void swap(int[] nums, int i, int j){ int t = nums[i]; nums[i] = nums[j]; nums[j] = t; } public void reverse(int[] nums, int i){ int j = nums.length - 1; while(i &lt; j)swap(nums, i ++, j --); } } . ",
    "url": "https://1001anjan.github.io/problem-17-Next%20Permutation/",
    "relUrl": "/problem-17-Next Permutation/"
  },"155": {
    "doc": "Remove Duplicates from Sorted Linked List",
    "title": "Remove Duplicates from Sorted List",
    "content": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well. Example 1 . Input: head = [1,1,2] Output: [1,2] . Example 2 . Input: head = [1,1,2,3,3] Output: [1,2,3] . Constraints: . | The number of nodes in the list is in the range [0, 300]. | -100 &lt;= Node.val &lt;= 100 | The list is guaranteed to be sorted in ascending order. | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode deleteDuplicates(ListNode head) { if (head == null || head.next == null ) return head; ListNode res, ptr, rem; // create first node res = ptr = head; int currVal = head.val; head = head.next; res.next = null; while(head != null){ if(head.val == currVal){ rem = head; head = head.next; rem.next = null; }else{ ptr.next = head; ptr = ptr.next; head = head.next; ptr.next = null; currVal = ptr.val; } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-17-remove-duplicates-from-sorted-list/#remove-duplicates-from-sorted-list",
    "relUrl": "/problem-17-remove-duplicates-from-sorted-list/#remove-duplicates-from-sorted-list"
  },"156": {
    "doc": "Remove Duplicates from Sorted Linked List",
    "title": "Remove Duplicates from Sorted Linked List",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-17-remove-duplicates-from-sorted-list/",
    "relUrl": "/problem-17-remove-duplicates-from-sorted-list/"
  },"157": {
    "doc": "Height Checker",
    "title": "Height Checker",
    "content": "A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line. You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed). Return the number of indices where heights[i] != expected[i]. Example 1: . Input: heights = [1,1,4,2,1,3] Output: 3 Explanation: heights: [1,1,4,2,1,3] expected: [1,1,1,2,3,4] Indices 2, 4, and 5 do not match. Example 2: . Input: heights = [5,1,2,3,4] Output: 5 Explanation: heights: [5,1,2,3,4] expected: [1,2,3,4,5] All indices do not match. Example 3: . Input: heights = [1,2,3,4,5] Output: 0 Explanation: heights: [1,2,3,4,5] expected: [1,2,3,4,5] All indices match. Constraints: . | 1 &lt;= heights.length &lt;= 100 | 1 &lt;= heights[i] &lt;= 100 | . Solution: . class Solution { public int heightChecker(int[] heights) { Queue&lt;Integer&gt; q = new PriorityQueue&lt;Integer&gt;(); for(int n : heights) q.add(n); int count = 0; for(int n : heights) if(q.poll() != n) count++; return count; } } . ",
    "url": "https://1001anjan.github.io/problem-170-Height-Checker/",
    "relUrl": "/problem-170-Height-Checker/"
  },"158": {
    "doc": "Unique Number of Occurrences",
    "title": "Unique Number of Occurrences",
    "content": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique, or false otherwise. Example 1: . Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: . Input: arr = [1,2] Output: false . Example 3: . Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true . Constraints: . | 1 &lt;= arr.length &lt;= 1000 | -1000 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean uniqueOccurrences(int[] arr) { Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr){ m.put(n,m.getOrDefault(n,0) + 1); } int prev = Integer.MAX_VALUE; for(int n : m.values().stream().sorted().collect(Collectors.toList())){ if(prev == n) return false; prev = n; } return true; } } . Extra Memory but Time Complexity O(n) . class Solution { public boolean uniqueOccurrences(int[] arr) { Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr){ m.put(n,m.getOrDefault(n,0) + 1); } Set&lt;Integer&gt; s = new HashSet(); for(int n : m.values()) s.add(n); return s.size() == m.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-171-Unique-Number-of-Occurrences/",
    "relUrl": "/problem-171-Unique-Number-of-Occurrences/"
  },"159": {
    "doc": "Minimum Absolute Difference",
    "title": "Minimum Absolute Difference",
    "content": "Given an array of distinct integers arr, find all pairs of elements with the minimum absolute difference of any two elements. Return a list of pairs in ascending order(with respect to pairs), each pair [a, b] follows . | a, b are from arr | a &lt; b | b - a equals to the minimum absolute difference of any two elements in arr | . Example 1: . Input: arr = [4,2,1,3] Output: [[1,2],[2,3],[3,4]] Explanation: The minimum absolute difference is 1. List all pairs with difference equal to 1 in ascending order. Example 2: . Input: arr = [1,3,6,10,15] Output: [[1,3]] . Example 3: . Input: arr = [3,8,-10,23,19,-4,-14,27] Output: [[-14,-10],[19,23],[23,27]] . Constraints: . | 2 &lt;= arr.length &lt;= 105 | -106 &lt;= arr[i] &lt;= 106 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; minimumAbsDifference(int[] arr) { Arrays.sort(arr); int diff = Integer.MAX_VALUE; for(int i = 1; i&lt;arr.length; i++) if(arr[i] - arr[i-1] &lt; diff) diff = arr[i] - arr[i-1]; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; arr.length; i++){ for(int j = i + 1; j &lt; arr.length; j++){ if(arr[j] - arr[i] == diff){ ans.add((Arrays.asList(new Integer[]{arr[i],arr[j]}))); }else if(arr[j] - arr[i] &gt; diff) break; } } return ans; } } . https://leetcode.com/problems/minimum-absolute-difference/solution/ . ",
    "url": "https://1001anjan.github.io/problem-172-Minimum-Absolute-Difference/",
    "relUrl": "/problem-172-Minimum-Absolute-Difference/"
  },"160": {
    "doc": "Maximum Number of Balloons",
    "title": "Maximum Number of Balloons",
    "content": "Given a string text, you want to use the characters of text to form as many instances of the word “balloon” as possible. You can use each character in text at most once. Return the maximum number of instances that can be formed. Example 1: . Input: text = \"nlaebolko\" Output: 1 . Example 2: . Input: text = \"loonbalxballpoon\" Output: 2 . Example 3: . Input: text = \"leetcode\" Output: 0 . Constraints: . | 1 &lt;= text.length &lt;= 104 | text consists of lower case English letters only. | . Solution: . class Solution { public int maxNumberOfBalloons(String text) { Map&lt;Character,Integer&gt; m = new HashMap&lt;&gt;(); for(char c : text.toCharArray()) if(c == 'b' || c == 'a' || c == 'n' || c == 'l' || c == 'o') m.put(c,m.getOrDefault(c,0)+1); if(m.size() != 5) return 0; int max = m.get('b'); for(char c : m.keySet()){ if(c == 'l' || c == 'o') max = Math.min(max, m.get(c)/2); else max = Math.min(max, m.get(c)); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-173-Maximum-Number-of-Balloons/",
    "relUrl": "/problem-173-Maximum-Number-of-Balloons/"
  },"161": {
    "doc": "Distance Between Bus Stops",
    "title": "Distance Between Bus Stops",
    "content": "A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n. The bus goes along both directions i.e. clockwise and counterclockwise. Return the shortest distance between the given start and destination stops. Example 1: . Input: distance = [1,2,3,4], start = 0, destination = 1 Output: 1 Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1. Example 2: . Input: distance = [1,2,3,4], start = 0, destination = 2 Output: 3 Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3. Example 3: . Input: distance = [1,2,3,4], start = 0, destination = 3 Output: 4 Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4. Constraints: . | 1 &lt;= n &lt;= 10^4 | distance.length == n | 0 &lt;= start, destination &lt; n | 0 &lt;= distance[i] &lt;= 10^4 | . Solution: . class Solution { public int distanceBetweenBusStops(int[] distance, int start, int destination) { int dist = 0; int sum = 0; if(start &gt; destination){ int t = destination; destination = start; start = t; } for(int i = 0; i&lt;distance.length; i++){ sum += distance[i]; if(i &gt;= start &amp;&amp; i &lt; destination) dist += distance[i]; } System.out.println(dist); return Math.min(dist,sum-dist); } } . ",
    "url": "https://1001anjan.github.io/problem-174-Distance-Between-Bus-Stops/",
    "relUrl": "/problem-174-Distance-Between-Bus-Stops/"
  },"162": {
    "doc": "Find Words That Can Be Formed by Characters",
    "title": "Find Words That Can Be Formed by Characters",
    "content": "You are given an array of strings words and a string chars. A string is good if it can be formed by characters from chars (each character can only be used once). Return the sum of lengths of all good strings in words. Example 1: . Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\" Output: 6 Explanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6. Example 2: . Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\" Output: 10 Explanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10. Constraints: . | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length, chars.length &lt;= 100 | words[i] and chars consist of lowercase English letters. | . Solution: . class Solution { public int countCharacters(String[] words, String chars) { int total = 0; int[] count = new int[26]; for(char c : chars.toCharArray()) count[c-'a']++; for(String str : words){ int[] temp = new int[26]; for(char c : str.toCharArray()) temp[c-'a']++; int i = 0; for(; i &lt; 26; i++) if(count[i]&lt;temp[i]) break; if(i == 26) total += str.length(); } return total; } } . ",
    "url": "https://1001anjan.github.io/problem-175-Distance-Between-Bus-Stops/",
    "relUrl": "/problem-175-Distance-Between-Bus-Stops/"
  },"163": {
    "doc": "N-th Tribonacci Number",
    "title": "N-th Tribonacci Number",
    "content": "The Tribonacci sequence Tn is defined as follows: . T0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0. Given n, return the value of Tn. Example 1: . Input: n = 4 Output: 4 Explanation: T_3 = 0 + 1 + 1 = 2 T_4 = 1 + 1 + 2 = 4 . Example 2: . Input: n = 25 Output: 1389537 . Constraints: . | 0 &lt;= n &lt;= 37 | The answer is guaranteed to fit within a 32-bit integer, ie. answer &lt;= 2^31 - 1. | . Solution: . class Solution { public int tribonacci(int n) { int[] m = new int[38]; return tribonacci(n,m); } public int tribonacci(int n, int[] m) { if(n == 0) return 0; if(n == 1) return 1; if(n == 2) return 1; int t1, t2, t3; if(m[n-1] == 0) t1 = tribonacci(n-1, m); else t1 = m[n-1]; if(m[n-2] == 0) t2 = tribonacci(n-2, m); else t2 = m[n-2]; if(m[n-3] == 0) t3 = tribonacci(n-3, m); else t3 = m[n-3]; m[n] = t1 + t2 + t3; return m[n]; } } . ",
    "url": "https://1001anjan.github.io/problem-176-N-th-Tribonacci-Number/",
    "relUrl": "/problem-176-N-th-Tribonacci-Number/"
  },"164": {
    "doc": "Number of Equivalent Domino Pairs",
    "title": "Number of Equivalent Domino Pairs",
    "content": "Given a list of dominoes, dominoes[i] = [a, b] is equivalent to dominoes[j] = [c, d] if and only if either (a == c and b == d), or (a == d and b == c) - that is, one domino can be rotated to be equal to another domino. Return the number of pairs (i, j) for which 0 &lt;= i &lt; j &lt; dominoes.length, and dominoes[i] is equivalent to dominoes[j]. Example 1: . Input: dominoes = [[1,2],[2,1],[3,4],[5,6]] Output: 1 . Example 2: . Input: dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]] Output: 3 . Constraints: . | 1 &lt;= dominoes.length &lt;= 4 * 104 | dominoes[i].length == 2 | 1 &lt;= dominoes[i][j] &lt;= 9 | . Solution: . class Solution { public int numEquivDominoPairs(int[][] dominoes) { int count = 0; Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;(); for(int i = 0; i &lt; dominoes.length ; i++){ int max = Math.max(dominoes[i][0],dominoes[i][1]); int min = Math.min(dominoes[i][0],dominoes[i][1]); int key = max*10 + min; count += m.getOrDefault(key,0); m.put(key, m.getOrDefault(key,0)+1); } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-177-Number-of-Equivalent-Domino-Pairs/",
    "relUrl": "/problem-177-Number-of-Equivalent-Domino-Pairs/"
  },"165": {
    "doc": "Relative Sort Array",
    "title": "Relative Sort Array",
    "content": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order. Example 1: . Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] . Example 2: . Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6] Output: [22,28,8,6,17,44] . Constraints: . | 1 &lt;= arr1.length, arr2.length &lt;= 1000 | 0 &lt;= arr1[i], arr2[i] &lt;= 1000 | All the elements of arr2 are distinct. | Each arr2[i] is in arr1. | . Solution: . class Solution { public int[] relativeSortArray(int[] arr1, int[] arr2) { Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;(); int[] ans = new int[arr1.length]; Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); for(int n : arr1) m.put(n,m.getOrDefault(n,0)+1); int i = 0; for(int n : arr2){ s.add(n); for(int j = 1; j&lt;= m.get(n); j++) ans[i++] = n; } Arrays.sort(arr1); for(int n : arr1){ if(!s.contains(n)) ans[i++] = n; } return ans; } } . Time-complexity O(n) . class Solution{ public int[] relativeSortArray(int[] arr1, int[] arr2) { int j=0; int[] freq=new int[100000]; int[] ans=new int[arr1.length]; for(int i:arr1){ freq[i]++; } for(int i:arr2){ while(freq[i]!=0){ ans[j++]=i; freq[i]--; } } for(int i=0;i&lt;freq.length;i++){ while(freq[i]!=0){ ans[j++]=i; freq[i]--; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-178-Relative-Sort-Array/",
    "relUrl": "/problem-178-Relative-Sort-Array/"
  },"166": {
    "doc": "Print in Order",
    "title": "Print in Order",
    "content": "Suppose we have a class: . public class Foo { public void first() { print(\"first\"); } public void second() { print(\"second\"); } public void third() { print(\"third\"); } } . The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second(). Note: . We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests’ comprehensiveness. Example 1: . Input: nums = [1,2,3] Output: \"firstsecondthird\" Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output. Example 2: . Input: nums = [1,3,2] Output: \"firstsecondthird\" Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output. Constraints: . | nums is a permutation of [1, 2, 3]. | . Solution: . class Foo { private boolean first = false; private boolean second = false; private boolean third = false; public Foo(){ } public void first(Runnable printFirst) throws InterruptedException { // printFirst.run() outputs \"first\". Do not change or remove this line. printFirst.run(); first = true; } public void second(Runnable printSecond) throws InterruptedException { while (!this.first) { try { Thread.sleep(1); } catch (InterruptedException e) { } } // printSecond.run() outputs \"second\". Do not change or remove this line. printSecond.run(); this.second = true; } public void third(Runnable printThird) throws InterruptedException { while (!this.second) { try { Thread.sleep(1); } catch (InterruptedException e) { } } // printThird.run() outputs \"third\". Do not change or remove this line. printThird.run(); } } . ",
    "url": "https://1001anjan.github.io/problem-179-Print-in-Order/",
    "relUrl": "/problem-179-Print-in-Order/"
  },"167": {
    "doc": "Merge Sorted Array",
    "title": "Merge Sorted Array",
    "content": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively. Merge nums1 and nums2 into a single array sorted in non-decreasing order. The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n. Example 1: . Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2: . Input: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3: . Input: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. Constraints: . | nums1.length == m + n | nums2.length == n | 0 &lt;= m, n &lt;= 200 | 1 &lt;= m + n &lt;= 200 | -109 &lt;= nums1[i], nums2[j] &lt;= 109 | . Solution . class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { if(n == 0) return; int i = m + n - 1; n --; m --; while(n &gt;= 0){ if(m &gt;= 0 &amp;&amp; nums1[m] &gt; nums2[n]){ nums1[i] = nums1[m]; m--; }else{ nums1[i] = nums2[n]; n --; } i --; } } } . ",
    "url": "https://1001anjan.github.io/problem-18-merge-sorted-array/",
    "relUrl": "/problem-18-merge-sorted-array/"
  },"168": {
    "doc": "Valid Sudoku",
    "title": "Valid Sudoku",
    "content": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules: . Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note: . | A Sudoku board (partially filled) could be valid but is not necessarily solvable. | Only the filled cells need to be validated according to the mentioned rules. | . Example 1: . Input: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: true . Example 2: . Input: board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] Output: false Explanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid. Constraints: . | board.length == 9 | board[i].length == 9 | board[i][j] is a digit 1-9 or ‘.’. | . Solution: . class Solution { public boolean isValidSudoku(char[][] board) { Set&lt;Character&gt; row = new HashSet&lt;&gt;(); Set&lt;Character&gt; col = new HashSet&lt;&gt;(); Set&lt;Character&gt; cube = new HashSet&lt;&gt;(); for(int i = 0; i &lt; 9; i++){ row.clear(); col.clear(); cube.clear(); for(int j = 0; j &lt; 9; j++){ if(board[i][j] != '.' &amp;&amp; !row.add(board[i][j])) return false; if(board[j][i] != '.' &amp;&amp; !col.add(board[j][i])) return false; int ci = 3*(i/3) + (j/3); int cj = 3*(i%3) + (j%3); if(board[ci][cj] != '.' &amp;&amp; !cube.add(board[ci][cj])) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-18-Valid%20Sudoku/",
    "relUrl": "/problem-18-Valid Sudoku/"
  },"169": {
    "doc": "Defanging an IP Address",
    "title": "Defanging an IP Address",
    "content": "Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period “.” with “[.]”. Example 1: . Input: address = \"1.1.1.1\" Output: \"1[.]1[.]1[.]1\" . Example 2: . Input: address = \"255.100.50.0\" Output: \"255[.]100[.]50[.]0\" . Constraints: . | The given address is a valid IPv4 address. | . Solution: . class Solution { public String defangIPaddr(String address) { StringBuilder sb = new StringBuilder(); for(char c : address.toCharArray()){ if(c == '.') sb.append(\"[.]\"); else sb.append(String.valueOf(c)); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-180-Defanging-an-IP-Address/",
    "relUrl": "/problem-180-Defanging-an-IP-Address/"
  },"170": {
    "doc": "Distribute Candies to People",
    "title": "Distribute Candies to People",
    "content": "We distribute some number of candies, to a row of n = num_people people in the following way: . We then give 1 candy to the first person, 2 candies to the second person, and so on until we give n candies to the last person. Then, we go back to the start of the row, giving n + 1 candies to the first person, n + 2 candies to the second person, and so on until we give 2 * n candies to the last person. This process repeats (with us giving one more candy each time, and moving to the start of the row after we reach the end) until we run out of candies. The last person will receive all of our remaining candies (not necessarily one more than the previous gift). Return an array (of length num_people and sum candies) that represents the final distribution of candies. Example 1: . Input: candies = 7, num_people = 4 Output: [1,2,3,1] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0,0]. On the third turn, ans[2] += 3, and the array is [1,2,3,0]. On the fourth turn, ans[3] += 1 (because there is only one candy left), and the final array is [1,2,3,1]. Example 2: . Input: candies = 10, num_people = 3 Output: [5,2,3] Explanation: On the first turn, ans[0] += 1, and the array is [1,0,0]. On the second turn, ans[1] += 2, and the array is [1,2,0]. On the third turn, ans[2] += 3, and the array is [1,2,3]. On the fourth turn, ans[0] += 4, and the final array is [5,2,3]. Constraints: . | 1 &lt;= candies &lt;= 10^9 | 1 &lt;= num_people &lt;= 1000 | . Solution: . class Solution { public int[] distributeCandies(int candies, int num_people) { int[] ans = new int[num_people]; int i = 0; int d = 1; while(candies &gt; 0){ ans[i%num_people] += d; i++; candies -= d; d++; if(d&gt;candies){ d=candies; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-181-Distribute-Candies-to-People/",
    "relUrl": "/problem-181-Distribute-Candies-to-People/"
  },"171": {
    "doc": "Duplicate Zeros",
    "title": "Duplicate Zeros",
    "content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: . Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] . Example 2: . Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 9 | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-182-Duplicate-Zeros/",
    "relUrl": "/problem-182-Duplicate-Zeros/"
  },"172": {
    "doc": "Occurrences After Bigram",
    "title": "Occurrences After Bigram",
    "content": "Given two strings first and second, consider occurrences in some text of the form “first second third”, where second comes immediately after first, and third comes immediately after second. Return an array of all the words third for each occurrence of “first second third”. Example 1: . Input: text = \"alice is a good girl she is a good student\", first = \"a\", second = \"good\" Output: [\"girl\",\"student\"] . Example 2: . Input: text = \"we will we will rock you\", first = \"we\", second = \"will\" Output: [\"we\",\"rock\"] . Constraints: . | 1 &lt;= text.length &lt;= 1000 | text consists of lowercase English letters and spaces. | All the words in text a separated by a single space. | 1 &lt;= first.length, second.length &lt;= 10 | first and second consist of lowercase English letters. | . Solution: . class Solution { public String[] findOcurrences(String text, String first, String second) { String[] words = text.split(\" \"); ArrayList&lt;String&gt; ans = new ArrayList&lt;&gt;(); for( int i = 0; i &lt; words.length - 2; i++){ if(words[i].equals(first) &amp;&amp; words[i+1].equals(second)) ans.add(words[i+2]); } String[] res = new String[ans.size()]; return ans.toArray(res); } } . ",
    "url": "https://1001anjan.github.io/problem-183-Occurrences-After-Bigram/",
    "relUrl": "/problem-183-Occurrences-After-Bigram/"
  },"173": {
    "doc": "Split a String in Balanced Strings",
    "title": "Split a String in Balanced Strings",
    "content": "Balanced strings are those that have an equal quantity of ‘L’ and ‘R’ characters. Given a balanced string s, split it into some number of substrings such that: . Each substring is balanced. Return the maximum number of balanced strings you can obtain. Example 1: . Input: s = \"RLRRLLRLRL\" Output: 4 Explanation: s can be split into \"RL\", \"RRLL\", \"RL\", \"RL\", each substring contains same number of 'L' and 'R'. Example 2: . Input: s = \"RLRRRLLRLL\" Output: 2 Explanation: s can be split into \"RL\", \"RRRLLRLL\", each substring contains same number of 'L' and 'R'. Note that s cannot be split into \"RL\", \"RR\", \"RL\", \"LR\", \"LL\", because the 2nd and 5th substrings are not balanced. Example 3: . Input: s = \"LLLLRRRR\" Output: 1 Explanation: s can be split into \"LLLLRRRR\". Constraints: . | 2 &lt;= s.length &lt;= 1000 | s[i] is either ‘L’ or ‘R’. | s is a balanced string. | . Solution: . class Solution { public int balancedStringSplit(String s) { int count = 0; int c = 0; for(char ch : s.toCharArray()){ if( ch == 'L') count++; else count--; if(count == 0){ c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-184-Split-a-String-in-Balanced-Strings/",
    "relUrl": "/problem-184-Split-a-String-in-Balanced-Strings/"
  },"174": {
    "doc": "String Matching in an Array",
    "title": "String Matching in an Array",
    "content": "Given an array of string words. Return all strings in words which is substring of another word in any order. String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j]. Example 1: . Input: words = [\"mass\",\"as\",\"hero\",\"superhero\"] Output: [\"as\",\"hero\"] Explanation: \"as\" is substring of \"mass\" and \"hero\" is substring of \"superhero\". [\"hero\",\"as\"] is also a valid answer. Example 2: . Input: words = [\"leetcode\",\"et\",\"code\"] Output: [\"et\",\"code\"] Explanation: \"et\", \"code\" are substring of \"leetcode\". Example 3: . Input: words = [\"blue\",\"green\",\"bu\"] Output: [] . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 30 | words[i] contains only lowercase English letters. | It’s guaranteed that words[i] will be unique. | . Solution: . class Solution { public List&lt;String&gt; stringMatching(String[] words) { List&lt;String&gt;ans = new ArrayList&lt;&gt;(); for(int i=0; i&lt;words.length; i++){ String s = words[i]; for(int j=0; j&lt;words.length; j++){ if(i == j){ continue; } if(words[j].contains(s)){ ans.add(s); break; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-185-String-Matching-in-an-Array/",
    "relUrl": "/problem-185-String-Matching-in-an-Array/"
  },"175": {
    "doc": "Find Lucky Integer in an Array",
    "title": "Find Lucky Integer in an Array",
    "content": "Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value. Return the largest lucky integer in the array. If there is no lucky integer return -1. Example 1: . Input: arr = [2,2,3,4] Output: 2 Explanation: The only lucky number in the array is 2 because frequency[2] == 2. Example 2: . Input: arr = [1,2,2,3,3,3] Output: 3 Explanation: 1, 2 and 3 are all lucky numbers, return the largest of them. Example 3: . Input: arr = [2,2,2,3,3] Output: -1 Explanation: There are no lucky numbers in the array. Constraints: . | 1 &lt;= arr.length &lt;= 500 | 1 &lt;= arr[i] &lt;= 500 | . Solution: . class Solution { public int findLucky(int[] arr) { int [] count = new int[501]; for(int n : arr) count[n]++; for(int i = 500; i&gt;=1; i--){ if(i == count[i]) return i; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-186-Find-Lucky-Integer-in-an-Array/",
    "relUrl": "/problem-186-Find-Lucky-Integer-in-an-Array/"
  },"176": {
    "doc": "Find the Distance Value Between Two Arrays",
    "title": "Find the Distance Value Between Two Arrays",
    "content": "Given two integer arrays arr1 and arr2, and the integer d, return the distance value between the two arrays. | The distance value is defined as the number of elements arr1[i] such that there is not any element arr2[j] where | arr1[i]-arr2[j] | &lt;= d. | . Example 1: . Input: arr1 = [4,5,8], arr2 = [10,9,1,8], d = 2 Output: 2 Explanation: For arr1[0]=4 we have: |4-10|=6 &gt; d=2 |4-9|=5 &gt; d=2 |4-1|=3 &gt; d=2 |4-8|=4 &gt; d=2 For arr1[1]=5 we have: |5-10|=5 &gt; d=2 |5-9|=4 &gt; d=2 |5-1|=4 &gt; d=2 |5-8|=3 &gt; d=2 For arr1[2]=8 we have: |8-10|=2 &lt;= d=2 |8-9|=1 &lt;= d=2 |8-1|=7 &gt; d=2 |8-8|=0 &lt;= d=2 . Example 2: . Input: arr1 = [1,4,2,3], arr2 = [-4,-3,6,10,20,30], d = 3 Output: 2 . Example 3: . Input: arr1 = [2,1,100,3], arr2 = [-5,-2,10,-3,7], d = 6 Output: 1 . Constraints: . | 1 &lt;= arr1.length, arr2.length &lt;= 500 | -1000 &lt;= arr1[i], arr2[j] &lt;= 1000 | 0 &lt;= d &lt;= 100 | . Solution: . class Solution { public int findTheDistanceValue(int[] arr1, int[] arr2, int d) { Arrays.sort(arr2); int count = 0; for(int i=0;i&lt;arr1.length;i++) if(distance(arr2, arr1[i], d)) count++; return count; } public boolean distance(int [] arr, int k, int d) { int start = 0, last = arr.length-1; while(start&lt;=last) { int mid = start + (last - start)/2; int diff = Math.abs(arr[mid] - k); if(diff &lt;= d) return false; else if(arr[mid] &gt; k) last = mid - 1; else start = mid + 1; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-187-Find-the-Distance-Value-Between-Two-Arrays/",
    "relUrl": "/problem-187-Find-the-Distance-Value-Between-Two-Arrays/"
  },"177": {
    "doc": "Shift 2D Grid",
    "title": "Shift 2D Grid",
    "content": "Given a 2D grid of size m x n and an integer k. You need to shift the grid k times. In one shift operation: . | Element at grid[i][j] moves to grid[i][j + 1]. | Element at grid[i][n - 1] moves to grid[i + 1][0]. | Element at grid[m - 1][n - 1] moves to grid[0][0]. | Return the 2D grid after applying shift operation k times. | . Example 1: . Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 Output: [[9,1,2],[3,4,5],[6,7,8]] . Example 2: . Input: grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4 Output: [[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]] . Example 3: . Input: grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9 Output: [[1,2,3],[4,5,6],[7,8,9]] . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m &lt;= 50 | 1 &lt;= n &lt;= 50 | -1000 &lt;= grid[i][j] &lt;= 1000 | 0 &lt;= k &lt;= 100 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; shiftGrid(int[][] grid, int k) { int[][] ans = new int[grid.length][grid[0].length]; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[0].length; j++) { int newCol = (j + k) % grid[0].length; int newRow = (i + (j + k) / grid[0].length) % grid.length; ans[newRow][newCol] = grid[i][j]; } } return (List) Arrays.asList(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-188-Shift-2D-Grid/",
    "relUrl": "/problem-188-Shift-2D-Grid/"
  },"178": {
    "doc": "Subtract the Product and Sum of Digits of an Integer",
    "title": "Subtract the Product and Sum of Digits of an Integer",
    "content": "Given an integer number n, return the difference between the product of its digits and the sum of its digits. Example 1: . Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 . Example 2: . Input: n = 4421 Output: 21 Explanation: Product of digits = 4 * 4 * 2 * 1 = 32 Sum of digits = 4 + 4 + 2 + 1 = 11 Result = 32 - 11 = 21 . Constraints: . | 1 &lt;= n &lt;= 10^5 | . Solution: . class Solution { public int subtractProductAndSum(int n) { int p = 1; int s = 0; while(n&gt;0){ int d = n%10; p *= d; s += d; n = n/10; } return p - s; } } . ",
    "url": "https://1001anjan.github.io/problem-189-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/",
    "relUrl": "/problem-189-Subtract-the-Product-and-Sum-of-Digits-of-an-Integer/"
  },"179": {
    "doc": "Binary Tree Inorder Traversal",
    "title": "Binary Tree Inorder Traversal",
    "content": "Given the root of a binary tree, return the inorder traversal of its nodes’ values. Example 1: . Input: root = [1,null,2,3] Output: [1,3,2] . Example 2: . Input: root = [] Output: [] . Example 3: . Input: root = [1] Output: [1] . Constraints: . | The number of nodes in the tree is in the range [0, 100]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { List&lt;Integer&gt; val = new ArrayList(); public List&lt;Integer&gt; inorderTraversal(TreeNode root) { if(root == null) return new ArrayList&lt;Integer&gt;(); inorderTraversal(root.left); val.add(root.val); inorderTraversal(root.right); return val; } } . ",
    "url": "https://1001anjan.github.io/problem-19-Binary-Tree-Inorder-Traversal/",
    "relUrl": "/problem-19-Binary-Tree-Inorder-Traversal/"
  },"180": {
    "doc": "Count and Say",
    "title": "Count and Say",
    "content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula: . | countAndSay(1) = “1” | countAndSay(n) is the way you would “say” the digit string from countAndSay(n-1), which is then converted into a different digit string. | To determine how you “say” a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit. | . For example, the saying and conversion for digit string “3322251”: Given a positive integer n, return the nth term of the count-and-say sequence. Example 1: . Input: n = 1 Output: \"1\" Explanation: This is the base case. Example 2: . Input: n = 4 Output: \"1211\" Explanation: countAndSay(1) = \"1\" countAndSay(2) = say \"1\" = one 1 = \"11\" countAndSay(3) = say \"11\" = two 1's = \"21\" countAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" . Constraints: . | 1 &lt;= n &lt;= 30 | . Solution: . class Solution { public String countAndSay(int n) { if(n == 1) return \"1\"; String dp = \"1\"; for(int i = 2; i &lt;= n; i++){ dp = process(n, dp); } return dp; } public String process(int n, String s){ int len = s.length(); StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; len; ){ int c = 0; int j = i; char ch = s.charAt(i); while(j &lt; len){ if(ch == s.charAt(j)){ j++; c++; }else break; } i = j; sb.append(c).append(ch); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-19-Count%20and%20Say/",
    "relUrl": "/problem-19-Count and Say/"
  },"181": {
    "doc": "Element Appearing More Than 25% In Sorted Array",
    "title": "Element Appearing More Than 25% In Sorted Array",
    "content": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer. Example 1: . Input: arr = [1,2,2,6,6,6,6,7,10] Output: 6 . Example 2: . Input: arr = [1,1] Output: 1 . Constraints: . | 1 &lt;= arr.length &lt;= 104 | 0 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public int findSpecialInteger(int[] arr) { int currSum = 1; for(int i = 1; i &lt; arr.length; i++){ if(arr[i-1] == arr[i]) currSum ++; else{ if(currSum &gt; arr.length/4) return arr[i-1]; currSum = 1; } } if(currSum &gt; arr.length/4) return arr[arr.length-1]; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-190-Element-Appearing-More-Than-25%25-In-Sorted-Array/",
    "relUrl": "/problem-190-Element-Appearing-More-Than-25%-In-Sorted-Array/"
  },"182": {
    "doc": "Convert Binary Number in a Linked List to Integer",
    "title": "Convert Binary Number in a Linked List to Integer",
    "content": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number. Return the decimal value of the number in the linked list. The most significant bit is at the head of the linked list. Example 1: . Input: head = [1,0,1] Output: 5 Explanation: (101) in base 2 = (5) in base 10 . Example 2: . Input: head = [0] Output: 0 . Constraints: . | The Linked List is not empty. | Number of nodes will not exceed 30. | Each node’s value is either 0 or 1. | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public int getDecimalValue(ListNode head) { int sum = 0; while(head != null){ sum = sum*2 + head.val; head = head.next; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-191-Convert-Binary-Number-in-a-Linked-List-to-Integer/",
    "relUrl": "/problem-191-Convert-Binary-Number-in-a-Linked-List-to-Integer/"
  },"183": {
    "doc": "Find Numbers with Even Number of Digits",
    "title": "Find Numbers with Even Number of Digits",
    "content": "Given an array nums of integers, return how many of them contain an even number of digits. Example 1: . Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits). Therefore only 12 and 7896 contain an even number of digits. Example 2: . Input: nums = [555,901,482,1771] Output: 1 Explanation: Only 1771 contains an even number of digits. Constraints: . | 1 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public int findNumbers(int[] nums) { int count = 0; for(int n : nums){ String s = String.valueOf(n); if(s.length()%2 == 0) count++; } return count; } } . Faster execution . class Solution { public int findNumbers(int[] nums) { int result=0; for(int i=0; i &lt; nums.length;i++){ if (CalculateDigitsOfNumber(nums[i])%2 == 0){ result++; } } return result; } public static int CalculateDigitsOfNumber(int Number){ return (int)(Math.log10(Number))+1; } } . ",
    "url": "https://1001anjan.github.io/problem-192-Find-Numbers-with-Even-Number-of-Digits/",
    "relUrl": "/problem-192-Find-Numbers-with-Even-Number-of-Digits/"
  },"184": {
    "doc": "Replace Elements with Greatest Element on Right Side",
    "title": "Replace Elements with The Greatest Element on Right Side",
    "content": "Given an array arr, replace every element in that array with the greatest element among the elements to its right, and replace the last element with -1. After doing so, return the array. Example 1: . Input: arr = [17,18,5,4,6,1] Output: [18,6,6,6,1,-1] Explanation: - index 0 --&gt; the greatest element to the right of index 0 is index 1 (18). - index 1 --&gt; the greatest element to the right of index 1 is index 4 (6). - index 2 --&gt; the greatest element to the right of index 2 is index 4 (6). - index 3 --&gt; the greatest element to the right of index 3 is index 4 (6). - index 4 --&gt; the greatest element to the right of index 4 is index 5 (1). - index 5 --&gt; there are no elements to the right of index 5, so we put -1. Example 2: . Input: arr = [400] Output: [-1] Explanation: There are no elements to the right of index 0. Constraints: . | 1 &lt;= arr.length &lt;= 104 | 1 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public int[] replaceElements(int[] arr) { int currMax = -1; for(int i = arr.length-1; i&gt;=0; i--){ int t = arr[i]; arr[i] = currMax; if(t&gt;currMax) currMax = t; } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/#replace-elements-with-the-greatest-element-on-right-side",
    "relUrl": "/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/#replace-elements-with-the-greatest-element-on-right-side"
  },"185": {
    "doc": "Replace Elements with Greatest Element on Right Side",
    "title": "Replace Elements with Greatest Element on Right Side",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/",
    "relUrl": "/problem-193-Replace-Elements-with-Greatest-Element-on-Right-Side/"
  },"186": {
    "doc": "Find N Unique Integers Sum up to Zero",
    "title": "Find N Unique Integers Sum up to Zero",
    "content": "Given an integer n, return any array containing n unique integers such that they add up to 0. Example 1: . Input: n = 5 Output: [-7,-1,1,3,4] Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: . Input: n = 3 Output: [-1,0,1] . Example 3: . Input: n = 1 Output: [0] . Constraints: . | 1 &lt;= n &lt;= 1000 | . Solution: . class Solution { public int[] sumZero(int n) { int[] ans = new int[n]; int k = 1; if(n%2 == 0){ for(int i = 0; i&lt;n; i++){ if(i%2 == 0) ans[i] = k; else{ ans[i] = k*-1; k++; } } }else{ ans[0] = 0; for(int i = 1; i&lt;n; i++){ if(i%2 == 0){ ans[i] = k*-1; k++; } else{ ans[i] = k; } } } return ans; } } . Other . class Solution { public int[] sumZero(int n) { int[] result = new int[n]; int start = (n/2)*-1, end = n/2, i = 0; while (start &lt; end) { result[i] = start; result[n - i - 1] = end; ++start; --end; ++i; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-194-Find-N-Unique-Integers-Sum-up-to-Zero/",
    "relUrl": "/problem-194-Find-N-Unique-Integers-Sum-up-to-Zero/"
  },"187": {
    "doc": "Decrypt String from Alphabet to Integer Mapping",
    "title": "Decrypt String from Alphabet to Integer Mapping",
    "content": "You are given a string s formed by digits and ‘#’. We want to map s to English lowercase characters as follows: . | Characters (‘a’ to ‘i’) are represented by (‘1’ to ‘9’) respectively. | Characters (‘j’ to ‘z’) are represented by (‘10#’ to ‘26#’) respectively. Return the string formed after mapping. | . The test cases are generated so that a unique mapping will always exist. Example 1: . Input: s = \"10#11#12\" Output: \"jkab\" Explanation: \"j\" -&gt; \"10#\" , \"k\" -&gt; \"11#\" , \"a\" -&gt; \"1\" , \"b\" -&gt; \"2\". Example 2: . Input: s = \"1326#\" Output: \"acz\" . Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of digits and the ‘#’ letter. | s will be a valid string such that mapping is always possible. | . Solution: . class Solution { public String freqAlphabets(String s) { StringBuilder sb = new StringBuilder(); for(int i = s.length()-1; i &gt;= 0; i--){ if(s.charAt(i) != '#'){ sb.append(Character.toString(s.charAt(i) + 48 )); }else{ sb.append(Character.toString(Integer.parseInt(s.substring(i-2,i)) + 96)); i -= 2; } } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-195-Decrypt-String-from-Alphabet-to-Integer-Mapping/",
    "relUrl": "/problem-195-Decrypt-String-from-Alphabet-to-Integer-Mapping/"
  },"188": {
    "doc": "Decompress Run-Length Encoded List",
    "title": "Decompress Run-Length Encoded List",
    "content": "We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2i], nums[2i+1]] (with i &gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. Example 1: . Input: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. Example 2: . Input: nums = [1,1,2,3] Output: [1,3,3] . Constraints: . | 2 &lt;= nums.length &lt;= 100 | nums.length % 2 == 0 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] decompressRLElist(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt;= nums.length-2; i = i+2){ while(nums[i] &gt; 0){ ans.add(nums[i+1]); nums[i]--; } } int[] res = new int[ans.size()]; int i = 0; for(int n : ans) res[i++] = n; return res; } } . Faster approach . class Solution { public int[] decompressRLElist(int[] nums) { int size=0; for(int i=0;i&lt;nums.length;i+=2) size+=nums[i]; int arr[] = new int[size]; int j=0; for(int i=0; i&lt;nums.length; i+=2){ while(nums[i]&gt;0){ arr[j] = nums[i+1]; j++; nums[i]--; } } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-196-Decompress-Run-Length-Encoded-List/",
    "relUrl": "/problem-196-Decompress-Run-Length-Encoded-List/"
  },"189": {
    "doc": "Convert Integer to the Sum of Two No-Zero Integers",
    "title": "Convert Integer to the Sum of Two No-Zero Integers",
    "content": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation. Given an integer n, return a list of two integers [A, B] where: . A and B are No-Zero integers. A + B = n The test cases are generated so that there is at least one valid solution. If there are many valid solutions you can return any of them. Example 1: . Input: n = 2 Output: [1,1] Explanation: A = 1, B = 1. A + B = n and both A and B do not contain any 0 in their decimal representation. Example 2: . Input: n = 11 Output: [2,9] . Constraints: . | 2 &lt;= n &lt;= 104 | . Solution: . class Solution { public int[] getNoZeroIntegers(int n) { int s = 1; int e = n-1; while(s&lt;=e){ if(checkNoZeroInteger(s) &amp;&amp; checkNoZeroInteger(e)) return new int[]{s,e}; s++; e--; } throw null; } public boolean checkNoZeroInteger(int n){ while(n&gt;0){ if(n%10 == 0) return false; n = n/10; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-197-Convert-Integer-to-the-Sum-of-Two-No-Zero%20Integers/",
    "relUrl": "/problem-197-Convert-Integer-to-the-Sum-of-Two-No-Zero Integers/"
  },"190": {
    "doc": "Maximum 69 Number",
    "title": "Maximum 69 Number",
    "content": "You are given a positive integer num consisting only of digits 6 and 9. Return the maximum number you can get by changing at most one digit (6 becomes 9, and 9 becomes 6). Example 1: . Input: num = 9669 Output: 9969 Explanation: Changing the first digit results in 6669. Changing the second digit results in 9969. Changing the third digit results in 9699. Changing the fourth digit results in 9666. The maximum number is 9969. Example 2: . Input: num = 9996 Output: 9999 Explanation: Changing the last digit 6 to 9 results in the maximum number. Example 3: . Input: num = 9999 Output: 9999 Explanation: It is better not to apply any change. Constraints: . | 1 &lt;= num &lt;= 104 | num consists of only 6 and 9 digits. | . Solution: . class Solution { public int maximum69Number (int num) { String s = String.valueOf(num); StringBuilder sb = new StringBuilder(); boolean f = true; for(char c : s.toCharArray()){ if(c == '6' &amp;&amp; f){ sb.append(\"9\"); f = false; } else sb.append(String.valueOf(c)); } return Integer.parseInt(sb.toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-198-Maximum-69-Number/",
    "relUrl": "/problem-198-Maximum-69-Number/"
  },"191": {
    "doc": "Rank Transform of an Array",
    "title": "Rank Transform of an Array",
    "content": "Given an array of integers arr, replace each element with its rank. The rank represents how large the element is. The rank has the following rules: . Rank is an integer starting from 1. The larger the element, the larger the rank. If two elements are equal, their rank must be the same. Rank should be as small as possible. Example 1: . Input: arr = [40,10,20,30] Output: [4,1,2,3] Explanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest. Example 2: . Input: arr = [100,100,100] Output: [1,1,1] Explanation: Same elements share the same rank. Example 3: . Input: arr = [37,12,28,9,100,56,80,5,12] Output: [5,3,4,2,8,6,7,1,3] . Constraints: . | 0 &lt;= arr.length &lt;= 105 | -109 &lt;= arr[i] &lt;= 109 | . Solution: . class Solution { public int[] arrayRankTransform(int[] arr) { Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int n : arr) s.add(n); Integer[] temp = new Integer[s.size()]; s.toArray(temp); Arrays.sort(temp); for(int j = 0; j&lt;arr.length; j++){ arr[j] = binarySearch(temp,arr[j]) + 1; } return arr; } public int binarySearch(Integer[] arr, int v){ int s = 0; int e = arr.length - 1; while(s&lt;=e){ int mid = (e+s)/2; if(arr[mid] == v) return mid; if(arr[mid]&gt;v) e = mid - 1; else s = mid + 1; } return -1; } } . Same Time Complexity but faster . class Solution { public int[] arrayRankTransform(int[] arr) { int[]res=new int[arr.length]; for(int i=0;i&lt;arr.length;i++){ res[i]=arr[i]; } Arrays.sort(arr); HashMap&lt;Integer,Integer&gt;h1=new HashMap(); int x=0; for(int i=0;i&lt;arr.length;i++){ if(!h1.containsKey(arr[i])){ x++; h1.put(arr[i],x); } } int ans[]=new int[arr.length]; for(int i=0;i&lt;arr.length;i++){ ans[i]=h1.get(res[i]); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-199-Rank-Transform-of-an-Array/",
    "relUrl": "/problem-199-Rank-Transform-of-an-Array/"
  },"192": {
    "doc": "Add Two Numbers",
    "title": "Add Two Numbers",
    "content": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example 1: . Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2: . Input: l1 = [0], l2 = [0] Output: [0] . Example 3: . Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] . Constraints: . | The number of nodes in each linked list is in the range [1, 100]. | 0 &lt;= Node.val &lt;= 9 | It is guaranteed that the list represents a number that does not have leading zeros. | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode resultList, ptr; int c = 0; // creating first node ListNode newNode = new ListNode((l1.val + l2.val)%10); c = (l1.val + l2.val) / 10; resultList = ptr = newNode; l1 = l1.next; l2 = l2.next; while(l1 != null &amp;&amp; l2 != null){ newNode = new ListNode((l1.val + l2.val + c)%10); c = (l1.val + l2.val + c) / 10; ptr.next = newNode; ptr = newNode; l1 = l1.next; l2 = l2.next; } while(l1 != null){ newNode = new ListNode((l1.val + c)%10); c = (l1.val + c) / 10; ptr.next = newNode; ptr = newNode; l1 = l1.next; } while(l2 != null){ newNode = new ListNode((l2.val + c)%10); c = (l2.val + c) / 10; ptr.next = newNode; ptr = newNode; l2 = l2.next; } if(c &gt; 0){ newNode = new ListNode(c); ptr.next = newNode; } return resultList; } } . ",
    "url": "https://1001anjan.github.io/problem-2-Add%20Two%20Numbers/",
    "relUrl": "/problem-2-Add Two Numbers/"
  },"193": {
    "doc": "Palindrome Number",
    "title": "2. Palindrome Number",
    "content": "Given an integer x, return true if x is palindrome integer. An integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not. Example 1: . Input: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2: . Input: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: . Input: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. Constraints: . -231 &lt;= x &lt;= 231 - 1 . Solution . class Solution { public boolean isPalindrome(int x) { if(x &lt; 0) return false; int rev = 0; int original = x; while(x &gt; 0){ rev = rev*10 + x%10; x = x/10; } return rev == original? true : false; } } . Complexity Analysis: . | Time complexity : O(log10(n)). We divided the input by 10 for every iteration, so the time complexity is O(log10(n)) . | Space complexity : O(1)O(1). | . ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/problem-2-Palindrome-Number/#2-palindrome-number",
    "relUrl": "/docs/data-structure/ds-easy-set-1/problem-2-Palindrome-Number/#2-palindrome-number"
  },"194": {
    "doc": "Palindrome Number",
    "title": "Palindrome Number",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/problem-2-Palindrome-Number/",
    "relUrl": "/docs/data-structure/ds-easy-set-1/problem-2-Palindrome-Number/"
  },"195": {
    "doc": "Combination Sum",
    "title": "Combination Sum",
    "content": "Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different. The test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input. Example 1: . Input: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. Example 2: . Input: candidates = [2,3,5], target = 8 Output: [[2,2,2,2],[2,3,3],[3,5]] . Example 3: . Input: candidates = [2], target = 1 Output: [] . Constraints: . | 1 &lt;= candidates.length &lt;= 30 | 2 &lt;= candidates[i] &lt;= 40 | All elements of candidates are distinct. | 1 &lt;= target &lt;= 40 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(candidates); for(int i = 0; i &lt; candidates.length; i++){ process(candidates, i, candidates.length - 1, target - candidates[i], ans, new ArrayList&lt;Integer&gt;(Arrays.asList(candidates[i]))); } return ans; } public void process(int[] arr, int currentIndex, int searchIndex, int target, List&lt;List&lt;Integer&gt;&gt; list, List&lt;Integer&gt; elist){ if(searchIndex &lt; 0) return; if(target == 0){ list.add(elist); } for(int i = searchIndex; i &gt;= currentIndex; i--){ if(target == arr[i]){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(elist); l.add(arr[i]); list.add(l); } if(target &gt; arr[i]){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(elist); l.add(arr[i]); process(arr,currentIndex, i,target - arr[i], list,l); } } } } . public class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) { //special case List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(candidates == null || candidates.length == 0) return res; Arrays.sort(candidates); help(res, new ArrayList&lt;Integer&gt;(), target, 0, candidates); return res; } public void help(List&lt;List&lt;Integer&gt;&gt; res, ArrayList&lt;Integer&gt; tmp, int target, int start, int [] candidates) { if(target == 0) { res.add(new ArrayList&lt;Integer&gt; (tmp)); return; } else { for(int i = start;i&lt;candidates.length;i++) { if(i &gt; start &amp;&amp; candidates[i] == candidates[i-1]) continue; if(target &gt;= candidates[i]) { tmp.add(new Integer(candidates[i])); help(res, tmp, target - candidates[i],i,candidates); tmp.remove(tmp.size()-1); } } } } } . ",
    "url": "https://1001anjan.github.io/problem-20-Combination%20Sum/",
    "relUrl": "/problem-20-Combination Sum/"
  },"196": {
    "doc": "Same Tree",
    "title": "Same Tree",
    "content": "Given the roots of two binary trees p and q, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical, and the nodes have the same value. Example 1: . Input: p = [1,2,3], q = [1,2,3] Output: true . Example 2 . Input: p = [1,2], q = [1,null,2] Output: false . Example 3: . Input: p = [1,2,1], q = [1,1,2] Output: false . Constraints: . | The number of nodes in both trees is in the range [0, 100]. | -104 &lt;= Node.val &lt;= 104 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if(p == null &amp;&amp; q == null) return true; if(p != null &amp;&amp; q == null) return false; if(p == null &amp;&amp; q != null) return false; if(p.val != q.val) return false; return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right); } } . ",
    "url": "https://1001anjan.github.io/problem-20-Same-Tree/",
    "relUrl": "/problem-20-Same-Tree/"
  },"197": {
    "doc": "Remove Palindromic Subsequences",
    "title": "Remove Palindromic Subsequences",
    "content": "You are given a string s consisting only of letters ‘a’ and ‘b’. In a single step you can remove one palindromic subsequence from s. Return the minimum number of steps to make the given string empty. A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. Note that a subsequence does not necessarily need to be contiguous. A string is called palindrome if is one that reads the same backward as well as forward. Example 1: . Input: s = \"ababa\" Output: 1 Explanation: s is already a palindrome, so its entirety can be removed in a single step. Example 2: . Input: s = \"abb\" Output: 2 Explanation: \"abb\" -&gt; \"bb\" -&gt; \"\". Remove palindromic subsequence \"a\" then \"bb\". Example 3: . Input: s = \"baabb\" Output: 2 Explanation: \"baabb\" -&gt; \"b\" -&gt; \"\". Remove palindromic subsequence \"baab\" then \"b\". Constraints: . | 1 &lt;= s.length &lt;= 1000 | s[i] is either ‘a’ or ‘b’. | . Solution: . class Solution { public int removePalindromeSub(String s) { StringBuilder sb = new StringBuilder(); sb.append(s); sb.reverse(); return sb.toString().equals(s) ? 1 : 2; } } . ",
    "url": "https://1001anjan.github.io/problem-200-Remove-Palindromic-Subsequences/",
    "relUrl": "/problem-200-Remove-Palindromic-Subsequences/"
  },"198": {
    "doc": "The K Weakest Rows in a Matrix",
    "title": "The K Weakest Rows in a Matrix",
    "content": "You are given an m x n binary matrix mat of 1’s (representing soldiers) and 0’s (representing civilians). The soldiers are positioned in front of the civilians. That is, all the 1’s will appear to the left of all the 0’s in each row. A row i is weaker than a row j if one of the following is true: . | The number of soldiers in row i is less than the number of soldiers in row j. | Both rows have the same number of soldiers and i &lt; j. | Return the indices of the k weakest rows in the matrix ordered from weakest to strongest. | . Example 1: . Input: mat = [[1,1,0,0,0], [1,1,1,1,0], [1,0,0,0,0], [1,1,0,0,0], [1,1,1,1,1]], k = 3 Output: [2,0,3] Explanation: The number of soldiers in each row is: - Row 0: 2 - Row 1: 4 - Row 2: 1 - Row 3: 2 - Row 4: 5 The rows ordered from weakest to strongest are [2,0,3,1,4]. Example 2: . Input: mat = [[1,0,0,0], [1,1,1,1], [1,0,0,0], [1,0,0,0]], k = 2 Output: [0,2] Explanation: The number of soldiers in each row is: - Row 0: 1 - Row 1: 4 - Row 2: 1 - Row 3: 1 The rows ordered from weakest to strongest are [0,2,3,1]. Constraints: . | m == mat.length | n == mat[i].length | 2 &lt;= n, m &lt;= 100 | 1 &lt;= k &lt;= m | matrix[i][j] is either 0 or 1. | . Solution: . class Solution { public int[] kWeakestRows(int[][] mat, int k) { int[] ans = new int[k]; int[][] count = new int[mat.length][2]; for(int i=0; i&lt;mat.length; i++){ count[i][1] = countValueOne(mat[i]); count[i][0] = i; } Arrays.sort(count, (a,b)-&gt;(a[1]-b[1])); for(int i=0; i&lt;k; i++) ans[i] = count[i][0]; return ans; } public int countValueOne(int[] arr){ int count = 0; for(int n: arr){ if(n == 1) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-201-The-K-Weakest-Rows-in-a-Matrix/",
    "relUrl": "/problem-201-The-K-Weakest-Rows-in-a-Matrix/"
  },"199": {
    "doc": "Number of Steps to Reduce a Number to Zero",
    "title": "Number of Steps to Reduce a Number to Zero",
    "content": "Given an integer num, return the number of steps to reduce it to zero. In one step, if the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Example 1: . Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3. Step 4) 3 is odd; subtract 1 and obtain 2. Step 5) 2 is even; divide by 2 and obtain 1. Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: . Input: num = 8 Output: 4 Explanation: Step 1) 8 is even; divide by 2 and obtain 4. Step 2) 4 is even; divide by 2 and obtain 2. Step 3) 2 is even; divide by 2 and obtain 1. Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: . Input: num = 123 Output: 12 . Constraints: . | 0 &lt;= num &lt;= 106 | . Solution: . class Solution { public int numberOfSteps(int n) { int step = 0; while(n&gt;0){ if(n%2 == 0) n = n/2; else n = n -1; step++; } return step; } } . ",
    "url": "https://1001anjan.github.io/problem-202-Number-of-Steps-to-Reduce-a-Number-to-Zero/",
    "relUrl": "/problem-202-Number-of-Steps-to-Reduce-a-Number-to-Zero/"
  },"200": {
    "doc": "Check If N and Its Double Exist",
    "title": "Check If N and Its Double Exist",
    "content": "Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M). More formally check if there exists two indices i and j such that : . | i != j | 0 &lt;= i, j &lt; arr.length | arr[i] == 2 * arr[j] | . Example 1: . Input: arr = [10,2,5,3] Output: true Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5. Example 2: . Input: arr = [7,1,14,11] Output: true Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7. Example 3: . Input: arr = [3,1,7,11] Output: false Explanation: In this case does not exist N and M, such that N = 2 * M. Constraints: . | 2 &lt;= arr.length &lt;= 500 | -10^3 &lt;= arr[i] &lt;= 10^3 | . Solution: . Time Complexity O(nLogN) Space: O(1); . class Solution { public boolean checkIfExist(int[] arr) { Arrays.sort(arr); for(int i = 0; i&lt;arr.length; i++){ if(binarySearch(arr, arr[i]*2, i)) return true; } return false; } public boolean binarySearch(int[] arr, int val, int index){ int s = 0; int e = arr.length - 1; while(s &lt;= e){ int mid = (s + e)/2; if(arr[mid] == val &amp;&amp; index != mid) return true; if(arr[mid] &gt; val) e = mid - 1; else s = mid + 1; } return false; } } . time Complexity: O(n) Space: O(n) . class Solution { public boolean checkIfExist(int[] arr) { HashMap&lt;Double,Integer&gt; map = new HashMap&lt;&gt;(); for(int i:arr) { double temp = i; if(map.containsKey(temp*2)) return true; else if(map.containsKey(temp/2)) return true; map.put(temp,1); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-203-Check-If-N-and-Its-Double-Exist/",
    "relUrl": "/problem-203-Check-If-N-and-Its-Double-Exist/"
  },"201": {
    "doc": "Count Negative Numbers in a Sorted Matrix",
    "title": "Count Negative Numbers in a Sorted Matrix",
    "content": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid. Example 1: . Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]] Output: 8 Explanation: There are 8 negatives number in the matrix. Example 2: . Input: grid = [[3,2],[1,0]] Output: 0 . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m, n &lt;= 100 | -100 &lt;= grid[i][j] &lt;= 100 | . Follow up: Could you find an O(n + m) solution? . Solution: . Time Complexity O(m*n) . class Solution { public int countNegatives(int[][] grid) { int count = 0; for(int i = 0; i &lt;grid.length; i++){ for(int j = grid[i].length - 1; j&gt;=0; j--){ if(grid[i][j] &lt; 0) count++; else break; } } return count; } } . Time Complexity O(m*logN) but actually consumed more time than first approach . class Solution { public int countNegatives(int[][] grid) { int count = 0; for(int i = 0; i &lt;grid.length; i++){ if(grid[i][grid[i].length - 1] &lt; 0) count += grid[i].length - binarySearch(grid[i]); System.out.println(count); } return count; } public int binarySearch(int[] arr){ int s = 0; int e = arr.length - 1; while(s &lt;= e){ int mid = (s+e)/2; if(mid == 0 &amp;&amp; arr[mid] &lt; 0) return mid; if(mid == arr.length - 1) return mid; if(mid == 0 &amp;&amp; arr[mid] &gt;= 0) s = mid + 1; else if(arr[mid - 1]&gt;=0 &amp;&amp; arr[mid] &lt; 0) return mid; else if(arr[mid - 1] &lt; 0) e = mid - 1; else s = mid + 1; } throw null; } } . Time Complexity: O(m+n) and much faster . class Solution { public int countNegatives(int[][] grid) { int m = grid.length; int n = grid[0].length; int i = 0; int j = n-1; int count = 0; while(i&lt;=m-1 &amp;&amp; j&gt;=0) { if(grid[i][j] &lt; 0) { count += m-i; j--; }else{ i++; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-204-Count-Negative-Numbers-in-a-Sorted-Matrix/",
    "relUrl": "/problem-204-Count-Negative-Numbers-in-a-Sorted-Matrix/"
  },"202": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "Sort Integers by The Number of 1 Bits",
    "content": "You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1’s in their binary representation and in case of two or more integers have the same number of 1’s you have to sort them in ascending order. Return the array after sorting it. Example 1: . Input: arr = [0,1,2,3,4,5,6,7,8] Output: [0,1,2,4,8,3,5,6,7] Explantion: [0] is the only integer with 0 bits. [1,2,4,8] all have 1 bit. [3,5,6] have 2 bits. [7] has 3 bits. The sorted array by bits is [0,1,2,4,8,3,5,6,7] . Example 2: . Input: arr = [1024,512,256,128,64,32,16,8,4,2,1] Output: [1,2,4,8,16,32,64,128,256,512,1024] Explantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order. Constraints: . | 1 &lt;= arr.length &lt;= 500 | 0 &lt;= arr[i] &lt;= 104 | . Solution: . class Solution { public int[] sortByBits(int[] arr) { int[][] map = new int[arr.length][2]; for(int i = 0; i &lt; arr.length; i++){ map[i][0] = arr[i]; map[i][1] = countBinaryOne(arr[i]); } Arrays.sort(map, (a,b) -&gt; { if(a[1] == b[1]) return a[0] - b[0]; return a[1] - b[1]; }); for(int i = 0; i &lt; arr.length; i++){ arr[i] = map[i][0]; } return arr; } public int countBinaryOne(int n){ int count = 0; while(n&gt;0){ if((n &amp; 1) == 1) count++; n = n &gt;&gt; 1; } return count; } } . Same time complexity but constant memory and faster execution time . class Solution { public int[] sortByBits(int[] arr) { for ( int i =0 ;i&lt; arr.length ;i++){ arr[i] += Integer.bitCount(arr[i])*10001; } Arrays.sort(arr); for ( int i =0 ;i&lt; arr.length ;i++){ arr[i] = arr[i] %10001; } return arr; } } . ",
    "url": "https://1001anjan.github.io/problem-205-Sort-Integers-by-The-Number-of-1-Bits/",
    "relUrl": "/problem-205-Sort-Integers-by-The-Number-of-1-Bits/"
  },"203": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "How Many Numbers Are Smaller Than the Current Number",
    "content": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j’s such that j != i and nums[j] &lt; nums[i]. Return the answer in an array. Example 1: . Input: nums = [8,1,2,2,3] Output: [4,0,1,1,3] Explanation: For nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). For nums[1]=1 does not exist any smaller number than it. For nums[2]=2 there exist one smaller number than it (1). For nums[3]=2 there exist one smaller number than it (1). For nums[4]=3 there exist three smaller numbers than it (1, 2 and 2). Example 2: . Input: nums = [6,5,4,8] Output: [2,1,0,3] . Example 3: . Input: nums = [7,7,7,7] Output: [0,0,0,0] . Constraints: . | 2 &lt;= nums.length &lt;= 500 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] smallerNumbersThanCurrent(int[] nums) { int[] temp = Arrays.copyOf(nums,nums.length); Arrays.sort(nums); Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); m.put(nums[0],0); int count = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i-1] != nums[i]){ m.put(nums[i],count); } count++; } for(int i = 0; i &lt; temp.length; i++) nums[i] = m.get(temp[i]); return nums; } } . class Solution { public int[] smallerNumbersThanCurrent(int[] nums) { //initiate an array to keep count of all elements in nums int[] arr = new int[101]; for(int num: nums){ arr[num]++; } //update array by cumulating sum for(int i = 1; i &lt; arr.length; i++){ arr[i] = arr[i] + arr[i-1]; } //change the nums array to number of smaller elements than the current number //the array arr keep count of elements smaller/equals to each index (element), so to find element smaller than current, look at previous index for(int i = 0; i &lt; nums.length; i++){ try{ nums[i] = arr[nums[i]-1]; } catch (ArrayIndexOutOfBoundsException e){ nums[i] = 0; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-206-How%20Many%20Numbers%20Are%20Smaller%20Than%20the%20Current%20Number/#how-many-numbers-are-smaller-than-the-current-number",
    "relUrl": "/problem-206-How Many Numbers Are Smaller Than the Current Number/#how-many-numbers-are-smaller-than-the-current-number"
  },"204": {
    "doc": "Sort Integers by The Number of 1 Bits",
    "title": "Sort Integers by The Number of 1 Bits",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-206-How%20Many%20Numbers%20Are%20Smaller%20Than%20the%20Current%20Number/",
    "relUrl": "/problem-206-How Many Numbers Are Smaller Than the Current Number/"
  },"205": {
    "doc": "Increasing Decreasing String",
    "title": "Increasing Decreasing String",
    "content": "You are given a string s. Reorder the string using the following algorithm: . | Pick the smallest character from s and append it to the result. | Pick the smallest character from s which is greater than the last appended character to the result and append it. | Repeat step 2 until you cannot pick more characters. | Pick the largest character from s and append it to the result. | Pick the largest character from s which is smaller than the last appended character to the result and append it. | Repeat step 5 until you cannot pick more characters. | Repeat the steps from 1 to 6 until you pick all characters from s. | . In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result. Return the result string after sorting s with this algorithm. Example 1: . Input: s = \"aaaabbbbcccc\" Output: \"abccbaabccba\" Explanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\" After steps 4, 5 and 6 of the first iteration, result = \"abccba\" First iteration is done. Now s = \"aabbcc\" and we go back to step 1 After steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\" After steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\" . Example 2: . Input: s = \"rat\" Output: \"art\" Explanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters. | . Solution: . class Solution { public String sortString(String s) { int[] map = new int[26]; for(char c : s.toCharArray()) { map[c - 'a']++; } StringBuilder sb = new StringBuilder(); while(sb.length() != s.length()){ for(int i = 0; i &lt; 26; i++){ if(map[i] &gt; 0){ sb.append((char)('a' + i)); map[i]--; } } for(int i = 25; i &gt;= 0; i--){ if(map[i] &gt; 0){ sb.append((char)('a' + i)); map[i]--; } } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-207-Increasing-Decreasing-String/",
    "relUrl": "/problem-207-Increasing-Decreasing-String/"
  },"206": {
    "doc": "Lucky Numbers in a Matrix",
    "title": "Lucky Numbers in a Matrix",
    "content": "Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order. A lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column. Example 1: . Input: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2: . Input: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3: . Input: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column. Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= n, m &lt;= 50 | 1 &lt;= matrix[i][j] &lt;= 105. | All elements in the matrix are distinct. | . Solution: . class Solution { public List&lt;Integer&gt; luckyNumbers (int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; matrix.length; i++){ // find min value int min = matrix[i][0]; int index = 0; for(int j = 1; j &lt; matrix[i].length; j++){ if(min &gt; matrix[i][j]){ min = matrix[i][j]; index = j; } } // check if (min) is the max value boolean f = true; for(int j = 0; j &lt; matrix.length; j++){ if(min &lt; matrix[j][index]){ f = false; break; } } // add element to the list if(f) ans.add(min); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-208-Lucky-Numbers-in-a-Matrix/",
    "relUrl": "/problem-208-Lucky-Numbers-in-a-Matrix/"
  },"207": {
    "doc": "Minimum Value to Get Positive Step by Step Sum",
    "title": "Minimum Value to Get Positive Step by Step Sum",
    "content": "Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1. Example 1: . Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 . Example 2: . Input: nums = [1,2] Output: 1 Explanation: Minimum start value should be positive. Example 3: . Input: nums = [1,-2,-3] Output: 5 . Constraints: . | 1 &lt;= nums.length &lt;= 100 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int minStartValue(int[] nums) { int start = nums[0]; if(start &lt; 0) start = (start*-1) + 1; else start = 1; int i = 0; while(i != nums.length){ int temp = start; for(i = 0; i &lt; nums.length; i++){ temp = temp + nums[i]; if(temp &lt; 1){ start++; break; } } } return start; } } . Faster Solution . class Solution { public int minStartValue(int[] nums) { int preSum=0; int minSum=Integer.MAX_VALUE; for(int i : nums){ preSum+=i; minSum=Math.min(minSum,preSum); } return minSum &gt; 0 ? 1 : Math.abs(minSum) + 1; } } . ",
    "url": "https://1001anjan.github.io/problem-209-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/",
    "relUrl": "/problem-209-Minimum-Value-to-Get-Positive-Step-by-Step-Sum/"
  },"208": {
    "doc": "Combination Sum II",
    "title": "Combination Sum II",
    "content": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target. Each number in candidates may only be used once in the combination. Note: The solution set must not contain duplicate combinations. Example 1: . Input: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] . Example 2: . Input: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ] . Constraints: . | 1 &lt;= candidates.length &lt;= 100 | 1 &lt;= candidates[i] &lt;= 50 | 1 &lt;= target &lt;= 30 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(candidates); process(0, candidates, target, ans, new ArrayList&lt;Integer&gt;()); return ans; } public void process(int start, int[] arr, int target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(target == 0) { ans.add(new ArrayList&lt;&gt;(list)); return; } for(int i = start; i &lt; arr.length; i++){ if(i &gt; start &amp;&amp; arr[i] == arr[i - 1]){ continue; } if(target &gt;= arr[i]){ list.add(arr[i]); process(i + 1,arr,target - arr[i],ans,list); list.remove(list.size() - 1); } } } } . ",
    "url": "https://1001anjan.github.io/problem-21-Combination%20Sum%20II/",
    "relUrl": "/problem-21-Combination Sum II/"
  },"209": {
    "doc": "Symmetric Tree",
    "title": "Symmetric Tree",
    "content": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center). Example 1: . Input: root = [1,2,2,3,4,4,3] Output: true . Example 2: . Input: root = [1,2,2,null,3,null,3] Output: false . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean isSymmetric(TreeNode root) { if(root == null) return true; return checkMiror(root.left, root.right); } public boolean checkMiror(TreeNode t1, TreeNode t2){ if(t1 == null || t2 == null) return t1 == t2; if(t1.val == t2.val) return checkMiror(t1.left, t2.right) &amp;&amp; checkMiror(t1.right, t2.left); return false; } } . ",
    "url": "https://1001anjan.github.io/problem-21-Symmetric-Tree/",
    "relUrl": "/problem-21-Symmetric-Tree/"
  },"210": {
    "doc": "Reformat The String",
    "title": "Reformat The String",
    "content": "You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits). You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type. Return the reformatted string or return an empty string if it is impossible to reformat the string. Example 1: . Input: s = \"a0b1c2\" Output: \"0a1b2c\" Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations. Example 2: . Input: s = \"leetcode\" Output: \"\" Explanation: \"leetcode\" has only characters so we cannot separate them by digits. Example 3: . Input: s = \"1229857369\" Output: \"\" Explanation: \"1229857369\" has only digits so we cannot separate them by characters. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters and/or digits. | . class Solution { public String reformat(String s) { int letters = 0, numbers = 0; for(char c : s.toCharArray()){ if(Character.isDigit(c)) numbers++; else letters++; } if(Math.abs(letters - numbers) &gt; 1) return \"\"; return letters &gt; numbers ? makeResult(s,0,1) : makeResult(s,1,0); } private String makeResult(String s, int i, int j){ char[] c = s.toCharArray(); char[] res = new char[s.length()]; for(char ch: c){ if(Character.isLetter(ch)){ res[i] = ch; i+=2; }else{ res[j] = ch; j+=2; } } return String.valueOf(res); } } . ",
    "url": "https://1001anjan.github.io/problem-210-Reformat-The-String/",
    "relUrl": "/problem-210-Reformat-The-String/"
  },"211": {
    "doc": "Maximum Score After Splitting a String",
    "title": "Maximum Score After Splitting a String",
    "content": "Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring). The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring. Example 1: . Input: s = \"011101\" Output: 5 Explanation: All possible ways of splitting s into two non-empty substrings are: left = \"0\" and right = \"11101\", score = 1 + 4 = 5 left = \"01\" and right = \"1101\", score = 1 + 3 = 4 left = \"011\" and right = \"101\", score = 1 + 2 = 3 left = \"0111\" and right = \"01\", score = 1 + 1 = 2 left = \"01110\" and right = \"1\", score = 2 + 1 = 3 . Example 2: . Input: s = \"00111\" Output: 5 Explanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5 . Example 3: . Input: s = \"1111\" Output: 3 . Constraints: . | 2 &lt;= s.length &lt;= 500 | The string s consists of characters ‘0’ and ‘1’ only. | . Solution: . class Solution { public int maxScore(String s) { int one = 0; for(int i = 0; i &lt; s.length(); i++) { one += s.charAt(i) == '1' ? 1 : 0; } int zero = 0; if(s.charAt(0) == '0') zero++; else one--; int ans = zero + one; for(int i = 1; i &lt; s.length() - 1; i++) { if(s.charAt(i) == '0') { zero++; } else { one--; } ans = Math.max(ans, zero + one); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-211-Maximum-Score-After-Splitting-a-String/",
    "relUrl": "/problem-211-Maximum-Score-After-Splitting-a-String/"
  },"212": {
    "doc": "Kids With the Greatest Number of Candies",
    "title": "Kids With the Greatest Number of Candies",
    "content": "There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have. Return a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise. Note that multiple kids can have the greatest number of candies. Example 1: . Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: If you give all extraCandies to: - Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids. - Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids. - Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids. - Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids. - Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids. Example 2: . Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy. Kid 1 will always have the greatest number of candies, even if a different kid is given the extra candy. Example 3: . Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] . Constraints: . | n == candies.length | 2 &lt;= n &lt;= 100 | 1 &lt;= candies[i] &lt;= 100 | 1 &lt;= extraCandies &lt;= 50 | . Solution: . class Solution { public List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) { LinkedList&lt;Boolean&gt; ans = new LinkedList&lt;Boolean&gt;(); int max = -1; for(int n : candies){ if(n &gt; max) max = n; } for(int n : candies){ if(n + extraCandies &gt;= max) ans.addLast(true); else ans.addLast(false); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-212-Kids-With-the-Greatest-Number-of-Candies/",
    "relUrl": "/problem-212-Kids-With-the-Greatest-Number-of-Candies/"
  },"213": {
    "doc": "Destination City",
    "title": "Destination City",
    "content": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city. It is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city. Example 1: . Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]] Output: \"Sao Paulo\" Explanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -&gt; \"New York\" -&gt; \"Lima\" -&gt; \"Sao Paulo\". Example 2: . Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]] Output: \"A\" Explanation: All possible trips are: \"D\" -&gt; \"B\" -&gt; \"C\" -&gt; \"A\". \"B\" -&gt; \"C\" -&gt; \"A\". \"C\" -&gt; \"A\". \"A\". Clearly the destination city is \"A\". Example 3: . Input: paths = [[\"A\",\"Z\"]] Output: \"Z\" . Constraints: . | 1 &lt;= paths.length &lt;= 100 | paths[i].length == 2 | 1 &lt;= cityAi.length, cityBi.length &lt;= 10 | cityAi != cityBi | All strings consist of lowercase and uppercase English letters and the space character. | . Solution: . class Solution { public String destCity(List&lt;List&lt;String&gt;&gt; paths) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); for(List&lt;String&gt; l : paths){ s.add(l.get(0)); } for(List&lt;String&gt; l : paths){ if(!s.contains(l.get(1))) return l.get(1); } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-213-Destination-City/",
    "relUrl": "/problem-213-Destination-City/"
  },"214": {
    "doc": "Check If All 1's Are at Least Length K Places Away",
    "title": "Check If All 1’s Are at Least Length K Places Away",
    "content": "Given an binary array nums and an integer k, return true if all 1’s are at least k places away from each other, otherwise return false. #####Example 1: . Input: nums = [1,0,0,0,1,0,0,1], k = 2 Output: true Explanation: Each of the 1s are at least 2 places away from each other. Example 2: . Input: nums = [1,0,0,1,0,1], k = 2 Output: false Explanation: The second 1 and third 1 are only one apart from each other. Constraints: . | 1 &lt;= nums.length &lt;= 105 | 0 &lt;= k &lt;= nums.length | nums[i] is 0 or 1 | . Solution: . class Solution { public boolean kLengthApart(int[] nums, int k) { // initialize the counter of zeros to k // to pass the first 1 in nums int count = k; for (int num : nums) { // if the current integer is 1 if (num == 1) { // check that number of zeros in-between 1s // is greater than or equal to k if (count &lt; k) { return false; } // reinitialize counter count = 0; // if the current integer is 0 } else { // increase the counter ++count; } } return true; } } . Bit manipulation . https://leetcode.com/problems/check-if-all-1s-are-at-least-length-k-places-away/solution/ . class Solution { public boolean kLengthApart(int[] nums, int k) { // convert binary array into int int x = 0; for (int num : nums) { x = (x &lt;&lt; 1) | num; } // base case if (x == 0 || k == 0) { return true; } // remove trailing zeros while ((x &amp; 1) == 0) { x = x &gt;&gt; 1; } while (x != 1) { // remove trailing 1-bit x = x &gt;&gt; 1; // count trailing zeros int count = 0; while ((x &amp; 1) == 0) { x = x &gt;&gt; 1; ++count; } // number of zeros in-between 1-bits // should be greater than or equal to k if (count &lt; k) { return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/#check-if-all-1s-are-at-least-length-k-places-away",
    "relUrl": "/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/#check-if-all-1s-are-at-least-length-k-places-away"
  },"215": {
    "doc": "Check If All 1's Are at Least Length K Places Away",
    "title": "Check If All 1's Are at Least Length K Places Away",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/",
    "relUrl": "/problem-214-Check-If-All-1's-Are-at-Least-Length-K-Places-Away/"
  },"216": {
    "doc": "Build an Array With Stack Operations",
    "title": "Build an Array With Stack Operations",
    "content": "You are given an array target and an integer n. In each iteration, you will read a number from list = [1, 2, 3, …, n]. Build the target array using the following operations: . | “Push”: Reads a new element from the beginning list, and pushes it in the array. | “Pop”: Deletes the last element of the array. | If the target array is already built, stop reading more elements. Return a list of the operations needed to build target. The test cases are generated so that the answer is unique. | . Example 1: . Input: target = [1,3], n = 3 Output: [\"Push\",\"Push\",\"Pop\",\"Push\"] Explanation: Read number 1 and automatically push in the array -&gt; [1] Read number 2 and automatically push in the array then Pop it -&gt; [1] Read number 3 and automatically push in the array -&gt; [1,3] . Example 2: . Input: target = [1,2,3], n = 3 Output: [\"Push\",\"Push\",\"Push\"] . Example 3: . Input: target = [1,2], n = 4 Output: [\"Push\",\"Push\"] Explanation: You only need to read the first 2 numbers and stop. Constraints: . | 1 &lt;= target.length &lt;= 100 | 1 &lt;= n &lt;= 100 | 1 &lt;= target[i] &lt;= n | target is strictly increasing. | . Solution: . class Solution { public List&lt;String&gt; buildArray(int[] target, int n) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int i = 0; for(int k = 1; i &lt; target.length &amp;&amp; k &lt;= n; k++){ ans.add(\"Push\"); if(target[i] == k){ i++; }else{ ans.add(\"Pop\"); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-215-Build-an-Array-With-Stack-Operations/",
    "relUrl": "/problem-215-Build-an-Array-With-Stack-Operations/"
  },"217": {
    "doc": "Consecutive Characters",
    "title": "Consecutive Characters",
    "content": "The power of the string is the maximum length of a non-empty substring that contains only one unique character. Given a string s, return the power of s. Example 1: . Input: s = \"leetcode\" Output: 2 Explanation: The substring \"ee\" is of length 2 with the character 'e' only. Example 2: . Input: s = \"abbcccddddeeeeedcba\" Output: 5 Explanation: The substring \"eeeee\" is of length 5 with the character 'e' only. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters. | . Solution: . class Solution { public int maxPower(String s) { int max = -1; int currMax = 1; for(int i = 1; i &lt; s.length(); i++){ if(s.charAt(i - 1) == s.charAt(i)){ currMax++; }else{ max = Math.max(max, currMax); currMax = 1; } } return Math.max(max, currMax); } } . Faster in execution: . class Solution { public int maxPower(String s) { int max = -1; int currMax = 1; char prev = s.charAt(0); for(int i = 1; i &lt; s.length(); i++){ char now = s.charAt(i); if(prev == now){ currMax++; }else{ max = Math.max(max, currMax); currMax = 1; } prev = now; } return Math.max(max, currMax); } } . ",
    "url": "https://1001anjan.github.io/problem-216-Consecutive-Characters/",
    "relUrl": "/problem-216-Consecutive-Characters/"
  },"218": {
    "doc": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
    "title": "Check If a Word Occurs As a Prefix of Any Word in a Sentence",
    "content": "Given a sentence that consists of some words separated by a single space, and a searchWord, check if searchWord is a prefix of any word in sentence. Return the index of the word in sentence (1-indexed) where searchWord is a prefix of this word. If searchWord is a prefix of more than one word, return the index of the first word (minimum index). If there is no such word return -1. A prefix of a string s is any leading contiguous substring of s. Example 1: . Input: sentence = \"i love eating burger\", searchWord = \"burg\" Output: 4 Explanation: \"burg\" is prefix of \"burger\" which is the 4th word in the sentence. Example 2: . Input: sentence = \"this problem is an easy problem\", searchWord = \"pro\" Output: 2 Explanation: \"pro\" is prefix of \"problem\" which is the 2nd and the 6th word in the sentence, but we return 2 as it's the minimal index. Example 3: . Input: sentence = \"i am tired\", searchWord = \"you\" Output: -1 Explanation: \"you\" is not a prefix of any word in the sentence. Constraints: . | 1 &lt;= sentence.length &lt;= 100 | 1 &lt;= searchWord.length &lt;= 10 | sentence consists of lowercase English letters and spaces. | searchWord consists of lowercase English letters. | . Solution: . class Solution { public int isPrefixOfWord(String sentence, String searchWord) { String[] words = sentence.split(\" \"); char first = searchWord.charAt(0); for(int i = 0; i &lt; words.length; i++){ if(words[i].charAt(0) == first){ int m = 1; while(m &lt; words[i].length() &amp;&amp; m &lt; searchWord.length()){ if(searchWord.charAt(m) != words[i].charAt(m)) break; m++; } if(m == searchWord.length()) return i+1; } } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-217-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/",
    "relUrl": "/problem-217-Check-If-a-Word-Occurs-As-a-Prefix-of-Any-Word-in-a-Sentence/"
  },"219": {
    "doc": "Make Two Arrays Equal by Reversing Sub-arrays",
    "title": "Make Two Arrays Equal by Reversing Sub-arrays",
    "content": "You are given two integer arrays of equal length target and arr. In one step, you can select any non-empty sub-array of arr and reverse it. You are allowed to make any number of steps. Return true if you can make arr equal to target or false otherwise. Example 1: . Input: target = [1,2,3,4], arr = [2,4,1,3] Output: true Explanation: You can follow the next steps to convert arr to target: 1- Reverse sub-array [2,4,1], arr becomes [1,4,2,3] 2- Reverse sub-array [4,2], arr becomes [1,2,4,3] 3- Reverse sub-array [4,3], arr becomes [1,2,3,4] There are multiple ways to convert arr to target, this is not the only way to do so. Example 2: . Input: target = [7], arr = [7] Output: true Explanation: arr is equal to target without any reverses. Example 3: . Input: target = [3,7,9], arr = [3,7,11] Output: false Explanation: arr does not have value 9 and it can never be converted to target. Constraints: . | target.length == arr.length | 1 &lt;= target.length &lt;= 1000 | 1 &lt;= target[i] &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean canBeEqual(int[] target, int[] arr) { int[] count = new int[1001]; for(int n : target) count[n]++; for(int n : arr) count[n]--; for(int i = 0; i &lt; count.length; i++){ if(count[i] != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-218-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/",
    "relUrl": "/problem-218-Make-Two-Arrays-Equal-by-Reversing-Sub-arrays/"
  },"220": {
    "doc": "Maximum Product of Two Elements in an Array",
    "title": "Maximum Product of Two Elements in an Array",
    "content": "Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1). Example 1: . Input: nums = [3,4,5,2] Output: 12 Explanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. Example 2: . Input: nums = [1,5,4,5] Output: 16 Explanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16. Example 3: . Input: nums = [3,7] Output: 12 . Constraints: . | 2 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 10^3 | . Solution: . class Solution { public int maxProduct(int[] nums) { int max1, max2; if(nums[0] &gt; nums[1]){ max1 = nums[0]; max2 = nums[1]; }else{ max1 = nums[1]; max2 = nums[0]; } for(int i = 2; i &lt; nums.length; i++){ if(max1 &lt; nums[i]){ max2 = max1; max1 = nums[i]; }else if(max2 &lt; nums[i]){ max2 = nums[i]; } } return (max1 - 1)*(max2 - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-219-Maximum-Product-of-Two-Elements-in-an-Array/",
    "relUrl": "/problem-219-Maximum-Product-of-Two-Elements-in-an-Array/"
  },"221": {
    "doc": "Jump Game II",
    "title": "Jump Game II",
    "content": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0]. Each element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where: . | 0 &lt;= j &lt;= nums[i] and | i + j &lt; n Return the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1]. | . Example 1: . Input: nums = [2,3,1,1,4] Output: 2 Explanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: . Input: nums = [2,3,0,1,4] Output: 2 . Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int jump(int[] nums) { int jump = 0, currEnd = 0, maxEnd = 0; for(int i = 0; i &lt; nums.length - 1; i++){ maxEnd = Math.max(maxEnd, i + nums[i]); if(i == currEnd){ jump++; currEnd = maxEnd; } } return jump; } } . ",
    "url": "https://1001anjan.github.io/problem-22-Jump%20Game%20II/",
    "relUrl": "/problem-22-Jump Game II/"
  },"222": {
    "doc": "Maximum Depth of Binary Tree",
    "title": "Maximum Depth of Binary Tree",
    "content": "Given the root of a binary tree, return its maximum depth. A binary tree’s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 3 . Example 2: . Input: root = [1,null,2] Output: 2 . Constraints: . | The number of nodes in the tree is in the range [0, 104]. | -100 &lt;= Node.val &lt;= 100 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int maxDepth(TreeNode root) { if(root == null ) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; return 1 + Math.max(maxDepth(root.left), maxDepth(root.right)); } } . ",
    "url": "https://1001anjan.github.io/problem-22-Maximum-Depth-of-Binary-Tree/",
    "relUrl": "/problem-22-Maximum-Depth-of-Binary-Tree/"
  },"223": {
    "doc": "Shuffle the Array",
    "title": "Shuffle the Array",
    "content": "Given the array nums consisting of 2n elements in the form [x1,x2,…,xn,y1,y2,…,yn]. Return the array in the form [x1,y1,x2,y2,…,xn,yn]. Example 1: . Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: . Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] . Example 3: . Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] . Constraints: . | 1 &lt;= n &lt;= 500 | nums.length == 2n | 1 &lt;= nums[i] &lt;= 10^3 | . Solution: . class Solution { public int[] shuffle(int[] nums, int n) { int[] ans = new int[nums.length]; int j = 0; int k = n; for(int i = 0; i &lt; nums.length; i++){ if(i%2 == 0){ ans[i] = nums[j++]; }else{ ans[i] = nums[k++]; } } return ans; } } . SAME execution time . class Solution { public int[] shuffle(int[] nums, int n) { int ans[] = new int[nums.length]; for(int i = 0; i &lt; nums.length/2; i++){ ans[i * 2] = nums[i]; ans[2 * i + 1] = nums[n + i]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-220-Shuffle-the-Array/",
    "relUrl": "/problem-220-Shuffle-the-Array/"
  },"224": {
    "doc": "Final Prices With a Special Discount in a Shop",
    "title": "Final Prices With a Special Discount in a Shop",
    "content": "Given the array prices where prices[i] is the price of the ith item in a shop. There is a special discount for items in the shop, if you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j &gt; i and prices[j] &lt;= prices[i], otherwise, you will not receive any discount at all. Return an array where the ith element is the final price you will pay for the ith item of the shop considering the special discount. Example 1: . Input: prices = [8,4,6,2,3] Output: [4,2,4,2,3] Explanation: For item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4. For item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2. For item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4. For items 3 and 4 you will not receive any discount at all. Example 2: . Input: prices = [1,2,3,4,5] Output: [1,2,3,4,5] Explanation: In this case, for all items, you will not receive any discount at all. Example 3: . Input: prices = [10,1,1,6] Output: [9,0,1,6] . Constraints: . | 1 &lt;= prices.length &lt;= 500 | 1 &lt;= prices[i] &lt;= 10^3 | . Solution: . class Solution { public int[] finalPrices(int[] prices) { for(int i = 0; i&lt;prices.length - 1; i++){ for(int j = i + 1; j &lt; prices.length; j++){ if(prices[i] &gt;= prices[j]){ prices[i] -= prices[j]; break; } } } return prices; } } . ",
    "url": "https://1001anjan.github.io/problem-221-Final-Prices-With-a-Special-Discount-in-a-Shop/",
    "relUrl": "/problem-221-Final-Prices-With-a-Special-Discount-in-a-Shop/"
  },"225": {
    "doc": "Running Sum of 1d Array",
    "title": "Running Sum of 1d Array",
    "content": "Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. Example 1: . Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: . Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: . Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17] . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -10^6 &lt;= nums[i] &lt;= 10^6 | . Solution: . class Solution { public int[] runningSum(int[] nums) { for(int i = 1; i&lt;nums.length; i++){ nums[i] += nums[i-1]; } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-222-Running-Sum-of-1d-Array/",
    "relUrl": "/problem-222-Running-Sum-of-1d-Array/"
  },"226": {
    "doc": "XOR Operation in an Array",
    "title": "XOR Operation in an Array",
    "content": "You are given an integer n and an integer start. Define an array nums where nums[i] = start + 2 * i (0-indexed) and n == nums.length. Return the bitwise XOR of all elements of nums. Example 1: . Input: n = 5, start = 0 Output: 8 Explanation: Array nums is equal to [0, 2, 4, 6, 8] where (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8. Where \"^\" corresponds to bitwise XOR operator. Example 2: . Input: n = 4, start = 3 Output: 8 Explanation: Array nums is equal to [3, 5, 7, 9] where (3 ^ 5 ^ 7 ^ 9) = 8. Constraints: . | 1 &lt;= n &lt;= 1000 | 0 &lt;= start &lt;= 1000 | n == nums.length | . Solution: . class Solution { public int xorOperation(int n, int start) { int ans = start; for(int i = 1; i &lt; n; i++) ans = ans ^ (start + 2*i); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-223-XOR-Operation-in-an-Array/",
    "relUrl": "/problem-223-XOR-Operation-in-an-Array/"
  },"227": {
    "doc": "Average Salary Excluding the Minimum and Maximum Salary",
    "title": "Average Salary Excluding the Minimum and Maximum Salary",
    "content": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee. Return the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: salary = [4000,3000,1000,2000] Output: 2500.00000 Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively. Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500 . Example 2: . Input: salary = [1000,2000,3000] Output: 2000.00000 Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively. Average salary excluding minimum and maximum salary is (2000) / 1 = 2000 . Constraints: . | 3 &lt;= salary.length &lt;= 100 | 1000 &lt;= salary[i] &lt;= 106 | All the integers of salary are unique. | . Solution: . class Solution { public double average(int[] salary) { int max = Math.max(salary[0],salary[1]); int min = Math.min(salary[0],salary[1]); double sum = max + min; for(int i = 2; i &lt; salary.length; i++){ if(max &lt; salary[i]){ max = salary[i]; }else if(min &gt; salary[i]){ min = salary[i]; } sum += salary[i]; } sum = sum - max - min; return sum/(salary.length - 2); } } . ",
    "url": "https://1001anjan.github.io/problem-224-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/",
    "relUrl": "/problem-224-Average-Salary-Excluding-the-Minimum-and-Maximum-Salary/"
  },"228": {
    "doc": "Path Crossing",
    "title": "Path Crossing",
    "content": "Given a string path, where path[i] = ‘N’, ‘S’, ‘E’ or ‘W’, each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path. Return true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise. Example 1: . Input: path = \"NES\" Output: false Explanation: Notice that the path doesn't cross any point more than once. Example 2: . Input: path = \"NESWW\" Output: true Explanation: Notice that the path visits the origin twice. Constraints: . | 1 &lt;= path.length &lt;= 104 | path[i] is either ‘N’, ‘S’, ‘E’, or ‘W’. | . Solution: . class Solution { public boolean isPathCrossing(String path) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); s.add(\"0,0\"); int x = 0, y = 0; for(char c : path.toCharArray()){ if(c == 'N') y++; else if(c == 'E') x++; else if(c == 'S') y--; else x--; String str = \"\"+x+\",\"+y; if(s.contains(str)) return true; s.add(str); } return false; } } . Faster using string Builder . class Solution { public boolean isPathCrossing(String path) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); s.add(\"0,0\"); int x = 0, y = 0; StringBuilder sb = new StringBuilder(); for(char c : path.toCharArray()){ sb.setLength(0); if(c == 'N') y++; else if(c == 'E') x++; else if(c == 'S') y--; else x--; if(!s.add(sb.append(x).append(\",\").append(y).toString())) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-225-Path-Crossing/",
    "relUrl": "/problem-225-Path-Crossing/"
  },"229": {
    "doc": "Can Make Arithmetic Progression From Sequence",
    "title": "Can Make Arithmetic Progression From Sequence",
    "content": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same. Given an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false. Example 1: . Input: arr = [3,5,1] Output: true Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements. Example 2: . Input: arr = [1,2,4] Output: false Explanation: There is no way to reorder the elements to obtain an arithmetic progression. Constraints: . | 2 &lt;= arr.length &lt;= 1000 | -106 &lt;= arr[i] &lt;= 106 | . Solution: . Time Complexity: O(nLogN) . class Solution { public boolean canMakeArithmeticProgression(int[] arr) { Arrays.sort(arr); int diff = arr[0] - arr[1]; for(int i = 1; i &lt; arr.length - 1; i++){ if(diff != arr[i] - arr[i + 1]) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-226-Can-Make-Arithmetic-Progression-From-Sequence/",
    "relUrl": "/problem-226-Can-Make-Arithmetic-Progression-From-Sequence/"
  },"230": {
    "doc": "Reformat Date",
    "title": "Reformat Date",
    "content": "Given a date string in the form Day Month Year, where: . | Day is in the set {“1st”, “2nd”, “3rd”, “4th”, …, “30th”, “31st”}. | Month is in the set {“Jan”, “Feb”, “Mar”, “Apr”, “May”, “Jun”, “Jul”, “Aug”, “Sep”, “Oct”, “Nov”, “Dec”}. | Year is in the range [1900, 2100]. | . Convert the date string to the format YYYY-MM-DD, where: . | YYYY denotes the 4 digit year. | MM denotes the 2 digit month. | DD denotes the 2 digit day. | . Example 1: . Input: date = \"20th Oct 2052\" Output: \"2052-10-20\" . Example 2: . Input: date = \"6th Jun 1933\" Output: \"1933-06-06\" . Example 3: . Input: date = \"26th May 1960\" Output: \"1960-05-26\" . Constraints: . | The given dates are guaranteed to be valid, so no error handling is necessary. | . Solution: . class Solution { public String reformatDate(String date) { String[] strs = date.split(\" \"); StringBuilder sb = new StringBuilder(); return sb.append(strs[2]).append(\"-\").append(getFormatedMonth(strs[1])).append(\"-\") .append(getFormatedDate(strs[0].substring(0,strs[0].length() - 2))).toString(); } public String getFormatedMonth(String str){ switch(str){ case \"Jan\": return \"01\"; case \"Feb\": return \"02\"; case \"Mar\": return \"03\"; case \"Apr\": return \"04\"; case \"May\": return \"05\"; case \"Jun\": return \"06\"; case \"Jul\": return \"07\"; case \"Aug\": return \"08\"; case \"Sep\": return \"09\"; case \"Oct\": return \"10\"; case \"Nov\": return \"11\"; case \"Dec\": return \"12\"; case default: return \"-1\"; } } public String getFormatedDate(String str){ if(str.length() == 1) return \"0\".concat(str); return str; } } . ",
    "url": "https://1001anjan.github.io/problem-227-Reformat-Date/",
    "relUrl": "/problem-227-Reformat-Date/"
  },"231": {
    "doc": "Number of Good Pairs",
    "title": "Number of Good Pairs",
    "content": "Given an array of integers nums, return the number of good pairs. A pair (i, j) is called good if nums[i] == nums[j] and i &lt; j. Example 1: . Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2: . Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good. Example 3: . Input: nums = [1,2,3] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int numIdenticalPairs(int[] nums) { int[] count = new int[101]; for(int n : nums) count[n]++; int sum = 0; for(int i = 1; i &lt;= 100; i++){ if(count[i] &gt;= 2){ sum += (count[i]*(count[i]-1))/2; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-228-Number-of-Good-Pairs/",
    "relUrl": "/problem-228-Number-of-Good-Pairs/"
  },"232": {
    "doc": "Count Odd Numbers in an Interval Range",
    "title": "Count Odd Numbers in an Interval Range",
    "content": "Given two non-negative integers low and high. Return the count of odd numbers between low and high (inclusive). Example 1: . Input: low = 3, high = 7 Output: 3 Explanation: The odd numbers between 3 and 7 are [3,5,7]. Example 2: . Input: low = 8, high = 10 Output: 1 Explanation: The odd numbers between 8 and 10 are [9]. Constraints: . | 0 &lt;= low &lt;= high &lt;= 10^9 | . Solution: . class Solution { public int countOdds(int low, int high) { int ans = (high - low)/2; if(low % 2 ==0 &amp;&amp; high % 2 == 0 ) return ans; return ans + 1; } } . ",
    "url": "https://1001anjan.github.io/problem-229-Count-Odd-Numbers-in-an-Interval-Range/",
    "relUrl": "/problem-229-Count-Odd-Numbers-in-an-Interval-Range/"
  },"233": {
    "doc": "Convert Sorted Array to Binary Search Tree",
    "title": "Convert Sorted Array to Binary Search Tree",
    "content": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one. Example 1: . Input: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: . Example 2: . Input: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | nums is sorted in a strictly increasing order. | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode sortedArrayToBST(int[] nums) { return convertBalancedTree(null, nums, 0, nums.length-1); } public TreeNode convertBalancedTree(TreeNode head, int[] nums, int s, int e){ if(s&gt;e) return head; int mid = (s+e)/2; head = new TreeNode(nums[mid]); head.left = convertBalancedTree(head.left, nums, s, mid-1); head.right = convertBalancedTree(head.right, nums, mid+1, e); return head; } } . ",
    "url": "https://1001anjan.github.io/problem-23-Convert-Sorted-Array-to-Binary-Search-Tree/",
    "relUrl": "/problem-23-Convert-Sorted-Array-to-Binary-Search-Tree/"
  },"234": {
    "doc": "Permutations",
    "title": "Permutations",
    "content": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order. Example 1: . Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] . Example 2: . Input: nums = [0,1] Output: [[0,1],[1,0]] . Example 3: . Input: nums = [1] Output: [[1]] . Constraints: . | 1 &lt;= nums.length &lt;= 6 | -10 &lt;= nums[i] &lt;= 10 | All the integers of nums are unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); processPermute(nums,0,ans); return ans; } public void processPermute(int[] arr, int level, List&lt;List&lt;Integer&gt;&gt; ans){ if(level == arr.length){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); for(int n : arr) l.add(n); ans.add(l); return; } for(int i = level; i &lt; arr.length; i++){ swap(arr,i,level); processPermute(arr, level + 1, ans); swap(arr,i,level); } } public void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } . ",
    "url": "https://1001anjan.github.io/problem-23-Permutations/",
    "relUrl": "/problem-23-Permutations/"
  },"235": {
    "doc": "Shuffle String",
    "title": "Shuffle String",
    "content": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string. Return the shuffled string. Example 1: . Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3] Output: \"leetcode\" Explanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling. Example 2: . Input: s = \"abc\", indices = [0,1,2] Output: \"abc\" Explanation: After shuffling, each character remains in its position. Constraints: . | s.length == indices.length == n | 1 &lt;= n &lt;= 100 | s consists of only lowercase English letters. | 0 &lt;= indices[i] &lt; n | All values of indices are unique. | . Solution: . class Solution { public String restoreString(String s, int[] indices) { char[] ans = new char[indices.length]; for(int i = 0; i &lt; indices.length; i++){ ans[indices[i]] = s.charAt(i); } return new String(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-230-Shuffle-String/",
    "relUrl": "/problem-230-Shuffle-String/"
  },"236": {
    "doc": "Count Good Triplets",
    "title": "Count Good Triplets",
    "content": "Given an array of integers arr, and three integers a, b and c. You need to find the number of good triplets. A triplet (arr[i], arr[j], arr[k]) is good if the following conditions are true: . | 0 &lt;= i &lt; j &lt; k &lt; arr.length | | arr[i] - arr[j] | &lt;= a | . | | arr[j] - arr[k] | &lt;= b | . | | arr[i] - arr[k] | &lt;= c | . | . | Where | x | denotes the absolute value of x. | . Return the number of good triplets. Example 1: . Input: arr = [3,0,1,1,9,7], a = 7, b = 2, c = 3 Output: 4 Explanation: There are 4 good triplets: [(3,0,1), (3,0,1), (3,1,1), (0,1,1)]. Example 2: . Input: arr = [1,1,2,2,3], a = 0, b = 0, c = 1 Output: 0 Explanation: No triplet satisfies all conditions. Constraints: . | 3 &lt;= arr.length &lt;= 100 | 0 &lt;= arr[i] &lt;= 1000 | 0 &lt;= a, b, c &lt;= 1000 | . Solution: . class Solution { public int countGoodTriplets(int[] arr, int a, int b, int c) { int count = 0; for(int i = 0; i &lt; arr.length - 2; i++) for(int j = i + 1; j &lt; arr.length - 1; j++) for(int k = j + 1; k &lt; arr.length; k++){ if(Math.abs(arr[i] - arr[j]) &lt;= a &amp;&amp; Math.abs(arr[j] - arr[k]) &lt;= b &amp;&amp; Math.abs(arr[i] - arr[k]) &lt;= c) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-231-Count-Good-Triplets/",
    "relUrl": "/problem-231-Count-Good-Triplets/"
  },"237": {
    "doc": "Kth Missing Positive Number",
    "title": "Kth Missing Positive Number",
    "content": "Given an array arr of positive integers sorted in a strictly increasing order, and an integer k. Return the kth positive integer that is missing from this array. Example 1: . Input: arr = [2,3,4,7,11], k = 5 Output: 9 Explanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th missing positive integer is 9. Example 2: . Input: arr = [1,2,3,4], k = 2 Output: 6 Explanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6. Constraints: . | 1 &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | 1 &lt;= k &lt;= 1000 | arr[i] &lt; arr[j] for 1 &lt;= i &lt; j &lt;= arr.length | . Follow up: . Could you solve this problem in less than O(n) complexity? . Solution . class Solution { public int findKthPositive(int[] arr, int k) { int count = 0; int i = 1; int j = 0; while(count != k){ if(j &lt; arr.length &amp;&amp; arr[j] == i){ j++; }else{ count++; } i++; } return i-1; } } . ",
    "url": "https://1001anjan.github.io/problem-232-Kth-Missing-Positive-Number/",
    "relUrl": "/problem-232-Kth-Missing-Positive-Number/"
  },"238": {
    "doc": "Make The String Great",
    "title": "Make The String Great",
    "content": "Given a string s of lower and upper case English letters. A good string is a string which doesn’t have two adjacent characters s[i] and s[i + 1] where: . | 0 &lt;= i &lt;= s.length - 2 | s[i] is a lower-case letter and s[i + 1] is the same letter but in upper-case or vice-versa. | . To make the string good, you can choose two adjacent characters that make the string bad and remove them. You can keep doing this until the string becomes good. Return the string after making it good. The answer is guaranteed to be unique under the given constraints. Notice that an empty string is also good. Example 1: . Input: s = \"leEeetcode\" Output: \"leetcode\" Explanation: In the first step, either you choose i = 1 or i = 2, both will result \"leEeetcode\" to be reduced to \"leetcode\". Example 2: . Input: s = \"abBAcC\" Output: \"\" Explanation: We have many possible scenarios, and all lead to the same answer. For example: \"abBAcC\" --&gt; \"aAcC\" --&gt; \"cC\" --&gt; \"\" \"abBAcC\" --&gt; \"abBA\" --&gt; \"aA\" --&gt; \"\" . Example 3: . Input: s = \"s\" Output: \"s\" . Constraints: . | 1 &lt;= s.length &lt;= 100 | s contains only lower and upper case English letters. | . Solution: . class Solution { public String makeGood(String s) { StringBuilder sb = new StringBuilder(); boolean status = false; sb.append(s); while(!status ){ char[] chs = sb.toString().toCharArray(); sb.setLength(0); status = true; for(int i = 0; i &lt; chs.length; i++){ if(i &lt; chs.length - 1 &amp;&amp; chs[i] != chs[i+1] &amp;&amp; Character.toUpperCase(chs[i]) == Character.toUpperCase(chs[i+1])){ i++; status = false; }else{ sb.append(chs[i]); } } } return sb.toString(); } } . Using recursion . class Solution { public String makeGood(String s) { for(int i=0;i&lt;s.length() - 1;i++){ if(Math.abs(s.charAt(i) - s.charAt(i+1)) ==32) return makeGood(s.substring(0, i)+ s.substring(i+2)); } return s; } } . using Stack but slow approach . class Solution { public String makeGood(String s) { Stack&lt;Character&gt; stk = new Stack&lt;&gt;(); for(int i=0; i&lt;s.length(); i++){ char c = s.charAt(i); if(!stk.isEmpty() &amp;&amp; Math.abs(stk.peek()-c) == 32) stk.pop(); else stk.push(c); } StringBuilder res = new StringBuilder(); while(!stk.isEmpty()) res.append(stk.pop()); return res.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-233-Make-The-String-Great/",
    "relUrl": "/problem-233-Make-The-String-Great/"
  },"239": {
    "doc": "Three Consecutive Odds",
    "title": "Three Consecutive Odds",
    "content": "Given an integer array arr, return true if there are three consecutive odd numbers in the array. Otherwise, return false. Example 1: . Input: arr = [2,6,4,1] Output: false Explanation: There are no three consecutive odds. Example 2: . Input: arr = [1,2,34,3,4,5,7,23,12] Output: true Explanation: [5,7,23] are three consecutive odds. Constraints: . | 1 &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i] &lt;= 1000 | . Solution: . class Solution { public boolean threeConsecutiveOdds(int[] arr) { int count = 0; for(int n : arr){ if(n % 2 == 0){ count = 0; }else{ count ++; } if(count == 3) return true; } return false; } } . class Solution { public boolean threeConsecutiveOdds(int[] arr) { if(arr.length &lt; 3) return false; for(int i=0;i&lt;arr.length-2;i++) { if(arr[i] % 2 != 0 &amp;&amp; arr[i+1] % 2 != 0 &amp;&amp; arr[i+2] % 2 != 0) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-234-Three-Consecutive-Odds/",
    "relUrl": "/problem-234-Three-Consecutive-Odds/"
  },"240": {
    "doc": "Thousand Separator",
    "title": "Thousand Separator",
    "content": "Given an integer n, add a dot (“.”) as the thousands separator and return it in string format. Example 1: . Input: n = 987 Output: \"987\" . Example 2: . Input: n = 1234 Output: \"1.234\" . Constraints: . | 0 &lt;= n &lt;= 231 - 1 | . Solution: . class Solution { public String thousandSeparator(int n) { if(n == 0) return \"0\"; StringBuilder sb = new StringBuilder(); int count = 0; while(n &gt; 0){ if(count == 3){ count = 0; sb.append(\".\"); } sb.append(n % 10); n = n/10; count++; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-235-Thousand-Separator/",
    "relUrl": "/problem-235-Thousand-Separator/"
  },"241": {
    "doc": "Detect Pattern of Length M Repeated K or More Times",
    "title": "Detect Pattern of Length M Repeated K or More Times",
    "content": "Given an array of positive integers arr, find a pattern of length m that is repeated k or more times. A pattern is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times consecutively without overlapping. A pattern is defined by its length and the number of repetitions. Return true if there exists a pattern of length m that is repeated k or more times, otherwise return false. Example 1: . Input: arr = [1,2,4,4,4,4], m = 1, k = 3 Output: true Explanation: The pattern (4) of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less. Example 2: . Input: arr = [1,2,1,2,1,1,1,3], m = 2, k = 2 Output: true Explanation: The pattern (1,2) of length 2 is repeated 2 consecutive times. Another valid pattern (2,1) is also repeated 2 times. Example 3: . Input: arr = [1,2,1,2,1,3], m = 2, k = 3 Output: false Explanation: The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times. Constraints: . | 2 &lt;= arr.length &lt;= 100 | 1 &lt;= arr[i] &lt;= 100 | 1 &lt;= m &lt;= 100 | 2 &lt;= k &lt;= 100 | . Solution: . class Solution { public boolean containsPattern(int[] arr, int m, int k) { int count = 0; for (int i = 0; i &lt; arr.length - m; i++) { if (arr[i] == arr[i + m]) { count++; } else { count = 0; } if (count == m * (k-1)) { return true; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-236-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times/",
    "relUrl": "/problem-236-Detect-Pattern-of-Length-M-Repeated-K-or-More-Times/"
  },"242": {
    "doc": "Matrix Diagonal Sum",
    "title": "Matrix Diagonal Sum",
    "content": "Given a square matrix mat, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal. Example 1: . Input: mat = [[1,2,3], [4,5,6], [7,8,9]] Output: 25 Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25 Notice that element mat[1][1] = 5 is counted only once. Example 2: . Input: mat = [[1,1,1,1], [1,1,1,1], [1,1,1,1], [1,1,1,1]] Output: 8 . Example 3: . Input: mat = [[5]] Output: 5 . Constraints: . | n == mat.length == mat[i].length | 1 &lt;= n &lt;= 100 | 1 &lt;= mat[i][j] &lt;= 100 | . Solution: . class Solution { public int diagonalSum(int[][] mat) { int sum = 0; int i = 0; int j = 0; while(i &lt; mat.length){ sum += mat[i++][j++]; } i = 0; j = mat[0].length - 1; while(i &lt; mat.length){ sum += mat[i++][j--]; } if(mat.length % 2 != 0) sum -= mat[mat.length / 2][mat.length / 2]; return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-237-Matrix-Diagonal-Sum/",
    "relUrl": "/problem-237-Matrix-Diagonal-Sum/"
  },"243": {
    "doc": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "title": "Replace All ?’s to Avoid Consecutive Repeating Characters",
    "content": "Given a string s containing only lowercase English letters and the ‘?’ character, convert all the ‘?’ characters into lowercase letters such that the final string does not contain any consecutive repeating characters. You cannot modify the non ‘?’ characters. It is guaranteed that there are no consecutive repeating characters in the given string except for ‘?’. Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them. It can be shown that an answer is always possible with the given constraints. Example 1: . Input: s = \"?zs\" Output: \"azs\" Explanation: There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\". Example 2: . Input: s = \"ubv?w\" Output: \"ubvaw\" Explanation: There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consist of lowercase English letters and ‘?’. | . Solution: . class Solution { public String modifyString(String s) { char[] chars = s.toCharArray(); char prev = '1'; for(int i = 0; i &lt; chars.length; i++){ if(chars[i] == '?'){ chars[i] = getNewChar(prev,chars[(i + 1)%chars.length]); } prev = chars[i]; } return new String(chars); } public char getNewChar(char prev, char next){ int i = 0; int p = prev - 'a'; int n = next - 'a'; while(i &lt; 26){ if(i != p &amp;&amp; i != n) break; i++; } return (char)('a' + i); } } . ",
    "url": "https://1001anjan.github.io/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/#replace-all-s-to-avoid-consecutive-repeating-characters",
    "relUrl": "/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/#replace-all-s-to-avoid-consecutive-repeating-characters"
  },"244": {
    "doc": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "title": "Replace All ?'s to Avoid Consecutive Repeating Characters",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/",
    "relUrl": "/problem-238-Replace-All-?'s-to-Avoid-Consecutive-Repeating-Characters/"
  },"245": {
    "doc": "Special Positions in a Binary Matrix",
    "title": "Special Positions in a Binary Matrix",
    "content": "Given an m x n binary matrix mat, return the number of special positions in mat. A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed). Example 1: . Input: mat = [[1,0,0],[0,0,1],[1,0,0]] Output: 1 Explanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0. Example 2: . Input: mat = [[1,0,0],[0,1,0],[0,0,1]] Output: 3 Explanation: (0, 0), (1, 1) and (2, 2) are special positions. Constraints: . | m == mat.length | n == mat[i].length | 1 &lt;= m, n &lt;= 100 | mat[i][j] is either 0 or 1. | . Solution: . class Solution { public int numSpecial(int[][] mat) { int m = mat.length, n = mat[0].length; int[] row = new int[m], col = new int[n]; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] == 1) { row[i]++; col[j]++; } } } int res = 0; for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (mat[i][j] == 1 &amp;&amp; row[i] == 1 &amp;&amp; col[j] == 1) { res++; } } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-239-Special-Positions-in-a-Binary-Matrix/",
    "relUrl": "/problem-239-Special-Positions-in-a-Binary-Matrix/"
  },"246": {
    "doc": "Balanced Binary Tree",
    "title": "Balanced Binary Tree",
    "content": "Given a binary tree, determine if it is height-balanced. For this problem, a height-balanced binary tree is defined as: . a binary tree in which the left and right subtrees of every node differ in height by no more than 1. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: true . Example 2: . Input: root = [1,2,2,3,3,null,null,4,4] Output: false . Example 3: . Input: root = [] Output: true . Constraints: . | The number of nodes in the tree is in the range [0, 5000]. | -104 &lt;= Node.val &lt;= 104 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { private boolean isBalanced = true; public boolean isBalanced(TreeNode root) { if(root == null) return true; if(root.left == null &amp;&amp; root.right == null) return true; getMaxDepth(root); return isBalanced; } public int getMaxDepth(TreeNode head){ if(head == null) return 0; if(head.left == null &amp;&amp; head.right == null) return 1; int left = getMaxDepth(head.left); int right = getMaxDepth(head.right); if(Math.abs(left - right) &gt; 1){ isBalanced = false; } return 1+ Math.max(left,right); } } . ",
    "url": "https://1001anjan.github.io/problem-24-Balanced-Binary-Tree/",
    "relUrl": "/problem-24-Balanced-Binary-Tree/"
  },"247": {
    "doc": "Permutations II",
    "title": "Permutations II",
    "content": "Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order. Example 1: . Input: nums = [1,1,2] Output: [[1,1,2], [1,2,1], [2,1,1]] . Example 2: . Input: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] . Constraints: . | 1 &lt;= nums.length &lt;= 8 | -10 &lt;= nums[i] &lt;= 10 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(nums); processPermute(nums,0,ans); return ans; } public void processPermute(int[] arr, int level, List&lt;List&lt;Integer&gt;&gt; ans){ if(level == arr.length){ List&lt;Integer&gt; l = new ArrayList&lt;&gt;(); for(int n : arr) l.add(n); ans.add(l); return; } HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = level; i &lt; arr.length; i++){ if(set.add(arr[i])){ swap(arr,i,level); processPermute(arr, level + 1, ans); swap(arr, i, level); } } } public void swap(int[] arr, int i, int j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } . ",
    "url": "https://1001anjan.github.io/problem-24-Permutations%20II/",
    "relUrl": "/problem-24-Permutations II/"
  },"248": {
    "doc": "Sum of All Odd Length Subarrays",
    "title": "Sum of All Odd Length Subarrays",
    "content": "Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr. A subarray is a contiguous subsequence of the array. Example 1: . Input: arr = [1,4,2,5,3] Output: 58 Explanation: The odd-length subarrays of arr and their sums are: [1] = 1 [4] = 4 [2] = 2 [5] = 5 [3] = 3 [1,4,2] = 7 [4,2,5] = 11 [2,5,3] = 10 [1,4,2,5,3] = 15 If we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58 . Example 2: . Input: arr = [1,2] Output: 3 Explanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3. Example 3: . Input: arr = [10,11,12] Output: 66 . Constraints: . | 1 &lt;= arr.length &lt;= 100 | 1 &lt;= arr[i] &lt;= 1000 | . Follow up: . Could you solve this problem in O(n) time complexity? . Solution: . class Solution { public int sumOddLengthSubarrays(int[] arr) { int sum = 0; for(int i = 0; i &lt; arr.length; i++){ // calculating no of times index will be present in all subarrays int allCount = (arr.length - i)*(i + 1); // calculate no of times index will be present in odd length subarrays int oddCount = allCount % 2 == 0 ? allCount/2 : allCount/2 + 1; sum += oddCount*arr[i]; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-240-Sum-of-All-Odd-Length-Subarrays/",
    "relUrl": "/problem-240-Sum-of-All-Odd-Length-Subarrays/"
  },"249": {
    "doc": "Rearrange Spaces Between Words",
    "title": "Rearrange Spaces Between Words",
    "content": "You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It’s guaranteed that text contains at least one word. Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text. Return the string after rearranging the spaces. Example 1: . Input: text = \" this is a sentence \" Output: \"this is a sentence\" Explanation: There are a total of 9 spaces and 4 words. We can evenly divide the 9 spaces between the words: 9 / (4-1) = 3 spaces. Example 2: . Input: text = \" practice makes perfect\" Output: \"practice makes perfect \" Explanation: There are a total of 7 spaces and 3 words. 7 / (3-1) = 3 spaces plus 1 extra space. We place this extra space at the end of the string. Constraints: . | 1 &lt;= text.length &lt;= 100 | text consists of lowercase English letters and ‘ ‘. | text contains at least one word. | . Solution: . class Solution { public String reorderSpaces(String text) { int totalLen = text.length(); if(totalLen == 1) return text; String[] words = text.trim().split(\"\\\\s+\"); int len = 0; for(String s : words) len += s.length(); int space = totalLen - len; boolean isOne = false; int extra = 0; if(words.length == 1){ isOne = true; }else{ extra = space - (space / (words.length - 1))*(words.length - 1); space = space / (words.length - 1); } StringBuilder sb = new StringBuilder(); for(String s : words){ sb.append(s); for(int i = 1; i &lt;= space; i++) sb.append(\" \"); } if(!isOne){ sb.setLength(sb.length() - space); } for(int i = 1; i &lt;= extra; i++) sb.append(\" \"); return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-241-Rearrange-Spaces-Between-Words/",
    "relUrl": "/problem-241-Rearrange-Spaces-Between-Words/"
  },"250": {
    "doc": "Crawler Log Folder",
    "title": "Crawler Log Folder",
    "content": "The Leetcode file system keeps a log each time some user performs a change folder operation. The operations are described below: . | ”../” : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder). | ”./” : Remain in the same folder. | “x/” : Move to the child folder named x (This folder is guaranteed to always exist). | . You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step. The file system starts in the main folder, then the operations in logs are performed. Return the minimum number of operations needed to go back to the main folder after the change folder operations. Example 1: . Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"] Output: 2 Explanation: Use this change folder operation \"../\" 2 times and go back to the main folder. Example 2: . Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"] Output: 3 . Example 3: . Input: logs = [\"d1/\",\"../\",\"../\",\"../\"] Output: 0 . Constraints: . | 1 &lt;= logs.length &lt;= 103 | 2 &lt;= logs[i].length &lt;= 10 | logs[i] contains lowercase English letters, digits, ‘.’, and ‘/’. | logs[i] follows the format described in the statement. | Folder names consist of lowercase English letters and digits. | . Solution: . class Solution { public int minOperations(String[] logs) { int level = 0; for(String s : logs){ if(s.length() == 3 &amp;&amp; s.charAt(0) == '.' &amp;&amp; s.charAt(1) == '.') { if(level &gt; 0) level--; }else if(s.charAt(0) != '.') level++; } return level; } } . ",
    "url": "https://1001anjan.github.io/problem-242-Crawler-Log-Folder/",
    "relUrl": "/problem-242-Crawler-Log-Folder/"
  },"251": {
    "doc": "Design Parking System",
    "title": "Design Parking System",
    "content": "Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size. Implement the ParkingSystem class: . | ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor. | bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true. | . Example 1: . Input [\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"] [[1, 1, 0], [1], [2], [3], [1]] Output [null, true, true, false, false] Explanation ParkingSystem parkingSystem = new ParkingSystem(1, 1, 0); parkingSystem.addCar(1); // return true because there is 1 available slot for a big car parkingSystem.addCar(2); // return true because there is 1 available slot for a medium car parkingSystem.addCar(3); // return false because there is no available slot for a small car parkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied. Constraints: . | 0 &lt;= big, medium, small &lt;= 1000 | carType is 1, 2, or 3 | At most 1000 calls will be made to addCar | . Solution: . class ParkingSystem { private int b; private int m; private int s; public ParkingSystem(int big, int medium, int small) { b = big; m = medium; s = small; } public boolean addCar(int carType) { if(carType == 1 &amp;&amp; b &gt; 0){ b--; return true; }else if(carType == 2 &amp;&amp; m &gt; 0){ m--; return true; }else if(carType == 3 &amp;&amp; s &gt; 0){ s--; return true; }else return false; } } /** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem obj = new ParkingSystem(big, medium, small); * boolean param_1 = obj.addCar(carType); */ . class ParkingSystem { int[] space = new int[4]; public ParkingSystem(int big, int medium, int small) { space[1] = big; space[2] = medium; space[3] = small; } public boolean addCar(int carType) { if (space[carType] &gt; 0) { space[carType]--; return true; } else { return false; } } } . ",
    "url": "https://1001anjan.github.io/problem-243-Design-Parking-System/",
    "relUrl": "/problem-243-Design-Parking-System/"
  },"252": {
    "doc": "Maximum Nesting Depth of the Parentheses",
    "title": "Maximum Nesting Depth of the Parentheses",
    "content": "A string is a valid parentheses string (denoted VPS) if it meets one of the following: . | It is an empty string “”, or a single character not equal to “(“ or “)”, | It can be written as AB (A concatenated with B), where A and B are VPS’s, or | It can be written as (A), where A is a VPS. | . We can similarly define the nesting depth depth(S) of any VPS S as follows: . | depth(“”) = 0 | depth(C) = 0, where C is a string with a single character not equal to “(“ or “)”. | depth(A + B) = max(depth(A), depth(B)), where A and B are VPS’s. | depth(“(“ + A + “)”) = 1 + depth(A), where A is a VPS. | For example, “”, “()()”, and “()(()())” are VPS’s (with nesting depths 0, 1, and 2), and “)(“ and “(()” are not VPS’s. | . Given a VPS represented as string s, return the nesting depth of s. Example 1: . Input: s = \"(1+(2*3)+((8)/4))+1\" Output: 3 Explanation: Digit 8 is inside of 3 nested parentheses in the string. Example 2: . Input: s = \"(1)+((2))+(((3)))\" Output: 3 . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of digits 0-9 and characters ‘+’, ‘-‘, ‘*’, ‘/’, ‘(‘, and ‘)’. | It is guaranteed that parentheses expression s is a VPS. | . Solution: . class Solution { public int maxDepth(String str) { Stack&lt;Character&gt; s = new Stack&lt;&gt;(); int depth = 0; for(char c : str.toCharArray()){ if(c == '(') s.push('('); else if(c == ')'){ depth = Math.max(depth, s.size()); s.pop(); } } return depth; } } . class Solution { public int maxDepth(String s) { int max = 0, count = 0; for(char c : s.toCharArray()){ if(c == '('){ count++; }else if(c == ')'){ count--; } max = Math.max(max,count); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-244-Maximum-Nesting-Depth-of-the-Parentheses/",
    "relUrl": "/problem-244-Maximum-Nesting-Depth-of-the-Parentheses/"
  },"253": {
    "doc": "Mean of Array After Removing Some Elements",
    "title": "Mean of Array After Removing Some Elements",
    "content": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements. Answers within 10-5 of the actual answer will be considered accepted. Example 1: . Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3] Output: 2.00000 Explanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2. Example 2: . Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0] Output: 4.00000 . Example 3: . Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4] Output: 4.77778 . Constraints: . | 20 &lt;= arr.length &lt;= 1000 | arr.length is a multiple of 20. | 0 &lt;= arr[i] &lt;= 105 | . Solution: . class Solution { public double trimMean(int[] arr) { Arrays.sort(arr); int d = arr.length / 20; double sum = 0.0; for(int i = d; i &lt; arr.length - d; i++){ sum += arr[i]; } return sum / (arr.length - 2*d); } } . ",
    "url": "https://1001anjan.github.io/problem-245-Mean-of-Array-After-Removing-Some-Elements/",
    "relUrl": "/problem-245-Mean-of-Array-After-Removing-Some-Elements/"
  },"254": {
    "doc": "Largest Substring Between Two Equal Characters",
    "title": "Largest Substring Between Two Equal Characters",
    "content": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1. A substring is a contiguous sequence of characters within a string. Example 1: . Input: s = \"aa\" Output: 0 Explanation: The optimal substring here is an empty substring between the two 'a's. Example 2: . Input: s = \"abca\" Output: 2 Explanation: The optimal substring here is \"bc\". Example 3: . Input: s = \"cbzxy\" Output: -1 Explanation: There are no characters that appear twice in s. Constraints: . | 1 &lt;= s.length &lt;= 300 | s contains only lowercase English letters. | . Solution: . class Solution { public int maxLengthBetweenEqualCharacters(String s) { int[][] index = new int[26][2]; for(int i = 0; i &lt; s.length(); i++){ char c = s.charAt(i); if(index[c - 'a'][0] == 0) index[c - 'a'][0] = i + 1; else index[c - 'a'][1] = i + 1; } int max = index[0][1] - index[0][0] - 1; for(int i = 1; i &lt; 26; i++){ max = Math.max(max, index[i][1] - index[i][0] - 1); } return max; } } . O(n*n) Time complexity . class Solution { public int maxLengthBetweenEqualCharacters(String s) { int res = -1; for(int i=0; i&lt;s.length(); i++){ char c = s.charAt(i); res = Math.max(res, s.lastIndexOf(c) - s.indexOf(c)-1); } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-246-Largest-Substring-Between-Two-Equal-Characters/",
    "relUrl": "/problem-246-Largest-Substring-Between-Two-Equal-Characters/"
  },"255": {
    "doc": "Sort Array by Increasing Frequency",
    "title": "Sort Array by Increasing Frequency",
    "content": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order. Return the sorted array. Example 1: . Input: nums = [1,1,2,2,2,3] Output: [3,1,1,2,2,2] Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3. Example 2: . Input: nums = [2,3,1,3,2] Output: [1,3,3,2,2] Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order. Example 3: . Input: nums = [-1,1,-6,4,5,-6,1,4,1] Output: [5,-1,4,4,-6,-6,1,1,1] . Constraints: . | 1 &lt;= nums.length &lt;= 100 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] frequencySort(int[] nums) { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int n : nums){ map.put(n,map.getOrDefault(n,0) + 1); } List&lt;Map.Entry&lt;Integer,Integer&gt;&gt; list = new LinkedList&lt;Map.Entry&lt;Integer,Integer&gt;&gt;(map.entrySet()); Collections.sort(list,(i1,i2) -&gt; { if(i1.getValue() == i2.getValue()) return i2.getKey().compareTo(i1.getKey()); else return i1.getValue().compareTo(i2.getValue()); }); int i = 0; for(Map.Entry&lt;Integer,Integer&gt; m : list){ for(int j = 1; j &lt;= m.getValue(); j++) nums[i++] = m.getKey(); } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-247-Sort-Array-by-Increasing-Frequency/",
    "relUrl": "/problem-247-Sort-Array-by-Increasing-Frequency/"
  },"256": {
    "doc": "Get Maximum in Generated Array",
    "title": "Get Maximum in Generated Array",
    "content": "You are given an integer n. A 0-indexed integer array nums of length n + 1 is generated in the following way: . | nums[0] = 0 | nums[1] = 1 | nums[2 * i] = nums[i] when 2 &lt;= 2 * i &lt;= n | nums[2 * i + 1] = nums[i] + nums[i + 1] when 2 &lt;= 2 * i + 1 &lt;= n Return the maximum integer in the array nums​​​. | . Example 1: . Input: n = 7 Output: 3 Explanation: According to the given rules: nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 Hence, nums = [0,1,1,2,1,3,2,3], and the maximum is max(0,1,1,2,1,3,2,3) = 3. Example 2: . Input: n = 2 Output: 1 Explanation: According to the given rules, nums = [0,1,1]. The maximum is max(0,1,1) = 1. Example 3: . Input: n = 3 Output: 2 Explanation: According to the given rules, nums = [0,1,1,2]. The maximum is max(0,1,1,2) = 2. Constraints: . | 0 &lt;= n &lt;= 100 | . Solution: . class Solution { public int getMaximumGenerated(int n) { if(n == 0) return 0; if(n == 1) return 1; int[] dp = new int[n + 1]; dp[0] = 0; dp[1] = 1; int max = 1; for(int i = 2; i &lt; n + 1; i++){ if(i % 2 == 0) dp[i] = dp[i / 2]; else dp[i] = dp[i / 2] + dp[(i / 2) + 1]; max = Math.max(max, dp[i]); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-248-Sort-Array-by-Increasing-Frequency/",
    "relUrl": "/problem-248-Sort-Array-by-Increasing-Frequency/"
  },"257": {
    "doc": "Defuse the Bomb",
    "title": "Defuse the Bomb",
    "content": "You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k. To decrypt the code, you must replace every number. All the numbers are replaced simultaneously. | If k &gt; 0, replace the ith number with the sum of the next k numbers. | If k &lt; 0, replace the ith number with the sum of the previous k numbers. | If k == 0, replace the ith number with 0. As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1]. | . Given the circular array code and an integer key k, return the decrypted code to defuse the bomb! . Example 1: . Input: code = [5,7,1,4], k = 3 Output: [12,10,16,13] Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is [7+1+4, 1+4+5, 4+5+7, 5+7+1]. Notice that the numbers wrap around. Example 2: . Input: code = [1,2,3,4], k = 0 Output: [0,0,0,0] Explanation: When k is zero, the numbers are replaced by 0. Example 3: . Input: code = [2,4,9,3], k = -2 Output: [12,5,6,13] Explanation: The decrypted code is [3+9, 2+3, 4+2, 9+4]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers. Constraints: . | n == code.length | 1 &lt;= n &lt;= 100 | 1 &lt;= code[i] &lt;= 100 | -(n - 1) &lt;= k &lt;= n - 1 | . Solution: O(n*k) . class Solution { public int[] decrypt(int[] code, int k) { int[] ans = new int[code.length]; if(k == 0) return ans; if(k &gt; 0){ for(int i = 0; i &lt; code.length; i++){ int sum = 0; for(int j = 1; j &lt;= k; j++){ sum += code[(i + j) % code.length]; } ans[i] = sum; } }else{ for(int i = 0; i &lt; code.length; i++){ int sum = 0; for(int j = 0; j &lt; Math.abs(k); j++){ sum += code[(code.length + k + i + j) % code.length]; } ans[i] = sum; } } return ans; } } . Faster O(n) . class Solution { public int[] decrypt(int[] code, int k) { if(k==0) return new int[code.length]; int n = code.length; int[] result = new int[code.length]; int start, end; start = k &gt; 0? 1: code.length + k; end = k &gt; 0? k : n-1; int sum = 0; for(int i = start; i &lt;= end; i++) sum += code[i]; for(int i=0;i&lt;code.length;i++){ result[i] = sum; sum -= code[start]; start = (start+1)%n; end = (end+1)%n; sum += code[end]; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-249-Defuse-the-Bomb/",
    "relUrl": "/problem-249-Defuse-the-Bomb/"
  },"258": {
    "doc": "Minimum Depth of Binary Tree",
    "title": "Minimum Depth of Binary Tree",
    "content": "Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Note: A leaf is a node with no children. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 2 . Example 2: . Input: root = [2,null,3,null,4,null,5,null,6] Output: 5 . Constraints: . | The number of nodes in the tree is in the range [0, 105]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDepth(TreeNode root) { if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; int left = Integer.MAX_VALUE; int right = Integer.MAX_VALUE; if(root.left != null) { left = minDepth(root.left); } if(root.right != null){ right = minDepth(root.right); } return 1 + Math.min(left,right ); } } . Non-recursive . class Solution { public int minDepth(TreeNode root) { if (root == null) return 0; Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); int depth = 1; while (true){ int level = queue.size(); for (int i = 0; i &lt; level; i++){ TreeNode data = queue.poll(); if (data.left == null &amp;&amp; data.right == null) return depth; if (data.left != null) queue.offer(data.left); if (data.right != null) queue.offer(data.right); } depth++; } } } . ",
    "url": "https://1001anjan.github.io/problem-25-Minimum-Depth-of-Binary-Tree/",
    "relUrl": "/problem-25-Minimum-Depth-of-Binary-Tree/"
  },"259": {
    "doc": "Rotate Image",
    "title": "Rotate Image",
    "content": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] . Example 2: . Input: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] . Constraints: . | n == matrix.length == matrix[i].length | 1 &lt;= n &lt;= 20 | -1000 &lt;= matrix[i][j] &lt;= 1000 | . Solution: . class Solution { public void rotate(int[][] matrix) { int n = matrix.length; for(int i = 0; i &lt; n/2; i++){ for(int j = i; j &lt; n - i - 1; j++){ int temp = matrix[i][j]; matrix[i][j] = matrix[n - j - 1][i]; matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1]; matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1]; matrix[j][n - i - 1] = temp; } } } } . ",
    "url": "https://1001anjan.github.io/problem-25-Rotate%20Image/",
    "relUrl": "/problem-25-Rotate Image/"
  },"260": {
    "doc": "Check If Two String Arrays are Equivalent",
    "title": "Check If Two String Arrays are Equivalent",
    "content": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise. A string is represented by an array if the array elements concatenated in order forms the string. Example 1: . Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"] Output: true Explanation: word1 represents string \"ab\" + \"c\" -&gt; \"abc\" word2 represents string \"a\" + \"bc\" -&gt; \"abc\" The strings are the same, so return true. Example 2: . Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"] Output: false . Example 3: . Input: word1 = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"] Output: true . Constraints: . | 1 &lt;= word1.length, word2.length &lt;= 103 | 1 &lt;= word1[i].length, word2[i].length &lt;= 103 | 1 &lt;= sum(word1[i].length), sum(word2[i].length) &lt;= 103 | word1[i] and word2[i] consist of lowercase letters. | . Solution: . class Solution { public boolean arrayStringsAreEqual(String[] word1, String[] word2) { StringBuilder sb1 = new StringBuilder(); StringBuilder sb2 = new StringBuilder(); for(String s : word1) sb1.append(s); for(String s : word2) sb2.append(s); return sb1.toString().equals(sb2.toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-250-Check-If-Two-String-Arrays-are-Equivalent/",
    "relUrl": "/problem-250-Check-If-Two-String-Arrays-are-Equivalent/"
  },"261": {
    "doc": "Maximum Repeating Substring",
    "title": "Check If Two String Arrays are Equivalent",
    "content": "For a string sequence, a string word is k-repeating if word concatenated k times is a substring of sequence. The word’s maximum k-repeating value is the highest value k where word is k-repeating in sequence. If word is not a substring of sequence, word’s maximum k-repeating value is 0. Given strings sequence and word, return the maximum k-repeating value of word in sequence. Example 1: . Input: sequence = \"ababc\", word = \"ab\" Output: 2 Explanation: \"abab\" is a substring in \"ababc\". Example 2: . Input: sequence = \"ababc\", word = \"ba\" Output: 1 Explanation: \"ba\" is a substring in \"ababc\". \"baba\" is not a substring in \"ababc\". Example 3: . Input: sequence = \"ababc\", word = \"ac\" Output: 0 Explanation: \"ac\" is not a substring in \"ababc\". Constraints: . | 1 &lt;= sequence.length &lt;= 100 | 1 &lt;= word.length &lt;= 100 | sequence and word contains only lowercase English letters. | . Solution: . class Solution { public int maxRepeating(String sequence, String word) { StringBuilder umang = new StringBuilder(word); int count =0; while(true){ if(sequence.contains(umang)){ count+=1; umang.append(word); } else{ return count; } } } } // The main concept here is , we have to form a possible longest substring using concatenated 'word' in 'sequence' and keep increasing our count of repeating ' word'. ",
    "url": "https://1001anjan.github.io/problem-251-Maximum-Repeating-Substring/#check-if-two-string-arrays-are-equivalent",
    "relUrl": "/problem-251-Maximum-Repeating-Substring/#check-if-two-string-arrays-are-equivalent"
  },"262": {
    "doc": "Maximum Repeating Substring",
    "title": "Maximum Repeating Substring",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-251-Maximum-Repeating-Substring/",
    "relUrl": "/problem-251-Maximum-Repeating-Substring/"
  },"263": {
    "doc": "Richest Customer Wealth",
    "title": "Richest Customer Wealth",
    "content": "You are given an m x n integer grid accounts where accounts[i][j] is the amount of money the i​​​​​​​​​​​th​​​​ customer has in the j​​​​​​​​​​​th​​​​ bank. Return the wealth that the richest customer has. A customer’s wealth is the amount of money they have in all their bank accounts. The richest customer is the customer that has the maximum wealth. Example 1: . Input: accounts = [[1,2,3],[3,2,1]] Output: 6 Explanation: 1st customer has wealth = 1 + 2 + 3 = 6 2nd customer has wealth = 3 + 2 + 1 = 6 Both customers are considered the richest with a wealth of 6 each, so return 6. Example 2: . Input: accounts = [[1,5],[7,3],[3,5]] Output: 10 Explanation: 1st customer has wealth = 6 2nd customer has wealth = 10 3rd customer has wealth = 8 The 2nd customer is the richest with a wealth of 10. Example 3: . Input: accounts = [[2,8,7],[7,1,3],[1,9,5]] Output: 17 . Constraints: . | m == accounts.length | n == accounts[i].length | 1 &lt;= m, n &lt;= 50 | 1 &lt;= accounts[i][j] &lt;= 100 | . Solution: . class Solution { public int maximumWealth(int[][] accounts) { int tempWealth; int maxWealth = sumArray(accounts[0]); for(int i = 1; i &lt; accounts.length; i++){ tempWealth = sumArray(accounts[i]); if(tempWealth &gt; maxWealth) maxWealth = tempWealth; } return maxWealth; } public int sumArray(int arr[]){ int sum = 0; for(int i=0; i &lt; arr.length; i++){ sum += arr[i]; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-252-Richest-Customer-Wealth/",
    "relUrl": "/problem-252-Richest-Customer-Wealth/"
  },"264": {
    "doc": "Goal Parser Interpretation",
    "title": "Goal Parser Interpretation",
    "content": "You own a Goal Parser that can interpret a string command. The command consists of an alphabet of “G”, “()” and/or “(al)” in some order. The Goal Parser will interpret “G” as the string “G”, “()” as the string “o”, and “(al)” as the string “al”. The interpreted strings are then concatenated in the original order. Given the string command, return the Goal Parser’s interpretation of command. Example 1: . Input: command = \"G()(al)\" Output: \"Goal\" Explanation: The Goal Parser interprets the command as follows: G -&gt; G () -&gt; o (al) -&gt; al The final concatenated result is \"Goal\". Example 2: . Input: command = \"G()()()()(al)\" Output: \"Gooooal\" . Example 3: . Input: command = \"(al)G(al)()()G\" Output: \"alGalooG\" . Constraints: . | 1 &lt;= command.length &lt;= 100 | command consists of “G”, “()”, and/or “(al)” in some order. | . Solution: . class Solution { public String interpret(String command) { StringBuilder sb = new StringBuilder(); char[] s = command.toCharArray(); int i = 0; while(i &lt; s.length){ if(s[i] == 'G'){ sb.append(\"G\"); i++; }else if(s[i] == '('){ if(s[i + 1] == ')'){ sb.append(\"o\"); i = i+ 2; }else{ i++; while(s[i] != ')') sb.append(s[i++]); i++; } } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-253-Goal-Parser%20Interpretation/",
    "relUrl": "/problem-253-Goal-Parser Interpretation/"
  },"265": {
    "doc": "Count the Number of Consistent Strings",
    "title": "Count the Number of Consistent Strings",
    "content": "You are given a string allowed consisting of distinct characters and an array of strings words. A string is consistent if all characters in the string appear in the string allowed. Return the number of consistent strings in the array words. Example 1: . Input: allowed = \"ab\", words = [\"ad\",\"bd\",\"aaab\",\"baa\",\"badab\"] Output: 2 Explanation: Strings \"aaab\" and \"baa\" are consistent since they only contain characters 'a' and 'b'. Example 2: . Input: allowed = \"abc\", words = [\"a\",\"b\",\"c\",\"ab\",\"ac\",\"bc\",\"abc\"] Output: 7 Explanation: All strings are consistent. Example 3: . Input: allowed = \"cad\", words = [\"cc\",\"acd\",\"b\",\"ba\",\"bac\",\"bad\",\"ac\",\"d\"] Output: 4 Explanation: Strings \"cc\", \"acd\", \"ac\", and \"d\" are consistent. Constraints: . | 1 &lt;= words.length &lt;= 104 | 1 &lt;= allowed.length &lt;= 26 | 1 &lt;= words[i].length &lt;= 10 | The characters in allowed are distinct. | words[i] and allowed contain only lowercase English letters. | . Solution: . class Solution { public int countConsistentStrings(String allowed, String[] words) { boolean[] a = new boolean[26]; for(char c : allowed.toCharArray()) a[c - 'a'] = true; int count = 0; for(String str : words){ boolean f = true; for(char c : str.toCharArray()){ if(!a[c - 'a']){ f = false; break; } } if(f) count++; } return count; } } . class Solution { public int countConsistentStrings(String allowed, String[] words) { int mask =0; for (int i =0; i&lt;allowed.length(); i++) { mask |= 1 &lt;&lt; (allowed.charAt(i) - 'a'); } int count = 0; outer: for (int i =0; i&lt; words.length; i++) { for (int j = 0; j&lt;words[i].length(); j++) { if ((mask &amp; (1 &lt;&lt; words[i].charAt(j) - 'a')) == 0) continue outer; } count ++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-254-Count-the-Number-of-Consistent-Strings/",
    "relUrl": "/problem-254-Count-the-Number-of-Consistent-Strings/"
  },"266": {
    "doc": "Count of Matches in Tournament",
    "title": "Count of Matches in Tournament",
    "content": "You are given an integer n, the number of teams in a tournament that has strange rules: . | If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round. | If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round. Return the number of matches played in the tournament until a winner is decided. | . Example 1: . Input: n = 7 Output: 6 Explanation: Details of the tournament: - 1st Round: Teams = 7, Matches = 3, and 4 teams advance. - 2nd Round: Teams = 4, Matches = 2, and 2 teams advance. - 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 3 + 2 + 1 = 6. Example 2: . Input: n = 14 Output: 13 Explanation: Details of the tournament: - 1st Round: Teams = 14, Matches = 7, and 7 teams advance. - 2nd Round: Teams = 7, Matches = 3, and 4 teams advance. - 3rd Round: Teams = 4, Matches = 2, and 2 teams advance. - 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner. Total number of matches = 7 + 3 + 2 + 1 = 13. Constraints: . | 1 &lt;= n &lt;= 200 | . Solution: . class Solution { public int numberOfMatches(int n) { int count = 0; while(n != 1){ if(n % 2 == 0){ count += n / 2; n = n / 2; }else{ count += (n - 1)/2; n = (n - 1)/2 + 1; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-255-Count-of-Matches-in-Tournament/",
    "relUrl": "/problem-255-Count-of-Matches-in-Tournament/"
  },"267": {
    "doc": "Reformat Phone Number",
    "title": "Reformat Phone Number",
    "content": "You are given a phone number as a string number. number consists of digits, spaces ‘ ‘, and/or dashes ‘-‘. You would like to reformat the phone number in a certain manner. Firstly, remove all spaces and dashes. Then, group the digits from left to right into blocks of length 3 until there are 4 or fewer digits. The final digits are then grouped as follows: . | 2 digits: A single block of length 2. | 3 digits: A single block of length 3. | 4 digits: Two blocks of length 2 each. The blocks are then joined by dashes. Notice that the reformatting process should never produce any blocks of length 1 and produce at most two blocks of length 2. | . Return the phone number after formatting. Example 1: . Input: number = \"1-23-45 6\" Output: \"123-456\" Explanation: The digits are \"123456\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 3 digits remaining, so put them in a single block of length 3. The 2nd block is \"456\". Joining the blocks gives \"123-456\". Example 2: . Input: number = \"123 4-567\" Output: \"123-45-67\" Explanation: The digits are \"1234567\". Step 1: There are more than 4 digits, so group the next 3 digits. The 1st block is \"123\". Step 2: There are 4 digits left, so split them into two blocks of length 2. The blocks are \"45\" and \"67\". Joining the blocks gives \"123-45-67\". Example 3: . Input: number = \"123 4-5678\" Output: \"123-456-78\" Explanation: The digits are \"12345678\". Step 1: The 1st block is \"123\". Step 2: The 2nd block is \"456\". Step 3: There are 2 digits left, so put them in a single block of length 2. The 3rd block is \"78\". Joining the blocks gives \"123-456-78\". Constraints: . | 2 &lt;= number.length &lt;= 100 | number consists of digits and the characters ‘-‘ and ‘ ‘. | There are at least two digits in number. | . Solution: . class Solution { public String reformatNumber(String number) { StringBuilder sb = new StringBuilder(); for(char c : number.toCharArray()){ if(c != '-' &amp;&amp; c != ' ') sb.append(c); } char[] chs = sb.toString().toCharArray(); sb.setLength(0); int i = 0; int d = 3; while(i &lt; chs.length){ if(i == chs.length - 4 || i == chs.length - 2){ d = 2; }else{ d = 3; } int k = i; while(i &lt; k + d &amp;&amp; i &lt; chs.length){ sb.append(chs[i]); i++; } if(i != chs.length) sb.append(\"-\"); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-256-Reformat%20Phone%20Number/",
    "relUrl": "/problem-256-Reformat Phone Number/"
  },"268": {
    "doc": "Number of Students Unable to Eat Lunch",
    "title": "Number of Students Unable to Eat Lunch",
    "content": "The school cafeteria offers circular and square sandwiches at lunch break, referred to by numbers 0 and 1 respectively. All students stand in a queue. Each student either prefers square or circular sandwiches. The number of sandwiches in the cafeteria is equal to the number of students. The sandwiches are placed in a stack. At each step: . | If the student at the front of the queue prefers the sandwich on the top of the stack, they will take it and leave the queue. | Otherwise, they will leave it and go to the queue’s end. This continues until none of the queue students want to take the top sandwich and are thus unable to eat. | . You are given two integer arrays students and sandwiches where sandwiches[i] is the type of the i​​​​​​th sandwich in the stack (i = 0 is the top of the stack) and students[j] is the preference of the j​​​​​​th student in the initial queue (j = 0 is the front of the queue). Return the number of students that are unable to eat. Example 1: . Input: students = [1,1,0,0], sandwiches = [0,1,0,1] Output: 0 Explanation: - Front student leaves the top sandwich and returns to the end of the line making students = [1,0,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,0,1,1]. - Front student takes the top sandwich and leaves the line making students = [0,1,1] and sandwiches = [1,0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [1,1,0]. - Front student takes the top sandwich and leaves the line making students = [1,0] and sandwiches = [0,1]. - Front student leaves the top sandwich and returns to the end of the line making students = [0,1]. - Front student takes the top sandwich and leaves the line making students = [1] and sandwiches = [1]. - Front student takes the top sandwich and leaves the line making students = [] and sandwiches = []. Hence all students are able to eat. Example 2: . Input: students = [1,1,1,0,0,1], sandwiches = [1,0,0,0,1,1] Output: 3 . Constraints: . | 1 &lt;= students.length, sandwiches.length &lt;= 100 | students.length == sandwiches.length | sandwiches[i] is 0 or 1. | students[i] is 0 or 1. | . Solution: . class Solution { public int countStudents(int[] students, int[] sandwiches) { Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); for(int n : students) q.add(n); int c = q.size(); int i = 0; while(c &gt; 0){ int n = q.poll(); if(n == sandwiches[i]){ i++; c = q.size(); }else{ q.add(n); c--; } } return q.size(); } } . Array Implementation and faster . class Solution { public int countStudents(int[] students, int[] sandwiches) { int c0, c1; c0 = c1 = 0; for(int n : students){ if(n == 0) c0++; else c1++; } for(int n : sandwiches){ if(n == 0){ if(c0 == 0) break; c0--; }else{ if(c1 == 0) break; c1--; } } return c1 + c0; } } . ",
    "url": "https://1001anjan.github.io/problem-256-Number-of-Students-Unable-to-Eat-Lunch/",
    "relUrl": "/problem-256-Number-of-Students-Unable-to-Eat-Lunch/"
  },"269": {
    "doc": "Determine if String Halves Are Alike",
    "title": "Determine if String Halves Are Alike",
    "content": "You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half. Two strings are alike if they have the same number of vowels (‘a’, ‘e’, ‘i’, ‘o’, ‘u’, ‘A’, ‘E’, ‘I’, ‘O’, ‘U’). Notice that s contains uppercase and lowercase letters. Return true if a and b are alike. Otherwise, return false. Example 1: . Input: s = \"book\" Output: true Explanation: a = \"bo\" and b = \"ok\". a has 1 vowel and b has 1 vowel. Therefore, they are alike. Example 2: . Input: s = \"textbook\" Output: false Explanation: a = \"text\" and b = \"book\". a has 1 vowel whereas b has 2. Therefore, they are not alike. Notice that the vowel o is counted twice. Constraints: . | 2 &lt;= s.length &lt;= 1000 | s.length is even. | s consists of uppercase and lowercase letters. | . Solution . class Solution { public boolean halvesAreAlike(String s) { int c = 0; for(int i = 0; i &lt; s.length() / 2; i++){ if(isVowel(s.charAt(i))) c++; } for(int i = s.length() / 2; i &lt; s.length(); i++){ if(isVowel(s.charAt(i))) c--; } return c == 0; } public boolean isVowel(char c){ if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') return true; return false; } } . Faster execution approach . class Solution { public boolean halvesAreAlike(String s) { String s1 = s.substring(0, s.length() / 2); String s2 = s.substring(s.length() / 2); return helper(s1) == helper(s2); } private static int helper(String s) { int count = 0; for (char c : s.toCharArray()){ if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-257-Determine-if-String-Halves-Are-Alike/",
    "relUrl": "/problem-257-Determine-if-String-Halves-Are-Alike/"
  },"270": {
    "doc": "Calculate Money in Leetcode Bank",
    "title": "Calculate Money in Leetcode Bank",
    "content": "Hercy wants to save money for his first car. He puts money in the Leetcode bank every day. He starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. Given n, return the total amount of money he will have in the Leetcode bank at the end of the nth day. Example 1: . Input: n = 4 Output: 10 Explanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10. Example 2: . Input: n = 10 Output: 37 Explanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2. Example 3: . Input: n = 20 Output: 96 Explanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96. Constraints: . | 1 &lt;= n &lt;= 1000 | . https://leetcode.com/problems/calculate-money-in-leetcode-bank/ . Solution: . ",
    "url": "https://1001anjan.github.io/problem-258-Calculate-Money-in-Leetcode-Bank/",
    "relUrl": "/problem-258-Calculate-Money-in-Leetcode-Bank/"
  },"271": {
    "doc": "Group Anagrams",
    "title": "Group Anagrams",
    "content": "Given an array of strings strs, group the anagrams together. You can return the answer in any order. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: . Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"] Output: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] . Example 2: . Input: strs = [\"\"] Output: [[\"\"]] . Example 3: . Input: strs = [\"a\"] Output: [[\"a\"]] . Constraints: . | 1 &lt;= strs.length &lt;= 104 | 0 &lt;= strs[i].length &lt;= 100 | strs[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { int[][] dp = new int[strs.length][26]; for(int i = 0; i &lt; strs.length; i++){ for(char ch : strs[i].toCharArray()){ dp[i][ch - 'a']++; } } List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;(); Set&lt;String&gt; used = new HashSet&lt;&gt;(); for(int i = 0; i &lt; strs.length; i++){ if(!used.add(strs[i])) continue; List&lt;String&gt; group = new ArrayList&lt;&gt;(); group.add(strs[i]); for(int j = i + 1; j &lt; dp.length; j++){ if(i == j) continue; int k = 0; while(k &lt; 26){ if(dp[i][k] != dp[j][k]) break; k++; } if(k == 26){ used.add(strs[j]); group.add(strs[j]); } } ans.add(group); } return ans; } } . class Solution { public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) { if (strs == null || strs.length == 0) return new ArrayList&lt;&gt;(); Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String s : strs) { char[] ca = new char[26]; for (char c : s.toCharArray()) ca[c - 'a']++; String keyStr = String.valueOf(ca); if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;&gt;()); map.get(keyStr).add(s); } return new ArrayList&lt;&gt;(map.values()); } } . ",
    "url": "https://1001anjan.github.io/problem-26-Group%20Anagrams/",
    "relUrl": "/problem-26-Group Anagrams/"
  },"272": {
    "doc": "Path Sum",
    "title": "Path Sum",
    "content": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum. A leaf is a node with no children. Example 1: . Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2: . Input: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --&gt; 2): The sum is 3. (1 --&gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3: . Input: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. Constraints: . | The number of nodes in the tree is in the range [0, 5000]. | -1000 &lt;= Node.val &lt;= 1000 | -1000 &lt;= targetSum &lt;= 1000 | . Solution . Non-Recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if(root == null) return false; Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;(); Map&lt;TreeNode, Relation&gt; map = new HashMap&lt;TreeNode, Relation&gt;(); stack.push(root); map.put(root, new Relation(null, root.val)); TreeNode ptr; int sum = 0; Relation rl; while(!stack.isEmpty()){ ptr = stack.pop(); rl = map.get(ptr); if(rl.parent != null){ sum = map.get(rl.parent).sumVal + ptr.val; }else{ sum = ptr.val; } if(ptr.left == null &amp;&amp; ptr.right == null &amp;&amp; sum == targetSum) return true; if(ptr.right != null) { stack.push(ptr.right); map.put(ptr.right,new Relation(ptr, sum+ptr.right.val)); } if(ptr.left != null) { stack.push(ptr.left); map.put(ptr.left,new Relation(ptr, sum+ptr.left.val)); } } return false; } } class Relation{ public TreeNode parent; public int sumVal; public Relation(TreeNode node, int val){ parent = node; sumVal = val; } } . Recursive . class Solution { public boolean hasPathSum(TreeNode root, int targetSum) { if (root == null) return false; return solve(root, targetSum); } public boolean solve(TreeNode root, int targetSum) { if (root == null) return false; if (root != null &amp;&amp; root.left == null &amp;&amp; root.right == null) { return (targetSum-root.val) == 0; } boolean a = solve(root.left, targetSum-root.val); boolean b = solve(root.right, targetSum-root.val); return a || b; } } . ",
    "url": "https://1001anjan.github.io/problem-26-Path-Sum/",
    "relUrl": "/problem-26-Path-Sum/"
  },"273": {
    "doc": "Decode XORed Array",
    "title": "Decode XORed Array",
    "content": "There is a hidden integer array arr that consists of n non-negative integers. It was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3]. You are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0]. Return the original array arr. It can be proved that the answer exists and is unique. Example 1: . Input: encoded = [1,2,3], first = 1 Output: [1,0,2,1] Explanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3] . Example 2: . Input: encoded = [6,2,7,3], first = 4 Output: [4,2,0,7,4] . Constraints: . | 2 &lt;= n &lt;= 104 | encoded.length == n - 1 | 0 &lt;= encoded[i] &lt;= 105 | 0 &lt;= first &lt;= 105 | . Solution: . class Solution { public int[] decode(int[] encoded, int first) { int[] ans = new int[encoded.length + 1]; ans[0] = first; for(int i = 1; i &lt; encoded.length + 1; i++){ ans[i] = ans[i - 1] ^ encoded[i - 1]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-259-Decode-XORed-Array/",
    "relUrl": "/problem-259-Decode-XORed-Array/"
  },"274": {
    "doc": "Find the Highest Altitude",
    "title": "Find the Highest Altitude",
    "content": "There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0. You are given an integer array gain of length n where gain[i] is the net gain in altitude between points i​​​​​​ and i + 1 for all (0 &lt;= i &lt; n). Return the highest altitude of a point. Example 1: . Input: gain = [-5,1,5,0,-7] Output: 1 Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1. Example 2: . Input: gain = [-4,-3,-2,-1,4,3,2] Output: 0 Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0. Constraints: . | n == gain.length | 1 &lt;= n &lt;= 100 | -100 &lt;= gain[i] &lt;= 100 | . Solution: . class Solution { public int largestAltitude(int[] gain) { int max = 0; int curr = 0; for(int n : gain){ curr = curr + n; max = Math.max(max,curr); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-260-Find-the-Highest-Altitude/",
    "relUrl": "/problem-260-Find-the-Highest-Altitude/"
  },"275": {
    "doc": "Latest Time by Replacing Hidden Digits",
    "title": "Latest Time by Replacing Hidden Digits",
    "content": "You are given a string time in the form of hh:mm, where some of the digits in the string are hidden (represented by ?). The valid times are those inclusively between 00:00 and 23:59. Return the latest valid time you can get from time by replacing the hidden digits. Example 1: . Input: time = \"2?:?0\" Output: \"23:50\" Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50. Example 2: . Input: time = \"0?:3?\" Output: \"09:39\" . Example 3: . Input: time = \"1?:22\" Output: \"19:22\" . Constraints: . | time is in the format hh:mm. | It is guaranteed that you can produce a valid time from the given string. | . Solution: . class Solution { public String maximumTime(String t) { char[] time = t.toCharArray(); if(time[4]=='?'){ time[4]='9'; } if(time[3]=='?'){ time[3]='5'; } if(time[0]=='?'){ if(time[1]=='1'||time[1]=='2'||time[1]=='3'||time[1]=='0'){ time[0]='2'; } else if(time[1]=='?'){ time[0]='2'; }else{ time[0]='1'; } } if(time[1]=='?'){ if(time[0]=='0'){ time[1]='9'; } else if(time[0]=='1'){ time[1]='9'; }else if(time[0]=='2'){ time[1]='3'; } } return new String(time); } } . ",
    "url": "https://1001anjan.github.io/problem-262-Latest-Time-by-Replacing-Hidden-Digits/",
    "relUrl": "/problem-262-Latest-Time-by-Replacing-Hidden-Digits/"
  },"276": {
    "doc": "Maximum Number of Balls in a Box",
    "title": "Maximum Number of Balls in a Box",
    "content": "You are working in a ball factory where you have n balls numbered from lowLimit up to highLimit inclusive (i.e., n == highLimit - lowLimit + 1), and an infinite number of boxes numbered from 1 to infinity. Your job at this factory is to put each ball in the box with a number equal to the sum of digits of the ball’s number. For example, the ball number 321 will be put in the box number 3 + 2 + 1 = 6 and the ball number 10 will be put in the box number 1 + 0 = 1. Given two integers lowLimit and highLimit, return the number of balls in the box with the most balls. Example 1: . Input: lowLimit = 1, highLimit = 10 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 2 1 1 1 1 1 1 1 1 0 0 ... Box 1 has the most number of balls with 2 balls. Example 2: . Input: lowLimit = 5, highLimit = 15 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 ... Ball Count: 1 1 1 1 2 2 1 1 1 0 0 ... Boxes 5 and 6 have the most number of balls with 2 balls in each. Example 3: . Input: lowLimit = 19, highLimit = 28 Output: 2 Explanation: Box Number: 1 2 3 4 5 6 7 8 9 10 11 12 ... Ball Count: 0 1 1 1 1 1 1 1 1 2 0 0 ... Box 10 has the most number of balls with 2 balls. Constraints: . | 1 &lt;= lowLimit &lt;= highLimit &lt;= 10^5 | . Solution: . class Solution { public int countBalls(int lowLimit, int highLimit) { Map&lt;Integer,Integer&gt; m = new HashMap&lt;&gt;(); int max = 0; int key = getKey(lowLimit); m.put(key, 1); max = Math.max(max,m.get(key)); for(int i = lowLimit + 1; i &lt;= highLimit; i++){ if(i % 10 == 0){ key = getKey(i); }else{ key++; } m.put(key, m.getOrDefault(key,0) + 1); max = Math.max(max,m.get(key)); } return max; } public int getKey(int n){ int sum = 0; while(n &gt; 0){ sum += n%10; n = n / 10; } return sum; } } . Faster . /** INPUT :- 1 &lt;= lowLimit &lt;= highLimit &lt;= 10^5 so the max number of boxes that can be there are 99999 = 45. **/ class Solution { public int countBalls(int lowLimit, int highLimit) { int[] boxes = new int[46]; int max = 0; int key = getKey(lowLimit); boxes[key]++; max = Math.max(max,boxes[key]); for(int i = lowLimit + 1; i &lt;= highLimit; i++){ if(i % 10 == 0){ key = getKey(i); }else{ key++; } boxes[key]++; max = Math.max(max,boxes[key]); } return max; } public int getKey(int n){ int sum = 0; while(n &gt; 0){ sum += n%10; n = n / 10; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-263-Maximum-Number-of-Balls-in-a-Box/",
    "relUrl": "/problem-263-Maximum-Number-of-Balls-in-a-Box/"
  },"277": {
    "doc": "Sum of Unique Elements",
    "title": "Sum of Unique Elements",
    "content": "You are given an integer array nums. The unique elements of an array are the elements that appear exactly once in the array. Return the sum of all the unique elements of nums. Example 1: . Input: nums = [1,2,3,2] Output: 4 Explanation: The unique elements are [1,3], and the sum is 4. Example 2: . Input: nums = [1,1,1,1,1] Output: 0 Explanation: There are no unique elements, and the sum is 0. Example 3: . Input: nums = [1,2,3,4,5] Output: 15 Explanation: The unique elements are [1,2,3,4,5], and the sum is 15. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int sumOfUnique(int[] nums) { int[] dp = new int[101]; for(int n : nums) dp[n]++; int sum = 0; int i = 0; for(int n : dp){ if(n == 1) sum += i; i++; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-264-Sum-of-Unique-Elements/",
    "relUrl": "/problem-264-Sum-of-Unique-Elements/"
  },"278": {
    "doc": "Check if Array Is Sorted and Rotated",
    "title": "Check if Array Is Sorted and Rotated",
    "content": "Given an array nums, return true if the array was originally sorted in non-decreasing order, then rotated some number of positions (including zero). Otherwise, return false. There may be duplicates in the original array. Note: An array A rotated by x positions results in an array B of the same length such that A[i] == B[(i+x) % A.length], where % is the modulo operation. Example 1: . Input: nums = [3,4,5,1,2] Output: true Explanation: [1,2,3,4,5] is the original sorted array. You can rotate the array by x = 3 positions to begin on the the element of value 3: [3,4,5,1,2]. Example 2: . Input: nums = [2,1,3,4] Output: false Explanation: There is no sorted array once rotated that can make nums. Example 3: . Input: nums = [1,2,3] Output: true Explanation: [1,2,3] is the original sorted array. You can rotate the array by x = 0 positions (i.e. no rotation) to make nums. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution . class Solution { public boolean check(int[] nums) { int i = 0; while(i &lt; nums.length - 1 &amp;&amp; nums[i] &lt;= nums[i + 1]) i++; if(i == nums.length - 1) return true; // may have rotated array if(nums[0] &lt; nums[nums.length - 1]) return false; i++; while(i &lt; nums.length - 1 &amp;&amp; nums[i] &lt;= nums[i + 1]) i++; if(i == nums.length - 1) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-265-Check-if-Array-Is-Sorted-and-Rotated/",
    "relUrl": "/problem-265-Check-if-Array-Is-Sorted-and-Rotated/"
  },"279": {
    "doc": "Minimum Changes To Make Alternating Binary String",
    "title": "Minimum Changes To Make Alternating Binary String",
    "content": "You are given a string s consisting only of the characters ‘0’ and ‘1’. In one operation, you can change any ‘0’ to ‘1’ or vice versa. The string is called alternating if no two adjacent characters are equal. For example, the string “010” is alternating, while the string “0100” is not. Return the minimum number of operations needed to make s alternating. Example 1: . Input: s = \"0100\" Output: 1 Explanation: If you change the last character to '1', s will be \"0101\", which is alternating. Example 2: . Input: s = \"10\" Output: 0 Explanation: s is already alternating. Example 3: . Input: s = \"1111\" Output: 2 Explanation: You need two operations to reach \"0101\" or \"1010\". Constraints: . | 1 &lt;= s.length &lt;= 10^4 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public int minOperations(String s) { int c1, c2; c1 = c2 = 0; boolean stc = true; for(char c : s.toCharArray()){ if(stc){ if(c == '0') c2++; else c1++; }else{ if(c == '0') c1++; else c2++; } stc = !stc; } return Math.min(c1,c2); } } . ",
    "url": "https://1001anjan.github.io/problem-266-Minimum-Changes-To-Make-Alternating-Binary-String/",
    "relUrl": "/problem-266-Minimum-Changes-To-Make-Alternating-Binary-String/"
  },"280": {
    "doc": "Merge Strings Alternately",
    "title": "Merge Strings Alternately",
    "content": "You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string. Return the merged string. Example 1: . Input: word1 = \"abc\", word2 = \"pqr\" Output: \"apbqcr\" Explanation: The merged string will be merged as so: word1: a b c word2: p q r merged: a p b q c r . Example 2: . Input: word1 = \"ab\", word2 = \"pqrs\" Output: \"apbqrs\" Explanation: Notice that as word2 is longer, \"rs\" is appended to the end. word1: a b word2: p q r s merged: a p b q r s . Example 3: . Input: word1 = \"abcd\", word2 = \"pq\" Output: \"apbqcd\" Explanation: Notice that as word1 is longer, \"cd\" is appended to the end. word1: a b c d word2: p q merged: a p b q c d . Constraints: . | 1 &lt;= word1.length, word2.length &lt;= 100 | word1 and word2 consist of lowercase English letters. | . Solution: . class Solution { public String mergeAlternately(String word1, String word2) { StringBuilder sb = new StringBuilder(); int i = 0, j = 0; boolean stc = true; while(i &lt; word1.length() &amp;&amp; j &lt; word2.length()){ if(stc){ sb.append(word1.charAt(i)); i++; }else{ sb.append(word2.charAt(j)); j++; } stc = !stc; } while(i &lt; word1.length()){ sb.append(word1.charAt(i)); i++; } while(j &lt; word2.length()){ sb.append(word2.charAt(j)); j++; } return sb.toString(); } } . Another way . class Solution { public String mergeAlternately(String word1, String word2) { int n=Math.max(word1.length(),word2.length()); StringBuilder res=new StringBuilder(); for(int i=0;i&lt;n;i++){ if(i&lt;word1.length())res.append(word1.charAt(i)); if(i&lt;word2.length())res.append(word2.charAt(i)); } return res.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-267-Merge-Strings-Alternately/",
    "relUrl": "/problem-267-Merge-Strings-Alternately/"
  },"281": {
    "doc": "Count Items Matching a Rule",
    "title": "Count Items Matching a Rule",
    "content": "You are given an array items, where each items[i] = [typei, colori, namei] describes the type, color, and name of the ith item. You are also given a rule represented by two strings, ruleKey and ruleValue. The ith item is said to match the rule if one of the following is true: . | ruleKey == “type” and ruleValue == typei. | ruleKey == “color” and ruleValue == colori. | ruleKey == “name” and ruleValue == namei. Return the number of items that match the given rule. | . Example 1: . Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"lenovo\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"color\", ruleValue = \"silver\" Output: 1 Explanation: There is only one item matching the given rule, which is [\"computer\",\"silver\",\"lenovo\"]. Example 2: . Input: items = [[\"phone\",\"blue\",\"pixel\"],[\"computer\",\"silver\",\"phone\"],[\"phone\",\"gold\",\"iphone\"]], ruleKey = \"type\", ruleValue = \"phone\" Output: 2 Explanation: There are only two items matching the given rule, which are [\"phone\",\"blue\",\"pixel\"] and [\"phone\",\"gold\",\"iphone\"]. Note that the item [\"computer\",\"silver\",\"phone\"] does not match. Constraints: . | 1 &lt;= items.length &lt;= 10^4 | 1 &lt;= typei.length, colori.length, namei.length, ruleValue.length &lt;= 10 | ruleKey is equal to either “type”, “color”, or “name”. | All strings consist only of lowercase letters. | . Solution: . class Solution { public int countMatches(List&lt;List&lt;String&gt;&gt; items, String ruleKey, String ruleValue) { int count = 0; for(List&lt;String&gt; list : items){ if(ruleKey.equals(\"type\")){ if(list.get(0).equals(ruleValue)) count++; }else if(ruleKey.equals(\"color\")){ if(list.get(1).equals(ruleValue)) count++; }else{ if(list.get(2).equals(ruleValue)) count++; } } return count; } } . class Solution { public int countMatches(List &lt; List &lt; String &gt;&gt; items, String ruleKey, String ruleValue) { int count = 0; int index = 0; switch (ruleKey) { case \"color\": { index = 1; break; } case \"type\": { index = 0; break; } case \"name\": { index = 2; break; } } for (List &lt; String &gt; item: items) { if (item.get(index).equals(ruleValue)) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-268-Count-Items-Matching-a-Rule/",
    "relUrl": "/problem-268-Count-Items-Matching-a-Rule/"
  },"282": {
    "doc": "Count Items Matching a Rule",
    "title": "Find Nearest Point That Has the Same X or Y Coordinate",
    "content": "You are given two integers, x and y, which represent your current location on a Cartesian grid: (x, y). You are also given an array points where each points[i] = [ai, bi] represents that a point exists at (ai, bi). A point is valid if it shares the same x-coordinate or the same y-coordinate as your location. Return the index (0-indexed) of the valid point with the smallest Manhattan distance from your current location. If there are multiple, return the valid point with the smallest index. If there are no valid points, return -1. The Manhattan distance between two points (x1, y1) and (x2, y2) is abs(x1 - x2) + abs(y1 - y2). Example 1: . Input: x = 3, y = 4, points = [[1,2],[3,1],[2,4],[2,3],[4,4]] Output: 2 Explanation: Of all the points, only [3,1], [2,4] and [4,4] are valid. Of the valid points, [2,4] and [4,4] have the smallest Manhattan distance from your current location, with a distance of 1. [2,4] has the smallest index, so return 2. Example 2: . Input: x = 3, y = 4, points = [[3,4]] Output: 0 Explanation: The answer is allowed to be on the same location as your current location. Example 3: . Input: x = 3, y = 4, points = [[2,3]] Output: -1 Explanation: There are no valid points. Constraints: . | 1 &lt;= points.length &lt;= 104 | points[i].length == 2 | 1 &lt;= x, y, ai, bi &lt;= 104 | . Solution: . class Solution { public int nearestValidPoint(int x, int y, int[][] points) { int md = Integer.MAX_VALUE; int index = -1; int i = 0; for(int[] p : points){ if(p[0] == x || p[1] == y){ int d = Math.abs(x - p[0]) + Math.abs(y - p[1]); if(md &gt; d){ md = d; index = i; } } i++; } return index; } } . Faster by nature . class Solution { public int nearestValidPoint(int x, int y, int[][] points) { int md = Integer.MAX_VALUE; int index = -1; for(int i = 0; i &lt; points.length; i++){ if(points[i][0] == x || points[i][1] == y){ int d = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]); if(md &gt; d){ md = d; index = i; } } } return index; } } . ",
    "url": "https://1001anjan.github.io/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/#find-nearest-point-that-has-the-same-x-or-y-coordinate",
    "relUrl": "/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/#find-nearest-point-that-has-the-same-x-or-y-coordinate"
  },"283": {
    "doc": "Count Items Matching a Rule",
    "title": "Count Items Matching a Rule",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/",
    "relUrl": "/problem-269-Find-Nearest-Point-That-Has-the-Same-X-or-Y-Coordinate/"
  },"284": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle",
    "content": "Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] . Example 2: . Input: numRows = 1 Output: [[1]] . Constraints: . 1 &lt;= numRows &lt;= 30 . ",
    "url": "https://1001anjan.github.io/problem-27-Pascal-Triangle/#pascals-triangle",
    "relUrl": "/problem-27-Pascal-Triangle/#pascals-triangle"
  },"285": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-27-Pascal-Triangle/",
    "relUrl": "/problem-27-Pascal-Triangle/"
  },"286": {
    "doc": "Pow(x, n)",
    "title": "Pow(x, n)",
    "content": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn). Example 1: . Input: x = 2.00000, n = 10 Output: 1024.00000 . Example 2: . Input: x = 2.10000, n = 3 Output: 9.26100 . Example 3: . Input: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 . Constraints: . | -100.0 &lt; x &lt; 100.0 | -2^31 &lt;= n &lt;= 2^31-1 | n is an integer. | -10^4 &lt;= x^n &lt;= 10^4 | . Solution: . class Solution { public double myPow(double x, int n) { if(n &lt; 0){ n = -n; x = 1/x; } if(n == 0) return 1; double pow = 1; while(n &gt; 0){ if((n &amp; 1) != 0){ pow *= x; } x *= x; n &gt;&gt;&gt;= 1; } return pow; } } . Logic: . n order to improve efficiency we will opt for Binary Exponentiation using which we can calculate xn using O log2(N) multiplications. Basic Idea is to divide the work using binary representation of exponents i.e. is to keep multiplying pow with x, if the bit is odd, and multiplying x with itself until we get 0 We will use very 1st example of 1st Approach i.e. x = 7, n = 11 and pow = 1 Here, we have to calculate 711 Binary of n i.e. (11)10 is (1011)2 1 0 1 1 23 22 21 20 &lt;– Corresponding place values of each bit . OR we can also write this as 1 0 1 1 8 4 2 1 &lt;– Corresponding place values of each bit . Now, 78 × 72 × 71 == 711 as 7(8 + 2 + 1) == 711 NOTE: We have not considered 74 in this case as the 4th place bit is OFF . So, 78 × 72 × 71 == 5764801 × 49 × 7 == 1977326743 &lt;– Desired Output Now, applying logic keeping this concept in mind . double pow = 1; while(n != 0){ if((n &amp; 1) != 0) // equivalent to if((n % 2) != 0) i.e. multiply only when the number is odd pow *= x; x *= x; n &gt;&gt;&gt;= 1; // equivalent to n = n / 2; i.e. keep dividing the number by 2 } . PROCESS . Iteration 1 pow = 1 × 7 = 7 x = 7 × 7 = 49 n = 11 »&gt; 1 = 5 . Iteration 2 pow = 7 × 49 = 343 x = 49 × 49 = 2401 n = 5 »&gt; 1 = 2 . Iteration 3 x = 2401 × 2401 = 5764801 n = 2 »&gt; 1 = 1 . Iteration 4 pow = 343 × 5764801 = 1977326743 x = 5764801 × 5764801 = 3.323293057 × 10¹³ n = 1 »&gt; 1 = 0 . We exit the loop as the number has become 0 and we got pow as 1977326743 which is the desired output In this binary exponentiation approach, the loop iterated for only 4 times which is nothing but (O log2(N) + 1) ~ (O log2(N)) . And for 2nd example of 1st Approach where x = 1 and n = 2147483647 This loop executed for only 31 times (O log2(N)) which is far far less than 2147483647 times(in case of O(N) approach) . ",
    "url": "https://1001anjan.github.io/problem-27-Pow(x,%20n)/",
    "relUrl": "/problem-27-Pow(x, n)/"
  },"287": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if Binary String Has at Most One Segment of Ones",
    "content": "Given a binary string s without leading zeros, return true if s contains at most one contiguous segment of ones. Otherwise, return false. Example 1: . Input: s = \"1001\" Output: false Explanation: The ones do not form a contiguous segment. Example 2: . Input: s = \"110\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘0’ or ‘1’. | s[0] is ‘1’ | . Solution: . Just increase the count when 0 comes, and when we get 1, check the value of count, if is not 0, return false . class Solution { public boolean checkOnesSegment(String s) { boolean consecOne = true; int count = 0; for(char c: s.toCharArray()){ if(c == '0') count++; else { if(count != 0) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-270-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/",
    "relUrl": "/problem-270-Check-if-Binary-String-Has-at-Most-One-Segment-of-Ones/"
  },"288": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if One String Swap Can Make Strings Equal",
    "content": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices. Return true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false. Example 1: . Input: s1 = \"bank\", s2 = \"kanb\" Output: true Explanation: For example, swap the first character with the last character of s2 to make \"bank\". Example 2: . Input: s1 = \"attack\", s2 = \"defend\" Output: false Explanation: It is impossible to make them equal with one string swap. Example 3: . Input: s1 = \"kelb\", s2 = \"kelb\" Output: true Explanation: The two strings are already equal, so no string swap operation is required. Constraints: . | 1 &lt;= s1.length, s2.length &lt;= 100 | s1.length == s2.length | s1 and s2 consist of only lowercase English letters. | . Solution: . class Solution { public boolean areAlmostEqual(String s1, String s2) { List&lt;Integer&gt; indexs = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; s1.length(); i++){ if(s1.charAt(i) != s2.charAt(i)){ indexs.add(i); } if(indexs.size() &gt; 2) return false; } if(indexs.size() == 0) return true; if(indexs.size() == 1) return false; return s1.charAt(indexs.get(0)) == s2.charAt(indexs.get(1)) &amp;&amp; s1.charAt(indexs.get(1)) == s2.charAt(indexs.get(0)); } } . ####### Another way . class Solution { public boolean areAlmostEqual(String s1, String s2) { if(s1.equals(s2)) return true; List&lt;Integer&gt; indexs = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; s1.length(); i++){ if(s1.charAt(i) != s2.charAt(i)){ indexs.add(i); } if(indexs.size() &gt; 2) return false; } if(indexs.size() == 2){ return s1.charAt(indexs.get(0)) == s2.charAt(indexs.get(1)) &amp;&amp; s1.charAt(indexs.get(1)) == s2.charAt(indexs.get(0)); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/#check-if-one-string-swap-can-make-strings-equal",
    "relUrl": "/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/#check-if-one-string-swap-can-make-strings-equal"
  },"289": {
    "doc": "Check if Binary String Has at Most One Segment of Ones",
    "title": "Check if Binary String Has at Most One Segment of Ones",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/",
    "relUrl": "/problem-271-Check-if-One-String-Swap-Can-Make-Strings-Equal/"
  },"290": {
    "doc": "Find Center of Star Graph",
    "title": "Find Center of Star Graph",
    "content": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node. You are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph. Example 1: . Input: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. Example 2: . Input: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 . Constraints: . | 3 &lt;= n &lt;= 10^5 | edges.length == n - 1 | edges[i].length == 2 | 1 &lt;= ui, vi &lt;= n | ui != vi | The given edges represent a valid star graph. | . Solution: . class Solution { public int findCenter(int[][] edges) { if(edges[0][0] == edges[1][0]) return edges[0][0]; if(edges[0][0] == edges[1][1]) return edges[0][0]; if(edges[0][1] == edges[1][0]) return edges[0][1]; if(edges[0][1] == edges[1][1]) return edges[0][1]; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-272-Find-Center-of-Star-Graph/",
    "relUrl": "/problem-272-Find-Center-of-Star-Graph/"
  },"291": {
    "doc": "Second Largest Digit in a String",
    "title": "Second Largest Digit in a String",
    "content": "Given an alphanumeric string s, return the second largest numerical digit that appears in s, or -1 if it does not exist. An alphanumeric string is a string consisting of lowercase English letters and digits. Example 1: . Input: s = \"dfa12321afd\" Output: 2 Explanation: The digits that appear in s are [1, 2, 3]. The second largest digit is 2. Example 2: . Input: s = \"abc1111\" Output: -1 Explanation: The digits that appear in s are [1]. There is no second largest digit. Constraints: . | 1 &lt;= s.length &lt;= 500 | s consists of only lowercase English letters and/or digits. | . Solution: . class Solution { public int secondHighest(String s) { boolean[] d = new boolean[10]; for(char c : s.toCharArray()){ if(!Character.isLetter(c)){ d[c - '0'] = true; } } int i = 9; while(i &gt;= 0 &amp;&amp; !d[i]) i--; if(i == 0 || i == -1) return -1; i--; while(i &gt;= 0 &amp;&amp; !d[i]) i--; return i; } } . naturally faster approach . class Solution { public int secondHighest(String s) { int first = -1; int second = -1; for(char c : s.toCharArray()) { if(c &gt;= '0' &amp;&amp; c &lt;= '9') { int num = c - '0'; if(num &gt; first) { second = first; first = num; } else if(num &gt; second &amp;&amp; num &lt; first) { second = num; } } } return second; } } . ",
    "url": "https://1001anjan.github.io/problem-273-Second-Largest-Digit-in-a-String/",
    "relUrl": "/problem-273-Second-Largest-Digit-in-a-String/"
  },"292": {
    "doc": "Maximum Ascending Subarray Sum",
    "title": "Maximum Ascending Subarray Sum",
    "content": "Given an array of positive integers nums, return the maximum possible sum of an ascending subarray in nums. A subarray is defined as a contiguous sequence of numbers in an array. A subarray [numsl, numsl+1, …, numsr-1, numsr] is ascending if for all i where l &lt;= i &lt; r, numsi &lt; numsi+1. Note that a subarray of size 1 is ascending. Example 1: . Input: nums = [10,20,30,5,10,50] Output: 65 Explanation: [5,10,50] is the ascending subarray with the maximum sum of 65. Example 2: . Input: nums = [10,20,30,40,50] Output: 150 Explanation: [10,20,30,40,50] is the ascending subarray with the maximum sum of 150. Example 3: . Input: nums = [12,17,15,13,10,11,12] Output: 33 Explanation: [10,11,12] is the ascending subarray with the maximum sum of 33. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int maxAscendingSum(int[] nums) { int max = -1; int curr = nums[0]; for(int i = 1; i &lt;nums.length; i++){ if(nums[i - 1] &lt; nums[i]){ curr += nums[i]; }else{ max = Math.max(max,curr); curr = nums[i]; } } return Math.max(max,curr); } } . ",
    "url": "https://1001anjan.github.io/problem-274-Maximum-Ascending-Subarray-Sum/",
    "relUrl": "/problem-274-Maximum-Ascending-Subarray-Sum/"
  },"293": {
    "doc": "Number of Different Integers in a String",
    "title": "Number of Different Integers in a String",
    "content": "You are given a string word that consists of digits and lowercase English letters. You will replace every non-digit character with a space. For example, “a123bc34d8ef34” will become “ 123 34 8 34”. Notice that you are left with some integers that are separated by at least one space: “123”, “34”, “8”, and “34”. Return the number of different integers after performing the replacement operations on word. Two integers are considered different if their decimal representations without any leading zeros are different. Example 1: . Input: word = \"a123bc34d8ef34\" Output: 3 Explanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once. Example 2: . Input: word = \"leet1234code234\" Output: 2 . Example 3: . Input: word = \"a1b01c001\" Output: 1 Explanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because the leading zeros are ignored when comparing their decimal values. Constraints: . | 1 &lt;= word.length &lt;= 1000 | word consists of digits and lowercase English letters. | . Solution: . class Solution { public int numDifferentIntegers(String word) { Set&lt;String&gt; s = new HashSet&lt;&gt;(); StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; word.length(); i++){ char c = word.charAt(i); if(!Character.isLetter(c)){ sb.append(c); }else{ if(sb.length() != 0) s.add(filterString(sb)); sb.setLength(0); } } if(sb.length() != 0) s.add(filterString(sb)); return s.size(); } public String filterString(StringBuilder str){ if(str.charAt(0) != '0') return str.toString(); int i = 0; int n = str.length(); while(i &lt; n &amp;&amp; str.charAt(i) == '0') i++; if(i == n) return \"0\"; return str.substring(i,n).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-275-Number-of-Different-Integers-in-a-String/",
    "relUrl": "/problem-275-Number-of-Different-Integers-in-a-String/"
  },"294": {
    "doc": "Determine Color of a Chessboard Square",
    "title": "Determine Color of a Chessboard Square",
    "content": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference. Return true if the square is white, and false if the square is black. The coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second. Example 1: . Input: coordinates = \"a1\" Output: false Explanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false. Example 2: . Input: coordinates = \"h3\" Output: true Explanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true. Example 3: . Input: coordinates = \"c7\" Output: false . Constraints: . | coordinates.length == 2 | ‘a’ &lt;= coordinates[0] &lt;= ‘h’ | ‘1’ &lt;= coordinates[1] &lt;= ‘8’ | . Solution: . class Solution { public boolean squareIsWhite(String coordinates) { return (getRefvalue(coordinates.charAt(0)) ^ ((coordinates.charAt(1) - '0')%2)) == 1; } public int getRefvalue(char c){ switch(c){ case 'a','c','e','g': return 1; default: return 0; } } } . Another way . class Solution { public boolean squareIsWhite(String coordinates) { int coord = coordinates.charAt(0) - 97 + coordinates.charAt(1) - 48; return coord % 2 == 0 ? true : false; } } . ",
    "url": "https://1001anjan.github.io/problem-276-Determine-Color-of-a-Chessboard-Square/",
    "relUrl": "/problem-276-Determine-Color-of-a-Chessboard-Square/"
  },"295": {
    "doc": "Truncate Sentence",
    "title": "Truncate Sentence",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation). For example, “Hello World”, “HELLO”, and “hello world hello world” are all sentences. You are given a sentence s and an integer k. You want to truncate s such that it contains only the first k words. Return s after truncating it. Example 1: . Input: s = \"Hello how are you Contestant\", k = 4 Output: \"Hello how are you\" Explanation: The words in s are [\"Hello\", \"how\" \"are\", \"you\", \"Contestant\"]. The first 4 words are [\"Hello\", \"how\", \"are\", \"you\"]. Hence, you should return \"Hello how are you\". Example 2: . Input: s = \"What is the solution to this problem\", k = 4 Output: \"What is the solution\" Explanation: The words in s are [\"What\", \"is\" \"the\", \"solution\", \"to\", \"this\", \"problem\"]. The first 4 words are [\"What\", \"is\", \"the\", \"solution\"]. Hence, you should return \"What is the solution\". Example 3: . Input: s = \"chopper is not a tanuki\", k = 5 Output: \"chopper is not a tanuki\" . Constraints: . | 1 &lt;= s.length &lt;= 500 | k is in the range [1, the number of words in s]. | s consist of only lowercase and uppercase English letters and spaces. | The words in s are separated by a single space. | There are no leading or trailing spaces. | . Solution: . class Solution { public String truncateSentence(String s, int k) { String[] wrd = s.split(\" \"); int i = 0; StringBuilder sb = new StringBuilder(); do{ sb.append(wrd[i]).append(\" \"); i++; }while(i &lt; k &amp;&amp; i &lt; wrd.length); return sb.substring(0,sb.length() - 1).toString(); } } . ####### Naturally faster . class Solution { public String truncateSentence(String s, int k) { StringBuilder sb = new StringBuilder(); int countSpaces = 0; for(char curr : s.toCharArray()) { if(curr == ' ') { countSpaces++; } if(countSpaces == k) break; sb.append(curr); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-277-Truncate-Sentence/",
    "relUrl": "/problem-277-Truncate-Sentence/"
  },"296": {
    "doc": "Sign of the Product of an Array",
    "title": "Sign of the Product of an Array",
    "content": "There is a function signFunc(x) that returns: . | 1 if x is positive. | -1 if x is negative. | 0 if x is equal to 0. You are given an integer array nums. Let product be the product of all values in the array nums. | . Return signFunc(product). Example 1: . Input: nums = [-1,-2,-3,-4,3,2,1] Output: 1 Explanation: The product of all values in the array is 144, and signFunc(144) = 1 . Example 2: . Input: nums = [1,5,0,2,-3] Output: 0 Explanation: The product of all values in the array is 0, and signFunc(0) = 0 . Example 3: . Input: nums = [-1,1,-1,1,-1] Output: -1 Explanation: The product of all values in the array is -1, and signFunc(-1) = -1 . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -100 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int arraySign(int[] nums) { boolean sign = true; for(int n : nums){ if(n == 0) return 0; else if(n &lt; 0) sign = !sign; } return sign == true? 1 : -1; } } . ",
    "url": "https://1001anjan.github.io/problem-278-Sign-of-the-Product-of-an-Array/",
    "relUrl": "/problem-278-Sign-of-the-Product-of-an-Array/"
  },"297": {
    "doc": "Minimum Operations to Make the Array Increasing",
    "title": "Minimum Operations to Make the Array Increasing",
    "content": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1. For example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3]. Return the minimum number of operations needed to make nums strictly increasing. An array nums is strictly increasing if nums[i] &lt; nums[i+1] for all 0 &lt;= i &lt; nums.length - 1. An array of length 1 is trivially strictly increasing. Example 1: . Input: nums = [1,1,1] Output: 3 Explanation: You can do the following operations: 1) Increment nums[2], so nums becomes [1,1,2]. 2) Increment nums[1], so nums becomes [1,2,2]. 3) Increment nums[2], so nums becomes [1,2,3]. Example 2: . Input: nums = [1,5,2,4,1] Output: 14 . Example 3: . Input: nums = [8] Output: 0 . Constraints: . | 1 &lt;= nums.length &lt;= 5000 | 1 &lt;= nums[i] &lt;= 10^4 | . Solution: . class Solution { public int minOperations(int[] nums) { int opt = 0; for(int i = 1; i &lt; nums.length; i++){ if(nums[i - 1] &gt;= nums[i]){ opt += nums[i - 1] - nums[i] + 1; nums[i] = nums[i - 1] + 1; } } return opt; } } . ",
    "url": "https://1001anjan.github.io/problem-279-Minimum-Operations-to-Make-the-Array-Increasing/",
    "relUrl": "/problem-279-Minimum-Operations-to-Make-the-Array-Increasing/"
  },"298": {
    "doc": "Maximum Subarray",
    "title": "Maximum Subarray",
    "content": "Given an integer array nums, find the subarray which has the largest sum and return its sum. Example 1: . Input: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: [4,-1,2,1] has the largest sum = 6. Example 2: . Input: nums = [1] Output: 1 . Example 3: . Input: nums = [5,4,-1,7,8] Output: 23 . Constraints: . | 1 &lt;= nums.length &lt;= 10^5 | -10^4 &lt;= nums[i] &lt;= 10^4 | . Follow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. Solution: . class Solution { public int maxSubArray(int[] nums) { int maxSum = nums[0]; int currSum = nums[0]; for(int i = 1; i &lt; nums.length; i++){ if(currSum + nums[i] &lt; nums[i]){ currSum = nums[i]; }else{ currSum += nums[i]; } maxSum = Math.max(maxSum,currSum); } return Math.max(maxSum,currSum); } } . class Solution { public int maxSubArray(int[] nums) { return divideAndConquer(nums, 0, nums.length - 1); } public int divideAndConquer(int[] arr, int l, int u){ if( l &gt; u) return Integer.MIN_VALUE; if(l == u) return arr[l]; int m = (l + u)/2; /* Return maximum of following three possible cases: a) Maximum subarray sum in left half b) Maximum subarray sum in right half c) Maximum subarray sum such that the subarray crosses the midpoint */ return Math.max(Math.max(divideAndConquer(arr, l, m - 1), divideAndConquer(arr, m + 1, u)), maximumCrossing(arr, l, m, u)); } public int maximumCrossing(int[] arr, int l, int m, int u){ int sum = 0; int leftSum = Integer.MIN_VALUE; for(int i = m; i &gt;= l; i--){ sum += arr[i]; if(sum &gt; leftSum) leftSum = sum; } sum = 0; int rightSum = Integer.MIN_VALUE; for(int i = m; i &lt;= u; i++){ sum += arr[i]; if(sum &gt; rightSum) rightSum = sum; } return Math.max(leftSum + rightSum - arr[m], Math.max(leftSum, rightSum)); } } . ",
    "url": "https://1001anjan.github.io/problem-28-Maximum%20Subarray/",
    "relUrl": "/problem-28-Maximum Subarray/"
  },"299": {
    "doc": "Valid Palindrome",
    "title": "Valid Palindrome",
    "content": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers. Given a string s, return true if it is a palindrome, or false otherwise. Example 1: . Input: s = \"A man, a plan, a canal: Panama\" Output: true Explanation: \"amanaplanacanalpanama\" is a palindrome. Example 2: . Input: s = \"race a car\" Output: false Explanation: \"raceacar\" is not a palindrome. Example 3: . Input: s = \" \" Output: true Explanation: s is an empty string \"\" after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. Constraints: . | 1 &lt;= s.length &lt;= 2 * 105 | s consists only of printable ASCII characters. | . Solution . class Solution { public boolean isPalindrome(String s) { StringBuffer sb = new StringBuffer(); s = s.toLowerCase().trim(); for(int i=0; i&lt;s.length(); i++){ if(Character.isLetter(s.charAt(i)) || Character.isDigit(s.charAt(i))) sb.append(s.charAt(i)); } String str = sb.toString(); if(str.equals(\" \")) return true; return str.equals(sb.reverse().toString()); } } . ",
    "url": "https://1001anjan.github.io/problem-27-Valid-Palindrome/",
    "relUrl": "/problem-27-Valid-Palindrome/"
  },"300": {
    "doc": "Check if the Sentence Is Pangram",
    "title": "Check if the Sentence Is Pangram",
    "content": "A pangram is a sentence where every letter of the English alphabet appears at least once. Given a string sentence containing only lowercase English letters, return true if sentence is a pangram, or false otherwise. Example 1: . Input: sentence = \"thequickbrownfoxjumpsoverthelazydog\" Output: true Explanation: sentence contains at least one of every letter of the English alphabet. Example 2: . Input: sentence = \"leetcode\" Output: false . Constraints: . | 1 &lt;= sentence.length &lt;= 1000 | sentence consists of lowercase English letters. | . Solution: . class Solution { public boolean checkIfPangram(String sentence) { Set&lt;Character&gt; s = new HashSet(); for(char c : sentence.toCharArray()){ s.add(c); } return s.size() == 26; } } . Execution wise faster . class Solution { public boolean checkIfPangram(String sentence) { boolean[] dp = new boolean[26]; for(char c : sentence.toCharArray()){ dp[c - 'a'] = true; } for(boolean d : dp){ if(!d) return false; } return true; } } . Even faster execution . class Solution { public boolean checkIfPangram(String sentence) { if(sentence.length() &lt; 26){ return false; } else{ String str = \"abcdefghijklmnopqrstuvwxyz\"; for(int i=0;i &lt; str.length();i++){ if(sentence.indexOf(str.charAt(i)) == -1){ return false; } } return true; } } } . ",
    "url": "https://1001anjan.github.io/problem-280-Check-if-the-Sentence-Is-Pangram/",
    "relUrl": "/problem-280-Check-if-the-Sentence-Is-Pangram/"
  },"301": {
    "doc": "Sum of Digits in Base K",
    "title": "Sum of Digits in Base K",
    "content": "Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k. After converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10. Example 1: . Input: n = 34, k = 6 Output: 9 Explanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9. Example 2: . Input: n = 10, k = 10 Output: 1 Explanation: n is already in base 10. 1 + 0 = 1. Constraints: . | 1 &lt;= n &lt;= 100 | 2 &lt;= k &lt;= 10 | . Solution: . class Solution { public int sumBase(int n, int k) { int sum = 0; while(n &gt; 0){ sum += n % k; n = n / k; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-281-Sum-of-Digits-in-Base-K/",
    "relUrl": "/problem-281-Sum-of-Digits-in-Base-K/"
  },"302": {
    "doc": "Replace All Digits with Characters",
    "title": "Replace All Digits with Characters",
    "content": "You are given a 0-indexed string s that has lowercase English letters in its even indices and digits in its odd indices. There is a function shift(c, x), where c is a character and x is a digit, that returns the xth character after c. For example, shift(‘a’, 5) = ‘f’ and shift(‘x’, 0) = ‘x’. For every odd index i, you want to replace the digit s[i] with shift(s[i-1], s[i]). Return s after replacing all digits. It is guaranteed that shift(s[i-1], s[i]) will never exceed ‘z’. Example 1: . Input: s = \"a1c1e1\" Output: \"abcdef\" Explanation: The digits are replaced as follows: - s[1] -&gt; shift('a',1) = 'b' - s[3] -&gt; shift('c',1) = 'd' - s[5] -&gt; shift('e',1) = 'f' . Example 2: . Input: s = \"a1b2c3d4e\" Output: \"abbdcfdhe\" Explanation: The digits are replaced as follows: - s[1] -&gt; shift('a',1) = 'b' - s[3] -&gt; shift('b',2) = 'd' - s[5] -&gt; shift('c',3) = 'f' - s[7] -&gt; shift('d',4) = 'h' . Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists only of lowercase English letters and digits. | shift(s[i-1], s[i]) &lt;= ‘z’ for all odd indices i. | . Solution . class Solution { public String replaceDigits(String s) { StringBuilder sb = new StringBuilder(); sb.append(s); for(int i = 1; i &lt; sb.length(); i = i + 2){ sb.setCharAt(i,(char)(sb.charAt(i - 1) + (sb.charAt(i) - '0'))); } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-281-Replace-All-Digits-with-Characters/",
    "relUrl": "/problem-281-Replace-All-Digits-with-Characters/"
  },"303": {
    "doc": "Minimum Distance to the Target Element",
    "title": "Minimum Distance to the Target Element",
    "content": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that abs(x) is the absolute value of x. Return abs(i - start). It is guaranteed that target exists in nums. Example 1: . Input: nums = [1,2,3,4,5], target = 5, start = 3 Output: 1 Explanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1. Example 2: . Input: nums = [1], target = 1, start = 0 Output: 0 Explanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0. Example 3: . Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0 Output: 0 Explanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 104 | 0 &lt;= start &lt; nums.length | target is in nums. | . Solution: . class Solution { public int getMinDistance(int[] nums, int target, int start) { int i, j; i = j = start; while(i &gt;= 0 &amp;&amp; j &lt; nums.length){ if(nums[j] == target) return j - start; if(nums[i] == target) return start - i; j++; i--; } while(i &gt;= 0){ if(nums[i] == target) return start - i; i--; } while(j &lt; nums.length){ if(nums[j] == target) return j - start; j++; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-283-Minimum-Distance-to-the-Target-Element/",
    "relUrl": "/problem-283-Minimum-Distance-to-the-Target-Element/"
  },"304": {
    "doc": "Maximum-Population-Year",
    "title": "Maximum Population Year",
    "content": "You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person. The population of some year x is the number of people alive during that year. The ith person is counted in year x’s population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die. Return the earliest year with the maximum population. Example 1: . Input: logs = [[1993,1999],[2000,2010]] Output: 1993 Explanation: The maximum population is 1, and 1993 is the earliest year with this population. Example 2: . Input: logs = [[1950,1961],[1960,1971],[1970,1981]] Output: 1960 Explanation: The maximum population is 2, and it had happened in years 1960 and 1970. The earlier year between them is 1960. Constraints: . | 1 &lt;= logs.length &lt;= 100 | 1950 &lt;= birthi &lt; deathi &lt;= 2050 | . Solution . class Solution { public int maximumPopulation(int[][] logs) { int[] years = new int[101]; for(int[] p : logs){ years[p[0] - 1950]++; years[p[1] - 1950]--; } int max = Integer.MIN_VALUE; int y = 0; int curr = 0; for(int i = 0; i &lt; 101; i++) { curr += years[i]; if(curr &gt; max) { max = curr; y = i + 1950; } } return y; } } . ",
    "url": "https://1001anjan.github.io/problem-284-Maximum-Population-Year/#maximum-population-year",
    "relUrl": "/problem-284-Maximum-Population-Year/#maximum-population-year"
  },"305": {
    "doc": "Maximum-Population-Year",
    "title": "Maximum-Population-Year",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-284-Maximum-Population-Year/",
    "relUrl": "/problem-284-Maximum-Population-Year/"
  },"306": {
    "doc": "Sorting the Sentence",
    "title": "Sorting the Sentence",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters. A sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence. | For example, the sentence “This is a sentence” can be shuffled as “sentence4 a3 is2 This1” or “is2 sentence4 This1 a3”. Given a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence. | . Example 1: . Input: s = \"is2 sentence4 This1 a3\" Output: \"This is a sentence\" Explanation: Sort the words in s to their original positions \"This1 is2 a3 sentence4\", then remove the numbers. Example 2: . Input: s = \"Myself2 Me1 I4 and3\" Output: \"Me Myself and I\" Explanation: Sort the words in s to their original positions \"Me1 Myself2 and3 I4\", then remove the numbers. Constraints: . | 2 &lt;= s.length &lt;= 200 | s consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9. | The number of words in s is between 1 and 9. | The words in s are separated by a single space. | s contains no leading or trailing spaces. | . Solution: . class Solution { public String sortSentence(String s) { // Since we have only 10 words String[] words = new String[10]; String[] w = s.split(\" \"); for(String str : w){ int n = str.length() - 1; int i = str.charAt(n) - '0'; words[i] = str.substring(0,n); } StringBuilder sb = new StringBuilder(); for(String str : words){ if(str != null) sb.append(str).append(\" \"); } return sb.substring(0,sb.length() - 1); } } . ",
    "url": "https://1001anjan.github.io/problem-285-Sorting-the-Sentence/",
    "relUrl": "/problem-285-Sorting-the-Sentence/"
  },"307": {
    "doc": "Longer Contiguous Segments of Ones than Zeros",
    "title": "Longer Contiguous Segments of Ones than Zeros",
    "content": "Given a binary string s, return true if the longest contiguous segment of 1’s is strictly longer than the longest contiguous segment of 0’s in s, or return false otherwise. | For example, in s = “110100010” the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3. Note that if there are no 0’s, then the longest continuous segment of 0’s is considered to have a length 0. The same applies if there is no 1’s. | . Example 1: . Input: s = \"1101\" Output: true Explanation: The longest contiguous segment of 1s has length 2: \"1101\" The longest contiguous segment of 0s has length 1: \"1101\" The segment of 1s is longer, so return true. Example 2: . Input: s = \"111000\" Output: false Explanation: The longest contiguous segment of 1s has length 3: \"111000\" The longest contiguous segment of 0s has length 3: \"111000\" The segment of 1s is not longer, so return false. Example 3: . Input: s = \"110100010\" Output: false Explanation: The longest contiguous segment of 1s has length 2: \"110100010\" The longest contiguous segment of 0s has length 3: \"110100010\" The segment of 1s is not longer, so return false. Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public boolean checkZeroOnes(String s) { int n = s.length(); if(n == 1) return s.charAt(0) == '1'; return longestSegmentLen(s,'1') &gt; longestSegmentLen(s,'0'); } public int longestSegmentLen(String s, char ch){ int max = 0; char prev = s.charAt(0); int crr = prev == ch? 1 : 0; for(int i = 1; i &lt; s.length(); i++){ char now = s.charAt(i); if(prev == ch &amp;&amp; prev == now) crr++; else{ max = Math.max(max,crr); crr = 1; } prev = now; } return Math.max(max,crr); } } . Single pass . class Solution { public boolean checkZeroOnes(String s) { int n = s.length(); if(n == 1) return s.charAt(0) == '1'; int zeros = 0, ones = 0, zMax = -1, oMax = -1; for (int i = 0; i &lt; n - 1; i++) { if (s.charAt(i) == s.charAt(i+1)) { if (s.charAt(i) == '0') zeros++; else ones++; } else { zMax = Integer.max(zeros, zMax); oMax = Integer.max(ones, oMax); zeros = 0; ones = 0; } } zMax = Integer.max(zeros, zMax); oMax = Integer.max(ones, oMax); return oMax &gt; zMax; } } . ",
    "url": "https://1001anjan.github.io/problem-286-Longer-Contiguous-Segments-of-Ones-than-Zeros/",
    "relUrl": "/problem-286-Longer-Contiguous-Segments-of-Ones-than-Zeros/"
  },"308": {
    "doc": "Substrings of Size Three with Distinct Characters",
    "title": "Substrings of Size Three with Distinct Characters",
    "content": "A string is good if there are no repeated characters. Given a string s, return the number of good substrings of length three in s. Note that if there are multiple occurrences of the same substring, every occurrence should be counted. A substring is a contiguous sequence of characters in a string. Example 1: . Input: s = \"xyzzaz\" Output: 1 Explanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". The only good substring of length 3 is \"xyz\". Example 2: . Input: s = \"aababcabc\" Output: 4 Explanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\". The good substrings are \"abc\", \"bca\", \"cab\", and \"abc\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | . Solution . class Solution { public int countGoodSubstrings(String s) { if(s.length() &lt; 3) return 0; char prev, now, next; prev = s.charAt(0); now = s.charAt(1); int c = 0; for(int i = 1; i &lt; s.length() - 1; i++){ next = s.charAt(i + 1); if(prev != now &amp;&amp; prev != next &amp;&amp; now != next) c++; prev = now; now = next; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-287-Substrings-of-Size-Three-with-Distinct-Characters/",
    "relUrl": "/problem-287-Substrings-of-Size-Three-with-Distinct-Characters/"
  },"309": {
    "doc": "Check if All the Integers in a Range Are Covered",
    "title": "Check if All the Integers in a Range Are Covered",
    "content": "You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi. Return true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise. An integer x is covered by an interval ranges[i] = [starti, endi] if starti &lt;= x &lt;= endi. Example 1: . Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5 Output: true Explanation: Every integer between 2 and 5 is covered: - 2 is covered by the first range. - 3 and 4 are covered by the second range. - 5 is covered by the third range. Example 2: . Input: ranges = [[1,10],[10,20]], left = 21, right = 21 Output: false Explanation: 21 is not covered by any range. Constraints: . | 1 &lt;= ranges.length &lt;= 50 | 1 &lt;= starti &lt;= endi &lt;= 50 | 1 &lt;= left &lt;= right &lt;= 50 | . Solution: . class Solution { public boolean isCovered(int[][] ranges, int left, int right) { boolean[] all = new boolean[51]; for(int[] arr : ranges){ for(int i = arr[0]; i &lt;= arr[1]; i++) all[i] = true; } while(left &lt;= right){ if(!all[left]) return false; left++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-288-Check-if-All-the-Integers-in-a-Range-Are-Covered/",
    "relUrl": "/problem-288-Check-if-All-the-Integers-in-a-Range-Are-Covered/"
  },"310": {
    "doc": "Check if Word Equals Summation of Two Words",
    "title": "Check if Word Equals Summation of Two Words",
    "content": "The letter value of a letter is its position in the alphabet starting from 0 (i.e. ‘a’ -&gt; 0, ‘b’ -&gt; 1, ‘c’ -&gt; 2, etc.). The numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer. | For example, if s = “acb”, we concatenate each letter’s letter value, resulting in “021”. After converting it, we get 21. You are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters ‘a’ through ‘j’ inclusive. | . Return true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise. Example 1: . Input: firstWord = \"acb\", secondWord = \"cba\", targetWord = \"cdb\" Output: true Explanation: The numerical value of firstWord is \"acb\" -&gt; \"021\" -&gt; 21. The numerical value of secondWord is \"cba\" -&gt; \"210\" -&gt; 210. The numerical value of targetWord is \"cdb\" -&gt; \"231\" -&gt; 231. We return true because 21 + 210 == 231. Example 2: . Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aab\" Output: false Explanation: The numerical value of firstWord is \"aaa\" -&gt; \"000\" -&gt; 0. The numerical value of secondWord is \"a\" -&gt; \"0\" -&gt; 0. The numerical value of targetWord is \"aab\" -&gt; \"001\" -&gt; 1. We return false because 0 + 0 != 1. Example 3: . Input: firstWord = \"aaa\", secondWord = \"a\", targetWord = \"aaaa\" Output: true Explanation: The numerical value of firstWord is \"aaa\" -&gt; \"000\" -&gt; 0. The numerical value of secondWord is \"a\" -&gt; \"0\" -&gt; 0. The numerical value of targetWord is \"aaaa\" -&gt; \"0000\" -&gt; 0. We return true because 0 + 0 == 0. Constraints: . | 1 &lt;= firstWord.length, secondWord.length, targetWord.length &lt;= 8 | firstWord, secondWord, and targetWord consist of lowercase English letters from ‘a’ to ‘j’ inclusive. | . Solution . class Solution { public boolean isSumEqual(String firstWord, String secondWord, String targetWord) { return parseString(firstWord) + parseString(secondWord) == parseString(targetWord); } public int parseString(String s){ int value = 0; int i = 0; int n = s.length(); // ignoring 'a' s while(i &lt; n &amp;&amp; s.charAt(i) == 'a') i++; while(i &lt; n){ value = value * 10 + (s.charAt(i) - 'a'); i++; } return value; } } . ",
    "url": "https://1001anjan.github.io/problem-289-Check-if-Word-Equals-Summation-of-Two-Words/",
    "relUrl": "/problem-289-Check-if-Word-Equals-Summation-of-Two-Words/"
  },"311": {
    "doc": "Single Number",
    "title": "Single Number",
    "content": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space. Example 1: . Input: nums = [2,2,1] Output: 1 . Example 2: . Input: nums = [4,1,2,1,2] Output: 4 . Example 3: . Input: nums = [1] Output: 1 . Constraints: . | 1 &lt;= nums.length &lt;= 3 * 104 | -3 * 104 &lt;= nums[i] &lt;= 3 * 104 | Each element in the array appears twice except for one element which appears only once. | . Solution . XOR . class Solution { public int singleNumber(int[] nums) { int x = nums[0]; for(int i=1; i&lt;nums.length; i++){ x = x^nums[i]; } return x; } } . ",
    "url": "https://1001anjan.github.io/problem-29-Single-Number/",
    "relUrl": "/problem-29-Single-Number/"
  },"312": {
    "doc": "Spiral Matrix",
    "title": "Spiral Matrix",
    "content": "Given an m x n matrix, return all elements of the matrix in spiral order. Example 1: . Input: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [1,2,3,6,9,8,7,4,5] . Example 2: . Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] Output: [1,2,3,4,8,12,11,10,9,5,6,7] . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 10 | -100 &lt;= matrix[i][j] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; spiralOrder(int[][] matrix) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int m = matrix.length; int n = matrix[0].length; int total = m * n, count = 0; int i = 0, j = 0; int yRight = 0, yLeft = 0, xUp = 1, xDown = 0; while(count &lt; total){ while(count &lt; total &amp;&amp; j &lt; n - yRight){ ans.add(matrix[i][j]); j++; count++; } yRight++; i++; j--; while(count &lt; total &amp;&amp; i &lt; m - xDown){ ans.add(matrix[i][j]); count++; i++; } xDown++; i--; j--; while(count &lt; total &amp;&amp; j &gt;= yLeft){ ans.add(matrix[i][j]); count++; j--; } yLeft++; j++; i--; while(count &lt; total &amp;&amp; i &gt;= xUp){ ans.add(matrix[i][j]); i--; count++; } i++; j++; xUp++; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-29-Spiral%20Matrix/",
    "relUrl": "/problem-29-Spiral Matrix/"
  },"313": {
    "doc": "Redistribute Characters to Make All Strings Equal",
    "title": "Redistribute Characters to Make All Strings Equal",
    "content": "You are given an array of strings words (0-indexed). In one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j]. Return true if you can make every string in words equal using any number of operations, and false otherwise. Example 1: . Input: words = [\"abc\",\"aabc\",\"bc\"] Output: true Explanation: Move the first 'a' in words[1] to the front of words[2], to make words[1] = \"abc\" and words[2] = \"abc\". All the strings are now equal to \"abc\", so return true. Example 2: . Input: words = [\"ab\",\"a\"] Output: false Explanation: It is impossible to make all the strings equal using the operation. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of lowercase English letters. | . Solution . class Solution { public boolean makeEqual(String[] words) { int[] count = new int[26]; for(String w : words){ for(char c : w.toCharArray()){ count[c - 'a']++; } } for(int i : count){ if(i % words.length != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-290-Redistribute-Characters-to-Make-All-Strings-Equal/",
    "relUrl": "/problem-290-Redistribute-Characters-to-Make-All-Strings-Equal/"
  },"314": {
    "doc": "Largest Odd Number in String",
    "title": "Largest Odd Number in String",
    "content": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string “” if no odd integer exists. A substring is a contiguous sequence of characters within a string. Example 1: . Input: num = \"52\" Output: \"5\" Explanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number. Example 2: . Input: num = \"4206\" Output: \"\" Explanation: There are no odd numbers in \"4206\". Example 3: . Input: num = \"35427\" Output: \"35427\" Explanation: \"35427\" is already an odd number. Constraints: . | 1 &lt;= num.length &lt;= 105 | num only consists of digits and does not contain any leading zeros. | . Solution: . class Solution { public String largestOddNumber(String num) { for(int i = num.length() - 1; i&gt;=0; i--){ if((num.charAt(i) - '0')%2 != 0) return num.substring(0,i+1); } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-291-Largest-Odd-Number-in-String/",
    "relUrl": "/problem-291-Largest-Odd-Number-in-String/"
  },"315": {
    "doc": "Remove One Element to Make the Array Strictly Increasing",
    "title": "Remove One Element to Make the Array Strictly Increasing",
    "content": "Given a 0-indexed integer array nums, return true if it can be made strictly increasing after removing exactly one element, or false otherwise. If the array is already strictly increasing, return true. The array nums is strictly increasing if nums[i - 1] &lt; nums[i] for each index (1 &lt;= i &lt; nums.length). Example 1: . Input: nums = [1,2,10,5,7] Output: true Explanation: By removing 10 at index 2 from nums, it becomes [1,2,5,7]. [1,2,5,7] is strictly increasing, so return true. Example 2: . Input: nums = [2,3,1,2] Output: false Explanation: [3,1,2] is the result of removing the element at index 0. [2,1,2] is the result of removing the element at index 1. [2,3,2] is the result of removing the element at index 2. [2,3,1] is the result of removing the element at index 3. No resulting array is strictly increasing, so return false. Example 3: . Input: nums = [1,1,1] Output: false Explanation: The result of removing any element is [1,1]. [1,1] is not strictly increasing, so return false. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution . class Solution { public boolean canBeIncreasing(int[] nums) { // corner cases if(nums.length == 1) return true; int c = 0; for(int i = 1; i &lt; nums.length; i++){ if(nums[i - 1] &gt;= nums[i]){ c++; if(c &gt; 1) return false; if(i &gt;= 2 &amp;&amp; nums[i-2] &gt;= nums[i]) nums[i] = nums[i - 1]; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-292-Remove-One-Element-to-Make-the-Array-Strictly-Increasing/",
    "relUrl": "/problem-292-Remove-One-Element-to-Make-the-Array-Strictly-Increasing/"
  },"316": {
    "doc": "Maximum Product Difference Between Two Pairs",
    "title": "Maximum Product Difference Between Two Pairs",
    "content": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d). | For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16. Given an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized. | . Return the maximum such product difference. Example 1: . Input: nums = [5,6,2,7,4] Output: 34 Explanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4). The product difference is (6 * 7) - (2 * 4) = 34. Example 2: . Input: nums = [4,2,5,9,7,4,8] Output: 64 Explanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4). The product difference is (9 * 8) - (2 * 4) = 64. Constraints: . | 4 &lt;= nums.length &lt;= 104 | 1 &lt;= nums[i] &lt;= 104 | . Solution: . class Solution { public int maxProductDifference(int[] nums) { int max1, max2, min1, min2; max1 = max2 = -1; min1 = min2 = Integer.MAX_VALUE; for(int n : nums){ if(n &gt; max1){ max2 = max1; max1 = n; }else if(n &gt; max2){ max2 = n; } if(n &lt; min1){ min2 = min1; min1 = n; }else if(n &lt; min2){ min2 = n; } } return (max1*max2) - (min1*min2); } } . ",
    "url": "https://1001anjan.github.io/problem-293-Maximum-Product-Difference-Between-Two-Pairs/",
    "relUrl": "/problem-293-Maximum-Product-Difference-Between-Two-Pairs/"
  },"317": {
    "doc": "Build Array from Permutation",
    "title": "Build Array from Permutation",
    "content": "Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 &lt;= i &lt; nums.length and return it. A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive). Example 1: . Input: nums = [0,2,1,5,3,4] Output: [0,1,2,4,5,3] Explanation: The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]] = [0,1,2,4,5,3] . Example 2: . Input: nums = [5,0,1,2,3,4] Output: [4,5,0,1,2,3] Explanation: The array ans is built as follows: ans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]] = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]] = [4,5,0,1,2,3] . Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 0 &lt;= nums[i] &lt; nums.length | The elements in nums are distinct. | Follow-up: Can you solve it without using an extra space (i.e., O(1) memory)? | . Solution: . class Solution { public int[] buildArray(int[] nums) { int[] ans = new int[nums.length]; for(int i = 0; i &lt; nums.length; i++) ans[i] = nums[nums[i]]; return ans; } } . Using constant memory . class Solution { public int[] buildArray(int[] nums) { for(int i = 0; i &lt; nums.length; i++){ nums[i] = nums.length*(nums[nums[i]]%nums.length) + nums[i]; } for(int i = 0; i &lt; nums.length; i++) nums[i] = nums[i]/nums.length; return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-294-Build-Array-from-Permutation/",
    "relUrl": "/problem-294-Build-Array-from-Permutation/"
  },"318": {
    "doc": "Count Square Sum Triples",
    "title": "Count Square Sum Triples",
    "content": "A square triple (a,b,c) is a triple where a, b, and c are integers and a2 + b2 = c2. Given an integer n, return the number of square triples such that 1 &lt;= a, b, c &lt;= n. Example 1: . Input: n = 5 Output: 2 Explanation: The square triples are (3,4,5) and (4,3,5). Example 2: . Input: n = 10 Output: 4 Explanation: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10). Constraints: . | 1 &lt;= n &lt;= 250 | . Solution: . class Solution { public int countTriples(int n) { int c = 0; for(int i = 1; i &lt;= n; i++){ for(int j = i + 1; j &lt;= n; j++){ double s = Math.sqrt(i*i + j*j); if(s &lt;= n &amp;&amp; s % 1 == 0) c++; } } return 2*c; } } . ",
    "url": "https://1001anjan.github.io/problem-295-Count-Square-Sum-Triples/",
    "relUrl": "/problem-295-Count-Square-Sum-Triples/"
  },"319": {
    "doc": "Concatenation of Array",
    "title": "Concatenation of Array",
    "content": "Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 &lt;= i &lt; n (0-indexed). Specifically, ans is the concatenation of two nums arrays. Return the array ans. Example 1: . Input: nums = [1,2,1] Output: [1,2,1,1,2,1] Explanation: The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]] - ans = [1,2,1,1,2,1] . Example 2: . Input: nums = [1,3,2,1] Output: [1,3,2,1,1,3,2,1] Explanation: The array ans is formed as follows: - ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]] - ans = [1,3,2,1,1,3,2,1] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution . class Solution { public int[] getConcatenation(int[] nums) { int[] ans = new int[nums.length*2]; for(int i = 0; i &lt; nums.length; i++){ ans[i] = nums[i]; ans[nums.length + i] = nums[i]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-296-Concatenation-of-Array/",
    "relUrl": "/problem-296-Concatenation-of-Array/"
  },"320": {
    "doc": "Maximum Number of Words You Can Type",
    "title": "Maximum Number of Words You Can Type",
    "content": "There is a malfunctioning keyboard where some letter keys do not work. All other keys on the keyboard work properly. Given a string text of words separated by a single space (no leading or trailing spaces) and a string brokenLetters of all distinct letter keys that are broken, return the number of words in text you can fully type using this keyboard. Example 1: . Input: text = \"hello world\", brokenLetters = \"ad\" Output: 1 Explanation: We cannot type \"world\" because the 'd' key is broken. Example 2: . Input: text = \"leet code\", brokenLetters = \"lt\" Output: 1 Explanation: We cannot type \"leet\" because the 'l' and 't' keys are broken. Example 3: . Input: text = \"leet code\", brokenLetters = \"e\" Output: 0 Explanation: We cannot type either word because the 'e' key is broken. Constraints: . | 1 &lt;= text.length &lt;= 104 | 0 &lt;= brokenLetters.length &lt;= 26 | text consists of words separated by a single space without any leading or trailing spaces. | Each word only consists of lowercase English letters. | brokenLetters consists of distinct lowercase English letters. | . Solution: . class Solution { public int canBeTypedWords(String text, String brokenLetters) { boolean[] dp = new boolean[26]; for(char c : brokenLetters.toCharArray()) dp[c - 'a'] = true; int wc = 1; int df = 0; boolean finished = true; for(char c : text.toCharArray()){ if(c == ' '){ wc++; finished = true; }else if(finished &amp;&amp; dp[c - 'a']){ finished = false; df++; } } return wc - df; } } . ",
    "url": "https://1001anjan.github.io/problem-297-Maximum-Number-of-Words-You-Can-Type/",
    "relUrl": "/problem-297-Maximum-Number-of-Words-You-Can-Type/"
  },"321": {
    "doc": "Check if All Characters Have Equal Number of Occurrences",
    "title": "Check if All Characters Have Equal Number of Occurrences",
    "content": "Given a string s, return true if s is a good string, or false otherwise. A string s is good if all the characters that appear in s have the same number of occurrences (i.e., the same frequency). Example 1: . Input: s = \"abacbc\" Output: true Explanation: The characters that appear in s are 'a', 'b', and 'c'. All characters occur 2 times in s. Example 2: . Input: s = \"aaabb\" Output: false Explanation: The characters that appear in s are 'a' and 'b'. 'a' occurs 3 times while 'b' occurs 2 times, which is not the same number of times. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of lowercase English letters. | . Solution: . class Solution { public boolean areOccurrencesEqual(String s) { int[] dp = new int[26]; for(char c : s.toCharArray()) dp[c - 'a']++; int i = 0; while(i &lt; 26 &amp;&amp; dp[i] == 0) i++; // since we have atleast one char int p = dp[i]; while(i &lt; 26){ if(dp[i] != 0 &amp;&amp; dp[i] != p) return false; i++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-298-Check%20if%20All%20Characters%20Have%20Equal%20Number%20of%20Occurrences/",
    "relUrl": "/problem-298-Check if All Characters Have Equal Number of Occurrences/"
  },"322": {
    "doc": "Sum of Digits of String After Convert",
    "title": "Sum of Digits of String After",
    "content": "You are given a string s consisting of lowercase English letters, and an integer k. First, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace ‘a’ with 1, ‘b’ with 2, …, ‘z’ with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total. For example, if s = “zbax” and k = 2, then the resulting integer would be 8 by the following operations: . | Convert: “zbax” ➝ “(26)(2)(1)(24)” ➝ “262124” ➝ 262124 | Transform #1: 262124 ➝ 2 + 6 + 2 + 1 + 2 + 4 ➝ 17 | Transform #2: 17 ➝ 1 + 7 ➝ 8 | Return the resulting integer after performing the operations described above. | . Example 1: . Input: s = \"iiii\", k = 1 Output: 36 Explanation: The operations are as follows: - Convert: \"iiii\" ➝ \"(9)(9)(9)(9)\" ➝ \"9999\" ➝ 9999 - Transform #1: 9999 ➝ 9 + 9 + 9 + 9 ➝ 36 Thus the resulting integer is 36. Example 2: . Input: s = \"leetcode\", k = 2 Output: 6 Explanation: The operations are as follows: - Convert: \"leetcode\" ➝ \"(12)(5)(5)(20)(3)(15)(4)(5)\" ➝ \"12552031545\" ➝ 12552031545 - Transform #1: 12552031545 ➝ 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 ➝ 33 - Transform #2: 33 ➝ 3 + 3 ➝ 6 Thus the resulting integer is 6. Example 3: Input: s = \"zbax\", k = 2 Output: 8 . Constraints: . | 1 &lt;= s.length &lt;= 100 | 1 &lt;= k &lt;= 10 | s consists of lowercase English letters. | . Solution: . class Solution { public int getLucky(String s, int k) { StringBuilder sb1 = new StringBuilder(); for(char c : s.toCharArray()) sb1.append(c - 96); int sum = 0; while(k &gt;= 1){ sum = 0; for(char c : sb1.toString().toCharArray()) sum += c - 48; sb1.setLength(0); sb1.append(sum); k--; } return sum; } } . Improvement–&gt; . class Solution { public static int getLucky(String s, int k) { int totalAddedValue = toInteger(s); for(int roundCounter = 1; roundCounter &lt; k; roundCounter++){ totalAddedValue = addDigitsOfNumbers(totalAddedValue); } return totalAddedValue; } public static int toInteger(String s) { int integerValueOfString = 0; int valueAdde; for(int index = 0; index &lt; s.length(); index++){ integerValueOfString = (integerValueOfString + addDigitsOfNumbers((int)(s.charAt(index) - 96))); } return integerValueOfString; } public static int addDigitsOfNumbers(int number) { int addedValue = 0; while (number != 0){ addedValue = addedValue + (number % 10); number = number / 10; } return addedValue; } } . ",
    "url": "https://1001anjan.github.io/problem-299-Sum%20of%20Digits%20of%20String%20After%20Convert/#sum-of-digits-of-string-after",
    "relUrl": "/problem-299-Sum of Digits of String After Convert/#sum-of-digits-of-string-after"
  },"323": {
    "doc": "Sum of Digits of String After Convert",
    "title": "Sum of Digits of String After Convert",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-299-Sum%20of%20Digits%20of%20String%20After%20Convert/",
    "relUrl": "/problem-299-Sum of Digits of String After Convert/"
  },"324": {
    "doc": "Longest Substring Without Repeating Characters",
    "title": "Longest Substring Without Repeating Characters",
    "content": "Given a string s, find the length of the longest substring without repeating characters. Example 1: . Input: s = \"abcabcbb\" Output: 3 Explanation: The answer is \"abc\", with the length of 3. Example 2: . Input: s = \"bbbbb\" Output: 1 Explanation: The answer is \"b\", with the length of 1. Example 3: . Input: s = \"pwwkew\" Output: 3 Explanation: The answer is \"wke\", with the length of 3. Notice that the answer must be a substring, \"pwke\" is a subsequence and not a substring. Constraints: . | 0 &lt;= s.length &lt;= 5 * 104 | s consists of English letters, digits, symbols and spaces. | . Solution: . class Solution { public int lengthOfLongestSubstring(String str) { Set&lt;Character&gt; set = new HashSet&lt;&gt;(); int s = 0, e = 0, max = 0, curr = 0; while(e &lt; str.length()){ char ch = str.charAt(e); if(set.add(ch)){ curr++; e++; }else{ while(str.charAt(s) != ch) { set.remove(str.charAt(s)); s++; } s++; curr = e - s + 1; e++; } max = Math.max(max, curr); } return max; } } . class Solution { public int lengthOfLongestSubstring(String s) { int max = 0; int tmax; for(int i=0; i&lt;s.length(); i++){ tmax= 1; HashSet&lt;Character&gt; set = new HashSet(); set.add(s.charAt(i)); for(int j= i+1; j&lt;s.length(); j++){ if(set.contains(s.charAt(j))) break; tmax++; set.add(s.charAt(j)); } if(tmax&gt;max) max = tmax; } return max; } } . class Solution { public int lengthOfLongestSubstring(String s) { int count = 0; int temp = 0; Set&lt;Character&gt; set = new HashSet&lt;Character&gt;(); if(s.length() == 0 ) return 0; if(s.length() == 1) return 1; for(int i = 0 ; i&lt;s.length(); i++){ if(temp&gt;count){ count = temp; } temp = 0; set.clear(); for(int j=i ; j&lt;s.length(); j++){ if(set.contains(s.charAt(j))){ break; } temp++; set.add(s.charAt(j)); } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-3-Longest%20Substring%20Without%20Repeating%20Characters/",
    "relUrl": "/problem-3-Longest Substring Without Repeating Characters/"
  },"325": {
    "doc": "Roman to Integer",
    "title": "3.  Roman to Integer",
    "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 . For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: . | I can be placed before V (5) and X (10) to make 4 and 9. | X can be placed before L (50) and C (100) to make 40 and 90. | C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. | . Example 1: . Input: s = \"III\" Output: 3 Explanation: III = 3. Example 2: . Input: s = \"LVIII\" Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3: . Input: s = \"MCMXCIV\" Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: . | 1 &lt;= s.length &lt;= 15 | s contains only the characters (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’). | It is guaranteed that s is a valid roman numeral in the range [1, 3999]. | . Solution: . class Solution { public int romanToInt(String s) { int sum = 0; char ch; for(int i = 0; i&lt;s.length(); i++){ ch = s.charAt(i); if(ch == 'I'){ if( i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'V'){ sum = sum + 4; i++; }else if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'X'){ sum = sum + 9; i++; }else{ sum = sum + 1; } }else if(ch == 'V'){ sum = sum + 5; }else if(ch == 'X'){ if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'L'){ sum = sum + 40; i++; }else if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'C'){ sum = sum + 90; i++; }else{ sum = sum + 10; } }else if(ch == 'L'){ sum = sum + 50; }else if(ch == 'C'){ if(i+1 &lt;s.length() &amp;&amp; s.charAt(i+1) == 'D'){ sum = sum + 400; i++; }else if(i+1&lt;s.length() &amp;&amp; s.charAt(i+1) == 'M'){ sum = sum + 900; i++; }else{ sum = sum + 100; } }else if(ch == 'D'){ sum = sum + 500; }else if(ch == 'M'){ sum = sum + 1000; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/problem-3-Roman-to-Integer/#3--roman-to-integer",
    "relUrl": "/docs/data-structure/ds-easy-set-1/problem-3-Roman-to-Integer/#3--roman-to-integer"
  },"326": {
    "doc": "Roman to Integer",
    "title": "Roman to Integer",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/problem-3-Roman-to-Integer/",
    "relUrl": "/docs/data-structure/ds-easy-set-1/problem-3-Roman-to-Integer/"
  },"327": {
    "doc": "Jump Game",
    "title": "Jump Game",
    "content": "You are given an integer array nums. You are initially positioned at the array’s first index, and each element in the array represents your maximum jump length at that position. Return true if you can reach the last index, or false otherwise. Example 1: . Input: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2: . Input: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public boolean canJump(int[] nums) { boolean[] dp = new boolean[nums.length]; return testJump(nums,0, dp); } public boolean testJump(int[] arr, int start, boolean[] dp){ if(start &gt;= arr.length - 1) return true; if(arr[start] == 0) return false; boolean status = false; for(int i = start + 1; i &lt;= start + arr[start]; i++){ if(i &gt;= arr.length - 1) return true; if(!dp[i]){ dp[i] = true; status = status | testJump(arr, i, dp); } } return status; } } . class Solution { //we can use dynamic programming. //for a given position i //OPT[i] represent whether it is possible to reach the last index or not. //OPT[i] = true if (i == last Index) //OPT[i] = OPT[i+1] || OPT[i+2] || ... }} OPT[i+nums[i]] //OPT[i] = false if (nums[i] == 0) //The result is opt[0]; public boolean canJump(int[] nums) { boolean[] dp = new boolean[nums.length]; Arrays.fill(dp, false); dp[nums.length-1] = true; for(int i = nums.length - 2; i &gt;= 0; i--){ if(nums[i] == 0) dp[i] = false; else{ if(nums[i] + i &gt;= nums.length) dp[i] = true; else{ for(int j = 1; j &lt;= nums[i]; j++){ dp[i] = dp[i] || dp[i + j]; //tricky part: the next recurrance is aslo cover some elements for this value so that we can skip them. j += nums[i + j]; } } } } return dp[0]; } } . Assume that we can move step = nums[0] steps at the beginning, then move to num[1] and step–, always take the max of num[1] and step as remaining steps, and repeat until arriving at the last element. If step == 0 during the iteration, it means we could neither move forward nor reach the end, so return false. class Solution { public boolean canJump(int[] nums) { int step = nums[0]; for (int i = 1; i &lt; nums.length; i++) { if (step == 0) return false; step = Math.max(--step, nums[i]); } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-30-Jump%20Game/",
    "relUrl": "/problem-30-Jump Game/"
  },"328": {
    "doc": "Linked List Cycle",
    "title": "Linked List Cycle",
    "content": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter. Return true if there is a cycle in the linked list. Otherwise, return false. Example 1: . Input: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Constraints: . | The number of the nodes in the list is in the range [0, 104]. | -105 &lt;= Node.val &lt;= 105 | pos is -1 or a valid index in the linked-list. | . Solution: . Using extra memory . /** * Definition for singly-linked list. * class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public boolean hasCycle(ListNode head) { if(head == null) return false; Set&lt;ListNode&gt; set = new HashSet&lt;ListNode&gt;(); while(head != null){ if(set.contains(head)) { return true; } set.add(head); head = head.next; } return false; } } . Using constant memory . public class Solution { public boolean hasCycle(ListNode head) { ListNode fast = head; ListNode last = head; while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; last = last.next; if(fast == last){ return true; } } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-30-Linked-List-Cycle/",
    "relUrl": "/problem-30-Linked-List-Cycle/"
  },"329": {
    "doc": "Three Divisors",
    "title": "Three Divisors",
    "content": "Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false. An integer m is a divisor of n if there exists an integer k such that n = k * m. Example 1: . Input: n = 2 Output: false Explantion: 2 has only two divisors: 1 and 2. Example 2: . Input: n = 4 Output: true Explantion: 4 has three divisors: 1, 2, and 4. Constraints: . | 1 &lt;= n &lt;= 10^4 | . Solution: . class Solution { public boolean isThree(int n) { int c = 0; for(int i = 2; i &lt;= n / 2; i++){ if(n % i == 0){ c++; if(c &gt; 1) return false; } } return c == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-300-Three-Divisors/",
    "relUrl": "/problem-300-Three-Divisors/"
  },"330": {
    "doc": "Delete Characters to Make Fancy String",
    "title": "Delete Characters to Make Fancy String",
    "content": "A fancy string is a string where no three consecutive characters are equal. Given a string s, delete the minimum possible number of characters from s to make it fancy. Return the final string after the deletion. It can be shown that the answer will always be unique. Example 1: . Input: s = \"leeetcode\" Output: \"leetcode\" Explanation: Remove an 'e' from the first group of 'e's to create \"leetcode\". No three consecutive characters are equal, so return \"leetcode\". Example 2: . Input: s = \"aaabaaaa\" Output: \"aabaa\" Explanation: Remove an 'a' from the first group of 'a's to create \"aabaaaa\". Remove two 'a's from the second group of 'a's to create \"aabaa\". No three consecutive characters are equal, so return \"aabaa\". Example 3: . Input: s = \"aab\" Output: \"aab\" Explanation: No three consecutive characters are equal, so return \"aab\". Constraints: . | 1 &lt;= s.length &lt;= 10^5 | s consists only of lowercase English letters. | . Solution: . class Solution { public String makeFancyString(String s) { StringBuilder sb = new StringBuilder(); char[] chr = s.toCharArray(); sb.append(chr[0]); int c = 1; for(int i = 1; i &lt; chr.length; i++){ if(chr[i - 1] == chr[i]){ c++; if(c &lt; 3){ sb.append(chr[i]); } }else{ c = 1; sb.append(chr[i]); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-301-Delete%20Characters%20to%20Make%20Fancy%20String/",
    "relUrl": "/problem-301-Delete Characters to Make Fancy String/"
  },"331": {
    "doc": "Check If String Is a Prefix of Array",
    "title": "Check If String Is a Prefix of Array",
    "content": "Given a string s and an array of strings words, determine whether s is a prefix string of words. A string s is a prefix string of words if s can be made by concatenating the first k strings in words for some positive k no larger than words.length. Return true if s is a prefix string of words, or false otherwise. Example 1: . Input: s = \"iloveleetcode\", words = [\"i\",\"love\",\"leetcode\",\"apples\"] Output: true Explanation: s can be made by concatenating \"i\", \"love\", and \"leetcode\" together. Example 2: . Input: s = \"iloveleetcode\", words = [\"apples\",\"i\",\"love\",\"leetcode\"] Output: false Explanation: It is impossible to make s using a prefix of arr. Constraints: . *1 &lt;= words.length &lt;= 100 . | 1 &lt;= words[i].length &lt;= 20 | 1 &lt;= s.length &lt;= 1000 | words[i] and s consist of only lowercase English letters. | . class Solution { public boolean isPrefixString(String s, String[] words) { StringBuilder sb = new StringBuilder(); for(String str : words){ sb.append(str); if(s.equals(sb.toString())) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-302-Check%20If%20String%20Is%20a%20Prefix%20of%20Array/",
    "relUrl": "/problem-302-Check If String Is a Prefix of Array/"
  },"332": {
    "doc": "Number of Strings That Appear as Substrings in Word",
    "title": "Number of Strings That Appear as Substrings in Word",
    "content": "Given an array of strings patterns and a string word, return the number of strings in patterns that exist as a substring in word. A substring is a contiguous sequence of characters within a string. Example 1: . Input: patterns = [\"a\",\"abc\",\"bc\",\"d\"], word = \"abc\" Output: 3 Explanation: - \"a\" appears as a substring in \"abc\". - \"abc\" appears as a substring in \"abc\". - \"bc\" appears as a substring in \"abc\". - \"d\" does not appear as a substring in \"abc\". 3 of the strings in patterns appear as a substring in word. Example 2: . Input: patterns = [\"a\",\"b\",\"c\"], word = \"aaaaabbbbb\" Output: 2 Explanation: - \"a\" appears as a substring in \"aaaaabbbbb\". - \"b\" appears as a substring in \"aaaaabbbbb\". - \"c\" does not appear as a substring in \"aaaaabbbbb\". 2 of the strings in patterns appear as a substring in word. Example 3: . Input: patterns = [\"a\",\"a\",\"a\"], word = \"ab\" Output: 3 Explanation: Each of the patterns appears as a substring in word \"ab\". Constraints: . | 1 &lt;= patterns.length &lt;= 100 | 1 &lt;= patterns[i].length &lt;= 100 | 1 &lt;= word.length &lt;= 100 | patterns[i] and word consist of lowercase English letters. | . Solution: . class Solution { public int numOfStrings(String[] patterns, String word) { int c = 0; for(String s : patterns){ if(word.contains(s)) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-303-Number%20of%20Strings%20That%20Appear%20as%20Substrings%20in%20Word/",
    "relUrl": "/problem-303-Number of Strings That Appear as Substrings in Word/"
  },"333": {
    "doc": "Minimum Time to Type Word Using Special Typewriter",
    "title": "Minimum Time to Type Word Using Special Typewriter",
    "content": "There is a special typewriter with lowercase English letters ‘a’ to ‘z’ arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character ‘a’. Each second, you may perform one of the following operations: . | Move the pointer one character counterclockwise or clockwise. | Type the character the pointer is currently on. | . Given a string word, return the minimum number of seconds to type out the characters in word. Example 1: . Input: word = \"abc\" Output: 5 Explanation: The characters are printed as follows: - Type the character 'a' in 1 second since the pointer is initially on 'a'. - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer clockwise to 'c' in 1 second. - Type the character 'c' in 1 second. Example 2: . Input: word = \"bza\" Output: 7 Explanation: The characters are printed as follows: - Move the pointer clockwise to 'b' in 1 second. - Type the character 'b' in 1 second. - Move the pointer counterclockwise to 'z' in 2 seconds. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'a' in 1 second. - Type the character 'a' in 1 second. Example 3: . Input: word = \"zjpc\" Output: 34 Explanation: The characters are printed as follows: - Move the pointer counterclockwise to 'z' in 1 second. - Type the character 'z' in 1 second. - Move the pointer clockwise to 'j' in 10 seconds. - Type the character 'j' in 1 second. - Move the pointer clockwise to 'p' in 6 seconds. - Type the character 'p' in 1 second. - Move the pointer counterclockwise to 'c' in 13 seconds. - Type the character 'c' in 1 second. Constraints: . | 1 &lt;= word.length &lt;= 100 | word consists of lowercase English letters. | . Solution: . class Solution { public int minTimeToType(String word) { int t = 0; char prev = 'a'; for(int i = 0; i &lt; word.length(); i++){ char curr = word.charAt(i); int d = Math.abs(prev - curr); int v = Math.min(d, 26 - d); t += v + 1; prev = curr; } return t; } } . ",
    "url": "https://1001anjan.github.io/problem-304-Minimum%20Time%20to%20Type%20Word%20Using%20Special%20Typewriter/",
    "relUrl": "/problem-304-Minimum Time to Type Word Using Special Typewriter/"
  },"334": {
    "doc": "Find Greatest Common Divisor of Array",
    "title": "Find Greatest Common Divisor of Array",
    "content": "Given an integer array nums, return the greatest common divisor of the smallest number and largest number in nums. The greatest common divisor of two numbers is the largest positive integer that evenly divides both numbers. Example 1: . Input: nums = [2,5,6,9,10] Output: 2 Explanation: The smallest number in nums is 2. The largest number in nums is 10. The greatest common divisor of 2 and 10 is 2. Example 2: . Input: nums = [7,5,6,8,3] Output: 1 Explanation: The smallest number in nums is 3. The largest number in nums is 8. The greatest common divisor of 3 and 8 is 1. Example 3: . Input: nums = [3,3] Output: 3 Explanation: The smallest number in nums is 3. The largest number in nums is 3. The greatest common divisor of 3 and 3 is 3. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int findGCD(int[] nums) { int mx, mn; mx = mn = nums[0]; for(int n : nums){ if(n &gt; mx) mx = n; if(n &lt; mn) mn = n; } for(int i = mn; i &gt;= 1; i--){ if(mx % i == 0 &amp;&amp; mn % i == 0) return i; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-305-Find%20Greatest%20Common%20Divisor%20of%20Array/",
    "relUrl": "/problem-305-Find Greatest Common Divisor of Array/"
  },"335": {
    "doc": "Minimum Difference Between Highest and Lowest of K Scores",
    "title": "Minimum Difference Between Highest and Lowest of K Scores",
    "content": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k. Pick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized. Return the minimum possible difference. Example 1: . Input: nums = [90], k = 1 Output: 0 Explanation: There is one way to pick score(s) of one student: - [90]. The difference between the highest and lowest score is 90 - 90 = 0. The minimum possible difference is 0. Example 2: . Input: nums = [9,4,1,7], k = 2 Output: 2 Explanation: There are six ways to pick score(s) of two students: - [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5. - [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8. - [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2. - [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3. - [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3. - [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6. The minimum possible difference is 2. Constraints: . | 1 &lt;= k &lt;= nums.length &lt;= 1000 | 0 &lt;= nums[i] &lt;= 105 | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-306-Minimum%20Difference%20Between%20Highest%20and%20Lowest%20of%20K%20Scores/",
    "relUrl": "/problem-306-Minimum Difference Between Highest and Lowest of K Scores/"
  },"336": {
    "doc": "Count Special Quadruplets",
    "title": "Count Special Quadruplets",
    "content": "Given a 0-indexed integer array nums, return the number of distinct quadruplets (a, b, c, d) such that: . | nums[a] + nums[b] + nums[c] == nums[d], and | a &lt; b &lt; c &lt; d | . Example 1: . Input: nums = [1,2,3,6] Output: 1 Explanation: The only quadruplet that satisfies the requirement is (0, 1, 2, 3) because 1 + 2 + 3 == 6. Example 2: . Input: nums = [3,3,6,4,5] Output: 0 Explanation: There are no such quadruplets in [3,3,6,4,5]. Example 3: . Input: nums = [1,1,1,3,5] Output: 4 Explanation: The 4 quadruplets that satisfy the requirement are: - (0, 1, 2, 3): 1 + 1 + 1 == 3 - (0, 1, 3, 4): 1 + 1 + 3 == 5 - (0, 2, 3, 4): 1 + 1 + 3 == 5 - (1, 2, 3, 4): 1 + 1 + 3 == 5 . Constraints: . | 4 &lt;= nums.length &lt;= 50 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int countQuadruplets(int[] nums) { int c = 0; for(int i = 0; i &lt; nums.length - 3; i++){ for(int j = i + 1; j &lt; nums.length - 2; j++){ for(int k = j + 1; k &lt; nums.length - 1; k++){ int v = nums[i] + nums[j] + nums[k]; for(int l = k + 1; l &lt; nums.length; l++) if(v == nums[l]) c++; } } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-307-Count%20Special%20Quadruplets/",
    "relUrl": "/problem-307-Count Special Quadruplets/"
  },"337": {
    "doc": "Reverse Prefix of Word",
    "title": "Reverse Prefix of Word",
    "content": "Given a 0-indexed string word and a character ch, reverse the segment of word that starts at index 0 and ends at the index of the first occurrence of ch (inclusive). If the character ch does not exist in word, do nothing. For example, if word = “abcdefd” and ch = “d”, then you should reverse the segment that starts at 0 and ends at 3 (inclusive). The resulting string will be “dcbaefd”. Return the resulting string. Example 1: . Input: word = \"abcdefd\", ch = \"d\" Output: \"dcbaefd\" Explanation: The first occurrence of \"d\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"dcbaefd\". Example 2: . Input: word = \"xyxzxe\", ch = \"z\" Output: \"zxyxxe\" Explanation: The first and only occurrence of \"z\" is at index 3. Reverse the part of word from 0 to 3 (inclusive), the resulting string is \"zxyxxe\". Example 3: . Input: word = \"abcd\", ch = \"z\" Output: \"abcd\" Explanation: \"z\" does not exist in word. You should not do any reverse operation, the resulting string is \"abcd\". Constraints: . | 1 &lt;= word.length &lt;= 250 | word consists of lowercase English letters. | ch is a lowercase English letter. | . Solution: . class Solution { public String reversePrefix(String word, char ch) { StringBuffer sb = new StringBuffer(); int n = word.length(); int i = 0; for(; i &lt; n; i++){ char c = word.charAt(i); sb.append(c); if(c == ch) break; } if(i == n) return sb.toString(); return sb.reverse().append(word.substring(i + 1,n)).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-308-Reverse-Prefix-of-Word/",
    "relUrl": "/problem-308-Reverse-Prefix-of-Word/"
  },"338": {
    "doc": "Count Number of Pairs With Absolute Difference K",
    "title": "Count Number of Pairs With Absolute Difference K",
    "content": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i &lt; j such that |nums[i] - nums[j]| == k. | The value of | x | is defined as: | . | x if x &gt;= 0. | -x if x &lt; 0. | . Example 1: . Input: nums = [1,2,2,1], k = 1 Output: 4 Explanation: The pairs with an absolute difference of 1 are: - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] - [1,2,2,1] . Example 2: . Input: nums = [1,3], k = 3 Output: 0 Explanation: There are no pairs with an absolute difference of 3. Example 3: . Input: nums = [3,2,1,5,4], k = 2 Output: 3 Explanation: The pairs with an absolute difference of 2 are: - [3,2,1,5,4] - [3,2,1,5,4] - [3,2,1,5,4] . Constraints: . | 1 &lt;= nums.length &lt;= 200 | 1 &lt;= nums[i] &lt;= 100 | 1 &lt;= k &lt;= 99 | . Solution: O(n) complexity with constant space . class Solution { public int countKDifference(int[] nums, int k) { int i , j , max = 0 , pairs = 0 ; int[] count = new int[101] ; for( i = 0 ; i &lt; nums.length ; i++ ){ count[nums[i]]++ ; if( nums[i] &gt; max ){ max = nums[i] ; } } for( i = 1 , j = i + k ; j &lt;= max ; i++ , j++ ){ if( count[i] &gt; 0 &amp;&amp; count[j] &gt; 0 ){ pairs += count[i] * count[j] ; } } return pairs ; } } . O(n^2 complexity) . class Solution { public int countKDifference(int[] nums, int k) { int c = 0; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ int d = nums[j] - nums[i]; if(d == k) c++; else if(d &gt; k) break; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-309-Count-Number-of-Pairs-With-Absolute-Difference-K/",
    "relUrl": "/problem-309-Count-Number-of-Pairs-With-Absolute-Difference-K/"
  },"339": {
    "doc": "Binary Tree Preorder Traversal",
    "title": "Binary Tree Preorder Traversal",
    "content": "Given the root of a binary tree, return the preorder traversal of its nodes’ values. Example 1: . Input: root = [1,null,2,3] Output: [1,2,3] . Example 2: . Input: root = [] Output: [] . Example 3: . Input: root = [1] Output: [1] . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public List&lt;Integer&gt; preorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); return preorderTraversal(root, list); } public List&lt;Integer&gt; preorderTraversal(TreeNode head, List&lt;Integer&gt; list){ if(head == null) return list; list.add(head.val); preorderTraversal(head.left,list); preorderTraversal(head.right,list); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-31-Binary-Tree-Preorder-Traversal/",
    "relUrl": "/problem-31-Binary-Tree-Preorder-Traversal/"
  },"340": {
    "doc": "Binary Tree Preorder Traversal",
    "title": "Binary Tree Postorder Traversal",
    "content": "Example 1: . Input: root = [1,null,2,3] Output: [3,2,1] . Example 2: . Input: root = [] Output: [] . Solution . class Solution { public List&lt;Integer&gt; postorderTraversal(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); return postorderTraversal(root, list); } public List&lt;Integer&gt; postorderTraversal(TreeNode head, List&lt;Integer&gt; list){ if(head == null) return list; postorderTraversal(head.left,list); postorderTraversal(head.right,list); list.add(head.val); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-31-Binary-Tree-Preorder-Traversal/#binary-tree-postorder-traversal",
    "relUrl": "/problem-31-Binary-Tree-Preorder-Traversal/#binary-tree-postorder-traversal"
  },"341": {
    "doc": "Merge Intervals",
    "title": "Merge Intervals",
    "content": "Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input. Example 1: . Input: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2: . Input: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping. Constraints: . | 1 &lt;= intervals.length &lt;= 10^4 | intervals[i].length == 2 | 0 &lt;= starti &lt;= endi &lt;= 10^4 | . Solution: . class Solution { public int[][] merge(int[][] intervals) { List&lt;List&lt;Integer&gt;&gt; list = new LinkedList&lt;&gt;(); Arrays.sort(intervals, (a,b) -&gt;{ if(a[0] != b[0]) return a[0] - b[0]; return a[1] - b[1]; }); int i1 = intervals[0][0]; int i2 = intervals[0][1]; int i = 1; while(i &lt; intervals.length){ if(i2 &gt;= intervals[i][0]){ i2 = Math.max(i2, intervals[i][1]); }else{ List&lt;Integer&gt; l = new LinkedList&lt;&gt;(); l.add(i1); l.add(i2); list.add(l); i1 = intervals[i][0]; i2 = intervals[i][1]; } i++; } List&lt;Integer&gt; l = new LinkedList&lt;&gt;(); l.add(i1); l.add(i2); list.add(l); int[][] ans = new int[list.size()][2]; i = 0; for(List&lt;Integer&gt; l1 : list){ ans[i][0] = l1.get(0); ans[i][1] = l1.get(1); i++; } return ans; } } . class Solution { public int[][] merge(int[][] intervals) { Arrays.sort(intervals, (a, b) -&gt; Integer.compare(a[0], b[0])); LinkedList&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); for (int[] interval : intervals) { // if the list of merged intervals is empty or if the current // interval does not overlap with the previous, simply append it. if (merged.isEmpty() || merged.getLast()[1] &lt; interval[0]) { merged.add(interval); } // otherwise, there is overlap, so we merge the current and previous // intervals. else { merged.getLast()[1] = Math.max(merged.getLast()[1], interval[1]); } } return merged.toArray(new int[merged.size()][]); } } . ",
    "url": "https://1001anjan.github.io/problem-31-Merge%20Intervals/",
    "relUrl": "/problem-31-Merge Intervals/"
  },"342": {
    "doc": "Final Value of Variable After Performing Operations",
    "title": "Final Value of Variable After Performing Operations",
    "content": "There is a programming language with only four operations and one variable X: . ++X and X++ increments the value of the variable X by 1. –X and X– decrements the value of the variable X by 1. Initially, the value of X is 0. Given an array of strings operations containing a list of operations, return the final value of X after performing all the operations. Example 1: . Input: operations = [\"--X\",\"X++\",\"X++\"] Output: 1 Explanation: The operations are performed as follows: Initially, X = 0. --X: X is decremented by 1, X = 0 - 1 = -1. X++: X is incremented by 1, X = -1 + 1 = 0. X++: X is incremented by 1, X = 0 + 1 = 1. Example 2: . Input: operations = [\"++X\",\"++X\",\"X++\"] Output: 3 Explanation: The operations are performed as follows: Initially, X = 0. ++X: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. X++: X is incremented by 1, X = 2 + 1 = 3. Example 3: . Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"] Output: 0 Explanation: The operations are performed as follows: Initially, X = 0. X++: X is incremented by 1, X = 0 + 1 = 1. ++X: X is incremented by 1, X = 1 + 1 = 2. --X: X is decremented by 1, X = 2 - 1 = 1. X--: X is decremented by 1, X = 1 - 1 = 0. Constraints: . | 1 &lt;= operations.length &lt;= 100 | operations[i] will be either “++X”, “X++”, “–X”, or “X–”. | . Solution: . class Solution { public int finalValueAfterOperations(String[] operations) { int x = 0; for(String str : operations){ char c = str.charAt(0); if(Character.isLetter(c)){ if(str.charAt(2) == '+'){ x++; }else{ x--; } }else{ if(c == '+'){ x++; }else{ x--; } } } return x; } } . Improved . class Solution { public int finalValueAfterOperations(String[] operations) { int x = 0; for(String str : operations){ if(str.charAt(1) == '+'){ x++; }else{ x--; } } return x; } } . ",
    "url": "https://1001anjan.github.io/problem-310-Final%20Value%20of%20Variable%20After%20Performing%20Operations/",
    "relUrl": "/problem-310-Final Value of Variable After Performing Operations/"
  },"343": {
    "doc": "Maximum Difference Between Increasing Elements",
    "title": "Maximum Difference Between Increasing Elements",
    "content": "Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 &lt;= i &lt; j &lt; n and nums[i] &lt; nums[j]. Return the maximum difference. If no such i and j exists, return -1. Example 1: . Input: nums = [7,1,5,4] Output: 4 Explanation: The maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4. Note that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i &gt; j, so it is not valid. Example 2: . Input: nums = [9,4,3,2] Output: -1 Explanation: There is no i and j such that i &lt; j and nums[i] &lt; nums[j]. Example 3: . Input: nums = [1,5,2,10] Output: 9 Explanation: The maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9. Constraints: . | n == nums.length | 2 &lt;= n &lt;= 1000 | 1 &lt;= nums[i] &lt;= 10^9 | . Solution: O(n^2) complexity . class Solution { public int maximumDifference(int[] nums) { int max = 0; for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ max = Math.max(max,nums[j] - nums[i]); } } return max == 0? -1 : max; } } . O(n) time Complexity . class Solution { public int maximumDifference(int[] nums) { int min = nums[0]; int maxDiff = -1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] &lt; min){ min = nums[i]; }else if(nums[i] - min &gt; maxDiff){ maxDiff = nums[i] - min; } } return maxDiff == 0? -1 : maxDiff; } } . ",
    "url": "https://1001anjan.github.io/problem-311-Maximum%20Difference%20Between%20Increasing%20Elements/",
    "relUrl": "/problem-311-Maximum Difference Between Increasing Elements/"
  },"344": {
    "doc": "Convert 1D Array Into 2D Array",
    "title": "Convert 1D Array Into 2D Array",
    "content": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with m rows and n columns using all the elements from original. The elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on. Return an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible. Example 1: . Input: original = [1,2,3,4], m = 2, n = 2 Output: [[1,2],[3,4]] Explanation: The constructed 2D array should contain 2 rows and 2 columns. The first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array. The second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array. Example 2: . Input: original = [1,2,3], m = 1, n = 3 Output: [[1,2,3]] Explanation: The constructed 2D array should contain 1 row and 3 columns. Put all three elements in original into the first row of the constructed 2D array. Example 3: . Input: original = [1,2], m = 1, n = 1 Output: [] Explanation: There are 2 elements in original. It is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array. Constraints: . | 1 &lt;= original.length &lt;= 5 * 10^4 | 1 &lt;= original[i] &lt;= 10^5 | 1 &lt;= m, n &lt;= 4 * 10^4 | . Solution: . class Solution { public int[][] construct2DArray(int[] original, int m, int n) { if(m * n != original.length) return new int[0][0]; int[][] ans = new int[m][n]; for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ ans[i][j] = original[n*i + j]; } } return ans; } } . ##### . ",
    "url": "https://1001anjan.github.io/problem-312-Convert%201D%20Array%20Into%202D%20Array/",
    "relUrl": "/problem-312-Convert 1D Array Into 2D Array/"
  },"345": {
    "doc": "Minimum Moves to Convert String",
    "title": "Minimum Moves to Convert String",
    "content": "You are given a string s consisting of n characters which are either ‘X’ or ‘O’. A move is defined as selecting three consecutive characters of s and converting them to ‘O’. Note that if a move is applied to the character ‘O’, it will stay the same. Return the minimum number of moves required so that all the characters of s are converted to ‘O’. Example 1: . Input: s = \"XXX\" Output: 1 Explanation: XXX -&gt; OOO We select all the 3 characters and convert them in one move. Example 2: . Input: s = \"XXOX\" Output: 2 Explanation: XXOX -&gt; OOOX -&gt; OOOO We select the first 3 characters in the first move, and convert them to 'O'. Then we select the last 3 characters and convert them so that the final string contains all 'O's. Example 3: . Input: s = \"OOOO\" Output: 0 Explanation: There are no 'X's in s to convert. Constraints: . | 3 &lt;= s.length &lt;= 1000 | s[i] is either ‘X’ or ‘O’. | . Solution: . class Solution { public int minimumMoves(String s) { int count = 0; int idx = 0; while(idx &lt; s.length()){ if(s.charAt(idx) == 'O'){ // if we hit a 'O' we can skip it idx++; }else{ count++; // we find a 'X' idx += 3; // we will flip the substing from(idx, idx+3); } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-313-Minimum%20Moves%20to%20Convert%20String/",
    "relUrl": "/problem-313-Minimum Moves to Convert String/"
  },"346": {
    "doc": "Two Out of Three",
    "title": "Two Out of Three",
    "content": "Given three integer arrays nums1, nums2, and nums3, return a distinct array containing all the values that are present in at least two out of the three arrays. You may return the values in any order. Example 1: . Input: nums1 = [1,1,3,2], nums2 = [2,3], nums3 = [3] Output: [3,2] Explanation: The values that are present in at least two arrays are: - 3, in all three arrays. - 2, in nums1 and nums2. Example 2: . Input: nums1 = [3,1], nums2 = [2,3], nums3 = [1,2] Output: [2,3,1] Explanation: The values that are present in at least two arrays are: - 2, in nums2 and nums3. - 3, in nums1 and nums2. - 1, in nums1 and nums3. Example 3: . Input: nums1 = [1,2,2], nums2 = [4,3,3], nums3 = [5] Output: [] Explanation: No value is present in at least two arrays. Constraints: . | 1 &lt;= nums1.length, nums2.length, nums3.length &lt;= 100 | 1 &lt;= nums1[i], nums2[j], nums3[k] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) { Set&lt;Integer&gt; s1 = new HashSet(); Set&lt;Integer&gt; s2 = new HashSet(); Set&lt;Integer&gt; s3 = new HashSet(); for(int n : nums1) s1.add(n); for(int n : nums2) s2.add(n); for(int n : nums3) s3.add(n); Set&lt;Integer&gt; ans = new HashSet&lt;&gt;(); for(int n : s1){ if(s2.contains(n) || s2.contains(n)) ans.add(n); } for(int n : s2){ if(s1.contains(n) || s3.contains(n)) ans.add(n); } for(int n : s3){ if(s1.contains(n) || s2.contains(n)) ans.add(n); } return new ArrayList(ans); } } . Improvement . class Solution { public List&lt;Integer&gt; twoOutOfThree(int[] nums1, int[] nums2, int[] nums3) { //as the max value of a number is limited to 100.. we can use an arrya of size 100. int[] present = new int[100]; for(int n : nums1) if(present[n - 1] == 0) present[n - 1] += 1; for(int n : nums2) if(present[n-1] &lt; 2) present[n - 1] += 2; for(int n : nums3) if(present[n - 1] != 0) present[n - 1] += 3; List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; 100; ++i){ if(present[i] &gt;= 3) result.add(i + 1); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-314-Two%20Out%20of%20Three/",
    "relUrl": "/problem-314-Two Out of Three/"
  },"347": {
    "doc": "Check if Numbers Are Ascending in a Sentence",
    "title": "Check if Numbers Are Ascending in a Sentence",
    "content": "A sentence is a list of tokens separated by a single space with no leading or trailing spaces. Every token is either a positive number consisting of digits 0-9 with no leading zeros, or a word consisting of lowercase English letters. | For example, “a puppy has 2 eyes 4 legs” is a sentence with seven tokens: “2” and “4” are numbers and the other tokens such as “puppy” are words. Given a string s representing a sentence, you need to check if all the numbers in s are strictly increasing from left to right (i.e., other than the last number, each number is strictly smaller than the number on its right in s). | . Return true if so, or false otherwise. Example 1: . Input: s = \"1 box has 3 blue 4 red 6 green and 12 yellow marbles\" Output: true Explanation: The numbers in s are: 1, 3, 4, 6, 12. They are strictly increasing from left to right: 1 &lt; 3 &lt; 4 &lt; 6 &lt; 12. Example 2: . Input: s = \"hello world 5 x 5\" Output: false Explanation: The numbers in s are: 5, 5. They are not strictly increasing. Example 3: . Input: s = \"sunset is at 7 51 pm overnight lows will be in the low 50 and 60 s\" Output: false Explanation: The numbers in s are: 7, 51, 50, 60. They are not strictly increasing. Constraints: . | 3 &lt;= s.length &lt;= 200 | s consists of lowercase English letters, spaces, and digits from 0 to 9, inclusive. | The number of tokens in s is between 2 and 100, inclusive. | The tokens in s are separated by a single space. | There are at least two numbers in s. | Each number in s is a positive number less than 100, with no leading zeros. | s contains no leading or trailing spaces. | . Solution: . class Solution { public boolean areNumbersAscending(String s) { int curr = 0; int i = 0; int n = s.length(); while(i &lt; n){ char ch = s.charAt(i); if(Character.isDigit(ch)){ int v = 0; while(ch != ' '){ v = v * 10 + ch - '0'; i++; if(i == n) break; ch = s.charAt(i); } if(v &lt;= curr) return false; curr = v; } i++; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-315-Check%20if%20Numbers%20Are%20Ascending%20in%20a%20Sentence/",
    "relUrl": "/problem-315-Check if Numbers Are Ascending in a Sentence/"
  },"348": {
    "doc": "Number of Valid Words in a Sentence",
    "title": "Number of Valid Words in a Sentence",
    "content": "A sentence consists of lowercase letters (‘a’ to ‘z’), digits (‘0’ to ‘9’), hyphens (‘-‘), punctuation marks (‘!’, ‘.’, and ‘,’), and spaces (‘ ‘) only. Each sentence can be broken down into one or more tokens separated by one or more spaces ‘ ‘. A token is a valid word if all three of the following are true: . | It only contains lowercase letters, hyphens, and/or punctuation (no digits). | There is at most one hyphen ‘-‘. If present, it must be surrounded by lowercase characters (“a-b” is valid, but “-ab” and “ab-“ are not valid). | There is at most one punctuation mark. If present, it must be at the end of the token (“ab,”, “cd!”, and “.” are valid, but “a!b” and “c.,” are not valid). | . Examples of valid words include “a-b.”, “afad”, “ba-c”, “a!”, and “!”. Given a string sentence, return the number of valid words in sentence. Example 1: . Input: sentence = \"cat and dog\" Output: 3 Explanation: The valid words in the sentence are \"cat\", \"and\", and \"dog\". Example 2: . Input: sentence = \"!this 1-s b8d!\" Output: 0 Explanation: There are no valid words in the sentence. \"!this\" is invalid because it starts with a punctuation mark. \"1-s\" and \"b8d\" are invalid because they contain digits. Example 3: . Input: sentence = \"alice and bob are playing stone-game10\" Output: 5 Explanation: The valid words in the sentence are \"alice\", \"and\", \"bob\", \"are\", and \"playing\". \"stone-game10\" is invalid because it contains digits. Constraints: . | 1 &lt;= sentence.length &lt;= 1000 | sentence only contains lowercase English letters, digits, ‘ ‘, ‘-‘, ‘!’, ‘.’, and ‘,’. | There will be at least 1 token. | . Solution: . class Solution { public int countValidWords(String sentence) { int count = 0; String[] words = sentence.trim().split(\"\\\\s+\"); for(String str : words){ int hypens = 0; int n = str.length(); int i = 0; while(i &lt; n){ char ch = str.charAt(i); if(Character.isDigit(ch)){ break; } if(ch == '-'){ if(i == 0 || i == n - 1) break; if(!Character.isLetter(str.charAt(i-1)) || !Character.isLetter(str.charAt(i+1))) break; hypens++; }else if(ch == '!' || ch == '.' || ch == ','){ if(i != n - 1) break; } i++; } if(hypens &lt;= 1 &amp;&amp; i == n) count++; } return count; } } . Improvement . class Solution { public int countValidWords(String sentence) { int count = 0; String[] words = sentence.split(\" \"); for(String str : words){ int n = str.length(); if(n == 0) continue; int hypens = 0; int i = 0; while(i &lt; n){ char ch = str.charAt(i); if(Character.isDigit(ch)){ break; } if(ch == '-'){ hypens++; if(i == 0 || i == n - 1 || hypens &gt; 1) break; if(!Character.isLetter(str.charAt(i-1)) || !Character.isLetter(str.charAt(i+1))) break; }else if(ch == '!' || ch == '.' || ch == ','){ if(i != n - 1) break; } i++; } if(i == n) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-316-Number%20of%20Valid%20Words%20in%20a%20Sentence/",
    "relUrl": "/problem-316-Number of Valid Words in a Sentence/"
  },"349": {
    "doc": "Kth Distinct String in an Array",
    "title": "Kth Distinct String in an Array",
    "content": "A distinct string is a string that is present only once in an array. Given an array of strings arr, and an integer k, return the kth distinct string present in arr. If there are fewer than k distinct strings, return an empty string “”. Note that the strings are considered in the order in which they appear in the array. Example 1: . Input: arr = [\"d\",\"b\",\"c\",\"b\",\"c\",\"a\"], k = 2 Output: \"a\" Explanation: The only distinct strings in arr are \"d\" and \"a\". \"d\" appears 1st, so it is the 1st distinct string. \"a\" appears 2nd, so it is the 2nd distinct string. Since k == 2, \"a\" is returned. Example 2: . Input: arr = [\"aaa\",\"aa\",\"a\"], k = 1 Output: \"aaa\" Explanation: All strings in arr are distinct, so the 1st string \"aaa\" is returned. Example 3: . Input: arr = [\"a\",\"b\",\"a\"], k = 3 Output: \"\" Explanation: The only distinct string is \"b\". Since there are fewer than 3 distinct strings, we return an empty string \"\". Constraints: . | 1 &lt;= k &lt;= arr.length &lt;= 1000 | 1 &lt;= arr[i].length &lt;= 5 | arr[i] consists of lowercase English letters. | . Solution: . class Solution { public String kthDistinct(String[] arr, int k) { Set&lt;String&gt; set = new LinkedHashSet&lt;&gt;(); Set&lt;String&gt; dupSet = new HashSet&lt;&gt;(); for(String s : arr){ if(set.contains(s)){ dupSet.add(s); }else{ set.add(s); } } for(String s : dupSet){ set.remove(s); } if(k &gt; set.size()) return \"\"; int i = 1; for(String str : set){ if(i == k) return str; i++; } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-317-Kth%20Distinct%20String%20in%20an%20Array/",
    "relUrl": "/problem-317-Kth Distinct String in an Array/"
  },"350": {
    "doc": "Smallest Index With Equal Value",
    "title": "Smallest Index With Equal Value",
    "content": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist. x mod y denotes the remainder when x is divided by y. Example 1: . Input: nums = [0,1,2] Output: 0 Explanation: i=0: 0 mod 10 = 0 == nums[0]. i=1: 1 mod 10 = 1 == nums[1]. i=2: 2 mod 10 = 2 == nums[2]. All indices have i mod 10 == nums[i], so we return the smallest index 0. Example 2: . Input: nums = [4,3,2,1] Output: 2 Explanation: i=0: 0 mod 10 = 0 != nums[0]. i=1: 1 mod 10 = 1 != nums[1]. i=2: 2 mod 10 = 2 == nums[2]. i=3: 3 mod 10 = 3 != nums[3]. 2 is the only index which has i mod 10 == nums[i]. Example 3: . Input: nums = [1,2,3,4,5,6,7,8,9,0] Output: -1 Explanation: No index satisfies i mod 10 == nums[i]. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 9 | . Solution: . class Solution { public int smallestEqual(int[] nums) { for(int i = 0; i &lt; nums.length; i++){ if(i % 10 == nums[i]) return i; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-318-Smallest%20Index%20With%20Equal%20Value/",
    "relUrl": "/problem-318-Smallest Index With Equal Value/"
  },"351": {
    "doc": "Check Whether Two Strings are Almost Equivalent",
    "title": "Check Whether Two Strings are Almost Equivalent",
    "content": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from ‘a’ to ‘z’ between word1 and word2 is at most 3. Given two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise. The frequency of a letter x is the number of times it occurs in the string. Example 1: . Input: word1 = \"aaaa\", word2 = \"bccb\" Output: false Explanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\". The difference is 4, which is more than the allowed 3. Example 2: . Input: word1 = \"abcdeef\", word2 = \"abaaacc\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 1 time in word1 and 4 times in word2. The difference is 3. - 'b' appears 1 time in word1 and 1 time in word2. The difference is 0. - 'c' appears 1 time in word1 and 2 times in word2. The difference is 1. - 'd' appears 1 time in word1 and 0 times in word2. The difference is 1. - 'e' appears 2 times in word1 and 0 times in word2. The difference is 2. - 'f' appears 1 time in word1 and 0 times in word2. The difference is 1. Example 3: . Input: word1 = \"cccddabba\", word2 = \"babababab\" Output: true Explanation: The differences between the frequencies of each letter in word1 and word2 are at most 3: - 'a' appears 2 times in word1 and 4 times in word2. The difference is 2. - 'b' appears 2 times in word1 and 5 times in word2. The difference is 3. - 'c' appears 3 times in word1 and 0 times in word2. The difference is 3. - 'd' appears 2 times in word1 and 0 times in word2. The difference is 2. Constraints: . | n == word1.length == word2.length | 1 &lt;= n &lt;= 100 | word1 and word2 consist only of lowercase English letters. | . Solution: . class Solution { public boolean checkAlmostEquivalent(String word1, String word2) { int[] dp1 = getFrequency(word1); int[] dp2 = getFrequency(word2); for(int i = 0; i &lt; 26; i++){ if(Math.abs(dp1[i] - dp2[i]) &gt; 3) return false; } return true; } public int[] getFrequency(String str){ int[] dp = new int[26]; for(char c : str.toCharArray()) dp[c - 'a']++; return dp; } } . ",
    "url": "https://1001anjan.github.io/problem-319-Check%20Whether%20Two%20Strings%20are%20Almost%20Equivalent/",
    "relUrl": "/problem-319-Check Whether Two Strings are Almost Equivalent/"
  },"352": {
    "doc": "Insert Interval",
    "title": "Insert Interval",
    "content": "You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval. Insert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary). Return intervals after the insertion. Example 1: . Input: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] . Example 2: . Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10]. Constraints: . | 0 &lt;= intervals.length &lt;= 10^4 | intervals[i].length == 2 | 0 &lt;= starti &lt;= endi &lt;= 10^5 | intervals is sorted by starti in ascending order. | newInterval.length == 2 | 0 &lt;= start &lt;= end &lt;= 10^5 | . Solution: . class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); // adding new item to sorted position boolean added = false; for(int[] arr : intervals){ if(!added){ if(newInterval[0] == arr[0]){ if(newInterval[1] &lt; arr[1]){ list.add(newInterval); list.add(arr); }else{ list.add(arr); list.add(newInterval); } added = true; }else if(newInterval[0] &lt; arr[0]){ list.add(newInterval); list.add(arr); added = true; } } list.add(arr); } if(!added){ list.add(newInterval); } // merging intervals LinkedList&lt;int[]&gt; merged = new LinkedList&lt;&gt;(); for(int[] interval : list){ if(merged.isEmpty() || merged.getLast()[1] &lt; interval[0]){ merged.add(interval); }else{ merged.getLast()[1] = Math.max(merged.getLast()[1] , interval[1]); } } return merged.toArray(new int[merged.size()][]); } } . ",
    "url": "https://1001anjan.github.io/problem-32-Insert%20Interval/",
    "relUrl": "/problem-32-Insert Interval/"
  },"353": {
    "doc": "Min Stack",
    "title": "Min Stack",
    "content": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time. Implement the MinStack class: . | MinStack() initializes the stack object. | void push(int val) pushes the element val onto the stack. | void pop() removes the element on the top of the stack. | int top() gets the top element of the stack. | int getMin() retrieves the minimum element in the stack. | . Example 1: . Input [\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"] [[],[-2],[0],[-3],[],[],[],[]] Output [null,null,null,null,-3,null,0,-2] Explanation MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); // return -3 minStack.pop(); minStack.top(); // return 0 minStack.getMin(); // return -2 . Constraints: . | -231 &lt;= val &lt;= 231 - 1 | Methods pop, top and getMin operations will always be called on non-empty stacks. | At most 3 * 104 calls will be made to push, pop, top, and getMin. | . Solution . class MinStack { public class Node { int val; Node above; Node below; Node() { val = 0; above = null; below = null; } } Node top; public MinStack() { top = new Node(); } public void push(int val) { Node newNode = new Node(); newNode.val = val; top.above = newNode; newNode.below = top; top = newNode; } // old top node gets lost to the abyss of rubbish data public void pop() { top = top.below; top.above = null; } public int top() { return top.val; } public int getMin() { int min = 2147483647; // max int Node traverse = top; while (traverse.below != null) { if (traverse.val &lt; min) min = traverse.val; traverse = traverse.below; } return min; } } /** * Your MinStack object will be instantiated and called as such: * MinStack obj = new MinStack(); * obj.push(val); * obj.pop(); * int param_3 = obj.top(); * int param_4 = obj.getMin(); */ . ",
    "url": "https://1001anjan.github.io/problem-31-Min-Stack/",
    "relUrl": "/problem-31-Min-Stack/"
  },"354": {
    "doc": "Time Needed to Buy Tickets",
    "title": "Time Needed to Buy Tickets",
    "content": "There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line. You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i]. Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line. Return the time taken for the person at position k (0-indexed) to finish buying tickets. Example 1: . Input: tickets = [2,3,2], k = 2 Output: 6 Explanation: - In the first pass, everyone in the line buys a ticket and the line becomes [1, 2, 1]. - In the second pass, everyone in the line buys a ticket and the line becomes [0, 1, 0]. The person at position 2 has successfully bought 2 tickets and it took 3 + 3 = 6 seconds. Example 2: . Input: tickets = [5,1,1,1], k = 0 Output: 8 Explanation: - In the first pass, everyone in the line buys a ticket and the line becomes [4, 0, 0, 0]. - In the next 4 passes, only the person in position 0 is buying tickets. The person at position 0 has successfully bought 5 tickets and it took 4 + 1 + 1 + 1 + 1 = 8 seconds. Constraints: . | n == tickets.length | 1 &lt;= n &lt;= 100 | 1 &lt;= tickets[i] &lt;= 100 | 0 &lt;= k &lt; n | . Solution: . class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int c = 0; int i = 0; while(tickets[k] != 0){ i = i % tickets.length; if(tickets[i] != 0){ c++; tickets[i]--; } i++; } return c; } } . O(n) time complexity . class Solution { public int timeRequiredToBuy(int[] tickets, int k) { int count = 0; for(int i = 0; i &lt;= k; i++){ count += Math.min(tickets[i],tickets[k]); } for(int i = k + 1; i &lt; tickets.length; i++){ if(tickets[i] &gt;= tickets[k]){ count += tickets[k] - 1; }else{ count += tickets[i]; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-320-Time%20Needed%20to%20Buy%20Tickets/",
    "relUrl": "/problem-320-Time Needed to Buy Tickets/"
  },"355": {
    "doc": "Two Furthest Houses With Different Colors",
    "title": "Two Furthest Houses With Different Colors",
    "content": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house. Return the maximum distance between two houses with different colors. The distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x. Example 1: . Input: colors = [1,1,1,6,1,1,1] Output: 3 Explanation: In the above image, color 1 is blue, and color 6 is red. The furthest two houses with different colors are house 0 and house 3. House 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3. Note that houses 3 and 6 can also produce the optimal answer. Example 2: . Input: colors = [1,8,3,8,3] Output: 4 Explanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green. The furthest two houses with different colors are house 0 and house 4. House 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4. Example 3: . Input: colors = [0,1] Output: 1 Explanation: The furthest two houses with different colors are house 0 and house 1. House 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1. Constraints: . | n == colors.length | 2 &lt;= n &lt;= 100 | 0 &lt;= colors[i] &lt;= 100 | Test data are generated such that at least two houses have different colors. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-321-Two%20Furthest%20Houses%20With%20Different%20Colors/",
    "relUrl": "/problem-321-Two Furthest Houses With Different Colors/"
  },"356": {
    "doc": "Count Common Words With One Occurrence",
    "title": "Count Common Words With One Occurrence",
    "content": "Given two string arrays words1 and words2, return the number of strings that appear exactly once in each of the two arrays. Example 1: . Input: words1 = [\"leetcode\",\"is\",\"amazing\",\"as\",\"is\"], words2 = [\"amazing\",\"leetcode\",\"is\"] Output: 2 Explanation: - \"leetcode\" appears exactly once in each of the two arrays. We count this string. - \"amazing\" appears exactly once in each of the two arrays. We count this string. - \"is\" appears in each of the two arrays, but there are 2 occurrences of it in words1. We do not count this string. - \"as\" appears once in words1, but does not appear in words2. We do not count this string. Thus, there are 2 strings that appear exactly once in each of the two arrays. Example 2: . Input: words1 = [\"b\",\"bb\",\"bbb\"], words2 = [\"a\",\"aa\",\"aaa\"] Output: 0 Explanation: There are no strings that appear in each of the two arrays. Example 3: . Input: words1 = [\"a\",\"ab\"], words2 = [\"a\",\"a\",\"a\",\"ab\"] Output: 1 Explanation: The only string that appears exactly once in each of the two arrays is \"ab\". Constraints: . | 1 &lt;= words1.length, words2.length &lt;= 1000 | 1 &lt;= words1[i].length, words2[j].length &lt;= 30 | words1[i] and words2[j] consists only of lowercase English letters. | . Solution: . class Solution { public int countWords(String[] words1, String[] words2) { Map&lt;String,Integer&gt; m1 = new HashMap&lt;&gt;(); Map&lt;String,Integer&gt; m2 = new HashMap&lt;&gt;(); for(String s : words1){ m1.put(s,m1.getOrDefault(s,0) + 1); } for(String s : words2){ m2.put(s,m2.getOrDefault(s,0) + 1); } int c = 0; for(String k : m1.keySet()){ if(m1.get(k) == 1 &amp;&amp; m2.getOrDefault(k,0) == 1) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-322-Count%20Common%20Words%20With%20One%20Occurrence/",
    "relUrl": "/problem-322-Count Common Words With One Occurrence/"
  },"357": {
    "doc": "Find Target Indices After Sorting Array",
    "title": "Find Target Indices After Sorting Array",
    "content": "You are given a 0-indexed integer array nums and a target element target. A target index is an index i such that nums[i] == target. Return a list of the target indices of nums after sorting nums in non-decreasing order. If there are no target indices, return an empty list. The returned list must be sorted in increasing order. Example 1: . Input: nums = [1,2,5,2,3], target = 2 Output: [1,2] Explanation: After sorting, nums is [1,2,2,3,5]. The indices where nums[i] == 2 are 1 and 2. Example 2: . Input: nums = [1,2,5,2,3], target = 3 Output: [3] Explanation: After sorting, nums is [1,2,2,3,5]. The index where nums[i] == 3 is 3. Example 3: . Input: nums = [1,2,5,2,3], target = 5 Output: [4] Explanation: After sorting, nums is [1,2,2,3,5]. The index where nums[i] == 5 is 4. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i], target &lt;= 100 | . Solution: O(nLogN) complexity . class Solution { public List&lt;Integer&gt; targetIndices(int[] nums, int target) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); Arrays.sort(nums); for(int i = 0; i &lt; nums.length; i++){ if(nums[i] == target){ ans.add(i); }else if(nums[i] &gt; target) break; } return ans; } } . Greedy Approach | Optimized Code . class Solution { public List&lt;Integer&gt; targetIndices(int[] nums, int target) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int lesserCount = 0; int targetCount = 0; for(int n : nums){ if(n &lt; target) lesserCount++; else if(n == target) targetCount++; } while(targetCount-- &gt; 0){ ans.add(lesserCount++); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-323-Find%20Target%20Indices%20After%20Sorting%20Array/",
    "relUrl": "/problem-323-Find Target Indices After Sorting Array/"
  },"358": {
    "doc": "Finding 3-Digit Even Numbers",
    "title": "Finding 3-Digit Even Numbers",
    "content": "You are given an integer array digits, where each element is a digit. The array may contain duplicates. You need to find all the unique integers that follow the given requirements: . | The integer consists of the concatenation of three elements from digits in any arbitrary order. | The integer does not have leading zeros. | The integer is even. For example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements. | . Return a sorted array of the unique integers. Example 1: . Input: digits = [2,1,3,0] Output: [102,120,130,132,210,230,302,310,312,320] Explanation: All the possible integers that follow the requirements are in the output array. Notice that there are no odd integers or integers with leading zeros. Example 2: . Input: digits = [2,2,8,8,2] Output: [222,228,282,288,822,828,882] Explanation: The same digit can be used as many times as it appears in digits. In this example, the digit 8 is used twice each time in 288, 828, and 882. Example 3: . Input: digits = [3,7,5] Output: [] Explanation: No even integers can be formed using the given digits. Constraints: . | 3 &lt;= digits.length &lt;= 100 | 0 &lt;= digits[i] &lt;= 9 | . Solution: . class Solution { public int[] findEvenNumbers(int[] digits) { int[] digitsCount = new int[10]; for(int i : digits) digitsCount[i]++; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(int i=100; i&lt;=998; i=i+2) { if(checkNum(i, digitsCount)) list.add(i); } return list.stream().mapToInt(x -&gt; x).toArray(); } public boolean checkNum(int num, int[] digitsCount) { int[] numCount = new int[10]; while(num != 0) { numCount[num%10]++; num/=10; } for(int i=0; i&lt;10; i++) if(numCount[i] &gt; digitsCount[i]) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-324-Finding%203-Digit%20Even%20Numbers/",
    "relUrl": "/problem-324-Finding 3-Digit Even Numbers/"
  },"359": {
    "doc": "Find Subsequence of Length K With the Largest Sum",
    "title": "Find Subsequence of Length K With the Largest Sum",
    "content": "You are given an integer array nums and an integer k. You want to find a subsequence of nums of length k that has the largest sum. Return any such subsequence as an integer array of length k. A subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements. Example 1: . Input: nums = [2,1,3,3], k = 2 Output: [3,3] Explanation: The subsequence has the largest sum of 3 + 3 = 6. Example 2: . Input: nums = [-1,-2,3,4], k = 3 Output: [-1,3,4] Explanation: The subsequence has the largest sum of -1 + 3 + 4 = 6. Example 3: . Input: nums = [3,4,3,3], k = 2 Output: [3,4] Explanation: The subsequence has the largest sum of 3 + 4 = 7. Another possible subsequence is [4, 3]. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | -105 &lt;= nums[i] &lt;= 105 | 1 &lt;= k &lt;= nums.length | . Solution: . class Solution { public int[] maxSubsequence(int[] nums, int k) { int[][] dp = new int[nums.length][2]; for(int i =0; i &lt; nums.length; i++){ dp[i][0] = nums[i]; dp[i][1] = i; } Arrays.sort(dp,(a,b) -&gt; a[0] - b[0]); int[][] sortedSeq = new int[k][2]; int m = k - 1; for(int i = nums.length - 1; i &gt;= nums.length - k; i--, m--){ sortedSeq[m][0] = dp[i][0]; sortedSeq[m][1] = dp[i][1]; } Arrays.sort(sortedSeq, (a,b) -&gt; a[1] - b[1]); int[] ans = new int[k]; for(int i = 0; i &lt; k; i++){ ans[i] = sortedSeq[i][0]; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-325-Find%20Subsequence%20of%20Length%20K%20With%20the%20Largest%20Sum/",
    "relUrl": "/problem-325-Find Subsequence of Length K With the Largest Sum/"
  },"360": {
    "doc": "Rings and Rods",
    "title": "Rings and Rods",
    "content": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9. You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where: . | The first character of the ith pair denotes the ith ring’s color (‘R’, ‘G’, ‘B’). | The second character of the ith pair denotes the rod that the ith ring is placed on (‘0’ to ‘9’). | . For example, “R3G2B1” describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1. Return the number of rods that have all three colors of rings on them. Example 1: . Input: rings = \"B0B6G0R6R0R6G9\" Output: 1 Explanation: - The rod labeled 0 holds 3 rings with all colors: red, green, and blue. - The rod labeled 6 holds 3 rings, but it only has red and blue. - The rod labeled 9 holds only a green ring. Thus, the number of rods with all three colors is 1. Example 2: . Input: rings = \"B0R0G0R9R0B0G0\" Output: 1 Explanation: - The rod labeled 0 holds 6 rings with all colors: red, green, and blue. - The rod labeled 9 holds only a red ring. Thus, the number of rods with all three colors is 1. Example 3: . Input: rings = \"G4\" Output: 0 Explanation: Only one ring is given. Thus, no rods have all three colors. Constraints: . | rings.length == 2 * n | 1 &lt;= n &lt;= 100 | rings[i] where i is even is either ‘R’, ‘G’, or ‘B’ (0-indexed). | rings[i] where i is odd is a digit from ‘0’ to ‘9’ (0-indexed). | . Solution . class Solution { public int countPoints(String rings) { boolean[][] dp = new boolean[10][3]; for(int i = 0; i &lt; rings.length(); i = i + 2){ char ch = rings.charAt(i); if(ch == 'R'){ dp[rings.charAt(i+1) - '0'][0] = true; }else if(ch == 'G'){ dp[rings.charAt(i+1) - '0'][1] = true; }else{ dp[rings.charAt(i+1) - '0'][2] = true; } } int c = 0; for(int i = 0; i &lt; 10; i++){ if(dp[i][0] &amp;&amp; dp[i][1] &amp;&amp; dp[i][2]) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-326-Rings%20and%20Rods/",
    "relUrl": "/problem-326-Rings and Rods/"
  },"361": {
    "doc": "Find First Palindromic String in the Array",
    "title": "Find First Palindromic String in the Array",
    "content": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string “”. A string is palindromic if it reads the same forward and backward. Example 1: . Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"] Output: \"ada\" Explanation: The first string that is palindromic is \"ada\". Note that \"racecar\" is also palindromic, but it is not the first. Example 2: . Input: words = [\"notapalindrome\",\"racecar\"] Output: \"racecar\" Explanation: The first and only string that is palindromic is \"racecar\". Example 3: . Input: words = [\"def\",\"ghi\"] Output: \"\" Explanation: There are no palindromic strings, so the empty string is returned. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists only of lowercase English letters. | . Solution: . class Solution { public String firstPalindrome(String[] words) { for(String str : words){ if(checkPalindrome(str)) return str; } return \"\"; } public boolean checkPalindrome(String str){ int i = 0; int j = str.length() - 1; while(i &lt; j){ if(str.charAt(i) != str.charAt(j)) return false; i++; j--; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-327-Find%20First%20Palindromic%20String%20in%20the%20Array/",
    "relUrl": "/problem-327-Find First Palindromic String in the Array/"
  },"362": {
    "doc": "Maximum Number of Words Found in Sentences",
    "title": "Maximum Number of Words Found in Sentences",
    "content": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. You are given an array of strings sentences, where each sentences[i] represents a single sentence. Return the maximum number of words that appear in a single sentence. Example 1: . Input: sentences = [\"alice and bob love leetcode\", \"i think so too\", \"this is great thanks very much\"] Output: 6 Explanation: - The first sentence, \"alice and bob love leetcode\", has 5 words in total. - The second sentence, \"i think so too\", has 4 words in total. - The third sentence, \"this is great thanks very much\", has 6 words in total. Thus, the maximum number of words in a single sentence comes from the third sentence, which has 6 words. Example 2: . Input: sentences = [\"please wait\", \"continue to fight\", \"continue to win\"] Output: 3 Explanation: It is possible that multiple sentences contain the same number of words. In this example, the second and third sentences (underlined) have the same number of words. Constraints: . | 1 &lt;= sentences.length &lt;= 100 | 1 &lt;= sentences[i].length &lt;= 100 | sentences[i] consists only of lowercase English letters and ‘ ‘ only. | sentences[i] does not have leading or trailing spaces. | All the words in sentences[i] are separated by a single space. | . Solution: . class Solution { public int mostWordsFound(String[] sentences) { int max = -1; for(String str : sentences){ String[] s = str.split(\" \"); max = Math.max(max,s.length); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-328-Maximum%20Number%20of%20Words%20Found%20in%20Sentences/",
    "relUrl": "/problem-328-Maximum Number of Words Found in Sentences/"
  },"363": {
    "doc": "A Number After a Double Reversal",
    "title": "A Number After a Double Reversal",
    "content": "Reversing an integer means to reverse all its digits. For example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained. Given an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false. Example 1: . Input: num = 526 Output: true Explanation: Reverse num to get 625, then reverse 625 to get 526, which equals num. Example 2: . Input: num = 1800 Output: false Explanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num. Example 3: . Input: num = 0 Output: true Explanation: Reverse num to get 0, then reverse 0 to get 0, which equals num. Constraints: . | 0 &lt;= num &lt;= 106 | . Solution: . class Solution { public boolean isSameAfterReversals(int num) { if(num == 0) return true; if(num % 10 == 0) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-329-A%20Number%20After%20a%20Double%20Reversal/",
    "relUrl": "/problem-329-A Number After a Double Reversal/"
  },"364": {
    "doc": "Intersection of Two Linked Lists",
    "title": "Intersection of Two Linked Lists",
    "content": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null. For example, the following two linked lists begin to intersect at node c1: . The test cases are generated such that there are no cycles anywhere in the entire linked structure. Note that the linked lists must retain their original structure after the function returns. Custom Judge: . The inputs to the judge are given as follows (your program is not given these inputs): . intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node. | listA - The first linked list. | listB - The second linked list. | skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node. | skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node. | . The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted. Example 1: . Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at '8' Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { * val = x; * next = null; * } * } */ public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { ListNode ptrA = headA, ptrB = headB; while (ptrA != ptrB) { // loop until we found the first common node ptrA = ptrA == null ? headB : ptrA.next; // once we're done with A, move to B ptrB = ptrB == null ? headA : ptrB.next; // once we're done with B, move to A } return ptrA; } } . ",
    "url": "https://1001anjan.github.io/problem-33-Intersection-of-Two-Linked-Lists/",
    "relUrl": "/problem-33-Intersection-of-Two-Linked-Lists/"
  },"365": {
    "doc": "Spiral Matrix II",
    "title": "Spiral Matrix II",
    "content": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order. Example 1: . Input: n = 3 Output: [[1,2,3],[8,9,4],[7,6,5]] . Example 2: . Input: n = 1 Output: [[1]] . Constraints: . | 1 &lt;= n &lt;= 20 | . Solution: . class Solution { public int[][] generateMatrix(int n) { int[][] mat = new int[n][n]; int c = 1, total = n * n; int i = 0, j = 0, yRight = 0, yLeft = 0, xUp = 1, xDown = 0; while(c &lt;= total){ while(c &lt;= total &amp;&amp; j &lt; n - yRight) mat[i][j ++] = c ++; yRight ++; j--; i++; while(c &lt;= total &amp;&amp; i &lt; n - xDown) mat[i ++][j] = c ++; xDown ++; i --; j --; while(c &lt;= total &amp;&amp; j &gt;= yLeft) mat[i][j --] = c ++; yLeft++; j++; i --; while(c &lt;= total &amp;&amp; i &gt;= xUp) mat[i --][j] = c ++; xUp++; i++; j++; } return mat; } } . ",
    "url": "https://1001anjan.github.io/problem-33-Spiral%20Matrix%20II/",
    "relUrl": "/problem-33-Spiral Matrix II/"
  },"366": {
    "doc": "Check if All A's Appears Before All B's",
    "title": "Check if All A’s Appears Before All B’s",
    "content": "Given a string s consisting of only the characters ‘a’ and ‘b’, return true if every ‘a’ appears before every ‘b’ in the string. Otherwise, return false. Example 1: . Input: s = \"aaabbb\" Output: true Explanation: The 'a's are at indices 0, 1, and 2, while the 'b's are at indices 3, 4, and 5. Hence, every 'a' appears before every 'b' and we return true. Example 2: . Input: s = \"abab\" Output: false Explanation: There is an 'a' at index 2 and a 'b' at index 1. Hence, not every 'a' appears before every 'b' and we return false. Example 3: . Input: s = \"bbb\" Output: true Explanation: There are no 'a's, hence, every 'a' appears before every 'b' and we return true. Constraints: . | 1 &lt;= s.length &lt;= 100 | s[i] is either ‘a’ or ‘b’. | . Solution: . class Solution { public boolean checkString(String s) { // traversing all a's first int i = 0; int n = s.length(); while(i &lt; n &amp;&amp; s.charAt(i) == 'a') i++; if(i == n) return true; while(i &lt; n &amp;&amp;s.charAt(i) == 'b') i++; return i == n; } } . ",
    "url": "https://1001anjan.github.io/problem-330-Check%20if%20All%20A's%20Appears%20Before%20All%20B's/#check-if-all-as-appears-before-all-bs",
    "relUrl": "/problem-330-Check if All A's Appears Before All B's/#check-if-all-as-appears-before-all-bs"
  },"367": {
    "doc": "Check if All A's Appears Before All B's",
    "title": "Check if All A's Appears Before All B's",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-330-Check%20if%20All%20A's%20Appears%20Before%20All%20B's/",
    "relUrl": "/problem-330-Check if All A's Appears Before All B's/"
  },"368": {
    "doc": "Capitalize the Title",
    "title": "Capitalize the Title",
    "content": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that: . | If the length of the word is 1 or 2 letters, change all letters to lowercase. | Otherwise, change the first letter to uppercase and the remaining letters to lowercase. Return the capitalized title. | . Example 1: . Input: title = \"capiTalIze tHe titLe\" Output: \"Capitalize The Title\" Explanation: Since all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase. Example 2: . Input: title = \"First leTTeR of EACH Word\" Output: \"First Letter of Each Word\" Explanation: The word \"of\" has length 2, so it is all lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. Example 3: . Input: title = \"i lOve leetcode\" Output: \"i Love Leetcode\" Explanation: The word \"i\" has length 1, so it is lowercase. The remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase. Constraints: . | 1 &lt;= title.length &lt;= 100 | title consists of words separated by a single space without any leading or trailing spaces. | Each word consists of uppercase and lowercase English letters and is non-empty. | . Solution: . class Solution { public String capitalizeTitle(String title) { StringBuilder sb = new StringBuilder(); String[] words = title.split(\" \"); for(String str : words){ str = str.toLowerCase(); if(str.length() &lt;= 2){ sb.append(str).append(\" \"); }else{ sb.append(Character.toUpperCase(str.charAt(0))) .append(str.substring(1,str.length())).append(\" \"); } } return sb.substring(0,sb.length() - 1).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-331-Capitalize%20the%20Title/",
    "relUrl": "/problem-331-Capitalize the Title/"
  },"369": {
    "doc": "Check if Every Row and Column Contains All Numbers",
    "title": "Check if Every Row and Column Contains All Numbers",
    "content": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive). Given an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false. Example 1: . Input: matrix = [[1,2,3],[3,1,2],[2,3,1]] Output: true Explanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3. Hence, we return true. Example 2: . Input: matrix = [[1,1,1],[1,2,3],[1,2,3]] Output: false Explanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3. Hence, we return false. Constraints: . | n == matrix.length == matrix[i].length | 1 &lt;= n &lt;= 100 | 1 &lt;= matrix[i][j] &lt;= n | . Solution: . class Solution { public boolean checkValid(int[][] matrix) { //check for row int n = matrix.length; for(int i = 0;i &lt; matrix.length; i++){ Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int j = 0; j &lt; matrix[i].length; j++){ s.add(matrix[i][j]); } if(s.size() != n){ return false; } } //check for column for(int i = 0;i &lt; matrix.length; i++){ Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int j = 0; j &lt; matrix[i].length; j++){ s.add(matrix[j][i]); } if(s.size() != n){ return false; } } return true; } } . Faster execution time . class Solution { public boolean checkValid(int[][] matrix) { for(int i=0;i&lt;matrix.length;i++){ boolean [] checkrow = new boolean[matrix[i].length]; for(int j= 0 ; j&lt;checkrow.length;j++){ int temp = matrix[i][j]; if(checkrow[temp-1]) return false; checkrow[temp-1] = true; } boolean [] checkcol = new boolean[matrix[i].length]; for(int j= 0 ; j&lt;checkcol.length;j++){ int temp = matrix[j][i]; if(checkcol[temp-1]) return false; checkcol[temp-1] = true; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-332-Check%20if%20Every%20Row%20and%20Column%20Contains%20All%20Numbers/",
    "relUrl": "/problem-332-Check if Every Row and Column Contains All Numbers/"
  },"370": {
    "doc": "Divide a String Into Groups of Size k",
    "title": "Divide a String Into Groups of Size k",
    "content": "A string s can be partitioned into groups of size k using the following procedure: . | The first group consists of the first k characters of the string, the second group consists of the next k characters of the string, and so on. Each character can be a part of exactly one group. | For the last group, if the string does not have k characters remaining, a character fill is used to complete the group. | . Note that the partition is done so that after removing the fill character from the last group (if it exists) and concatenating all the groups in order, the resultant string should be s. Given the string s, the size of each group k and the character fill, return a string array denoting the composition of every group s has been divided into, using the above procedure. Example 1: . Input: s = \"abcdefghi\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\"] Explanation: The first 3 characters \"abc\" form the first group. The next 3 characters \"def\" form the second group. The last 3 characters \"ghi\" form the third group. Since all groups can be completely filled by characters from the string, we do not need to use fill. Thus, the groups formed are \"abc\", \"def\", and \"ghi\". Example 2: . Input: s = \"abcdefghij\", k = 3, fill = \"x\" Output: [\"abc\",\"def\",\"ghi\",\"jxx\"] Explanation: Similar to the previous example, we are forming the first three groups \"abc\", \"def\", and \"ghi\". For the last group, we can only use the character 'j' from the string. To complete this group, we add 'x' twice. Thus, the 4 groups formed are \"abc\", \"def\", \"ghi\", and \"jxx\". Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters only. | 1 &lt;= k &lt;= 100 | fill is a lowercase English letter. | . Solution: . class Solution { public String[] divideString(String s, int k, char fill) { int n = s.length(); String[] ans = new String[(int)Math.ceil((double)n/k)]; StringBuilder sb = new StringBuilder(); int i = 0; int l = 0; while(i &lt; n){ sb.setLength(0); int m = k; while(m &gt; 0 &amp;&amp; i &lt; n){ sb.append(s.charAt(i)); i++; m--; } while(m &gt; 0){ sb.append(fill); m--; } ans[l++] = sb.toString(); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-333-Divide%20a%20String%20Into%20Groups%20of%20Size%20k/",
    "relUrl": "/problem-333-Divide a String Into Groups of Size k/"
  },"371": {
    "doc": "Minimum Cost of Buying Candies With Discount",
    "title": "Minimum Cost of Buying Candies With Discount",
    "content": "A shop is selling candies at a discount. For every two candies sold, the shop gives a third candy for free. The customer can choose any candy to take away for free as long as the cost of the chosen candy is less than or equal to the minimum cost of the two candies bought. | For example, if there are 4 candies with costs 1, 2, 3, and 4, and the customer buys candies with costs 2 and 3, they can take the candy with cost 1 for free, but not the candy with cost 4. Given a 0-indexed integer array cost, where cost[i] denotes the cost of the ith candy, return the minimum cost of buying all the candies. | . Example 1: . Input: cost = [1,2,3] Output: 5 Explanation: We buy the candies with costs 2 and 3, and take the candy with cost 1 for free. The total cost of buying all candies is 2 + 3 = 5. This is the only way we can buy the candies. Note that we cannot buy candies with costs 1 and 3, and then take the candy with cost 2 for free. The cost of the free candy has to be less than or equal to the minimum cost of the purchased candies. Example 2: . Input: cost = [6,5,7,9,2,2] Output: 23 Explanation: The way in which we can get the minimum cost is described below: - Buy candies with costs 9 and 7 - Take the candy with cost 6 for free - We buy candies with costs 5 and 2 - Take the last remaining candy with cost 2 for free Hence, the minimum cost to buy all candies is 9 + 7 + 5 + 2 = 23. Example 3: . Input: cost = [5,5] Output: 10 Explanation: Since there are only 2 candies, we buy both of them. There is not a third candy we can take for free. Hence, the minimum cost to buy all candies is 5 + 5 = 10. Constraints: . | 1 &lt;= cost.length &lt;= 100 | 1 &lt;= cost[i] &lt;= 100 | . Solution: . class Solution { public int minimumCost(int[] cost) { Arrays.sort(cost); int d = 0; int sum = 0; for(int i = cost.length - 1; i &gt;= 0; i--){ d++; if(d % 3 == 0) continue; sum += cost[i]; } return sum; } } . class Solution { public int minimumCost(int[] cost) { Arrays.sort(cost); int sum = 0; for(int i = 1; i &lt;= cost.length; i++){ if(i % 3 == 0){ continue; } else{ sum += cost[cost.length - i]; } } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-334-Minimum%20Cost%20of%20Buying%20Candies%20With%20Discount/",
    "relUrl": "/problem-334-Minimum Cost of Buying Candies With Discount/"
  },"372": {
    "doc": "Keep Multiplying Found Values by Two",
    "title": "Keep Multiplying Found Values by Two",
    "content": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums. You then do the following steps: . | If original is found in nums, multiply it by two (i.e., set original = 2 * original). | Otherwise, stop the process. | Repeat this process with the new number as long as you keep finding the number. Return the final value of original. | . Example 1: . Input: nums = [5,3,6,1,12], original = 3 Output: 24 Explanation: - 3 is found in nums. 3 is multiplied by 2 to obtain 6. - 6 is found in nums. 6 is multiplied by 2 to obtain 12. - 12 is found in nums. 12 is multiplied by 2 to obtain 24. - 24 is not found in nums. Thus, 24 is returned. Example 2: . Input: nums = [2,7,9], original = 4 Output: 4 Explanation: - 4 is not found in nums. Thus, 4 is returned. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i], original &lt;= 1000 | . Solution: . class Solution { public int findFinalValue(int[] nums, int original) { Arrays.sort(nums); for(int n : nums){ if(n == original) original *= 2; } return original; } } . Improvement using binary search . class Solution { public int findFinalValue(int[] nums, int original) { Arrays.sort(nums); int s = 0; int e = nums.length - 1; while(s &lt;= e){ int mid = (s + e)/2; if(nums[mid] == original){ original *= 2; e = nums.length - 1; }else if(nums[mid] &gt; original){ e = mid - 1; }else{ s = mid + 1; } } return original; } } . But faster approach . class Solution { public int findFinalValue(int[] nums, int original) { while(isPresent(nums, original)) original *= 2; return original; } public boolean isPresent(int[] nums, int target){ for(int i: nums) if(i == target) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-335-Keep%20Multiplying%20Found%20Values%20by%20Two/",
    "relUrl": "/problem-335-Keep Multiplying Found Values by Two/"
  },"373": {
    "doc": "Minimum Sum of Four Digit Number After Splitting Digits",
    "title": "Minimum Sum of Four Digit Number After Splitting Digits",
    "content": "You are given a positive integer num consisting of exactly four digits. Split num into two new integers new1 and new2 by using the digits found in num. Leading zeros are allowed in new1 and new2, and all the digits found in num must be used. | For example, given num = 2932, you have the following digits: two 2’s, one 9 and one 3. Some of the possible pairs [new1, new2] are [22, 93], [23, 92], [223, 9] and [2, 329]. Return the minimum possible sum of new1 and new2. | . Example 1: . Input: num = 2932 Output: 52 Explanation: Some possible pairs [new1, new2] are [29, 23], [223, 9], etc. The minimum sum can be obtained by the pair [29, 23]: 29 + 23 = 52. Example 2: . Input: num = 4009 Output: 13 Explanation: Some possible pairs [new1, new2] are [0, 49], [490, 0], etc. The minimum sum can be obtained by the pair [4, 9]: 4 + 9 = 13. Constraints: . | 1000 &lt;= num &lt;= 9999 | . Solution: . class Solution { public int minimumSum(int num) { int[] d = new int[4]; int i = 0; while(num &gt; 0){ d[i++] = num % 10; num = num / 10; } Arrays.sort(d); int d1 = d[0] * 10 + d[2]; int d2 = d[1] * 10 + d[3]; return d1 + d2; } } . ",
    "url": "https://1001anjan.github.io/problem-336-Minimum%20Sum%20of%20Four%20Digit%20Number%20After%20Splitting%20Digits/",
    "relUrl": "/problem-336-Minimum Sum of Four Digit Number After Splitting Digits/"
  },"374": {
    "doc": "Sort Even and Odd Indices Independently",
    "title": "Sort Even and Odd Indices Independently",
    "content": "You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules: . | Sort the values at odd indices of nums in non-increasing order. | For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order. | . | Sort the values at even indices of nums in non-decreasing order. | For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order. Return the array formed after rearranging the values of nums. | . | . Example 1: . Input: nums = [4,1,2,3] Output: [2,3,4,1] Explanation: First, we sort the values present at odd indices (1 and 3) in non-increasing order. So, nums changes from [4,1,2,3] to [4,3,2,1]. Next, we sort the values present at even indices (0 and 2) in non-decreasing order. So, nums changes from [4,1,2,3] to [2,3,4,1]. Thus, the array formed after rearranging the values is [2,3,4,1]. Example 2: . Input: nums = [2,1] Output: [2,1] Explanation: Since there is exactly one odd index and one even index, no rearrangement of values takes place. The resultant array formed is [2,1], which is the same as the initial array. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] sortEvenOdd(int[] nums) { int[] even, odd; if(nums.length % 2 == 0){ even = new int[nums.length/2]; odd = new int[nums.length/2]; }else{ even = new int[nums.length/2 + 1]; odd = new int[nums.length/2]; } int k = 0,l = 0; for(int i = 0; i &lt; nums.length; i++){ if(i % 2 == 0){ even[k++] = nums[i]; }else{ odd[l++] = nums[i]; } } Arrays.sort(even); Arrays.sort(odd); k = 0; l = odd.length - 1; for(int i = 0; i &lt; nums.length; i++){ if(i % 2 == 0){ nums[i] = even[k++]; }else{ nums[i] = odd[l--]; } } return nums; } } . ",
    "url": "https://1001anjan.github.io/problem-337-Sort%20Even%20and%20Odd%20Indices%20Independently/",
    "relUrl": "/problem-337-Sort Even and Odd Indices Independently/"
  },"375": {
    "doc": "Count Operations to Obtain Zero",
    "title": "Count Operations to Obtain Zero",
    "content": "You are given two non-negative integers num1 and num2. In one operation, if num1 &gt;= num2, you must subtract num2 from num1, otherwise subtract num1 from num2. | For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1. Return the number of operations required to make either num1 = 0 or num2 = 0. | . Example 1: . Input: num1 = 2, num2 = 3 Output: 3 Explanation: - Operation 1: num1 = 2, num2 = 3. Since num1 &lt; num2, we subtract num1 from num2 and get num1 = 2, num2 = 3 - 2 = 1. - Operation 2: num1 = 2, num2 = 1. Since num1 &gt; num2, we subtract num2 from num1. - Operation 3: num1 = 1, num2 = 1. Since num1 == num2, we subtract num2 from num1. Now num1 = 0 and num2 = 1. Since num1 == 0, we do not need to perform any further operations. So the total number of operations required is 3. Example 2: . Input: num1 = 10, num2 = 10 Output: 1 Explanation: - Operation 1: num1 = 10, num2 = 10. Since num1 == num2, we subtract num2 from num1 and get num1 = 10 - 10 = 0. Now num1 = 0 and num2 = 10. Since num1 == 0, we are done. So the total number of operations required is 1. Constraints: . | 0 &lt;= num1, num2 &lt;= 105 | . Solution: . class Solution { public int countOperations(int num1, int num2) { int op = 0; while(num1 &gt; 0 &amp;&amp; num2 &gt; 0){ if(num1 &gt; num2){ num1 = num1 - num2; }else{ num2 = num2 - num1; } op++; } return op; } } . Optimised . class Solution { public int countOperations(int num1, int num2) { int op = 0; while(num1 &gt; 0 &amp;&amp; num2 &gt; 0){ int max = Math.max(num1,num2); int min = Math.min(num1,num2); op += max / min; num1 = min; num2 = max % min; } return op; } } . ",
    "url": "https://1001anjan.github.io/problem-338-Count%20Operations%20to%20Obtain%20Zero/",
    "relUrl": "/problem-338-Count Operations to Obtain Zero/"
  },"376": {
    "doc": "Count Equal and Divisible Pairs in an Array",
    "title": "Count Equal and Divisible Pairs in an Array",
    "content": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 &lt;= i &lt; j &lt; n, such that nums[i] == nums[j] and (i * j) is divisible by k. Example 1: . Input: nums = [3,1,2,2,2,1,3], k = 2 Output: 4 Explanation: There are 4 pairs that meet all the requirements: - nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2. - nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2. - nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2. - nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2. Example 2: . Input: nums = [1,2,3,4], k = 1 Output: 0 Explanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i], k &lt;= 100 | . Solution: . class Solution { public int countPairs(int[] nums, int k) { int c = 0; for(int i = 0; i &lt; nums.length - 1; i++){ for(int j = i + 1; j &lt; nums.length; j++){ if(nums[i] == nums[j]){ if((i*j)%k == 0) c++; } } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-339-Count%20Equal%20and%20Divisible%20Pairs%20in%20an%20Array/",
    "relUrl": "/problem-339-Count Equal and Divisible Pairs in an Array/"
  },"377": {
    "doc": "Excel Sheet Column Title",
    "title": "Excel Sheet Column Title",
    "content": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet. For example: . A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... Example 1: . Input: columnNumber = 1 Output: \"A\" . Example 2: . Input: columnNumber = 28 Output: \"AB\" . Example 3: . Input: columnNumber = 701 Output: \"ZY\" . Constraints: . | 1 &lt;= columnNumber &lt;= 231 - 1 | . Solution . class Solution { public String convertToTitle(int columnNumber) { StringBuilder sb = new StringBuilder(); int digit; while(columnNumber&gt;0){ digit = (columnNumber-1)%26; sb.append((char)((int)'A' + digit)); columnNumber = (columnNumber-1)/26; } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-34-Excel-Sheet-Column-Title/",
    "relUrl": "/problem-34-Excel-Sheet-Column-Title/"
  },"378": {
    "doc": "Rotate List",
    "title": "Rotate List",
    "content": "Given the head of a linked list, rotate the list to the right by k places. Example 1: . Input: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] . Example 2: . Input: head = [0,1,2], k = 4 Output: [2,0,1] . Constraints: . | The number of nodes in the list is in the range [0, 500]. | -100 &lt;= Node.val &lt;= 100 | 0 &lt;= k &lt;= 2 * 10^9 | . Solution: . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null || k ==0 || head.next == null) return head; int len = 1; ListNode ptr; ptr = head; while(ptr.next != null){ len++; ptr = ptr.next; } int t = k % len; if(t == 0) return head; ListNode slow, fast; slow = fast = head; for(int i = 0; i &lt; t &amp;&amp; fast.next != null; i++, fast = fast.next); while(fast.next != null){ slow = slow.next; fast = fast.next; } ptr = slow.next; slow.next = null; fast.next = head; head = ptr; return head; } } . ",
    "url": "https://1001anjan.github.io/problem-34-Rotate%20List/",
    "relUrl": "/problem-34-Rotate List/"
  },"379": {
    "doc": "Count Integers With Even Digit Sum",
    "title": "Count Integers With Even Digit Sum",
    "content": "Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even. The digit sum of a positive integer is the sum of all its digits. Example 1: . Input: num = 4 Output: 2 Explanation: The only integers less than or equal to 4 whose digit sums are even are 2 and 4. Example 2: . Input: num = 30 Output: 14 Explanation: The 14 integers less than or equal to 30 whose digit sums are even are 2, 4, 6, 8, 11, 13, 15, 17, 19, 20, 22, 24, 26, and 28. Constraints: . | 1 &lt;= num &lt;= 1000 | . Solution: . class Solution { public int countEven(int num) { int c = 0; for(int i = 2; i &lt;= num; i++){ if(digitSum(i) % 2 == 0) c++; } return c; } public int digitSum(int n){ int sum = 0; while(n &gt; 0){ sum += n % 10; n = n / 10; } return sum; } } . Improvement . class Solution { public boolean sumOfDigits(int n){ int sum = 0; while(n != 0){ sum += (n % 10); n = n / 10; } return sum %2 == 0 ? true : false; } public int countEven(int num) { int c = 0; for(int i = 2;i &lt;= num; i++){ if(i &lt; 10 &amp;&amp; i %2 == 0) c++; else if(sumOfDigits(i) == true) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-340-Count%20Integers%20With%20Even%20Digit%20Sum/",
    "relUrl": "/problem-340-Count Integers With Even Digit Sum/"
  },"380": {
    "doc": "Counting Words With a Given Prefix",
    "title": "Counting Words With a Given Prefix",
    "content": "You are given an array of strings words and a string pref. Return the number of strings in words that contain pref as a prefix. A prefix of a string s is any leading contiguous substring of s. Example 1: . Input: words = [\"pay\",\"attention\",\"practice\",\"attend\"], pref = \"at\" Output: 2 Explanation: The 2 strings that contain \"at\" as a prefix are: \"attention\" and \"attend\". Example 2: . Input: words = [\"leetcode\",\"win\",\"loops\",\"success\"], pref = \"code\" Output: 0 Explanation: There are no strings that contain \"code\" as a prefix. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length, pref.length &lt;= 100 | words[i] and pref consist of lowercase English letters. | . Solution: . class Solution { public int prefixCount(String[] words, String pref) { int c = 0; for(String str : words){ if(str.indexOf(pref) == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-341-Counting%20Words%20With%20a%20Given%20Prefix/",
    "relUrl": "/problem-341-Counting Words With a Given Prefix/"
  },"381": {
    "doc": "Find All K-Distant Indices in an Array",
    "title": "Find All K-Distant Indices in an Array",
    "content": "You are given a 0-indexed integer array nums and two integers key and k. A k-distant index is an index i of nums for which there exists at least one index j such that |i - j| &lt;= k and nums[j] == key. Return a list of all k-distant indices sorted in increasing order. Example 1: . Input: nums = [3,4,9,1,3,9,5], key = 9, k = 1 Output: [1,2,3,4,5,6] Explanation: Here, nums[2] == key and nums[5] == key. - For index 0, |0 - 2| &gt; k and |0 - 5| &gt; k, so there is no j where |0 - j| &lt;= k and nums[j] == key. Thus, 0 is not a k-distant index. - For index 1, |1 - 2| &lt;= k and nums[2] == key, so 1 is a k-distant index. - For index 2, |2 - 2| &lt;= k and nums[2] == key, so 2 is a k-distant index. - For index 3, |3 - 2| &lt;= k and nums[2] == key, so 3 is a k-distant index. - For index 4, |4 - 5| &lt;= k and nums[5] == key, so 4 is a k-distant index. - For index 5, |5 - 5| &lt;= k and nums[5] == key, so 5 is a k-distant index. - For index 6, |6 - 5| &lt;= k and nums[5] == key, so 6 is a k-distant index. Thus, we return [1,2,3,4,5,6] which is sorted in increasing order. Example 2: . Input: nums = [2,2,2,2,2], key = 2, k = 2 Output: [0,1,2,3,4] Explanation: For all indices i in nums, there exists some index j such that |i - j| &lt;= k and nums[j] == key, so every index is a k-distant index. Hence, we return [0,1,2,3,4]. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= nums[i] &lt;= 1000 | key is an integer from the array nums. | 1 &lt;= k &lt;= nums.length | . Solution: . class Solution { public List&lt;Integer&gt; findKDistantIndices(int[] nums, int key, int k) { Set&lt;Integer&gt; s = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++){ if(nums[i] == key){ if(s.add(i)){ for(int j = i - 1; j &gt;= 0 &amp;&amp; j &gt;= i - k ; j--){ if(!s.add(j)) break; } } for(int j = i + 1; j &lt; nums.length &amp;&amp; j &lt;= i + k ; j++){ s.add(j); } } } List&lt;Integer&gt; ans = s.stream().collect(Collectors.toList()); Collections.sort(ans); return ans; } } . Improvement and O(n) complexity . class Solution { public List&lt;Integer&gt; findKDistantIndices(int[] nums, int key, int k) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); for(int i = 0, j =0, lastVisited = 0; i &lt; nums.length; i++){ if(nums[i] == key){ for(j = Math.max(lastVisited,i - k); j &lt; Math.min(nums.length,i + k + 1); j++){ ans.add(j); } lastVisited = j; } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-342-Find%20All%20K-Distant%20Indices%20in%20an%20Array/",
    "relUrl": "/problem-342-Find All K-Distant Indices in an Array/"
  },"382": {
    "doc": "Divide Array Into Equal Pairs",
    "title": "Divide Array Into Equal Pairs",
    "content": "You are given an integer array nums consisting of 2 * n integers. You need to divide nums into n pairs such that: . | Each element belongs to exactly one pair. | The elements present in a pair are equal. Return true if nums can be divided into n pairs, otherwise return false. | . Example 1: . Input: nums = [3,2,3,2,2,2] Output: true Explanation: There are 6 elements in nums, so they should be divided into 6 / 2 = 3 pairs. If nums is divided into the pairs (2, 2), (3, 3), and (2, 2), it will satisfy all the conditions. Example 2: . Input: nums = [1,2,3,4] Output: false Explanation: There is no way to divide nums into 4 / 2 = 2 pairs such that the pairs satisfy every condition. Constraints: . | nums.length == 2 * n | 1 &lt;= n &lt;= 500 | 1 &lt;= nums[i] &lt;= 500 | . Solution: . class Solution { public boolean divideArray(int[] nums) { int[] dp = new int[501]; for(int n : nums) dp[n]++; for(int n : dp){ if(n % 2 != 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-343-Divide%20Array%20Into%20Equal%20Pairs/",
    "relUrl": "/problem-343-Divide Array Into Equal Pairs/"
  },"383": {
    "doc": "Count Hills and Valleys in an Array",
    "title": "Count Hills and Valleys in an Array",
    "content": "You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j]. Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index. Return the number of hills and valleys in nums. Example 1: . Input: nums = [2,4,1,1,6,5] Output: 3 Explanation: At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley. At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 &gt; 2 and 4 &gt; 1, index 1 is a hill. At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 2 is a valley. At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 &lt; 4 and 1 &lt; 6, index 3 is a valley, but note that it is part of the same valley as index 2. At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 &gt; 1 and 6 &gt; 5, index 4 is a hill. At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. There are 3 hills and valleys so we return 3. Example 2: . Input: nums = [6,6,5,5,4,1] Output: 0 Explanation: At index 0: There is no non-equal neighbor of 6 on the left, so index 0 is neither a hill nor a valley. At index 1: There is no non-equal neighbor of 6 on the left, so index 1 is neither a hill nor a valley. At index 2: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 2 is neither a hill nor a valley. At index 3: The closest non-equal neighbors of 5 are 6 and 4. Since 5 &lt; 6 and 5 &gt; 4, index 3 is neither a hill nor a valley. At index 4: The closest non-equal neighbors of 4 are 5 and 1. Since 4 &lt; 5 and 4 &gt; 1, index 4 is neither a hill nor a valley. At index 5: There is no non-equal neighbor of 1 on the right, so index 5 is neither a hill nor a valley. There are 0 hills and valleys so we return 0. Constraints: . | 3 &lt;= nums.length &lt;= 100 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int countHillValley(int[] nums) { int c = 0; int lastElement = nums[0]; int i = 1; while(i &lt; nums.length - 1){ lastElement = nums[i-1]; while(i &lt; nums.length &amp;&amp; nums[i - 1] == nums[i]) i++; while(i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i+1]) i++; if(i &lt; nums.length - 1 &amp;&amp; lastElement &gt; nums[i] &amp;&amp; nums[i] &lt; nums[i+1]) c++; if(i &lt; nums.length - 1 &amp;&amp; lastElement &lt; nums[i] &amp;&amp; nums[i] &gt; nums[i+1]) c++; i++; } return c; } } . Another way . class Solution { public int countHillValley(int[] nums) { int res = 0; int prev = 0; for(int i = 1; i &lt; nums.length; ++i) { int diff = nums[i] - nums[i - 1]; if (prev != 0 &amp;&amp; diff != 0 &amp;&amp; !((prev &gt; 0 &amp;&amp; diff &gt; 0) || (prev &lt; 0 &amp;&amp; diff &lt; 0))) ++res; prev = diff == 0 ? prev : diff; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-344-Count%20Hills%20and%20Valleys%20in%20an%20Array/",
    "relUrl": "/problem-344-Count Hills and Valleys in an Array/"
  },"384": {
    "doc": "Find the Difference of Two Arrays",
    "title": "Find the Difference of Two Arrays",
    "content": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where: . | answer[0] is a list of all distinct integers in nums1 which are not present in nums2. | answer[1] is a list of all distinct integers in nums2 which are not present in nums1. Note that the integers in the lists may be returned in any order. | . Example 1: . Input: nums1 = [1,2,3], nums2 = [2,4,6] Output: [[1,3],[4,6]] Explanation: For nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3]. For nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6]. Example 2: . Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2] Output: [[3],[]] Explanation: For nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3]. Every integer in nums2 is present in nums1. Therefore, answer[1] = []. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | -1000 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; findDifference(int[] nums1, int[] nums2) { Set&lt;Integer&gt; s1 = new HashSet&lt;&gt;(); Set&lt;Integer&gt; s2 = new HashSet&lt;&gt;(); for(int n : nums1) s1.add(n); for(int n : nums2) s2.add(n); List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int n : s1){ if(!s2.contains(n)) temp.add(n); } ans.add(temp); List&lt;Integer&gt; temp1 = new ArrayList&lt;&gt;(); for(int n : s2){ if(!s1.contains(n)) temp1.add(n); } ans.add(temp1); return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-345-Find%20the%20Difference%20of%20Two%20Arrays/",
    "relUrl": "/problem-345-Find the Difference of Two Arrays/"
  },"385": {
    "doc": "Minimum Bit Flips to Convert Number",
    "title": "Minimum Bit Flips to Convert Number",
    "content": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0. | For example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc. Given two integers start and goal, return the minimum number of bit flips to convert start to goal. | . Example 1: . Input: start = 10, goal = 7 Output: 3 Explanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps: - Flip the first bit from the right: 1010 -&gt; 1011. - Flip the third bit from the right: 1011 -&gt; 1111. - Flip the fourth bit from the right: 1111 -&gt; 0111. It can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3. Example 2: . Input: start = 3, goal = 4 Output: 3 Explanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps: - Flip the first bit from the right: 011 -&gt; 010. - Flip the second bit from the right: 010 -&gt; 000. - Flip the third bit from the right: 000 -&gt; 100. It can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3. Constraints: . | 0 &lt;= start, goal &lt;= 10^9 | . Solution: . class Solution { public int minBitFlips(int start, int goal) { int n = start ^ goal; int c = 0; while(n != 0){ if((n &amp; 1) == 1) c++; n = n &gt;&gt; 1; } return c; } } . Faster excution . class Solution { public int minBitFlips(int start, int goal) { int xORStartGoal= start ^ goal; // Different bits will be set int count=0; while(xORStartGoal &gt; 0) { xORStartGoal &amp;= (xORStartGoal - 1); count++; // Count number of set Bits } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-346-Minimum%20Bit%20Flips%20to%20Convert%20Number/",
    "relUrl": "/problem-346-Minimum Bit Flips to Convert Number/"
  },"386": {
    "doc": "Minimum Number of Operations to Convert Time",
    "title": "Minimum Number of Operations to Convert Time",
    "content": "You are given two strings current and correct representing two 24-hour times. 24-hour times are formatted as “HH:MM”, where HH is between 00 and 23, and MM is between 00 and 59. The earliest 24-hour time is 00:00, and the latest is 23:59. In one operation you can increase the time current by 1, 5, 15, or 60 minutes. You can perform this operation any number of times. Return the minimum number of operations needed to convert current to correct. Example 1: . Input: current = \"02:30\", correct = \"04:35\" Output: 3 Explanation: We can convert current to correct in 3 operations as follows: - Add 60 minutes to current. current becomes \"03:30\". - Add 60 minutes to current. current becomes \"04:30\". - Add 5 minutes to current. current becomes \"04:35\". It can be proven that it is not possible to convert current to correct in fewer than 3 operations. Example 2: . Input: current = \"11:00\", correct = \"11:01\" Output: 1 Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1. Constraints: . | current and correct are in the format “HH:MM” | current &lt;= correct | . Solution: . class Solution { public int convertTime(String current, String correct) { String[] cr = current.split(\":\"); String[] co = correct.split(\":\"); int minCurr = Integer.parseInt(cr[0]) * 60 + Integer.parseInt(cr[1]); int minCorr = Integer.parseInt(co[0]) * 60 + Integer.parseInt(co[1]); int minDiff = minCorr - minCurr; int op = 0; if(minDiff &gt;= 60){ int d = minDiff / 60; op += d; minDiff -= d * 60; } if(minDiff &gt;= 15){ int d = minDiff / 15; op += d; minDiff -= d * 15; } if(minDiff &gt;= 5){ int d = minDiff / 5; op += d; minDiff -= d * 5; } if(minDiff &gt;= 1){ op += minDiff; } return op; } } . Faster execution . class Solution { public int HHMMToMinutes(String s){ return Integer.parseInt(s.substring(0,2))*60 + Integer.parseInt(s.substring(3,5)) ; } public int convertTime(String current, String correct) { int diff = HHMMToMinutes(correct) - HHMMToMinutes(current); int[] order = {60,15,5,1}; int i = 0; int ops = 0; while(i &lt; 4){ ops += (diff / order[i]); diff %= order[i]; i++; } return ops; } } . ",
    "url": "https://1001anjan.github.io/problem-347-Minimum%20Number%20of%20Operations%20to%20Convert%20Time/",
    "relUrl": "/problem-347-Minimum Number of Operations to Convert Time/"
  },"387": {
    "doc": "Find Closest Number to Zero",
    "title": "Find Closest Number to Zero",
    "content": "Given an integer array nums of size n, return the number with the value closest to 0 in nums. If there are multiple answers, return the number with the largest value. Example 1: . Input: nums = [-4,-2,1,4,8] Output: 1 Explanation: The distance from -4 to 0 is |-4| = 4. The distance from -2 to 0 is |-2| = 2. The distance from 1 to 0 is |1| = 1. The distance from 4 to 0 is |4| = 4. The distance from 8 to 0 is |8| = 8. Thus, the closest number to 0 in the array is 1. Example 2: . Input: nums = [2,-1,1] Output: 1 Explanation: 1 and -1 are both the closest numbers to 0, so 1 being larger is returned. Constraints: . | 1 &lt;= n &lt;= 1000 | -105 &lt;= nums[i] &lt;= 105 | . Solution: . class Solution { public int findClosestNumber(int[] nums) { int num = nums[0]; int diff = Math.abs(nums[0]); for(int n : nums){ int abs = Math.abs(n); if(diff &gt; abs){ diff = abs; num = n; }else if(diff == abs &amp;&amp; n &gt; num){ num = n; } } return num; } } . ",
    "url": "https://1001anjan.github.io/problem-348-Find%20Closest%20Number%20to%20Zero/",
    "relUrl": "/problem-348-Find Closest Number to Zero/"
  },"388": {
    "doc": "Calculate Digit Sum of a String",
    "title": "Calculate Digit Sum of a String",
    "content": "You are given a string s consisting of digits and an integer k. A round can be completed if the length of s is greater than k. In one round, do the following: . | Divide s into consecutive groups of size k such that the first k characters are in the first group, the next k characters are in the second group, and so on. Note that the size of the last group can be smaller than k. | Replace each group of s with a string representing the sum of all its digits. For example, “346” is replaced with “13” because 3 + 4 + 6 = 13. | Merge consecutive groups together to form a new string. If the length of the string is greater than k, repeat from step 1. Return s after all rounds have been completed. | . Example 1: . Input: s = \"11111222223\", k = 3 Output: \"135\" Explanation: - For the first round, we divide s into groups of size 3: \"111\", \"112\", \"222\", and \"23\". Then we calculate the digit sum of each group: 1 + 1 + 1 = 3, 1 + 1 + 2 = 4, 2 + 2 + 2 = 6, and 2 + 3 = 5. So, s becomes \"3\" + \"4\" + \"6\" + \"5\" = \"3465\" after the first round. - For the second round, we divide s into \"346\" and \"5\". Then we calculate the digit sum of each group: 3 + 4 + 6 = 13, 5 = 5. So, s becomes \"13\" + \"5\" = \"135\" after second round. Now, s.length &lt;= k, so we return \"135\" as the answer. Example 2: . Input: s = \"00000000\", k = 3 Output: \"000\" Explanation: We divide s into \"000\", \"000\", and \"00\". Then we calculate the digit sum of each group: 0 + 0 + 0 = 0, 0 + 0 + 0 = 0, and 0 + 0 = 0. s becomes \"0\" + \"0\" + \"0\" = \"000\", whose length is equal to k, so we return \"000\". Constraints: . | 1 &lt;= s.length &lt;= 100 | 2 &lt;= k &lt;= 100 | s consists of digits only. | . Solution: . class Solution { public String digitSum(String s, int k) { StringBuilder sb = new StringBuilder(); while(s.length() &gt; k){ int d = s.charAt(0) - '0'; int i = 1; for(; i &lt; s.length(); i++){ if(i % k == 0){ sb.append(d); d = s.charAt(i) - '0'; }else{ d += s.charAt(i) - '0'; } } sb.append(d); s = sb.toString(); sb.setLength(0); } return s; } } . ",
    "url": "https://1001anjan.github.io/problem-349-Calculate%20Digit%20Sum%20of%20a%20String/",
    "relUrl": "/problem-349-Calculate Digit Sum of a String/"
  },"389": {
    "doc": "Majority Element",
    "title": "Majority Element",
    "content": "Given an array nums of size n, return the majority element. The majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array. Example 1: . Input: nums = [3,2,3] Output: 3 . Example 2: . Input: nums = [2,2,1,1,1,2,2] Output: 2 . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 5 * 104 | -109 &lt;= nums[i] &lt;= 109 | . Solution . Sorting Approach: NlogN complexity. Space: O(1) . class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); return nums[nums.length/2]; } } . HashMap Approach: Time Complexity O(n), Space Complexity: O(n) . class Solution { public int majorityElement(int[] nums) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i=0; i&lt;nums.length; i++){ if(map.containsKey(nums[i])){ map.put(nums[i],map.get(nums[i])+1); }else{ map.put(nums[i],1); } } int count = 0; int key = 0; for(Map.Entry&lt;Integer,Integer&gt; keyValue : map.entrySet()){ if(keyValue.getValue()&gt;count){ count = keyValue.getValue(); key = keyValue.getKey(); } } return key; } } . Moor’s Algorithm: Time Complexity: O(n), Space Complexity: O(1) . class Solution { public int majorityElement(int[] nums) { if(nums.length == 1) return nums[0]; int majorElementIndex = 0; int majorElementCount = 1; for(int i=1; i&lt;nums.length; i++){ if(nums[majorElementIndex] == nums[i]){ majorElementCount ++; }else{ majorElementCount --; } if(majorElementCount == 0){ majorElementCount = 1; majorElementIndex = i; } } return nums[majorElementIndex]; } } . ",
    "url": "https://1001anjan.github.io/problem-35-Majority-Element/",
    "relUrl": "/problem-35-Majority-Element/"
  },"390": {
    "doc": "Unique Paths",
    "title": "Unique Paths",
    "content": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner. The test cases are generated so that the answer will be less than or equal to 2 * 109. Example 1: . Input: m = 3, n = 7 Output: 28 . Example 2: . Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Down . Constraints: . | 1 &lt;= m, n &lt;= 100 | . Solution: . Time limits exceeds with backtracking () . class Solution { public int uniquePaths(int m, int n) { return processPaths(m,n,1,1); } public int processPaths(int m, int n, int i, int j){ // index stating from (1,1) if(i == m &amp;&amp; j == n) return 1; if(i &gt; m || j &gt; n) return 0; int ans = processPaths(m,n,i + 1, j) + processPaths(m,n,i, j + 1); return ans; } } . O(m*n) time complexity . class Solution { public int uniquePaths(int m, int n) { int[][] dp = new int[m][n]; for(int i = 0; i &lt; m; i++) dp[i][0] = 1; for(int j = 0; j &lt; n; j++) dp[0][j] = 1; for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++) dp[i][j] = dp[i][j - 1] + dp[i - 1][j]; } return dp[m - 1][n - 1]; } } . class Solution { public int uniquePaths(int m, int n) { int[] dp = new int[n]; for(int j = 0; j &lt; n; j++) dp[j] = 1; for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++) dp[j] += dp[j - 1]; } return dp[n - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-35-Unique%20Paths/",
    "relUrl": "/problem-35-Unique Paths/"
  },"391": {
    "doc": "Intersection of Multiple Arrays",
    "title": "Intersection of Multiple Arrays",
    "content": "Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order. Example 1: . Input: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] Output: [3,4] Explanation: The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4]. Example 2: . Input: nums = [[1,2,3],[4,5,6]] Output: [] Explanation: There does not exist any integer present both in nums[0] and nums[1], so we return an empty list []. Constraints: . | 1 &lt;= nums.length &lt;= 1000 | 1 &lt;= sum(nums[i].length) &lt;= 1000 | 1 &lt;= nums[i][j] &lt;= 1000 | All the values of nums[i] are unique. | . Solution: . class Solution { public List&lt;Integer&gt; intersection(int[][] nums) { int[] dp = new int[1001]; for(int[] arr : nums){ for(int n : arr) dp[n]++; } List&lt;Integer&gt; ans = new LinkedList(); for(int i = 0; i &lt; 1001; i++){ if(dp[i] == nums.length) ans.add(i); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-350-Intersection%20of%20Multiple%20Arrays/",
    "relUrl": "/problem-350-Intersection of Multiple Arrays/"
  },"392": {
    "doc": "Count Prefixes of a Given String",
    "title": "Count Prefixes of a Given String",
    "content": "You are given a string array words and a string s, where words[i] and s comprise only of lowercase English letters. Return the number of strings in words that are a prefix of s. A prefix of a string is a substring that occurs at the beginning of the string. A substring is a contiguous sequence of characters within a string. Example 1: . Input: words = [\"a\",\"b\",\"c\",\"ab\",\"bc\",\"abc\"], s = \"abc\" Output: 3 Explanation: The strings in words which are a prefix of s = \"abc\" are: \"a\", \"ab\", and \"abc\". Thus the number of strings in words which are a prefix of s is 3. Example 2: . Input: words = [\"a\",\"a\"], s = \"aa\" Output: 2 Explanation: Both of the strings are a prefix of s. Note that the same string can occur multiple times in words, and it should be counted each time. Constraints: . | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length, s.length &lt;= 10 | words[i] and s consist of lowercase English letters only. | . Solution: . class Solution { public int countPrefixes(String[] words, String s) { int c = 0; for(String str : words){ if(s.indexOf(str) == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-351-Count%20Prefixes%20of%20a%20Given%20String/",
    "relUrl": "/problem-351-Count Prefixes of a Given String/"
  },"393": {
    "doc": "Remove Digit From Number to Maximize Result",
    "title": "Remove Digit From Number to Maximize Result",
    "content": "You are given a string number representing a positive integer and a character digit. Return the resulting string after removing exactly one occurrence of digit from number such that the value of the resulting string in decimal form is maximized. The test cases are generated such that digit occurs at least once in number. Example 1: . Input: number = \"123\", digit = \"3\" Output: \"12\" Explanation: There is only one '3' in \"123\". After removing '3', the result is \"12\". Example 2: . Input: number = \"1231\", digit = \"1\" Output: \"231\" Explanation: We can remove the first '1' to get \"231\" or remove the second '1' to get \"123\". Since 231 &gt; 123, we return \"231\". Example 3: . Input: number = \"551\", digit = \"5\" Output: \"51\" Explanation: We can remove either the first or second '5' from \"551\". Both result in the string \"51\". Constraints: . | 2 &lt;= number.length &lt;= 100 | number consists of digits from ‘1’ to ‘9’. | digit is a digit from ‘1’ to ‘9’. | digit occurs at least once in number. | . Solution: . class Solution { public String removeDigit(String number, char digit) { int index = 0; int n = number.length(); for(int i = 0; i &lt; n; i++){ if(number.charAt(i) == digit){ index = i; if(i &lt; n - 1 &amp;&amp; digit &lt; number.charAt(i + 1)) break; } } return number.substring(0,index) + number.substring(index + 1, n); } } . ",
    "url": "https://1001anjan.github.io/problem-352-Remove%20Digit%20From%20Number%20to%20Maximize%20Result/",
    "relUrl": "/problem-352-Remove Digit From Number to Maximize Result/"
  },"394": {
    "doc": "Largest 3-Same-Digit Number in String",
    "title": "Largest 3-Same-Digit Number in String",
    "content": "You are given a string num representing a large integer. An integer is good if it meets the following conditions: . | It is a substring of num with length 3. | It consists of only one unique digit. Return the maximum good integer as a string or an empty string “” if no such integer exists. | . Note: . | A substring is a contiguous sequence of characters within a string. | There may be leading zeroes in num or a good integer. | . Example 1: . Input: num = \"6777133339\" Output: \"777\" Explanation: There are two distinct good integers: \"777\" and \"333\". \"777\" is the largest, so we return \"777\". Example 2: . Input: num = \"2300019\" Output: \"000\" Explanation: \"000\" is the only good integer. Example 3: . Input: num = \"42352338\" Output: \"\" Explanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers. Constraints: . | 3 &lt;= num.length &lt;= 1000 | num only consists of digits. | . Solution: . class Solution { public String largestGoodInteger(String num) { int d = -1; String ans = \"\"; char[] str = num.toCharArray(); for(int i = 0; i &lt; str.length - 2; i++){ if(str[i] == str[i + 1] &amp;&amp; str[i] == str[i + 2] &amp;&amp; d &lt; str[i] - '0'){ d = str[i] - '0'; ans = num.substring(i,i + 3); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-353-Largest%203-Same-Digit%20Number%20in%20String/",
    "relUrl": "/problem-353-Largest 3-Same-Digit Number in String/"
  },"395": {
    "doc": "Find the K-Beauty of a Number",
    "title": "Find the K-Beauty of a Number",
    "content": "The k-beauty of an integer num is defined as the number of substrings of num when it is read as a string that meet the following conditions: . | It has a length of k. | It is a divisor of num. Given integers num and k, return the k-beauty of num. | . Note: . | Leading zeros are allowed. | 0 is not a divisor of any value. | A substring is a contiguous sequence of characters in a string. | . Example 1: . Input: num = 240, k = 2 Output: 2 Explanation: The following are the substrings of num of length k: - \"24\" from \"240\": 24 is a divisor of 240. - \"40\" from \"240\": 40 is a divisor of 240. Therefore, the k-beauty is 2. Example 2: . Input: num = 430043, k = 2 Output: 2 Explanation: The following are the substrings of num of length k: - \"43\" from \"430043\": 43 is a divisor of 430043. - \"30\" from \"430043\": 30 is not a divisor of 430043. - \"00\" from \"430043\": 0 is not a divisor of 430043. - \"04\" from \"430043\": 4 is not a divisor of 430043. - \"43\" from \"430043\": 43 is a divisor of 430043. Therefore, the k-beauty is 2. Constraints: . | 1 &lt;= num &lt;= 109 | 1 &lt;= k &lt;= num.length (taking num as a string) | . Solution: . class Solution { public int divisorSubstrings(int num, int k) { String str = String.valueOf(num); int c = 0; for(int i = 0; i &lt;= str.length() - k; i++){ int d = Integer.parseInt(str.substring(i, i + k)); if(d != 0 &amp;&amp; num % d == 0) c++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-354-Find%20the%20K-Beauty%20of%20a%20Number/",
    "relUrl": "/problem-354-Find the K-Beauty of a Number/"
  },"396": {
    "doc": "Find Resultant Array After Removing Anagrams",
    "title": "Find Resultant Array After Removing Anagrams",
    "content": "You are given a 0-indexed string array words, where words[i] consists of lowercase English letters. In one operation, select any index i such that 0 &lt; i &lt; words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words. Keep performing this operation as long as you can select an index that satisfies the conditions. Return words after performing all operations. It can be shown that selecting the indices for each operation in any arbitrary order will lead to the same result. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, “dacb” is an anagram of “abdc”. Example 1: . Input: words = [\"abba\",\"baba\",\"bbaa\",\"cd\",\"cd\"] Output: [\"abba\",\"cd\"] Explanation: One of the ways we can obtain the resultant array is by using the following operations: - Since words[2] = \"bbaa\" and words[1] = \"baba\" are anagrams, we choose index 2 and delete words[2]. Now words = [\"abba\",\"baba\",\"cd\",\"cd\"]. - Since words[1] = \"baba\" and words[0] = \"abba\" are anagrams, we choose index 1 and delete words[1]. Now words = [\"abba\",\"cd\",\"cd\"]. - Since words[2] = \"cd\" and words[1] = \"cd\" are anagrams, we choose index 2 and delete words[2]. Now words = [\"abba\",\"cd\"]. We can no longer perform any operations, so [\"abba\",\"cd\"] is the final answer. Example 2: . Input: words = [\"a\",\"b\",\"c\",\"d\",\"e\"] Output: [\"a\",\"b\",\"c\",\"d\",\"e\"] Explanation: No two adjacent strings in words are anagrams of each other, so no operations are performed. Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 10 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public List&lt;String&gt; removeAnagrams(String[] words) { List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] dp = new int[26]; ans.add(words[0]); for(char ch : words[0].toCharArray()) dp[ch - 'a']++; for(int i = 1; i &lt; words.length; i++){ int[] dpp = getAnagramsMap(words[i]); boolean flag = true; for(int j = 0; j &lt; 26; j++){ if(dpp[j] != dp[j]) flag = false; dp[j] = dpp[j]; } if(!flag) ans.add(words[i]); } return ans; } public int[] getAnagramsMap(String str){ int[] dp = new int[26]; for(char ch : str.toCharArray()) dp[ch - 'a']++; return dp; } } . Anotherway . class Solution { public List&lt;String&gt; removeAnagrams(String[] words) { int low = 0; List&lt;String&gt; ans = new ArrayList&lt;&gt;(); int[] prev = count(words[low]); for(int i=1;i&lt;words.length;i++){ int[] curr = count(words[i]); if(Arrays.equals(prev,curr)){ continue; } ans.add(words[low]); low = i; prev = count(words[low]); } ans.add(words[low]); return ans; } private int[] count(String s){ int[] c = new int[26]; int n = s.length(); for(int i=0;i&lt;n;i++){ c[s.charAt(i)-'a']++; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-355-Find%20Resultant%20Array%20After%20Removing%20Anagrams/",
    "relUrl": "/problem-355-Find Resultant Array After Removing Anagrams/"
  },"397": {
    "doc": "Percentage of Letter in String",
    "title": "Percentage of Letter in String",
    "content": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent. Example 1: . Input: s = \"foobar\", letter = \"o\" Output: 33 Explanation: The percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33. Example 2: . Input: s = \"jjjj\", letter = \"k\" Output: 0 Explanation: The percentage of characters in s that equal the letter 'k' is 0%, so we return 0. Constraints: . | 1 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | letter is a lowercase English letter. | . Solution: . class Solution { public int percentageLetter(String s, char letter) { int c = 0; for(char ch : s.toCharArray()) if(ch == letter) c++; return (c * 100) / s.length(); } } . ",
    "url": "https://1001anjan.github.io/problem-356-Percentage%20of%20Letter%20in%20String/",
    "relUrl": "/problem-356-Percentage of Letter in String/"
  },"398": {
    "doc": "Check if Number Has Equal Digit Count and Digit Value",
    "title": "Check if Number Has Equal Digit Count and Digit Value",
    "content": "You are given a 0-indexed string num of length n consisting of digits. Return true if for every index i in the range 0 &lt;= i &lt; n, the digit i occurs num[i] times in num, otherwise return false. #####Example 1: . Input: num = \"1210\" Output: true Explanation: num[0] = '1'. The digit 0 occurs once in num. num[1] = '2'. The digit 1 occurs twice in num. num[2] = '1'. The digit 2 occurs once in num. num[3] = '0'. The digit 3 occurs zero times in num. The condition holds true for every index in \"1210\", so return true. Example 2: . Input: num = \"030\" Output: false Explanation: num[0] = '0'. The digit 0 should occur zero times, but actually occurs twice in num. num[1] = '3'. The digit 1 should occur three times, but actually occurs zero times in num. num[2] = '0'. The digit 2 occurs zero times in num. The indices 0 and 1 both violate the condition, so return false. Constraints: . | n == num.length | 1 &lt;= n &lt;= 10 | num consists of digits. | . Solution: . class Solution { public boolean digitCount(String num) { int[] dm = new int[10]; for(char ch : num.toCharArray()){ dm[ch - '0']++; } for(int i = 0; i &lt; num.length(); i++){ int d = num.charAt(i) - '0'; if(dm[i] != d) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-357-Check%20if%20Number%20Has%20Equal%20Digit%20Count%20and%20Digit%20Value/",
    "relUrl": "/problem-357-Check if Number Has Equal Digit Count and Digit Value/"
  },"399": {
    "doc": "Rearrange Characters to Make Target String",
    "title": "Rearrange Characters to Make Target String",
    "content": "You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings. Return the maximum number of copies of target that can be formed by taking letters from s and rearranging them. Example 1: . Input: s = \"ilovecodingonleetcode\", target = \"code\" Output: 2 Explanation: For the first copy of \"code\", take the letters at indices 4, 5, 6, and 7. For the second copy of \"code\", take the letters at indices 17, 18, 19, and 20. The strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\". We can make at most two copies of \"code\", so we return 2. Example 2: . Input: s = \"abcba\", target = \"abc\" Output: 1 Explanation: We can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2. We can make at most one copy of \"abc\", so we return 1. Note that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\". Example 3: . Input: s = \"abbaccaddaeea\", target = \"aaaaa\" Output: 1 Explanation: We can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12. We can make at most one copy of \"aaaaa\", so we return 1. Constraints: . | 1 &lt;= s.length &lt;= 100 | 1 &lt;= target.length &lt;= 10 | s and target consist of lowercase English letters. | . Solution: . class Solution { public int rearrangeCharacters(String s, String target) { int[] dp1 = new int[26]; int[] dp2 = new int[26]; for(char ch : s.toCharArray()) dp1[ch - 'a']++; for(char ch : target.toCharArray()) dp2[ch - 'a']++; int max = Integer.MAX_VALUE; for(int i = 0; i &lt; 26; i++){ if(dp2[i] != 0) max= Math.min(max,dp1[i] / dp2[i]); } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-358-Rearrange%20Characters%20to%20Make%20Target%20String/",
    "relUrl": "/problem-358-Rearrange Characters to Make Target String/"
  },"400": {
    "doc": "Min Max Game",
    "title": "Min Max Game",
    "content": "You are given a 0-indexed integer array nums whose length is a power of 2. Apply the following algorithm on nums: . | Let n be the length of nums. If n == 1, end the process. Otherwise, create a new 0-indexed integer array newNums of length n / 2. | For every even index i where 0 &lt;= i &lt; n / 2, assign the value of newNums[i] as min(nums[2 * i], nums[2 * i + 1]). | For every odd index i where 0 &lt;= i &lt; n / 2, assign the value of newNums[i] as max(nums[2 * i], nums[2 * i + 1]). | Replace the array nums with newNums. | Repeat the entire process starting from step 1. Return the last number that remains in nums after applying the algorithm. | . Example 1: . Input: nums = [1,3,5,2,4,8,2,2] Output: 1 Explanation: The following arrays are the results of applying the algorithm repeatedly. First: nums = [1,5,4,2] Second: nums = [1,4] Third: nums = [1] 1 is the last remaining number, so we return 1. Example 2: . Input: nums = [3] Output: 3 Explanation: 3 is already the last remaining number, so we return 3. Constraints: . | 1 &lt;= nums.length &lt;= 1024 | 1 &lt;= nums[i] &lt;= 109 | nums.length is a power of 2. | . Solution: . class Solution { public int minMaxGame(int[] nums) { while(nums.length != 1){ int[] temp = new int[nums.length / 2]; boolean min = true; for(int i = 0, k = 0; i &lt; nums.length - 1; i = i + 2, k++){ if(min){ temp[k] = Math.min(nums[i],nums[i+1]); }else{ temp[k] = Math.max(nums[i],nums[i+1]); } min = !min; } nums = temp; } return nums[0]; } } . Improvement using recursion . class Solution { public int minMaxGame(int[] nums) { if(nums.length == 1) return nums[0]; int[] temp = new int[nums.length / 2]; boolean min = true; for(int i = 0, k = 0; i &lt; nums.length - 1; i = i + 2, k++){ if(min){ temp[k] = Math.min(nums[i],nums[i+1]); }else{ temp[k] = Math.max(nums[i],nums[i+1]); } min = !min; } return minMaxGame(temp); } } . Optimised extra variables . class Solution { public int minMaxGame(int[] nums) { if(nums.length == 1) return nums[0]; int[] temp = new int[nums.length / 2]; for(int i = 0; i &lt; nums.length / 2; i++){ if(i % 2 == 0){ temp[i] = Math.min(nums[2*i],nums[2*i+1]); }else{ temp[i] = Math.max(nums[2*i],nums[2*i+1]); } } return minMaxGame(temp); } } . ",
    "url": "https://1001anjan.github.io/problem-359-Min%20Max%20Game/",
    "relUrl": "/problem-359-Min Max Game/"
  },"401": {
    "doc": "Excel Sheet Column Number",
    "title": "Excel Sheet Column Number",
    "content": "Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number. For example: . A -&gt; 1 B -&gt; 2 C -&gt; 3 ... Z -&gt; 26 AA -&gt; 27 AB -&gt; 28 ... Example 1: . Input: columnTitle = \"A\" Output: 1 . Example 2: . Input: columnTitle = \"AB\" Output: 28 . Example 3: . Input: columnTitle = \"ZY\" Output: 701 . Constraints: . | 1 &lt;= columnTitle.length &lt;= 7 | columnTitle consists only of uppercase English letters. | columnTitle is in the range [“A”, “FXSHRXW”]. | . Solution . class Solution { public int titleToNumber(String columnTitle) { int ans = 0; for(int i=0; i&lt;=columnTitle.length() -1; i++){ ans = 26*ans + columnTitle.charAt(i) - 'A' +1; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-36-Excel-Sheet-Column-Number/",
    "relUrl": "/problem-36-Excel-Sheet-Column-Number/"
  },"402": {
    "doc": "Unique Paths II",
    "title": "Unique Paths II",
    "content": "You are given an m x n integer array grid. There is a robot initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time. An obstacle and space are marked as 1 or 0 respectively in grid. A path that the robot takes cannot include any square that is an obstacle. Return the number of possible unique paths that the robot can take to reach the bottom-right corner. The testcases are generated so that the answer will be less than or equal to 2 * 109. Example 1: . Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] Output: 2 Explanation: There is one obstacle in the middle of the 3x3 grid above. There are two ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down -&gt; Down 2. Down -&gt; Down -&gt; Right -&gt; Right . Example 2: . Input: obstacleGrid = [[0,1],[0,0]] Output: 1 . Constraints: . | m == obstacleGrid.length | n == obstacleGrid[i].length | 1 &lt;= m, n &lt;= 100 | obstacleGrid[i][j] is 0 or 1. | . Solution: . Time Limit Exceeded . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) { return 0; } return paths(obstacleGrid, obstacleGrid.length-1, obstacleGrid[0].length-1); } private int paths(int[][] obstacleGrid, int m, int n){ if(m == 0 &amp;&amp; n == 0) return 1; if(m&lt;0 || n&lt;0 || obstacleGrid[m][n] == 1) return 0; return paths(obstacleGrid, m-1,n)+paths(obstacleGrid, m,n-1); } } . With memorization . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { Map&lt;String,Integer&gt; dp = new HashMap&lt;&gt;(); if(obstacleGrid.length == 0 || obstacleGrid[0].length == 0 || obstacleGrid[0][0] == 1) { return 0; } return paths(obstacleGrid, obstacleGrid.length-1, obstacleGrid[0].length-1, dp); } private int paths(int[][] obstacleGrid, int m, int n, Map&lt;String,Integer&gt; dp){ String key = m+\"-\"+n; if(m == 0 &amp;&amp; n == 0) return 1; if(m&lt;0 || n&lt;0 || obstacleGrid[m][n] == 1) return 0; if(dp.containsKey(key)) return dp.get(key); dp.put(key, paths(obstacleGrid, m-1,n, dp)+paths(obstacleGrid, m,n-1, dp)); return dp.get(key); } } . Dynamic programming . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int m = obstacleGrid.length; int n = obstacleGrid[0].length; int[][] dp = new int[m][n]; // intializing base dp boolean found = false; for(int i = 0; i &lt; m ; i++){ if(obstacleGrid[i][0] == 1) found = true; if(!found) dp[i][0] = 1; else dp[i][0] = 0; } found = false; for(int i = 0; i &lt; n ; i++){ if(obstacleGrid[0][i] == 1) found = true; if(!found) dp[0][i] = 1; else dp[0][i] = 0; } // process the paths for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ if(obstacleGrid[i][j] == 1){ dp[i][j] = 0; }else{ dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; } } } return dp[m - 1][n - 1]; } } . class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int width = obstacleGrid[0].length; int[] dp = new int[width]; dp[0] = 1; for (int[] row : obstacleGrid) { for (int j = 0; j &lt; width; j++) { if (row[j] == 1) dp[j] = 0; else if (j &gt; 0) dp[j] += dp[j - 1]; } } return dp[width - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-36-Unique%20Paths%20II/",
    "relUrl": "/problem-36-Unique Paths II/"
  },"403": {
    "doc": "Strong Password Checker II",
    "title": "Strong Password Checker II",
    "content": "A password is said to be strong if it satisfies all the following criteria: . | It has at least 8 characters. | It contains at least one lowercase letter. | It contains at least one uppercase letter. | It contains at least one digit. | It contains at least one special character. The special characters are the characters in the following string: “!@#$%^&amp;*()-+”. | It does not contain 2 of the same character in adjacent positions (i.e., “aab” violates this condition, but “aba” does not). Given a string password, return true if it is a strong password. Otherwise, return false. | . Example 1: . Input: password = \"IloveLe3tcode!\" Output: true Explanation: The password meets all the requirements. Therefore, we return true. Example 2: . Input: password = \"Me+You--IsMyDream\" Output: false Explanation: The password does not contain a digit and also contains 2 of the same character in adjacent positions. Therefore, we return false. Example 3: . Input: password = \"1aB!\" Output: false Explanation: The password does not meet the length requirement. Therefore, we return false. Constraints: . | 1 &lt;= password.length &lt;= 100 | password consists of letters, digits, and special characters: “!@#$%^&amp;*()-+”. | . Solution: . class Solution { public boolean strongPasswordCheckerII(String password) { if(password.length() &lt; 8) return false; boolean lc = false, uc = false, d = false, sc = false; char prev = ' '; for(char crr : password.toCharArray()){ if(prev == crr) return false; if(Character.isDigit(crr)){ d = true; }else if(Character.isLetter(crr)){ if(Character.isUpperCase(crr)){ uc= true; }else{ lc = true; } }else{ sc = true; } prev = crr; } return lc &amp;&amp; uc &amp;&amp; d &amp;&amp; sc; } } . ",
    "url": "https://1001anjan.github.io/problem-360-Strong%20Password%20Checker%20II/",
    "relUrl": "/problem-360-Strong Password Checker II/"
  },"404": {
    "doc": "Greatest English Letter in Upper and Lower Case",
    "title": "Greatest English Letter in Upper and Lower Case",
    "content": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string. An English letter b is greater than another letter a if b appears after a in the English alphabet. Example 1: . Input: s = \"lEeTcOdE\" Output: \"E\" Explanation: The letter 'E' is the only letter to appear in both lower and upper case. Example 2: . Input: s = \"arRAzFif\" Output: \"R\" Explanation: The letter 'R' is the greatest letter to appear in both lower and upper case. Note that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'. Example 3: . Input: s = \"AbCdEfGhIjK\" Output: \"\" Explanation: There is no letter that appears in both lower and upper case. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consists of lowercase and uppercase English letters. | . Solution: . class Solution { public String greatestLetter(String s) { boolean[][] cm = new boolean[26][2]; for(char c : s.toCharArray()){ if(Character.isUpperCase(c)){ cm[c - 'A'][0] = true; }else{ cm[c - 'a'][1] = true; } } for(int i = 25; i &gt;= 0; i--){ if(cm[i][0] &amp;&amp; cm[i][1]) return Character.toString('A' + i); } return \"\"; } } . Improvement . class Solution { public String greatestLetter(String s) { boolean[] letters = new boolean[58]; for (char c : s.toCharArray()) { letters[c - 'A'] = true; } for (int i = 26; i &gt;= 0; i--) { if (letters[i] &amp;&amp; letters[i + 32]) { return \"\" + (char)('A' + i); } } return \"\"; } } . ",
    "url": "https://1001anjan.github.io/problem-361-Greatest%20English%20Letter%20in%20Upper%20and%20Lower%20Case/",
    "relUrl": "/problem-361-Greatest English Letter in Upper and Lower Case/"
  },"405": {
    "doc": "Count Asterisks",
    "title": "Count Asterisks",
    "content": "You are given a string s, where every two consecutive vertical bars ‘|’ are grouped into a pair. In other words, the 1st and 2nd ‘|’ make a pair, the 3rd and 4th ‘|’ make a pair, and so forth. | Return the number of ‘’ in s, excluding the ‘’ between each pair of ‘ | ’. | . | Note that each ‘ | ’ will belong to exactly one pair. | . Example 1: . Input: s = \"l|*e*et|c**o|*de|\" Output: 2 Explanation: The considered characters are underlined: \"l|*e*et|c**o|*de|\". The characters between the first and second '|' are excluded from the answer. Also, the characters between the third and fourth '|' are excluded from the answer. There are 2 asterisks considered. Therefore, we return 2. Example 2: . Input: s = \"iamprogrammer\" Output: 0 Explanation: In this example, there are no asterisks in s. Therefore, we return 0. Example 3: . Input: s = \"yo|uar|e**|b|e***au|tifu|l\" Output: 5 Explanation: The considered characters are underlined: \"yo|uar|e**|b|e***au|tifu|l\". There are 5 asterisks considered. Therefore, we return 5. Constraints: . | 1 &lt;= s.length &lt;= 1000 | | s consists of lowercase English letters, vertical bars ‘ | ’, and asterisks ‘*’. | . | | s contains an even number of vertical bars ‘ | ’. | . | . Solution: . class Solution { public int countAsterisks(String s) { String[] words = s.split(\"\\\\|\"); int c = 0; for(int i = 0; i &lt; words.length; i = i+ 2){ for(char ch : words[i].toCharArray()){ if(ch == '*') c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-362-Count%20Asterisks/",
    "relUrl": "/problem-362-Count Asterisks/"
  },"406": {
    "doc": "Check if Matrix Is X-Matrix",
    "title": "Check if Matrix Is X-Matrix",
    "content": "A square matrix is said to be an X-Matrix if both of the following conditions hold: . | All the elements in the diagonals of the matrix are non-zero. | All other elements are 0. Given a 2D integer array grid of size n x n representing a square matrix, return true if grid is an X-Matrix. Otherwise, return false. | . Example 1: . Input: grid = [[2,0,0,1],[0,3,1,0],[0,5,2,0],[4,0,0,2]] Output: true Explanation: Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is an X-Matrix. Example 2: . Input: grid = [[5,7,0],[0,3,1],[0,5,0]] Output: false Explanation: Refer to the diagram above. An X-Matrix should have the green elements (diagonals) be non-zero and the red elements be 0. Thus, grid is not an X-Matrix. Constraints: . | n == grid.length == grid[i].length | 3 &lt;= n &lt;= 100 | 0 &lt;= grid[i][j] &lt;= 10^5 | . Solution: . class Solution { private boolean isDiagonal(int i, int j, int length) { return (i == j || j == length - 1 - i); } public boolean checkXMatrix(int[][] grid) { for(int i = 0; i &lt; grid.length; i++) { for(int j = 0; j &lt; grid[i].length; j++) { if(isDiagonal(i, j, grid.length)){ if(grid[i][j] == 0) return false; }else{ if(grid[i][j] != 0) return false; } } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-363-Check%20if%20Matrix%20Is%20X-Matrix/",
    "relUrl": "/problem-363-Check if Matrix Is X-Matrix/"
  },"407": {
    "doc": "Decode the Message",
    "title": "Decode the Message",
    "content": "You are given the strings key and message, which represent a cipher key and a secret message, respectively. The steps to decode message are as follows: . | Use the first appearance of all 26 lowercase English letters in key as the order of the substitution table. | Align the substitution table with the regular English alphabet. | Each letter in message is then substituted using the table. | Spaces ‘ ‘ are transformed to themselves. | For example, given key = “happy boy” (actual key would have at least one instance of each letter in the alphabet), we have the partial substitution table of (‘h’ -&gt; ‘a’, ‘a’ -&gt; ‘b’, ‘p’ -&gt; ‘c’, ‘y’ -&gt; ‘d’, ‘b’ -&gt; ‘e’, ‘o’ -&gt; ‘f’). Return the decoded message. | . | . Example 1: . Input: key = \"the quick brown fox jumps over the lazy dog\", message = \"vkbs bs t suepuv\" Output: \"this is a secret\" Explanation: The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"the quick brown fox jumps over the lazy dog\". Example 2: . Input: key = \"eljuxhpwnyrdgtqkviszcfmabo\", message = \"zwx hnfx lqantp mnoeius ycgk vcnjrdb\" Output: \"the five boxing wizards jump quickly\" Explanation: The diagram above shows the substitution table. It is obtained by taking the first appearance of each letter in \"eljuxhpwnyrdgtqkviszcfmabo\". Constraints: . | 26 &lt;= key.length &lt;= 2000 | key consists of lowercase English letters and ‘ ‘. | key contains every letter in the English alphabet (‘a’ to ‘z’) at least once. | 1 &lt;= message.length &lt;= 2000 | message consists of lowercase English letters and ‘ ‘. | . Solution: . class Solution { public String decodeMessage(String key, String message) { char[] dp = new char[26]; char c = 'a'; for(char ch : key.toCharArray()){ int index = ch - 'a'; if(ch != ' ' &amp;&amp; dp[index] == 0){ dp[index] = c++; } } StringBuilder sb = new StringBuilder(); for(char ch : message.toCharArray()){ if(ch == ' '){ sb.append(ch); } else{ sb.append(dp[ch - 'a']); } } return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-364-Decode%20the%20Message/",
    "relUrl": "/problem-364-Decode the Message/"
  },"408": {
    "doc": "Evaluate Boolean Binary Tree",
    "title": "Evaluate Boolean Binary Tree",
    "content": "You are given the root of a full binary tree with the following properties: . | Leaf nodes have either the value 0 or 1, where 0 represents False and 1 represents True. | Non-leaf nodes have either the value 2 or 3, where 2 represents the boolean OR and 3 represents the boolean AND. The evaluation of a node is as follows: . | If the node is a leaf node, the evaluation is the value of the node, i.e. True or False. | Otherwise, evaluate the node’s two children and apply the boolean operation of its value with the children’s evaluations. Return the boolean result of evaluating the root node. | . A full binary tree is a binary tree where each node has either 0 or 2 children. A leaf node is a node that has zero children. Example 1: . Input: root = [2,1,3,null,null,0,1] Output: true Explanation: The above diagram illustrates the evaluation process. The AND node evaluates to False AND True = False. The OR node evaluates to True OR False = True. The root node evaluates to True, so we return true. Example 2: . Input: root = [0] Output: false Explanation: The root node is a leaf node and it evaluates to false, so we return false. Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | 0 &lt;= Node.val &lt;= 3 | Every node has either 0 or 2 children. | Leaf nodes have a value of 0 or 1. | Non-leaf nodes have a value of 2 or 3. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public boolean evaluateTree(TreeNode root) { if(root.left == null &amp;&amp; root.right == null) return root.val == 1; if(root.val == 2){ return evaluateTree(root.left) | evaluateTree(root.right); }else{ return evaluateTree(root.left) &amp; evaluateTree(root.right); } } } . ",
    "url": "https://1001anjan.github.io/problem-365-Evaluate%20Boolean%20Binary%20Tree/",
    "relUrl": "/problem-365-Evaluate Boolean Binary Tree/"
  },"409": {
    "doc": "Maximum Number of Pairs in Array",
    "title": "Maximum Number of Pairs in Array",
    "content": "You are given a 0-indexed integer array nums. In one operation, you may do the following: . | Choose two integers in nums that are equal. | Remove both integers from nums, forming a pair. The operation is done on nums as many times as possible. | . Return a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible. Example 1: . Input: nums = [1,3,2,1,3,2,2] Output: [3,1] Explanation: Form a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2]. Form a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2]. Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2]. No more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums. Example 2: . Input: nums = [1,1] Output: [1,0] Explanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = []. No more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums. Example 3: . Input: nums = [0] Output: [0,1] Explanation: No pairs can be formed, and there is 1 number leftover in nums. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int[] numberOfPairs(int[] nums) { int[] dp = new int[101]; int pair = 0, leftOver = 0; for(int n : nums) dp[n]++; for(int n : dp){ pair += n / 2; leftOver += n % 2; } return new int[] {pair,leftOver}; } } . ",
    "url": "https://1001anjan.github.io/problem-366-Maximum%20Number%20of%20Pairs%20in%20Array/",
    "relUrl": "/problem-366-Maximum Number of Pairs in Array/"
  },"410": {
    "doc": "First Letter to Appear Twice",
    "title": "First Letter to Appear Twice",
    "content": "Given a string s consisting of lowercase English letters, return the first letter to appear twice. Note: . | A letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b. | s will contain at least one letter that appears twice. | . Example 1: . Input: s = \"abccbaacz\" Output: \"c\" Explanation: The letter 'a' appears on the indexes 0, 5 and 6. The letter 'b' appears on the indexes 1 and 4. The letter 'c' appears on the indexes 2, 3 and 7. The letter 'z' appears on the index 8. The letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest. Example 2: . Input: s = \"abcdd\" Output: \"d\" Explanation: The only letter that appears twice is 'd' so we return 'd'. Constraints: . | 2 &lt;= s.length &lt;= 100 | s consists of lowercase English letters. | s has at least one repeated letter. | . Solution: . class Solution { public char repeatedCharacter(String s) { boolean[] dp = new boolean[26]; for(char ch : s.toCharArray()){ if(dp[ch - 'a']) return ch; dp[ch - 'a'] = true; } throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-367-First%20Letter%20to%20Appear%20Twice/",
    "relUrl": "/problem-367-First Letter to Appear Twice/"
  },"411": {
    "doc": "Make Array Zero by Subtracting Equal Amounts",
    "title": "Make Array Zero by Subtracting Equal Amounts",
    "content": "You are given a non-negative integer array nums. In one operation, you must: . | Choose a positive integer x such that x is less than or equal to the smallest non-zero element in nums. | Subtract x from every positive element in nums. Return the minimum number of operations to make every element in nums equal to 0. | . Example 1: . Input: nums = [1,5,0,3,5] Output: 3 Explanation: In the first operation, choose x = 1. Now, nums = [0,4,0,2,4]. In the second operation, choose x = 2. Now, nums = [0,2,0,0,2]. In the third operation, choose x = 2. Now, nums = [0,0,0,0,0]. Example 2: . Input: nums = [0] Output: 0 Explanation: Each element in nums is already 0 so no operations are needed. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public int minimumOperations(int[] nums) { int c = 0; Arrays.sort(nums); int prev = 0; for(int n : nums){ if(n - prev != 0) c++; prev = n; } return c; } } . O(n) complexity . class Solution { public int minimumOperations(int[] nums) { int c = 0; boolean[] dp = new boolean[101]; for(int n : nums){ if(n == 0) continue; if(!dp[n]){ dp[n] = true; c++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-368-Make%20Array%20Zero%20by%20Subtracting%20Equal%20Amounts/",
    "relUrl": "/problem-368-Make Array Zero by Subtracting Equal Amounts/"
  },"412": {
    "doc": "Merge Similar Items",
    "title": "Merge Similar Items",
    "content": "You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties: . | items[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item. | The value of each item in items is unique. Return a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei. | . Note: ret should be returned in ascending order by value. Example 1: . Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]] Output: [[1,6],[3,9],[4,5]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6. The item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9. The item with value = 4 occurs in items1 with weight = 5, total weight = 5. Therefore, we return [[1,6],[3,9],[4,5]]. Example 2: . Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]] Output: [[1,4],[2,4],[3,4]] Explanation: The item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4. The item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4. The item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. Therefore, we return [[1,4],[2,4],[3,4]]. Example 3: . Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]] Output: [[1,7],[2,4],[7,1]] Explanation: The item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. The item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. The item with value = 7 occurs in items2 with weight = 1, total weight = 1. Therefore, we return [[1,7],[2,4],[7,1]]. Constraints: . | 1 &lt;= items1.length, items2.length &lt;= 1000 | items1[i].length == items2[i].length == 2 | 1 &lt;= valuei, weighti &lt;= 1000 | Each valuei in items1 is unique. | Each valuei in items2 is unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; mergeSimilarItems(int[][] items1, int[][] items2) { int[] dp = new int[1001]; for(int arr[] : items1) dp[arr[0]] += arr[1]; for(int arr[] : items2) dp[arr[0]] += arr[1]; List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); for(int i = 1; i &lt; 1001; i++){ if(dp[i] != 0){ List&lt;Integer&gt; t = new ArrayList&lt;&gt;(); t.add(i); t.add(dp[i]); ans.add(t); } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-369-Merge%20Similar%20Items/",
    "relUrl": "/problem-369-Merge Similar Items/"
  },"413": {
    "doc": "Minimum Path Sum",
    "title": "Minimum Path Sum",
    "content": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. Example 1: . Input: grid = [[1,3,1],[1,5,1],[4,2,1]] Output: 7 Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum. Example 2: . Input: grid = [[1,2,3],[4,5,6]] Output: 12 . Constraints: . | m == grid.length | n == grid[i].length | 1 &lt;= m, n &lt;= 200 | 0 &lt;= grid[i][j] &lt;= 100 | . Solution: . class Solution { public int minPathSum(int[][] grid) { int m = grid.length; int n = grid[0].length; int[][] dp = new int[m][n]; int sum = 0; for(int i = 0; i &lt; n; i++){ sum = sum + grid[0][i]; dp[0][i] = sum; } sum = 0; for(int i = 0; i &lt; m; i++){ sum += grid[i][0]; dp[i][0] = sum; } for(int i = 1; i &lt; m; i++){ for(int j = 1; j &lt; n; j++){ dp[i][j] = Math.min(grid[i][j] + dp[i - 1][j], grid[i][j] + dp[i][j - 1]); } } return dp[m - 1][n - 1]; } } . ",
    "url": "https://1001anjan.github.io/problem-37-Minimum%20Path%20Sum/",
    "relUrl": "/problem-37-Minimum Path Sum/"
  },"414": {
    "doc": "Reverse Bits",
    "title": "Reverse Bits",
    "content": "Reverse bits of a given 32 bits unsigned integer. Note: . | Note that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. | In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825. | . Example 1: . Input: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2: . Input: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. Constraints: . | The input must be a binary string of length 32 | . Solution . public class Solution { // you need treat n as an unsigned value public int reverseBits(int n) { return Integer.reverse(n); } } . ",
    "url": "https://1001anjan.github.io/problem-37-Reverse-Bits/",
    "relUrl": "/problem-37-Reverse-Bits/"
  },"415": {
    "doc": "Number of Arithmetic Triplets",
    "title": "Number of Arithmetic Triplets",
    "content": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met: . | i &lt; j &lt; k, | nums[j] - nums[i] == diff, and | nums[k] - nums[j] == diff. Return the number of unique arithmetic triplets. | . Example 1: . Input: nums = [0,1,4,6,7,10], diff = 3 Output: 2 Explanation: (1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3. (2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3. Example 2: . Input: nums = [4,5,6,7,8,9], diff = 2 Output: 2 Explanation: (0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2. (1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2. Constraints: . | 3 &lt;= nums.length &lt;= 200 | 0 &lt;= nums[i] &lt;= 200 | 1 &lt;= diff &lt;= 50 | nums is strictly increasing. | . Solution: . Complexity O(n^3) . class Solution { public int arithmeticTriplets(int[] nums, int diff) { int count = 0; for(int i = 0; i &lt; nums.length - 2; i++){ for(int j = i + 1; j &lt; nums.length - 1; j++){ for(int k = j + 1; k &lt; nums.length; k++){ if(nums[j] - nums[i] == diff &amp;&amp; nums[k] - nums[j] == diff) count++; } } } return count; } } . Complexity O(nLogN) . class Solution { public int arithmeticTriplets(int[] nums, int diff) { int count = 0; for(int i = 0; i &lt; nums.length - 2; i++){ int findNum = nums[i] + diff; int index = Arrays.binarySearch(nums,i + 1, nums.length, findNum); if(index &gt; 0 &amp;&amp; Arrays.binarySearch(nums,i + 1, nums.length, findNum + diff) &gt; 0) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-370-Number%20of%20Arithmetic%20Triplets/",
    "relUrl": "/problem-370-Number of Arithmetic Triplets/"
  },"416": {
    "doc": "Find Subarrays With Equal Sum",
    "title": "Find Subarrays With Equal Sum",
    "content": "Given a 0-indexed integer array nums, determine whether there exist two subarrays of length 2 with equal sum. Note that the two subarrays must begin at different indices. Return true if these subarrays exist, and false otherwise. A subarray is a contiguous non-empty sequence of elements within an array. Example 1: . Input: nums = [4,2,4] Output: true Explanation: The subarrays with elements [4,2] and [2,4] have the same sum of 6. Example 2: . Input: nums = [1,2,3,4,5] Output: false Explanation: No two subarrays of size 2 have the same sum. Example 3: . Input: nums = [0,0,0] Output: true Explanation: The subarrays [nums[0],nums[1]] and [nums[1],nums[2]] have the same sum of 0. Note that even though the subarrays have the same content, the two subarrays are considered different because they are in different positions in the original array. Constraints: . | 2 &lt;= nums.length &lt;= 1000 | -109 &lt;= nums[i] &lt;= 10^9 | . Solution: . class Solution { public boolean findSubarrays(int[] nums) { Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int i = 0; i &lt; nums.length - 1; i++){ if(!set.add(nums[i] + nums[i + 1])) return true; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-371-Find%20Subarrays%20With%20Equal%20Sum/",
    "relUrl": "/problem-371-Find Subarrays With Equal Sum/"
  },"417": {
    "doc": "Check Distances Between Same Letters",
    "title": "Check Distances Between Same Letters",
    "content": "You are given a 0-indexed string s consisting of only lowercase English letters, where each letter in s appears exactly twice. You are also given a 0-indexed integer array distance of length 26. Each letter in the alphabet is numbered from 0 to 25 (i.e. ‘a’ -&gt; 0, ‘b’ -&gt; 1, ‘c’ -&gt; 2, … , ‘z’ -&gt; 25). In a well-spaced string, the number of letters between the two occurrences of the ith letter is distance[i]. If the ith letter does not appear in s, then distance[i] can be ignored. Return true if s is a well-spaced string, otherwise return false. Example 1: . Input: s = \"abaccb\", distance = [1,3,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: true Explanation: - 'a' appears at indices 0 and 2 so it satisfies distance[0] = 1. - 'b' appears at indices 1 and 5 so it satisfies distance[1] = 3. - 'c' appears at indices 3 and 4 so it satisfies distance[2] = 0. Note that distance[3] = 5, but since 'd' does not appear in s, it can be ignored. Return true because s is a well-spaced string. Example 2: . Input: s = \"aa\", distance = [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] Output: false Explanation: - 'a' appears at indices 0 and 1 so there are zero letters between them. Because distance[0] = 1, s is not a well-spaced string. Constraints: . | 2 &lt;= s.length &lt;= 52 | s consists only of lowercase English letters. | Each letter appears in s exactly twice. | distance.length == 26 | 0 &lt;= distance[i] &lt;= 50 | . Solution: . class Solution { public boolean checkDistances(String s, int[] distance) { int[] dp = new int[26]; for(int i = 0; i &lt; s.length(); i++){ int d = s.charAt(i) - 'a'; if(dp[d] == 0){ dp[d] = i + 1; }else{ dp[d] = i - dp[d] + 1; } } for(int i = 0; i &lt; 26; i++){ if(dp[i] != 0 &amp;&amp; distance[i] + 1 != dp[i]) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-372-Check%20Distances%20Between%20Same%20Letters/",
    "relUrl": "/problem-372-Check Distances Between Same Letters/"
  },"418": {
    "doc": "Most Frequent Even Element",
    "title": "Most Frequent Even Element",
    "content": "Given an integer array nums, return the most frequent even element. If there is a tie, return the smallest one. If there is no such element, return -1. Example 1: . Input: nums = [0,1,2,2,4,4,1] Output: 2 Explanation: The even elements are 0, 2, and 4. Of these, 2 and 4 appear the most. We return the smallest one, which is 2. Example 2: . Input: nums = [4,4,4,9,2,4] Output: 4 Explanation: 4 is the even element appears the most. Example 3: . Input: nums = [29,47,21,41,13,37,25,7] Output: -1 Explanation: There is no even element. Constraints: . | 1 &lt;= nums.length &lt;= 2000 | 0 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public int mostFrequentEven(int[] nums) { int max = 0; Arrays.sort(nums); int prev = -1; int count = 0; int element = -1; for(int n : nums){ if(n != prev) count = 0; if(n % 2 == 0) count++; if(count &gt; max){ element = n; max = count; } prev = n; } return element; } } . ",
    "url": "https://1001anjan.github.io/problem-373-Most%20Frequent%20Even%20Element/",
    "relUrl": "/problem-373-Most Frequent Even Element/"
  },"419": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle",
    "content": "Given an integer numRows, return the first numRows of Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] . Example 2: . Input: numRows = 1 Output: [[1]] . Constraints: . | 1 &lt;= numRows &lt;= 30 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); List&lt;Integer&gt; prev = null, curr = null; for(int i = 0; i &lt; numRows; i++){ curr = new ArrayList&lt;&gt;(); for(int j = 0; j &lt;= i; j++){ if(j == 0 || j == i){ curr.add(1); }else{ curr.add(prev.get(j - 1) + prev.get(j)); } } prev = curr; ans.add(curr); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-374-Pascal's%20Triangle/#pascals-triangle",
    "relUrl": "/problem-374-Pascal's Triangle/#pascals-triangle"
  },"420": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-374-Pascal's%20Triangle/",
    "relUrl": "/problem-374-Pascal's Triangle/"
  },"421": {
    "doc": "Pascal's Triangle",
    "title": "Pascal’s Triangle II",
    "content": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal’s triangle. In Pascal’s triangle, each number is the sum of the two numbers directly above it as shown: . Example 1: . Input: rowIndex = 3 Output: [1,3,3,1] . Example 2: . Input: rowIndex = 0 Output: [1] . Example 3: . Input: rowIndex = 1 Output: [1,1] . Constraints: . | 0 &lt;= rowIndex &lt;= 33 | . Solution: . class Solution { // Time Complexity = O(N*N) (approximation) // Space Complexity = O(N) public List&lt;Integer&gt; getRow(int rowIndex) { List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;(); for (int row = 0; row &lt;= rowIndex; row++) { result.add(0, 1); for (int i = 1; i &lt; row; i++) result.set(i, result.get(i) + result.get(i + 1)); } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-375-Pascal's%20Triangle%20II/#pascals-triangle-ii",
    "relUrl": "/problem-375-Pascal's Triangle II/#pascals-triangle-ii"
  },"422": {
    "doc": "Pascal's Triangle",
    "title": "Pascal's Triangle",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-375-Pascal's%20Triangle%20II/",
    "relUrl": "/problem-375-Pascal's Triangle II/"
  },"423": {
    "doc": "Implement Stack using Queues",
    "title": "Implement Stack using Queues",
    "content": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: . | void push(int x) Pushes element x to the top of the stack. | int pop() Removes the element on the top of the stack and returns it. | int top() Returns the element on the top of the stack. | boolean empty() Returns true if the stack is empty, false otherwise. Notes: | . You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. Example 1: . Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] Explanation MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, top, and empty. | All the calls to pop and top are valid. | . Follow-up: Can you implement the stack using only one queue? . Solution: . class MyStack { Queue&lt;Integer&gt; queue; public MyStack() { queue = new LinkedList&lt;&gt;(); } public void push(int x) { int size = queue.size(); queue.add(x); while(size &gt; 0){ queue.add(queue.remove()); size--; } } public int pop() { return queue.remove(); } public int top() { return queue.peek(); } public boolean empty() { return queue.isEmpty(); } } /** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */ . ",
    "url": "https://1001anjan.github.io/problem-376-Implement%20Stack%20using%20Queues/",
    "relUrl": "/problem-376-Implement Stack using Queues/"
  },"424": {
    "doc": "Isomorphic Strings",
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: . Input: s = \"egg\", t = \"add\" Output: true . Example 2: . Input: s = \"foo\", t = \"bar\" Output: false . Example 3: . Input: s = \"paper\", t = \"title\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | t.length == s.length | s and t consist of any valid ascii character. | . Solution: . class Solution { public boolean isIsomorphic(String s, String t) { Map&lt;Character,Character&gt; mp1 = new HashMap&lt;&gt;(); Map&lt;Character,Character&gt; mp2 = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++){ char ch1 = s.charAt(i); char ch2 = t.charAt(i); boolean s1 = mp1.containsKey(ch1); boolean s2 = mp2.containsKey(ch2); if(s1 != s2) return false; if(!s1){ mp1.put(ch1,ch2); mp2.put(ch2,ch1); }else{ if(mp1.get(ch1) != ch2 || mp2.get(ch2) != ch1) return false; } } return true; } } . Improvement . class Solution { public boolean isIsomorphic(String s, String t) { int[] mappingDictStoT = new int[256]; Arrays.fill(mappingDictStoT, -1); int[] mappingDictTtoS = new int[256]; Arrays.fill(mappingDictTtoS, -1); for (int i = 0; i &lt; s.length(); ++i) { char c1 = s.charAt(i); char c2 = t.charAt(i); // Case 1: No mapping exists in either of the dictionaries if (mappingDictStoT[c1] == -1 &amp;&amp; mappingDictTtoS[c2] == -1) { mappingDictStoT[c1] = c2; mappingDictTtoS[c2] = c1; } // Case 2: Ether mapping doesn't exist in one of the dictionaries or Mapping exists and // it doesn't match in either of the dictionaries or both else if (!(mappingDictStoT[c1] == c2 &amp;&amp; mappingDictTtoS[c2] == c1)) { return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-377-Isomorphic%20Strings/",
    "relUrl": "/problem-377-Isomorphic Strings/"
  },"425": {
    "doc": "Implement Queue using Stacks",
    "title": "Implement Queue using Stacks",
    "content": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: . | void push(int x) Pushes element x to the back of the queue. | int pop() Removes the element from the front of the queue and returns it. | int peek() Returns the element at the front of the queue. | boolean empty() Returns true if the queue is empty, false otherwise. Notes: | . You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. Example 1: . Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, peek, and empty. | All the calls to pop and peek are valid. | . Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Solution: . ",
    "url": "https://1001anjan.github.io/problem-378-Implement%20Queue%20using%20Stacks/",
    "relUrl": "/problem-378-Implement Queue using Stacks/"
  },"426": {
    "doc": "First Bad Version",
    "title": "First Bad Version",
    "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Example 1: . Input: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -&gt; false call isBadVersion(5) -&gt; true call isBadVersion(4) -&gt; true Then 4 is the first bad version. Example 2: . Input: n = 1, bad = 1 Output: 1 . Constraints: . | 1 &lt;= bad &lt;= n &lt;= 231 - 1 | . Solution: . /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int l = 1; while(l &lt;= n){ int m = l + (n - l)/2;; if(isBadVersion(m)){ n = m - 1; }else{ l = m + 1; } } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-379-First%20Bad%20Version/",
    "relUrl": "/problem-379-First Bad Version/"
  },"427": {
    "doc": "Number of 1 Bits",
    "title": "Number of 1 Bits",
    "content": "Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). Note: . | Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer’s internal binary representation is the same, whether it is signed or unsigned. | In Java, the compiler represents the signed integers using 2’s complement notation. Therefore, in Example 3, the input represents the signed integer. -3. | . Example 1: . Input: n = 00000000000000000000000000001011 Output: 3 Explanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits. Example 2: . Input: n = 00000000000000000000000010000000 Output: 1 Explanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit. Example 3: . Input: n = 11111111111111111111111111111101 Output: 31 Explanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits. Constraints: . | The input must be a binary string of length 32. | . Solution . public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { String str = Integer.toBinaryString(n); int c = 0; for(int i=0; i&lt;str.length(); i++){ if(str.charAt(i) == '1') c++; } return c; } } . Other . public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int sum = 0; while(n != 0) { sum++; n &amp;= (n-1); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-38-Number-of-1-Bits/",
    "relUrl": "/problem-38-Number-of-1-Bits/"
  },"428": {
    "doc": "Simplify Path",
    "title": "Simplify Path",
    "content": "Given a string path, which is an absolute path (starting with a slash ‘/’) to a file or directory in a Unix-style file system, convert it to the simplified canonical path. In a Unix-style file system, a period ‘.’ refers to the current directory, a double period ‘..’ refers to the directory up a level, and any multiple consecutive slashes (i.e. ‘//’) are treated as a single slash ‘/’. For this problem, any other format of periods such as ‘…’ are treated as file/directory names. The canonical path should have the following format: . | The path starts with a single slash ‘/’. | Any two directories are separated by a single slash ‘/’. | The path does not end with a trailing ‘/’. | The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period ‘.’ or double period ‘..’) Return the simplified canonical path. | . Example 1: . Input: path = \"/home/\" Output: \"/home\" Explanation: Note that there is no trailing slash after the last directory name. Example 2: . Input: path = \"/../\" Output: \"/\" Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3: . Input: path = \"/home//foo/\" Output: \"/home/foo\" Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. Constraints: . | 1 &lt;= path.length &lt;= 3000 | path consists of English letters, digits, period ‘.’, slash ‘/’ or ‘_’. | path is a valid absolute Unix path. | . Solution: . class Solution { public String simplifyPath(String path) { LinkedList&lt;String&gt; list = new LinkedList&lt;&gt;(); for(String s : path.split(\"/\")){ if(s.equals(\".\") || s.equals(\"\")) continue; else if(s.equals(\"..\")){ if(list.size() &gt; 0) list.removeLast(); }else{ list.add(\"/\"+s); } } if(list.size() == 0) return \"/\"; StringBuilder sb = new StringBuilder(); for(String s : list) sb.append(s); return sb.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-38-Simplify%20Path/",
    "relUrl": "/problem-38-Simplify Path/"
  },"429": {
    "doc": "Word Pattern",
    "title": "Word Pattern",
    "content": "Given a pattern and a string s, find if s follows the same pattern. Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s. Example 1: . Input: pattern = \"abba\", s = \"dog cat cat dog\" Output: true . Example 2: . Input: pattern = \"abba\", s = \"dog cat cat fish\" Output: false . Example 3: . Input: pattern = \"aaaa\", s = \"dog cat cat dog\" Output: false . Constraints: . | 1 &lt;= pattern.length &lt;= 300 | pattern contains only lower-case English letters. | 1 &lt;= s.length &lt;= 3000 | s contains only lowercase English letters and spaces ‘ ‘. | s does not contain any leading or trailing spaces. | All the words in s are separated by a single space. | . Solution: . class Solution { public boolean wordPattern(String pattern, String s) { String[] str = s.split(\" \"); if(pattern.length()!=str.length) return false; HashMap&lt;Character, String&gt; hm = new HashMap&lt;&gt;(); for(int i=0; i&lt;pattern.length(); i++){ char c = pattern.charAt(i); if(hm.containsKey(c)){ if(!hm.get(c).equals(str[i]))return false; } else{ if(hm.containsValue(str[i])) return false; hm.put(c, str[i]); } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-380-Word%20Pattern/",
    "relUrl": "/problem-380-Word Pattern/"
  },"430": {
    "doc": "Implement Queue using Stacks",
    "title": "Implement Queue using Stacks",
    "content": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty). Implement the MyQueue class: . | void push(int x) Pushes element x to the back of the queue. | int pop() Removes the element from the front of the queue and returns it. | int peek() Returns the element at the front of the queue. | boolean empty() Returns true if the queue is empty, false otherwise. Notes: . | You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. | Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack’s standard operations. | . Example 1: . Input [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, peek, and empty. | All the calls to pop and peek are valid. | . Follow-up: Can you implement the queue such that each operation is amortized O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer. Solution: . class MyQueue { Stack&lt;Integer&gt; s1; Stack&lt;Integer&gt; s2; public MyQueue() { s1 = new Stack&lt;&gt;(); s2 = new Stack&lt;&gt;(); } public void push(int x) { s1.push(x); } public int pop() { s2.clear(); while(s1.size() &gt; 1){ s2.push(s1.pop()); } int v = s1.pop(); while(!s2.isEmpty()) s1.push(s2.pop()); return v; } public int peek() { s2.clear(); while(s1.size() &gt; 0){ s2.push(s1.pop()); } int v = s2.peek(); while(!s2.isEmpty()) s1.push(s2.pop()); return v; } public boolean empty() { return s1.isEmpty(); } } /** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */ . ",
    "url": "https://1001anjan.github.io/problem-381-Implement%20Queue%20using%20Stacks/",
    "relUrl": "/problem-381-Implement Queue using Stacks/"
  },"431": {
    "doc": "Longest Uncommon Subsequence I",
    "title": "Longest Uncommon Subsequence I",
    "content": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1. An uncommon subsequence between two strings is a string that is a subsequence of one but not the other. A subsequence of a string s is a string that can be obtained after deleting any number of characters from s. | For example, “abc” is a subsequence of “aebdc” because you can delete the underlined characters in “aebdc” to get “abc”. Other subsequences of “aebdc” include “aebdc”, “aeb”, and “” (empty string). | . Example 1: . Input: a = \"aba\", b = \"cdc\" Output: 3 Explanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\". Note that \"cdc\" is also a longest uncommon subsequence. Example 2: . Input: a = \"aaa\", b = \"bbb\" Output: 3 Explanation: The longest uncommon subsequences are \"aaa\" and \"bbb\". Example 3: . Input: a = \"aaa\", b = \"aaa\" Output: -1 Explanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a. Constraints: . | 1 &lt;= a.length, b.length &lt;= 100 | a and b consist of lower-case English letters. | . Solution: . class Solution { public int findLUSlength(String a, String b) { if(a.equals(b)) return -1; return Math.max(a.length(),b.length()); } } . ",
    "url": "https://1001anjan.github.io/problem-382-Longest%20Uncommon%20Subsequence%20I/",
    "relUrl": "/problem-382-Longest Uncommon Subsequence I/"
  },"432": {
    "doc": "Minimum Absolute Difference in BST",
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 104]. | 0 &lt;= Node.val &lt;= 10^5 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int getMinimumDifference(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); inoderTraverse(root,list); int prev = list.get(1); int diff = prev - list.get(0); for(int i = 2; i &lt; list.size(); i++){ int curr = list.get(i); diff = Math.min(diff,curr - prev); prev = curr; } return diff; } public void inoderTraverse(TreeNode tree, List&lt;Integer&gt; list){ if(tree == null) return; inoderTraverse(tree.left,list); list.add(tree.val); inoderTraverse(tree.right,list); } } . Faster solution . class Solution { /* As the tree is BST, we will do the inorder so that we will get a asceding order. We will just calculate the difference with adjaced nodes in the inorder. PS: Just consider the inorder of the tree as soreted array in ascending order and you have to find the min diff of two elements. */ int minDiff=Integer.MAX_VALUE,prev=-1; public int getMinimumDifference(TreeNode root) { inorder(root); return minDiff; } public void inorder(TreeNode root){ if(root != null){ inorder(root.left); if(prev != -1) minDiff = Math.min(Math.abs(root.val-prev),minDiff); prev=root.val; inorder(root.right); } } } . ",
    "url": "https://1001anjan.github.io/problem-383-Minimum%20Absolute%20Difference%20in%20BST/",
    "relUrl": "/problem-383-Minimum Absolute Difference in BST/"
  },"433": {
    "doc": "Range Addition IIRange Addition II",
    "title": "Range Addition II",
    "content": "You are given an m x n matrix M initialized with all 0’s and an array of operations ops, where ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 &lt;= x &lt; ai and 0 &lt;= y &lt; bi. Count and return the number of maximum integers in the matrix after performing all the operations. Example 1: . Input: m = 3, n = 3, ops = [[2,2],[3,3]] Output: 4 Explanation: The maximum integer in M is 2, and there are four of it in M. So return 4. Example 2: . Input: m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]] Output: 4 . Example 3: . Input: m = 3, n = 3, ops = [] Output: 9 . Constraints: . | 1 &lt;= m, n &lt;= 4 * 104 | 0 &lt;= ops.length &lt;= 104 | ops[i].length == 2 | 1 &lt;= ai &lt;= m | 1 &lt;= bi &lt;= n | . Solution: . Memory limits exceeds . class Solution { // Goal should be to find that maxima grid which is common (overlapping) across ops[i] range. // e.g: M[0][0] would always hold maxValue but it would not give us number of maximas // so if we keep on reducing row and columns by scanning ops set, we would end up with that maxima grid (r*c) :) // Runtime: 0 ms, faster than 100.00% of Java online submissions for Range Addition II. // Memory Usage: 42 MB, less than 99.81% of Java online submissions for Range Addition II. public int maxCount(int m, int n, int[][] ops) { int rowMinima = m; // number of row cells holding max value int colMinima = n; // number of column cells holding max value for(int i = 0; i &lt; ops.length; i++){ rowMinima = Math.min(rowMinima, ops[i][0]); colMinima = Math.min(colMinima, ops[i][1]); } return rowMinima * colMinima; } } . Improvement . ",
    "url": "https://1001anjan.github.io/problem-384-Range%20Addition%20II/#range-addition-ii",
    "relUrl": "/problem-384-Range Addition II/#range-addition-ii"
  },"434": {
    "doc": "Range Addition IIRange Addition II",
    "title": "Range Addition IIRange Addition II",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-384-Range%20Addition%20II/",
    "relUrl": "/problem-384-Range Addition II/"
  },"435": {
    "doc": "Set Mismatch",
    "title": "Set Mismatch",
    "content": "You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number. You are given an integer array nums representing the data status of this set after the error. Find the number that occurs twice and the number that is missing and return them in the form of an array. Example 1: . Input: nums = [1,2,2,4] Output: [2,3] . Example 2: . Input: nums = [1,1] Output: [1,2] . Constraints: . | 2 &lt;= nums.length &lt;= 10^4 | 1 &lt;= nums[i] &lt;= 10^4 | . Solution: Time Complexity: O(nlogN) . class Solution { public int[] findErrorNums(int[] nums) { Arrays.sort(nums); int dup = 0, miss = 1; for(int i = 1; i &lt; nums.length; i++){ if(nums[i] == nums[i - 1]) dup = nums[i]; else if(nums[i] &gt; nums[i - 1] + 1) miss = nums[i - 1] + 1; } miss = nums[nums.length - 1] != nums.length? nums.length : miss; return new int[]{dup,miss}; } } . Solution: Time Complexity O(n) Space Complexity: O(n) . class Solution { public int[] findErrorNums(int[] nums) { int dup = 0, miss = 0; int[] temp = new int[nums.length]; for(int n : nums) temp[n - 1]++; for(int i = 0; i &lt; temp.length; i++){ if(temp[i] == 0) miss = i + 1; else if(temp[i] == 2) dup = i + 1; } return new int[]{dup,miss}; } } . ",
    "url": "https://1001anjan.github.io/problem-385-Set%20Mismatch/",
    "relUrl": "/problem-385-Set Mismatch/"
  },"436": {
    "doc": "Count Binary Substrings",
    "title": "Count Binary Substrings",
    "content": "Given a binary string s, return the number of non-empty substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1: . Input: s = \"00110011\" Output: 6 Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: \"0011\", \"01\", \"1100\", \"10\", \"0011\", and \"01\". Notice that some of these substrings repeat and are counted the number of times they occur. Also, \"00110011\" is not a valid substring because all the 0's (and 1's) are not grouped together. Example 2: . Input: s = \"10101\" Output: 4 Explanation: There are 4 substrings: \"10\", \"01\", \"10\", \"01\" that have equal number of consecutive 1's and 0's. Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘0’ or ‘1’. | . Solution: . class Solution { public int countBinarySubstrings(String s) { int count = 0, curr = 1, prev = 0; char[] str = s.toCharArray(); for(int i = 1; i &lt; str.length; i++){ if(str[i - 1] != str[i]){ count += Math.min(curr,prev); prev = curr; curr = 1; }else{ curr++; } } count += Math.min(curr,prev); return count; } } . ",
    "url": "https://1001anjan.github.io/problem-386-Count%20Binary%20Substrings/",
    "relUrl": "/problem-386-Count Binary Substrings/"
  },"437": {
    "doc": "Degree of an Array",
    "title": "Degree of an Array",
    "content": "Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: . Input: nums = [1,2,2,3,1] Output: 2 Explanation: The input array has a degree of 2 because both elements 1 and 2 appear twice. Of the subarrays that have the same degree: [1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2] The shortest length is 2. So return 2. Example 2: . Input: nums = [1,2,2,3,1,4,2] Output: 6 Explanation: The degree is 3 because the element 2 is repeated 3 times. So [2,2,3,1,4,2] is the shortest subarray, therefore returning 6. Constraints: . | nums.length will be between 1 and 50,000. | nums[i] will be an integer between 0 and 49,999. | . Solution: . class Solution { public int findShortestSubArray(int[] nums) { Map&lt;Integer, Integer&gt; leftIndex = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; rightIndex = new HashMap&lt;&gt;(); Map&lt;Integer, Integer&gt; count = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++){ if(leftIndex.get(nums[i]) == null) leftIndex.put(nums[i],i); rightIndex.put(nums[i],i); count.put(nums[i],count.getOrDefault(nums[i],0) + 1); } int ans = nums.length; int degree = Collections.max(count.values()); for (int x: count.keySet()) { if (count.get(x) == degree) { ans = Math.min(ans, rightIndex.get(x) - leftIndex.get(x) + 1); } } return ans; } } . class Solution { public int findShortestSubArray(int[] nums) { if (nums.length == 0 || nums == null) return 0; Map&lt;Integer, int[]&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++){ if (!map.containsKey(nums[i])){ map.put(nums[i], new int[]{1, i, i}); // the first element in array is degree, second is first index of this key, third is last index of this key } else { int[] temp = map.get(nums[i]); temp[0]++; temp[2] = i; } } int degree = Integer.MIN_VALUE, res = Integer.MAX_VALUE; for (int[] value : map.values()){ if (value[0] &gt; degree){ degree = value[0]; res = value[2] - value[1] + 1; } else if (value[0] == degree){ res = Math.min( value[2] - value[1] + 1, res); } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-387-Degree%20of%20an%20Array/",
    "relUrl": "/problem-387-Degree of an Array/"
  },"438": {
    "doc": "Kth Largest Element in a Stream",
    "title": "Kth Largest Element in a Stream",
    "content": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element. Implement KthLargest class: . KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums. int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream. Example 1: . Input [\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"] [[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]] Output [null, 4, 5, 5, 8, 8] Explanation KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]); kthLargest.add(3); // return 4 kthLargest.add(5); // return 5 kthLargest.add(10); // return 5 kthLargest.add(9); // return 8 kthLargest.add(4); // return 8 . Constraints: . | 1 &lt;= k &lt;= 104 | 0 &lt;= nums.length &lt;= 104 | -104 &lt;= nums[i] &lt;= 104 | -104 &lt;= val &lt;= 104 | At most 104 calls will be made to add. | It is guaranteed that there will be at least k elements in the array when you search for the kth element. | . Solution: . class KthLargest { private int k; private PriorityQueue&lt;Integer&gt; heap; public KthLargest(int k, int[] nums) { this.k = k; heap = new PriorityQueue&lt;&gt;(); for(int n : nums) heap.offer(n); while(heap.size() &gt; k) heap.poll(); } public int add(int val) { heap.offer(val); if (heap.size() &gt; k) { heap.poll(); } return heap.peek(); } } /** * Your KthLargest object will be instantiated and called as such: * KthLargest obj = new KthLargest(k, nums); * int param_1 = obj.add(val); */ . ",
    "url": "https://1001anjan.github.io/problem-388-Kth%20Largest%20Element%20in%20a%20Stream/",
    "relUrl": "/problem-388-Kth Largest Element in a Stream/"
  },"439": {
    "doc": "Flood Fill",
    "title": "Flood Fill",
    "content": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image. You are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc]. To perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color. Return the modified image after performing the flood fill. Example 1: . Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2: . Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 Output: [[0,0,0],[0,0,0]] Explanation: The starting pixel is already colored 0, so no changes are made to the image. Constraints: . | m == image.length | n == image[i].length | 1 &lt;= m, n &lt;= 50 | 0 &lt;= image[i][j], color &lt; 216 | 0 &lt;= sr &lt; m | 0 &lt;= sc &lt; n | . Solution: . class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if(image[sr][sc] != color){ dfsFill(image,sr,sc,image[sr][sc],color); } return image; } public void dfsFill(int[][] image, int sr, int sc,int baseColor, int color){ if(image[sr][sc] == baseColor){ image[sr][sc] = color; if(sc + 1 &lt; image[sr].length) dfsFill(image,sr,sc + 1,baseColor,color); if(sc - 1 &gt;= 0) dfsFill(image,sr,sc - 1,baseColor,color); if(sr - 1 &gt;= 0) dfsFill(image,sr - 1,sc,baseColor,color); if(sr + 1 &lt; image.length) dfsFill(image,sr + 1,sc,baseColor,color); } } } . ",
    "url": "https://1001anjan.github.io/problem-389-Flood%20Fill/",
    "relUrl": "/problem-389-Flood Fill/"
  },"440": {
    "doc": "Happy Number",
    "title": "Happy Number",
    "content": "Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process: . | Starting with any positive integer, replace the number by the sum of the squares of its digits. | Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. | Those numbers for which this process ends in 1 are happy. | Return true if n is a happy number, and false if not. | . Example 1: . Input: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 . Example 2: . Input: n = 2 Output: false . Constraints: . | 1 &lt;= n &lt;= 231 - 1 Solution . class Solution { public boolean isHappy(int n) { while(n != 1 &amp;&amp; n != 4){ n = getNext(n); } return n==1; } public int getNext(int n){ int sum = 0; int d; while(n&gt;0){ d = n%10; sum += d*d; n = n/10; } return sum; } } . Approach : Detect Cycles with a HashSet . More details: https://leetcode.com/problems/happy-number/solution/ . class Solution { public boolean isHappy(int n) { Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int sum = 0; int d; while(n != 1){ n = getDigitsSum(n); if(set.contains(n)) return false; set.add(n); } return true; } public int getDigitsSum(int n){ int sum = 0; int d; while(n&gt;0){ d = n%10; sum += d*d; n = n/10; } return sum; } } . | . ",
    "url": "https://1001anjan.github.io/problem-39-Number-of-1-Bits/",
    "relUrl": "/problem-39-Number-of-1-Bits/"
  },"441": {
    "doc": "Set Matrix Zeroes",
    "title": "Set Matrix Zeroes",
    "content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0’s. You must do it in place. Example 1: . Input: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] . Example 2: . Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] . Constraints: . | m == matrix.length | n == matrix[0].length | 1 &lt;= m, n &lt;= 200 | -2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1 | . Solution: . class Solution { public void setZeroes(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; List&lt;int[]&gt; list = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; m; i++){ for(int j = 0; j &lt; n; j++){ if(matrix[i][j] == 0){ list.add(new int[]{i,j}); } } } for(int[] l : list){ for(int i = 0; i &lt; m; i++) matrix[i][l[1]] = 0; for(int i = 0; i &lt; n; i++) matrix[l[0]][i] = 0; } } } . ",
    "url": "https://1001anjan.github.io/problem-39-Set%20Matrix%20Zeroes/",
    "relUrl": "/problem-39-Set Matrix Zeroes/"
  },"442": {
    "doc": "Min Cost Climbing Stairs",
    "title": "Min Cost Climbing Stairs",
    "content": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps. You can either start from the step with index 0, or the step with index 1. Return the minimum cost to reach the top of the floor. Example 1: . Input: cost = [10,15,20] Output: 15 Explanation: You will start at index 1. - Pay 15 and climb two steps to reach the top. The total cost is 15. Example 2: . Input: cost = [1,100,1,1,1,100,1,1,100,1] Output: 6 Explanation: You will start at index 0. - Pay 1 and climb two steps to reach index 2. - Pay 1 and climb two steps to reach index 4. - Pay 1 and climb two steps to reach index 6. - Pay 1 and climb one step to reach index 7. - Pay 1 and climb two steps to reach index 9. - Pay 1 and climb one step to reach the top. The total cost is 6. Constraints: . | 2 &lt;= cost.length &lt;= 1000 | 0 &lt;= cost[i] &lt;= 999 | . Solution: . class Solution { public int minCostClimbingStairs(int[] cost) { int[] dp = new int[cost.length + 2]; for(int i = cost.length - 1; i &gt;= 0; i--){ dp[i] = cost[i] + Math.min(dp[i + 1], dp[i + 2]); } return Math.min(dp[0],dp[1]); } } . ",
    "url": "https://1001anjan.github.io/problem-390-Min%20Cost%20Climbing%20Stairs/",
    "relUrl": "/problem-390-Min Cost Climbing Stairs/"
  },"443": {
    "doc": "Shortest Completing Word",
    "title": "Shortest Completing Word",
    "content": "Given a string licensePlate and an array of strings words, find the shortest completing word in words. A completing word is a word that contains all the letters in licensePlate. Ignore numbers and spaces in licensePlate, and treat letters as case insensitive. If a letter appears more than once in licensePlate, then it must appear in the word the same number of times or more. For example, if licensePlate = “aBc 12c”, then it contains letters ‘a’, ‘b’ (ignoring case), and ‘c’ twice. Possible completing words are “abccdef”, “caaacab”, and “cbca”. Return the shortest completing word in words. It is guaranteed an answer exists. If there are multiple shortest completing words, return the first one that occurs in words. Example 1: . Input: licensePlate = \"1s3 PSt\", words = [\"step\",\"steps\",\"stripe\",\"stepple\"] Output: \"steps\" Explanation: licensePlate contains letters 's', 'p', 's' (ignoring case), and 't'. \"step\" contains 't' and 'p', but only contains 1 's'. \"steps\" contains 't', 'p', and both 's' characters. \"stripe\" is missing an 's'. \"stepple\" is missing an 's'. Since \"steps\" is the only word containing all the letters, that is the answer. Example 2: . Input: licensePlate = \"1s3 456\", words = [\"looks\",\"pest\",\"stew\",\"show\"] Output: \"pest\" Explanation: licensePlate only contains the letter 's'. All the words contain 's', but among these \"pest\", \"stew\", and \"show\" are shortest. The answer is \"pest\" because it is the word that appears earliest of the 3. Constraints: . | 1 &lt;= licensePlate.length &lt;= 7 | licensePlate contains digits, letters (uppercase or lowercase), or space ‘ ‘. | 1 &lt;= words.length &lt;= 1000 | 1 &lt;= words[i].length &lt;= 15 | words[i] consists of lower case English letters. | . Solution: . class Solution { public String shortestCompletingWord(String licensePlate, String[] words) { String str = licensePlate.toLowerCase(); int[] cm = new int[26]; for(char ch : str.toCharArray()) { if(Character.isLetter(ch)) cm[ch - 'a']++; } String ans = null; for(String s : words){ int[] cm1 = new int[26]; for(char ch : s.toCharArray()) cm1[ch - 'a']++; int i = 0; for(; i &lt; 26; i++){ if(cm[i] &gt; cm1[i]) break; } if(i == 26){ if(ans != null){ if(ans.length() &gt; s.length()) ans = s; }else{ ans = s; } } } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-391-Shortest%20Completing%20Word/",
    "relUrl": "/problem-391-Shortest Completing Word/"
  },"444": {
    "doc": "Toeplitz Matrix",
    "title": "Toeplitz Matrix",
    "content": "Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false. A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements. Example 1: . Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]] Output: true Explanation: In the above grid, the diagonals are: \"[9]\", \"[5, 5]\", \"[1, 1, 1]\", \"[2, 2, 2]\", \"[3, 3]\", \"[4]\". In each diagonal all elements are the same, so the answer is True. Example 2: . Input: matrix = [[1,2],[2,2]] Output: false Explanation: The diagonal \"[1, 2]\" has different elements. Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 20 | 0 &lt;= matrix[i][j] &lt;= 99 | . Follow up: . | What if the matrix is stored on disk, and the memory is limited such that you can only load at most one row of the matrix into the memory at once? | What if the matrix is so large that you can only load up a partial row into the memory at once? | . Solution: . class Solution { public boolean isToeplitzMatrix(int[][] matrix) { for(int i = 0; i &lt; matrix.length - 1; i++){ for(int j = 0; j &lt; matrix[i].length - 1; j++){ if(matrix[i][j] != matrix[i + 1][j + 1]) return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-392-Toeplitz%20Matrix/",
    "relUrl": "/problem-392-Toeplitz Matrix/"
  },"445": {
    "doc": "Jewels and Stones",
    "title": "Jewels and Stones",
    "content": "You’re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example 1: . Input: jewels = \"aA\", stones = \"aAAbbbb\" Output: 3 . Example 2: . Input: jewels = \"z\", stones = \"ZZ\" Output: 0 . Constraints: . | 1 &lt;= jewels.length, stones.length &lt;= 50 | jewels and stones consist of only English letters. | All the characters of jewels are unique. | . Solution: . class Solution { public int numJewelsInStones(String jewels, String stones) { int count = 0; boolean[] um = new boolean[26]; boolean[] lm = new boolean[26]; for(char ch : jewels.toCharArray()){ if(Character.isUpperCase(ch)){ um[ch - 'A'] = true; }else{ lm[ch - 'a'] = true; } } for(char ch : stones.toCharArray()){ if(Character.isUpperCase(ch)){ if(um[ch - 'A']) count++; }else{ if(lm[ch - 'a']) count++; } } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-393-Jewels%20and%20Stones/",
    "relUrl": "/problem-393-Jewels and Stones/"
  },"446": {
    "doc": "Minimum Distance Between BST Nodes",
    "title": "Minimum Distance Between BST Nodes",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 100]. | 0 &lt;= Node.val &lt;= 10^5 | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public int minDiffInBST(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list = inorderTravaerse(root, list); int prev = list.get(1); int diff = prev - list.get(0); for(int i = 2; i &lt; list.size(); i++){ int curr = list.get(i); diff = Math.min(diff, curr - prev); prev = curr; } return diff; } public List&lt;Integer&gt; inorderTravaerse(TreeNode root, List&lt;Integer&gt; list){ if(root == null) return list; list = inorderTravaerse(root.left, list); list.add(root.val); list = inorderTravaerse(root.right, list); return list; } } . ",
    "url": "https://1001anjan.github.io/problem-394-Minimum%20Distance%20Between%20BST%20Nodes/",
    "relUrl": "/problem-394-Minimum Distance Between BST Nodes/"
  },"447": {
    "doc": "Rotate String",
    "title": "Rotate String",
    "content": "Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s. A shift on s consists of moving the leftmost character of s to the rightmost position. For example, if s = “abcde”, then it will be “bcdea” after one shift. Example 1: . Input: s = \"abcde\", goal = \"cdeab\" Output: true . Example 2: . Input: s = \"abcde\", goal = \"abced\" Output: false . Constraints: . | 1 &lt;= s.length, goal.length &lt;= 100 | s and goal consist of lowercase English letters. | . Solution: . class Solution { public boolean rotateString(String s, String goal) { if(goal.length() &lt; s.length()) return false; return (goal + goal).indexOf(s) != -1; } } . ",
    "url": "https://1001anjan.github.io/problem-395-Rotate%20String/",
    "relUrl": "/problem-395-Rotate String/"
  },"448": {
    "doc": "Unique Morse Code Words",
    "title": "Unique Morse Code Words",
    "content": "International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: . | ‘a’ maps to “.-“, | ‘b’ maps to “-…”, | ‘c’ maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: | . [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] . Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter. | For example, “cab” can be written as “-.-..–…”, which is the concatenation of “-.-.”, “.-“, and “-…”. We will call such a concatenation the transformation of a word. Return the number of different transformations among all words we have. | . Example 1: . Input: words = [\"gin\",\"zen\",\"gig\",\"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -&gt; \"--...-.\" \"zen\" -&gt; \"--...-.\" \"gig\" -&gt; \"--...--.\" \"msg\" -&gt; \"--...--.\" There are 2 different transformations: \"--...-.\" and \"--...--.\". Example 2: . Input: words = [\"a\"] Output: 1 . Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 12 | words[i] consists of lowercase English letters. | . Solution: . class Solution { public int uniqueMorseRepresentations(String[] words) { String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\", \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\", \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\", \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; Set&lt;String&gt; seen = new HashSet(); for (String word: words) { StringBuilder code = new StringBuilder(); for (char c: word.toCharArray()) code.append(MORSE[c - 'a']); seen.add(code.toString()); } return seen.size(); } } . ",
    "url": "https://1001anjan.github.io/problem-396-Unique%20Morse%20Code%20Words/",
    "relUrl": "/problem-396-Unique Morse Code Words/"
  },"449": {
    "doc": "Most Common Word",
    "title": "Most Common Word",
    "content": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique. The words in paragraph are case-insensitive and the answer should be returned in lowercase. Example 1: . Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"] Output: \"ball\" Explanation: \"hit\" occurs 3 times, but it is a banned word. \"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive, that punctuation is ignored (even if adjacent to words, such as \"ball,\"), and that \"hit\" isn't the answer even though it occurs more because it is banned. Example 2: . Input: paragraph = \"a.\", banned = [] Output: \"a\" . Constraints: . | 1 &lt;= paragraph.length &lt;= 1000 | paragraph consists of English letters, space ‘ ‘, or one of the symbols: “!?’,;.”. | 0 &lt;= banned.length &lt;= 100 | 1 &lt;= banned[i].length &lt;= 10 | banned[i] consists of only lowercase English letters. | . Solution . class Solution { public String mostCommonWord(String paragraph, String[] banned) { Set&lt;String&gt; set = new HashSet&lt;&gt;(); for(String str : banned) set.add(str); HashMap&lt;String,Integer&gt; mp = new HashMap&lt;&gt;(); int i = 0; int size = paragraph.length(); char[] str = paragraph.toCharArray(); StringBuilder sb = new StringBuilder(); while(i &lt; size){ while(i &lt; size &amp;&amp; str[i] == ' ') i++; sb.setLength(0); while(i &lt; size){ if(Character.isLetter(str[i])) sb.append(Character.toLowerCase(str[i])); else break; i++; } String s = sb.toString(); if(sb.length() &gt; 0 &amp;&amp; !set.contains(s)) mp.put(s, mp.getOrDefault(s,0) + 1); i++; } int max = Collections.max(mp.values()); for(String key : mp.keySet()){ if(mp.get(key) == max) return key; } return null; } } . ",
    "url": "https://1001anjan.github.io/problem-397-Most%20Common%20Word/",
    "relUrl": "/problem-397-Most Common Word/"
  },"450": {
    "doc": "Largest Triangle Area",
    "title": "Largest Triangle Area",
    "content": "Given an array of points on the X-Y plane points where points[i] = [xi, yi], return the area of the largest triangle that can be formed by any three different points. Answers within 10-5 of the actual answer will be accepted. Example 1: . Input: points = [[0,0],[0,1],[1,0],[0,2],[2,0]] Output: 2.00000 Explanation: The five points are shown in the above figure. The red triangle is the largest. Example 2: . Input: points = [[1,0],[0,0],[0,1]] Output: 0.50000 . Constraints: . | 3 &lt;= points.length &lt;= 50 | -50 &lt;= xi, yi &lt;= 50 | All the given points are unique. | . Solution: . class Solution { public double largestTriangleArea(int[][] points) { double max = 0.0; for(int i = 0; i &lt; points.length - 2; i++){ for(int j = i + 1; j &lt; points.length - 1; j++){ for(int k = j + 1; k &lt; points.length; k++){ max = Math.max(max,calculateTriangleArea(points[i], points[j], points[k])); } } } return max; } public double calculateTriangleArea(int[] p1, int[] p2, int[] p3){ return Math.abs(p1[0]*(p2[1] - p3[1]) + p2[0]*(p3[1] - p1[1]) + p3[0]*(p1[1] - p2[1]))/2.0; } } . ",
    "url": "https://1001anjan.github.io/problem-398-Largest%20Triangle%20Area/",
    "relUrl": "/problem-398-Largest Triangle Area/"
  },"451": {
    "doc": "Rectangle Overlap",
    "title": "Rectangle Overlap",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-399-Rectangle%20Overlap/",
    "relUrl": "/problem-399-Rectangle Overlap/"
  },"452": {
    "doc": "Longest Palindromic Substring",
    "title": "Longest Palindromic Substring",
    "content": "Given a string s, return the longest palindromic substring in s. Example 1: . Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer. Example 2: . Input: s = \"cbbd\" Output: \"bb\" . Constraints: . | 1 &lt;= s.length &lt;= 1000 | s consist of only digits and English letters. | . Solution: . class Solution { public String longestPalindrome(String s) { int n = s.length(); int start = 0, end = 0; boolean[][] dp = new boolean[n][n]; for(int len = 0; len &lt; n; len++){ for(int i = 0; len + i &lt; n; i++){ dp[i][i + len] = (s.charAt(i) == s.charAt(i + len)) &amp;&amp; (len &lt; 2 || dp[i + 1][i + len -1]); if(dp[i][i + len] &amp;&amp; len &gt; (end - start)){ start = i; end = i + len; } } } return s.substring(start, end + 1); } } . Logic: . The dynamic programmic approach to this question is quite simple actually! For any given substring, we can confirm if it is a palindrome in O(1) time if: . The characters at the ends of the substring are the same. If the inner substring is a palindrome. Observe this relationship below: . Algorithm: . | Our outter loop will represent our length - 1, len. | Our inner loop will represent our left pointer, i. Therefore, our right pointer will be represented by i+len. This makes our logic a bit easier: | . Our base cases are when len is 0 or 1 (i.e. when the length of the substring is of length 1 or 2). In these situations, DP won’t work. Thankfully, all we need to check for is whether s.charAt(i) == s.charAt(i + len). For len &gt; 1, we would also need to check whether the inner substring is a palindrome as illustrated above. Therefore, we’ll also check if dp[i+1][i+len-1] is true. There are a few ways we could keep track of our longest substring. We could just assign a new substring whenever our current window length is greater than the current string’s length. However, assigning a new substring on each update takes O(n) time at worst. Therefore, we’ll just keep track of the indices of our longest substring using start and end and we’ll only convert this into a substring at the end. ",
    "url": "https://1001anjan.github.io/problem-4-Longest%20Palindromic%20Substring/",
    "relUrl": "/problem-4-Longest Palindromic Substring/"
  },"453": {
    "doc": "Longest Common Prefix",
    "title": "Longest Common Prefix",
    "content": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: . Input: strs = [\"flower\",\"flow\",\"flight\"] Output: \"fl\" . Example 2: . Input: strs = [\"dog\",\"racecar\",\"car\"] Output: \"\" Explanation: There is no common prefix among the input strings. Constraints: . | 1 &lt;= strs.length &lt;= 200 | 0 &lt;= strs[i].length &lt;= 200 | strs[i] consists of only lowercase English letters. | . Solution: . class Solution { public String longestCommonPrefix(String[] strs) { if(strs == null || strs.length ==0) return \"\"; String str= strs[0]; int i; for(i=0; i&lt;str.length(); i++){ for(int j=0;j&lt;strs.length; j++){ if(strs[j].length()&lt;=i) return str.substring(0,i); if(strs[j].charAt(i) != str.charAt(i)) return str.substring(0,i); } } if(i==0) return \"\"; return strs[0]; } } . Complexity Analysis . Time complexity : O(S) , where S is the sum of all characters in all strings. In the worst case there will be nn equal strings with length m and the algorithm performs S = m \\cdot nS=m⋅n character comparisons. Even though the worst case is still the same as Approach 1, in the best case there are at most n \\cdot minLenn⋅minLen comparisons where minLenminLen is the length of the shortest string in the array. Space complexity : O(1). We only used constant extra space. Solution: Divide and Conquer . class Solution { public String longestCommonPrefix(String[] strs) { if(strs == null || strs.length ==0) return \"\"; return longestCommonPrefix(strs,0, strs.length-1); } private String longestCommonPrefix(String[] strs, int l, int u){ if(l == u ) return strs[l]; int mid = (l+u)/2; String left = longestCommonPrefix(strs, l, mid); String right = longestCommonPrefix(strs, mid+1, u); return commonPrefix(left, right); } private String commonPrefix(String left, String right){ int min = Math.min(left.length(), right.length()); for(int i=0; i&lt;min; i++){ if(left.charAt(i) != right.charAt(i)) return left.substring(0, i); } return left.substring(0,min); } } . Complexity Analysis . In the worst case we have nn equal strings with length m . | Time complexity : O(S), where S is the number of all characters in the array, S = m \\cdot nS=m⋅n Time complexity is 2 \\cdot T\\left ( \\frac{n}{2} \\right ) + O(m)2⋅T(2 n )+O(m). Therefore time complexity is O(S)O(S). In the best case this algorithm performs O(minLen \\cdot n)O(minLen⋅n) comparisons, where minLenminLen is the shortest string of the array . | Space complexity : O(m \\cdot \\log n)O(m⋅logn) . | . There is a memory overhead since we store recursive calls in the execution stack. There are \\log nlogn recursive calls, each store need mm space to store the result, so space complexity is O(m \\cdot \\log n)O(m⋅logn) . ",
    "url": "https://1001anjan.github.io/docs/data-structure/ds-easy-set-1/problem-4-Longest-Common-Prefix/",
    "relUrl": "/docs/data-structure/ds-easy-set-1/problem-4-Longest-Common-Prefix/"
  },"454": {
    "doc": "Remove Linked List Elements",
    "title": "Remove Linked List Elements",
    "content": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head. Example 1: . Input: head = [1,2,6,3,4,5,6], val = 6 Output: [1,2,3,4,5] . Example 2: . Input: head = [], val = 1 Output: [] . Example 3: . Input: head = [7,7,7,7], val = 7 Output: [] . Constraints: . | The number of nodes in the list is in the range [0, 104]. | 1 &lt;= Node.val &lt;= 50 | 0 &lt;= val &lt;= 50 | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode removeElements(ListNode head, int val) { ListNode ptr, qtr; while(head != null &amp;&amp; head.val == val){ ptr = head; head = head.next; ptr.next = null; } if(head == null) return head; ptr = head; while(ptr.next != null){ if(ptr.next.val == val){ qtr = ptr.next; ptr.next = ptr.next.next; qtr.next = null; }else ptr = ptr.next; } return head; } } . ",
    "url": "https://1001anjan.github.io/problem-40-Remove-Linked-List-Elements/",
    "relUrl": "/problem-40-Remove-Linked-List-Elements/"
  },"455": {
    "doc": "Search a 2D Matrix",
    "title": "Search a 2D Matrix",
    "content": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties: . | Integers in each row are sorted from left to right. | The first integer of each row is greater than the last integer of the previous row. | . Example 1: . Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true . Example 2: . Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false . Constraints: . | m == matrix.length | n == matrix[i].length | 1 &lt;= m, n &lt;= 100 | -10^4 &lt;= matrix[i][j], target &lt;= 10^4 | . Solution: . class Solution { public boolean searchMatrix(int[][] matrix, int target) { int n = matrix[0].length - 1; for(int[] arr : matrix){ if(arr[0] == target || target == arr[n]) return true; if(arr[0] &lt; target &amp;&amp; target &lt; arr[n]) return binarySearch(arr, 0, n, target); } return false; } public boolean binarySearch(int[] arr, int l, int u, int target){ if(l &gt; u) return false; int m = (l + u)/2; if(arr[m] == target) return true; if(arr[m] &gt; target) return binarySearch(arr, l, m - 1, target); else return binarySearch(arr, m + 1, u, target); } } . ",
    "url": "https://1001anjan.github.io/problem-40-Search%20a%202D%20Matrix/",
    "relUrl": "/problem-40-Search a 2D Matrix/"
  },"456": {
    "doc": "Fair Candy Swap",
    "title": "Fair Candy Swap",
    "content": "Fair Candy Swap . Alice and Bob have a different total number of candies. You are given two integer arrays aliceSizes and bobSizes where aliceSizes[i] is the number of candies of the ith box of candy that Alice has and bobSizes[j] is the number of candies of the jth box of candy that Bob has. Since they are friends, they would like to exchange one candy box each so that after the exchange, they both have the same total amount of candy. The total amount of candy a person has is the sum of the number of candies in each box they have. Return an integer array answer where answer[0] is the number of candies in the box that Alice must exchange, and answer[1] is the number of candies in the box that Bob must exchange. If there are multiple answers, you may return any one of them. It is guaranteed that at least one answer exists. Example 1: . Input: aliceSizes = [1,1], bobSizes = [2,2] Output: [1,2] . Example 2: . Input: aliceSizes = [1,2], bobSizes = [2,3] Output: [1,2] . Example 3: . Input: aliceSizes = [2], bobSizes = [1,3] Output: [2,3] . Constraints: . | 1 &lt;= aliceSizes.length, bobSizes.length &lt;= 104 | 1 &lt;= aliceSizes[i], bobSizes[j] &lt;= 105 | Alice and Bob have a different total number of candies. | There will be at least one valid answer for the given input. | . Solution . Time Complexity O(m*n) Space Complexity: O(1) . class Solution { public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) { int aliceSum = 0, bobSum = 0; for(int n : aliceSizes) aliceSum += n; for(int n : bobSizes) bobSum += n; int total = (aliceSum + bobSum)/2; for(int m : aliceSizes){ for(int n : bobSizes){ if(total == (aliceSum - m + n)) return new int[]{m,n}; } } throw null; } } . class Solution { public int[] fairCandySwap(int[] aliceSizes, int[] bobSizes) { int aliceSum = 0, bobSum = 0; for(int n : aliceSizes) aliceSum += n; for(int n : bobSizes) bobSum += n; int total = (aliceSum + bobSum)/2; Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); if(aliceSizes.length &gt; bobSizes.length){ for(int n : aliceSizes) set.add(n); int delta = total - bobSum; for(int m : bobSizes){ if(set.contains(delta + m)) return new int[]{delta + m, m}; } }else{ for(int n : bobSizes) set.add(n); int delta = total - aliceSum; for(int m : aliceSizes){ if(set.contains(delta + m)) return new int[]{m,delta + m}; } } throw null; } } . class Solution { public int[] fairCandySwap(int[] A, int[] B) { int sa = 0, sb = 0; // sum of A, B respectively for (int x: A) sa += x; for (int x: B) sb += x; int delta = (sb - sa) / 2; // If Alice gives x, she expects to receive x + delta Set&lt;Integer&gt; setB = new HashSet(); for (int x: B) setB.add(x); for (int x: A) if (setB.contains(x + delta)) return new int[]{x, x + delta}; throw null; } } . ",
    "url": "https://1001anjan.github.io/problem-400-Fair%20Candy%20Swap/",
    "relUrl": "/problem-400-Fair Candy Swap/"
  },"457": {
    "doc": "Smallest Range I",
    "title": "Smallest Range I",
    "content": "Smallest Range I . You are given an integer array nums and an integer k. In one operation, you can choose any index i where 0 &lt;= i &lt; nums.length and change nums[i] to nums[i] + x where x is an integer from the range [-k, k]. You can apply this operation at most once for each index i. The score of nums is the difference between the maximum and minimum elements in nums. Return the minimum score of nums after applying the mentioned operation at most once for each index in it. Example 1: . Input: nums = [1], k = 0 Output: 0 Explanation: The score is max(nums) - min(nums) = 1 - 1 = 0. Example 2: . Input: nums = [0,10], k = 2 Output: 6 Explanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6. Example 3: . Input: nums = [1,3,6], k = 3 Output: 0 Explanation: Change nums to be [4, 4, 4]. The score is max(nums) - min(nums) = 4 - 4 = 0. Constraints: . | 1 &lt;= nums.length &lt;= 10^4 | 0 &lt;= nums[i] &lt;= 10^4 | 0 &lt;= k &lt;= 10^4 | . Solution: . class Solution { public int smallestRangeI(int[] nums, int k) { int max = -1, min = Integer.MAX_VALUE; for(int n : nums){ max = Math.max(max,n); min = Math.min(min,n); } if((max - min) &lt;= 2*k) return 0; return max - k - min - k; } } . ",
    "url": "https://1001anjan.github.io/problem-401-Smallest%20Range%20I/",
    "relUrl": "/problem-401-Smallest Range I/"
  },"458": {
    "doc": "X of a Kind in a Deck of Cards",
    "title": "X of a Kind in a Deck of Cards",
    "content": "You are given an integer array deck where deck[i] represents the number written on the ith card. Partition the cards into one or more groups such that: . | Each group has exactly x cards where x &gt; 1, and | All the cards in one group have the same integer written on them. Return true if such partition is possible, or false otherwise. | . Example 1: . Input: deck = [1,2,3,4,4,3,2,1] Output: true Explanation: Possible partition [1,1],[2,2],[3,3],[4,4]. Example 2: . Input: deck = [1,1,1,2,2,2,3,3] Output: false Explanation: No possible partition. Constraints: . | 1 &lt;= deck.length &lt;= 10^4 | 0 &lt;= deck[i] &lt; 10^4 | . Solution: . class Solution { public boolean hasGroupsSizeX(int[] deck) { if(deck.length == 1) return false; int[] dp = new int[10000]; for(int n : deck) dp[n]++; int minCount = Integer.MAX_VALUE; for(int n : dp) { if(n != 0) minCount = Math.min(minCount,n); } int i = 2; for(; i &lt;= minCount; i++){ boolean f = true; for(int n : dp){ if(n != 0 &amp;&amp; (n%i != 0)){ f = false; break; } } if(f) break; } return i &lt;= minCount; } } . Improvement . class Solution { public boolean hasGroupsSizeX(int[] deck) { int[] count = new int[10000]; for (int c: deck) count[c]++; int g = -1; for (int i = 0; i &lt; 10000; ++i) if (count[i] &gt; 0) { if (g == -1) g = count[i]; else g = gcd(g, count[i]); } return g &gt;= 2; } public int gcd(int x, int y) { return x == 0 ? y : gcd(y%x, x); } } . Complexity Analysis . | Time Complexity: O(Nlog^2 N)where N is the number of votes. If there are Ci cards with number i, then each gcd operation is naively O(log^2Ci). Better bounds exist, but are outside the scope of this article to develop. | Space Complexity: O(N). | . ",
    "url": "https://1001anjan.github.io/problem-402-X%20of%20a%20Kind%20in%20a%20Deck%20of%20Cards/",
    "relUrl": "/problem-402-X of a Kind in a Deck of Cards/"
  },"459": {
    "doc": "Best Time to Buy and Sell Stock",
    "title": "Best Time to Buy and Sell Stock",
    "content": "You are given an array prices where prices[i] is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0. Example 1: . Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2: . Input: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. Constraints: . | 1 &lt;= prices.length &lt;= 10^5 | 0 &lt;= prices[i] &lt;= 10^4 | . Solution . class Solution { public int maxProfit(int[] prices) { int i = 0, j = 0; int max = 0; while(j &lt; prices.length){ if(prices[i] &gt; prices[j]){ i = j; }else{ max = Math.max(max,prices[j] - prices[i]); j++; } } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-403-Best%20Time%20to%20Buy%20and%20Sell%20Stock/",
    "relUrl": "/problem-403-Best Time to Buy and Sell Stock/"
  },"460": {
    "doc": "DI String Match",
    "title": "DI String Match",
    "content": "A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where: . | s[i] == ‘I’ if perm[i] &lt; perm[i + 1], and | s[i] == ‘D’ if perm[i] &gt; perm[i + 1]. Given a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them. | . Example 1: . Input: s = \"IDID\" Output: [0,4,1,3,2] . Example 2: . Input: s = \"III\" Output: [0,1,2,3] . Example 3: . Input: s = \"DDI\" Output: [3,2,0,1] . Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘I’ or ‘D’. | . Solution: . class Solution { public int[] diStringMatch(String s) { char[] chs = s.toCharArray(); int[] ans = new int[chs.length + 1]; int u = chs.length; int l = 0; for(int i = 0; i &lt; chs.length; i++){ if(chs[i] == 'I'){ ans[i] = l++; }else{ ans[i] = u--; } } ans[chs.length] = l; return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-404-DI%20String%20Match/",
    "relUrl": "/problem-404-DI String Match/"
  },"461": {
    "doc": "Verifying an Alien Dictionary",
    "title": "Verifying an Alien Dictionary",
    "content": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters. Given a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language. Example 1: . Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\" Output: true Explanation: As 'h' comes before 'l' in this language, then the sequence is sorted. Example 2: . Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\" Output: false Explanation: As 'd' comes after 'l' in this language, then words[0] &gt; words[1], hence the sequence is unsorted. Example 3: . Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\" Output: false Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" &gt; \"app\", because 'l' &gt; '∅', where '∅' is defined as the blank character which is less than any other character (More info). Constraints: . | 1 &lt;= words.length &lt;= 100 | 1 &lt;= words[i].length &lt;= 20 | order.length == 26 | All characters in words[i] and order are English lowercase letters. | . Solution: . class Solution { public boolean isAlienSorted(String[] words, String order) { int[] mp = new int[26]; for(int i = 0; i &lt; order.length(); i++){ mp[order.charAt(i) - 'a'] = i; } for(int i = 0; i &lt; words.length - 1; i++){ int k = 0; int kn = words[i].length(); int ln = words[i + 1].length(); int minDiff = 0; while(k &lt; kn &amp;&amp; k &lt; ln){ int diff = mp[words[i].charAt(k) - 'a'] - mp[words[i + 1].charAt(k) - 'a']; minDiff = Math.min(diff,minDiff); if(diff &lt; 0) break; if(diff &gt; 0) return false; k++; } if(minDiff == 0 &amp;&amp; kn &gt; ln) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-405-Verifying%20an%20Alien%20Dictionary/",
    "relUrl": "/problem-405-Verifying an Alien Dictionary/"
  },"462": {
    "doc": "Remove Outermost Parentheses",
    "title": "Remove Outermost Parentheses",
    "content": "A valid parentheses string is either empty “”, “(“ + A + “)”, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. | For example, “”, “()”, “(())()”, and “(()(()))” are all valid parentheses strings. | . A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings. Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + … + Pk, where Pi are primitive valid parentheses strings. Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s. Example 1: . Input: s = \"(()())(())\" Output: \"()()()\" Explanation: The input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\". After removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\". Example 2: . Input: s = \"(()())(())(()(()))\" Output: \"()()()()(())\" Explanation: The input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\". After removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\". Example 3: . Input: s = \"()()\" Output: \"\" Explanation: The input string is \"()()\", with primitive decomposition \"()\" + \"()\". After removing outer parentheses of each part, this is \"\" + \"\" = \"\". Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is either ‘(‘ or ‘)’. | s is a valid parentheses string. | . Solution: . class Solution { public String removeOuterParentheses(String s) { int open = 0; StringBuilder sb = new StringBuilder(); for(char ch : s.toCharArray()){ if(ch == '('){ if(open == 0){ open++; }else{ open++; sb.append(ch); } }else{ if(open &gt; 1){ open--; sb.append(ch); }else{ open = 0; } } } return sb.toString(); } } . class Solution { public String removeOuterParentheses(String S) { StringBuilder s = new StringBuilder(); int opened = 0; for (char c : S.toCharArray()) { if (c == '(' &amp;&amp; opened++ &gt; 0) s.append(c); if (c == ')' &amp;&amp; opened-- &gt; 1) s.append(c); } return s.toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-406-Remove%20Outermost%20Parentheses/",
    "relUrl": "/problem-406-Remove Outermost Parentheses/"
  },"463": {
    "doc": "Matrix Cells in Distance Order",
    "title": "Matrix Cells in Distance Order",
    "content": "You are given four integers row, cols, rCenter, and cCenter. There is a rows x cols matrix and you are on the cell with the coordinates (rCenter, cCenter). Return the coordinates of all cells in the matrix, sorted by their distance from (rCenter, cCenter) from the smallest distance to the largest distance. You may return the answer in any order that satisfies this condition. | The distance between two cells (r1, c1) and (r2, c2) is | r1 - r2 | + | c1 - c2 | . | . Example 1: . Input: rows = 1, cols = 2, rCenter = 0, cCenter = 0 Output: [[0,0],[0,1]] Explanation: The distances from (0, 0) to other cells are: [0,1] . Example 2: . Input: rows = 2, cols = 2, rCenter = 0, cCenter = 1 Output: [[0,1],[0,0],[1,1],[1,0]] Explanation: The distances from (0, 1) to other cells are: [0,1,1,2] The answer [[0,1],[1,1],[0,0],[1,0]] would also be accepted as correct. Example 3: . Input: rows = 2, cols = 3, rCenter = 1, cCenter = 2 Output: [[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]] Explanation: The distances from (1, 2) to other cells are: [0,1,1,2,2,3] There are other answers that would also be accepted as correct, such as [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]. Constraints: . | 1 &lt;= rows, cols &lt;= 100 | 0 &lt;= rCenter &lt; rows | 0 &lt;= cCenter &lt; cols | . Solution: . Using Sorting: . class Solution { public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) { int[][] ans = new int[rows*cols][2]; int k = 0; for(int i = 0; i &lt; rows; i++){ for(int j = 0; j &lt; cols; j++){ ans[k][0] = i; ans[k][1] = j; k++; } } // sort the array Arrays.sort(ans, (a,b) -&gt;{ int d1 = Math.abs(a[0] - rCenter) + Math.abs(a[1] - cCenter); int d2 = Math.abs(b[0] - rCenter) + Math.abs(b[1] - cCenter); return d1 - d2; }); return ans; } } . Using BFS but slow execution . class Solution { public int[][] allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) { int[][] ans = new int[rows*cols][2]; Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); boolean[][] visited = new boolean[rows][cols]; queue.offer(new int[]{rCenter,cCenter}); int k = 0; while(!queue.isEmpty()){ int[] item = queue.poll(); if(item[0] &lt; 0 || item[0] &gt;= rows || item[1] &lt; 0 || item[1] &gt;= cols) continue; if(visited[item[0]][item[1]]) continue; visited[item[0]][item[1]] = true; ans[k++] = item; queue.offer(new int[]{item[0], item[1] + 1}); queue.offer(new int[]{item[0], item[1] - 1}); queue.offer(new int[]{item[0] + 1, item[1]}); queue.offer(new int[]{item[0] - 1, item[1]}); } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-407-Matrix%20Cells%20in%20Distance%20Order/",
    "relUrl": "/problem-407-Matrix Cells in Distance Order/"
  },"464": {
    "doc": "Greatest Common Divisor of Strings",
    "title": "Greatest Common Divisor of Strings",
    "content": "For two strings s and t, we say “t divides s” if and only if s = t + … + t (i.e., t is concatenated with itself one or more times). Given two strings str1 and str2, return the largest string x such that x divides both str1 and str2. Example 1: . Input: str1 = \"ABCABC\", str2 = \"ABC\" Output: \"ABC\" . Example 2: . Input: str1 = \"ABABAB\", str2 = \"ABAB\" Output: \"AB\" . Example 3: . Input: str1 = \"LEET\", str2 = \"CODE\" Output: \"\" . Constraints: . | 1 &lt;= str1.length, str2.length &lt;= 1000 | str1 and str2 consist of English uppercase letters. | . Solution: . class Solution { public String gcdOfStrings(String str1, String str2) { if (!(str1+str2).equals(str2+str1)) return \"\"; int gcdVal = gcd(str1.length() , str2.length()); return str2.substring(0, gcdVal); } public static int gcd(int p, int q) { if (q == 0) return p; else return gcd(q, p % q); } } . ",
    "url": "https://1001anjan.github.io/problem-408-Greatest%20Common%20Divisor%20of%20Strings/",
    "relUrl": "/problem-408-Greatest Common Divisor of Strings/"
  },"465": {
    "doc": "Duplicate Zeros",
    "title": "Duplicate Zeros",
    "content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right. Note that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything. Example 1: . Input: arr = [1,0,2,3,0,4,5,0] Output: [1,0,0,2,3,0,0,4] Explanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4] . Example 2: . Input: arr = [1,2,3] Output: [1,2,3] Explanation: After calling your function, the input array is modified to: [1,2,3] . Constraints: . | 1 &lt;= arr.length &lt;= 10^4 | 0 &lt;= arr[i] &lt;= 9 | . Solution: . class Solution { public void duplicateZeros(int[] arr) { for(int i = 0; i &lt; arr.length - 1; i++){ if(arr[i] == 0){ for(int j = arr.length - 2; j &gt; i; j--){ arr[j + 1] = arr[j]; } arr[i + 1] = 0; i++; } } } } . class Solution { public void duplicateZeros(int[] arr) { int possibleDups = 0; int length_ = arr.length - 1; // Find the number of zeros to be duplicated // Stopping when left points beyond the last element in the original array // which would be part of the modified array for (int left = 0; left &lt;= length_ - possibleDups; left++) { // Count the zeros if (arr[left] == 0) { // Edge case: This zero can't be duplicated. We have no more space, // as left is pointing to the last element which could be included if (left == length_ - possibleDups) { // For this zero we just copy it without duplication. arr[length_] = 0; length_ -= 1; break; } possibleDups++; } } // Start backwards from the last element which would be part of new array. int last = length_ - possibleDups; // Copy zero twice, and non zero once. for (int i = last; i &gt;= 0; i--) { if (arr[i] == 0) { arr[i + possibleDups] = 0; possibleDups--; arr[i + possibleDups] = 0; } else { arr[i + possibleDups] = arr[i]; } } } } . Practice link . ",
    "url": "https://1001anjan.github.io/problem-409-Duplicate%20Zeros/",
    "relUrl": "/problem-409-Duplicate Zeros/"
  },"466": {
    "doc": "Reverse Linked List",
    "title": "Reverse Linked List",
    "content": "Given the head of a singly linked list, reverse the list, and return the reversed list. Example 1: . Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] . Solution . Non-recursive . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode reverseList(ListNode head) { if(head == null) return head; ListNode ptr = null, qtr ; while(head != null){ qtr = head; head = head.next; qtr.next = ptr; ptr = qtr; } return ptr; } } . Recursive . class Solution { public ListNode reverseList(ListNode head) { if(head == null) return head; if(head.next == null) return head; ListNode newNode = reverseList(head.next); head.next.next = head; head.next = null; return newNode; } } . ",
    "url": "https://1001anjan.github.io/problem-41-Reverse-Linked-List/",
    "relUrl": "/problem-41-Reverse-Linked-List/"
  },"467": {
    "doc": "Sort Colors",
    "title": "Sort Colors",
    "content": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue. We will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively. You must solve this problem without using the library’s sort function. Example 1: . Input: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] . Example 2: . Input: nums = [2,0,1] Output: [0,1,2] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 300 | nums[i] is either 0, 1, or 2. | . Follow up: Could you come up with a one-pass algorithm using only constant extra space? . Solution: . class Solution { public void sortColors(int[] nums) { int s = 0,e = 0; int l = nums.length - 1; int pivot = 1; while(e &lt;= l){ if(nums[e] &lt; pivot){ swap(nums, s, e); s++; e++; } else if(nums[e] == pivot){ e++; } else{ swap(nums, e, l); l--; } } } public void swap(int[] arr, int i, int j){ int t = arr[i]; arr[i] = arr[j]; arr[j] = t; } } . ",
    "url": "https://1001anjan.github.io/problem-41-Sort%20Colors/",
    "relUrl": "/problem-41-Sort Colors/"
  },"468": {
    "doc": "Day of the Year",
    "title": "Day of the Year",
    "content": "Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year. Example 1: . Input: date = \"2019-01-09\" Output: 9 Explanation: Given date is the 9th day of the year in 2019. Example 2: . Input: date = \"2019-02-10\" Output: 41 . Constraints: . | date.length == 10 | date[4] == date[7] == ‘-‘, and all other date[i]’s are digits | date represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019. | . Solution: . import java.time.LocalDate; class Solution { public int dayOfYear(String date) { return LocalDate.parse(date).getDayOfYear(); } } . class Solution { public int dayOfYear(String S) { String[] s = S.split(\"-\"); int year = Integer.parseInt(s[0]); int month = Integer.parseInt(s[1]); int date = Integer.parseInt(s[2]); boolean isLeap = checkYear(year); int noOfDays = 0; int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; for (int i = 0; i &lt; month - 1; i++) { if (isLeap &amp;&amp; i == 1) { noOfDays += days[i] + 1; continue; } noOfDays += days[i]; } return noOfDays + date; } boolean checkYear(int year) { if (year % 400 == 0) return true; if (year % 100 == 0) return false; if (year % 4 == 0) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-410-Day%20of%20the%20Year/",
    "relUrl": "/problem-410-Day of the Year/"
  },"469": {
    "doc": "Prime Arrangements",
    "title": "Prime Arrangements",
    "content": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.) . (Recall that an integer is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers both smaller than it.) . Since the answer may be large, return the answer modulo 10^9 + 7. Example 1: . Input: n = 5 Output: 12 Explanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1. Example 2: . Input: n = 100 Output: 682289015 . Constraints: . | 1 &lt;= n &lt;= 100 Prime Arrangements | . ",
    "url": "https://1001anjan.github.io/problem-411-Prime%20Arrangements/",
    "relUrl": "/problem-411-Prime Arrangements/"
  },"470": {
    "doc": "Day of the Week",
    "title": "Day of the Week",
    "content": "Given a date, return the corresponding day of the week for that date. The input is given as three integers representing the day, month and year respectively. Return the answer as one of the following values {“Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}. Example 1: . Input: day = 31, month = 8, year = 2019 Output: \"Saturday\" . Example 2: . Input: day = 18, month = 7, year = 1999 Output: \"Sunday\" . Example 3: . Input: day = 15, month = 8, year = 1993 Output: \"Sunday\" . Constraints: . | The given dates are valid dates between the years 1971 and 2100. | . Solution: . class Solution { int[] m = {0,31,28,31,30,31,30,31,31,30,31,30,31}; String[] res = {\"Friday\", \"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\"}; public String dayOfTheWeek(int day, int month, int year) { int days = years(year); if(isLeap(year)) m[2] = 29; for(int i=0; i &lt; month; i++){ days += m[i]; } days += day-1; return res[days%7]; } private int years(int y){ int count = 0; for(int i=1971; i &lt; y; i++){ if(isLeap(i)) count += 366; else count += 365; } return count; } private boolean isLeap(int y){ if(y % 4 != 0) return false; else if(y%100 != 0) return true; else if(y % 400 != 0) return false; else return true; } } . ",
    "url": "https://1001anjan.github.io/problem-412-Day%20of%20the%20Week/",
    "relUrl": "/problem-412-Day of the Week/"
  },"471": {
    "doc": "Minimum Cost to Move Chips to The Same Position",
    "title": "Minimum Cost to Move Chips to The Same Position",
    "content": "We have n chips, where the position of the ith chip is position[i]. We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to: . | position[i] + 2 or position[i] - 2 with cost = 0. | position[i] + 1 or position[i] - 1 with cost = 1. Return the minimum cost needed to move all the chips to the same position. | . Example 1: . Input: position = [1,2,3] Output: 1 Explanation: First step: Move the chip at position 3 to position 1 with cost = 0. Second step: Move the chip at position 2 to position 1 with cost = 1. Total cost is 1. Example 2: . Input: position = [2,2,2,3,3] Output: 2 Explanation: We can move the two chips at position 3 to position 2. Each move has cost = 1. The total cost = 2. Example 3: . Input: position = [1,1000000000] Output: 1 . Constraints: . | 1 &lt;= position.length &lt;= 100 | 1 &lt;= position[i] &lt;= 10^9 | . Solution: . class Solution { public int minCostToMoveChips(int[] position) { int even_cnt = 0; int odd_cnt = 0; for (int i : position) { if (i % 2 == 0) { even_cnt++; } else { odd_cnt++; } } return Math.min(odd_cnt, even_cnt); } } . ",
    "url": "https://1001anjan.github.io/problem-413-Minimum%20Cost%20to%20Move%20Chips%20to%20The%20Same%20Position/",
    "relUrl": "/problem-413-Minimum Cost to Move Chips to The Same Position/"
  },"472": {
    "doc": "Check If It Is a Straight Line",
    "title": "Check If It Is a Straight Line",
    "content": "You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents the coordinate of a point. Check if these points make a straight line in the XY plane. Example 1: . Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]] Output: true . Example 2: . Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]] Output: false . Constraints: . | 2 &lt;= coordinates.length &lt;= 1000 | coordinates[i].length == 2 | -10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4 | coordinates contains no duplicate point. | . Solution: . The slope for a line through any 2 points (x0, y0) and (x1, y1) is (y1 - y0) / (x1 - x0); Therefore, for any given 3 points (denote the 3rd point as (x, y)), if they are in a straight line, the slopes of the lines from the 3rd point to the 2nd point and the 2nd point to the 1st point must be equal: . (y - y1) / (x - x1) = (y1 - y0) / (x1 - x0) In order to avoid being divided by 0, use multiplication form: . (x1 - x0) * (y - y1) = (x - x1) * (y1 - y0) =&gt; dx * (y - y1) = dy * (x - x1), where dx = x1 - x0 and dy = y1 - y0 . class Solution { public boolean checkStraightLine(int[][] coordinates) { int dx = coordinates[1][0] - coordinates[0][0]; int dy = coordinates[1][1] - coordinates[0][1]; for(int i = 2; i &lt; coordinates.length; i++){ int dxi = coordinates[i][0] - coordinates[i - 1][0]; int dyi = coordinates[i][1] - coordinates[i - 1][1]; if(dx * dyi != dy * dxi) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-414-Check%20If%20It%20Is%20a%20Straight%20Line/",
    "relUrl": "/problem-414-Check If It Is a Straight Line/"
  },"473": {
    "doc": "Minimum Time Visiting All Points",
    "title": "Minimum Time Visiting All Points",
    "content": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points. You can move according to these rules: . | In 1 second, you can either: | move vertically by one unit, | move horizontally by one unit, or | move diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second). | You have to visit the points in the same order as they appear in the array. | You are allowed to pass through points that appear later in the order, but these do not count as visits. | . Example 1: . Input: points = [[1,1],[3,4],[-1,0]] Output: 7 Explanation: One optimal path is [1,1] -&gt; [2,2] -&gt; [3,3] -&gt; [3,4] -&gt; [2,3] -&gt; [1,2] -&gt; [0,1] -&gt; [-1,0] Time from [1,1] to [3,4] = 3 seconds Time from [3,4] to [-1,0] = 4 seconds Total time = 7 seconds . Example 2: . Input: points = [[3,2],[-2,2]] Output: 5 . Constraints: . | points.length == n | 1 &lt;= n &lt;= 100 | points[i].length == 2 | -1000 &lt;= points[i][0], points[i][1] &lt;= 1000 | . Solution: . class Solution { public int minTimeToVisitAllPoints(int[][] points) { int time = 0; for(int i = 0; i &lt; points.length - 1; i++) { int xDiff = Math.abs(points[i][0] - points[i + 1][0]); int yDiff = Math.abs(points[i][1] - points[i + 1][1]); time += Math.max(xDiff, yDiff); } return time; } } . ",
    "url": "https://1001anjan.github.io/problem-415-Minimum%20Time%20Visiting%20All%20Points/",
    "relUrl": "/problem-415-Minimum Time Visiting All Points/"
  },"474": {
    "doc": "Find Winner on a Tic Tac Toe Game",
    "title": "Find Winner on a Tic Tac Toe Game",
    "content": "Tic-tac-toe is played by two players A and B on a 3 x 3 grid. The rules of Tic-Tac-Toe are: . | Players take turns placing characters into empty squares ‘ ‘. | The first player A always places ‘X’ characters, while the second player B always places ‘O’ characters. | ‘X’ and ‘O’ characters are always placed into empty squares, never on filled ones. | The game ends when there are three of the same (non-empty) character filling any row, column, or diagonal. | The game also ends if all squares are non-empty. | No more moves can be played if the game is over. Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B). In case the game ends in a draw return “Draw”. If there are still movements to play return “Pending”. | . You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid is initially empty, and A will play first. Example 1: . Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] Output: \"A\" Explanation: A wins, they always play first. Example 2: . Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] Output: \"B\" Explanation: B wins. Example 3: . Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] Output: \"Draw\" Explanation: The game ends in a draw since there are no moves to make. Constraints: . | 1 &lt;= moves.length &lt;= 9 | moves[i].length == 2 | 0 &lt;= rowi, coli &lt;= 2 | There are no repeated elements on moves. | moves follow the rules of tic tac toe. | . Solution: . There are 8 ways to win for each player: . | 3 columns | 3 rows | 2 diagonals Players make moves one by one so all odd moves are for player A, even for B. Now we just need to track if we reach 3 in any line for any of the players. One array keeps all ways to win for each player: . | 0,1,2 - for rows | 3,4,5 - for cols | 6 - for diagonal top left - bottom right | 7 - for diagonal top right - bottom left | . class Solution { public String tictactoe(int[][] moves) { int a[] = new int[8]; int b[] = new int[8]; boolean t = true; for(int m[] : moves){ int p[] = t ? a : b; t = t ? false : true; p[m[0]]++; p[m[1] + 3]++; if(m[0] == m[1]) p[6]++; if(m[0] == 2 - m[1]) p[7]++; } for(int i = 0; i &lt; 8 ; i++){ if(a[i] == 3) return \"A\"; if(b[i] == 3) return \"B\"; } return moves.length == 9 ? \"Draw\" : \"Pending\"; } } . ",
    "url": "https://1001anjan.github.io/problem-416-Find%20Winner%20on%20a%20Tic%20Tac%20Toe%20Game/",
    "relUrl": "/problem-416-Find Winner on a Tic Tac Toe Game/"
  },"475": {
    "doc": "Number of Days Between Two Dates",
    "title": "Number of Days Between Two Dates",
    "content": "Write a program to count the number of days between two dates. The two dates are given as strings, their format is YYYY-MM-DD as shown in the examples. Example 1: . Input: date1 = \"2019-06-29\", date2 = \"2019-06-30\" Output: 1 . Example 2: . Input: date1 = \"2020-01-15\", date2 = \"2019-12-31\" Output: 15 . Constraints: . | The given dates are valid dates between the years 1971 and 2100. | . Solution: . class Solution { int dM[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; public int daysBetweenDates(String date1, String date2) { String ds1[] = date1.split(\"-\"); String ds2[] = date2.split(\"-\"); int ddy1 = Integer.parseInt(ds1[0]); int ddm1 = Integer.parseInt(ds1[1]); int ddd1 = Integer.parseInt(ds1[2]); int ddy2 = Integer.parseInt(ds2[0]); int ddm2 = Integer.parseInt(ds2[1]); int ddd2 = Integer.parseInt(ds2[2]); int dy1, dy2, dm1, dm2, dd1, dd2; dy1 = ddy1; dm1 = ddm1; dd1 = ddd1; dy2 = ddy2; dm2 = ddm2; dd2 = ddd2; if(ddy1 &gt; ddy2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; }else if(ddy1 == ddy2 &amp;&amp; ddm1 &gt; ddm2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; }else if(ddy1 == ddy2 &amp;&amp; ddm1 == ddm2 &amp;&amp; ddd1 &gt; ddd2){ dy1 = ddy2; dm1 = ddm2; dd1 = ddd2; dy2 = ddy1; dm2 = ddm1; dd2 = ddd1; } int count = 0; // cheacking is date1 and date2 if same year and same month if(dy1 == dy2 &amp;&amp; dm1 == dm2){ return dd2 - dd1; } // adding reaming day in the month count += dM[dm1] - dd1; if(dm1 == 2 &amp;&amp; isLeapYear(dy1)){ count++; } dm1++; // counting first year if(dy1 &lt; dy2){ while(dm1 &lt;= 12){ if(dm1 == 2 &amp;&amp; isLeapYear(dy1)) count++; count += dM[dm1]; dm1++; } } dy1++; // counting middle years while(dy1 &lt; dy2){ if(isLeapYear(dy1)) count++; count += 365; dy1++; } // countiing end year dm1 = 1; while(dy1 &lt;= dy2 &amp;&amp; dm1 &lt; dm2){ if(dm1 == 2 &amp;&amp; isLeapYear(dy1)) count++; count += dM[dm1]; dm1++; } // counting last month count += dd2; return count; } public boolean isLeapYear(int y){ if(y % 400 == 0) return true; if(y % 100 == 0) return false; if(y % 4 == 0) return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-417-Number%20of%20Days%20Between%20Two%20Dates/",
    "relUrl": "/problem-417-Number of Days Between Two Dates/"
  },"476": {
    "doc": "Count Largest Group",
    "title": "Count Largest Group",
    "content": "You are given an integer n. Each number from 1 to n is grouped according to the sum of its digits. Return the number of groups that have the largest size. Example 1: . Input: n = 13 Output: 4 Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. Example 2: . Input: n = 2 Output: 2 Explanation: There are 2 groups [1], [2] of size 1. Constraints: . | 1 &lt;= n &lt;= 10^4 | . Solution: . class Solution { public int countLargestGroup(int n) { int count = 0; int[] dp = new int[n + 1]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 1; i &lt;= n; i++){ dp[i] = i % 10 + dp[i/10]; map.put(dp[i], map.getOrDefault(dp[i],0) + 1); } int max = 0; for(int key : map.keySet()){ if(map.get(key) &gt; max){ count = 1; max = map.get(key); }else if(map.get(key) == max) count++; } return count; } } . ",
    "url": "https://1001anjan.github.io/problem-418-Count%20Largest%20Group/",
    "relUrl": "/problem-418-Count Largest Group/"
  },"477": {
    "doc": "Minimum Subsequence in Non-Increasing Order",
    "title": "Minimum Subsequence in Non-Increasing Order",
    "content": "Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order. Example 1: . Input: nums = [4,3,10,9,8] Output: [10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements. Example 2: . Input: nums = [4,4,7,6,7] Output: [7,7,6] Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order. Constraints: . | 1 &lt;= nums.length &lt;= 500 | 1 &lt;= nums[i] &lt;= 100 | . Solution: . class Solution { public List&lt;Integer&gt; minSubsequence(int[] nums) { List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); int sum = 0; for(int n : nums) sum += n; Arrays.sort(nums); int i = nums.length - 1; int currSum = 0; while(currSum &lt;= sum &amp;&amp; i &gt;= 0){ currSum += nums[i]; sum -= nums[i]; ans.add(nums[i]); i--; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-419-Minimum%20Subsequence%20in%20Non-Increasing%20Order/",
    "relUrl": "/problem-419-Minimum Subsequence in Non-Increasing Order/"
  },"478": {
    "doc": "Combinations",
    "title": "Combinations",
    "content": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n]. You may return the answer in any order. Example 1: . Input: n = 4, k = 2 Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination. Example 2: . Input: n = 1, k = 1 Output: [[1]] Explanation: There is 1 choose 1 = 1 total combination. Constraints: . | 1 &lt;= n &lt;= 20 | 1 &lt;= k &lt;= n | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); process(1, n, k, ans, new ArrayList&lt;&gt;()); return ans; } public void process(int start, int n, int k, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; k) return; if(list.size() == k){ ans.add(new ArrayList&lt;&gt;(list)); return; } for(int i = start; i &lt;= n; i++){ list.add(i); process(i + 1, n, k, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-42-Combinations/",
    "relUrl": "/problem-42-Combinations/"
  },"479": {
    "doc": "Isomorphic Strings",
    "title": "Isomorphic Strings",
    "content": "Given two strings s and t, determine if they are isomorphic. Two strings s and t are isomorphic if the characters in s can be replaced to get t. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. Example 1: . Input: s = \"egg\", t = \"add\" Output: true . Example 2: . Input: s = \"foo\", t = \"bar\" Output: false . Example 3: . Input: s = \"paper\", t = \"title\" Output: true . Constraints: . | 1 &lt;= s.length &lt;= 5 * 104 | t.length == s.length | s and t consist of any valid ascii character. | . Solution . https://leetcode.com/problems/isomorphic-strings/solution/ . ",
    "url": "https://1001anjan.github.io/problem-42-Isomorphic-Strings/",
    "relUrl": "/problem-42-Isomorphic-Strings/"
  },"480": {
    "doc": "Special Array With X Elements Greater Than or Equal X",
    "title": "Special Array With X Elements Greater Than or Equal X",
    "content": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x. Notice that x does not have to be an element in nums. Return x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique. Example 1: . Input: nums = [3,5] Output: 2 Explanation: There are 2 values (3 and 5) that are greater than or equal to 2. Example 2: . Input: nums = [0,0] Output: -1 Explanation: No numbers fit the criteria for x. If x = 0, there should be 0 numbers &gt;= x, but there are 2. If x = 1, there should be 1 number &gt;= x, but there are 0. If x = 2, there should be 2 numbers &gt;= x, but there are 0. x cannot be greater since there are only 2 numbers in nums. Example 3: . Input: nums = [0,4,3,0,4] Output: 3 Explanation: There are 3 values that are greater than or equal to 3. Constraints: . | 1 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 1000 | . Solution: . class Solution { public int specialArray(int[] nums) { int l = 0, u = nums.length; while(l &lt;= u){ int mid = (l + u)/2; int count = 0; for(int n : nums) if(n &gt;= mid) count++; if(mid == count) return mid; if(count &gt; mid) l = mid + 1; else u = mid - 1; } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-420-Special%20Array%20With%20X%20Elements%20Greater%20Than%20or%20Equal%20X/",
    "relUrl": "/problem-420-Special Array With X Elements Greater Than or Equal X/"
  },"481": {
    "doc": "Contains Duplicate",
    "title": "Contains Duplicate",
    "content": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct. Example 1: . Input: nums = [1,2,3,1] Output: true . Example 2: . Input: nums = [1,2,3,4] Output: false . Example 3: . Input: nums = [1,1,1,3,3,4,3,2,4,2] Output: true . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -109 &lt;= nums[i] &lt;= 109 | . Solution . class Solution { public boolean containsDuplicate(int[] nums) { Set&lt;Integer&gt; set = new HashSet(); for(int i : nums){ if(set.contains(i)) return true; set.add(i); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-43-Contains-Duplicate/",
    "relUrl": "/problem-43-Contains-Duplicate/"
  },"482": {
    "doc": "Subsets",
    "title": "Subsets",
    "content": "Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order. Example 1: . Input: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] . Example 2: . Input: nums = [0] Output: [[],[0]] . Constraints: . | 1 &lt;= nums.length &lt;= 10 | -10 &lt;= nums[i] &lt;= 10 | All the numbers of nums are unique. | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) { List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(); process(nums, 0, ans, new ArrayList&lt;&gt;()); return ans; } public void process(int[] nums, int start, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list){ if(list.size() &gt; nums.length) return; ans.add(new ArrayList&lt;&gt;(list)); for(int i = start; i &lt; nums.length; i++){ list.add(nums[i]); process(nums, i + 1, ans, list); list.remove(list.size() - 1); } } } . ",
    "url": "https://1001anjan.github.io/problem-43-Subsets/",
    "relUrl": "/problem-43-Subsets/"
  },"483": {
    "doc": "Contains Duplicate II",
    "title": "Contains Duplicate II",
    "content": "Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) &lt;= k. Example 1: . Input: nums = [1,2,3,1], k = 3 Output: true . Example 2: . Input: nums = [1,0,1,1], k = 1 Output: true . Example 3: . Input: nums = [1,2,3,1,2,3], k = 2 Output: false . Constraints: . | 1 &lt;= nums.length &lt;= 105 | -109 &lt;= nums[i] &lt;= 109 | 0 &lt;= k &lt;= 105 | . Solution . class Solution { public boolean containsNearbyDuplicate(int[] nums, int k) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i = 0; i&lt;nums.length; i++){ if(map.containsKey(nums[i])){ if(Math.abs(map.get(nums[i]) - i) &lt;= k) return true; } map.put(nums[i],i); } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-44-Contains-Duplicate-II/",
    "relUrl": "/problem-44-Contains-Duplicate-II/"
  },"484": {
    "doc": "Word Search",
    "title": "Word Search",
    "content": " ",
    "url": "https://1001anjan.github.io/problem-44-Word%20Search/",
    "relUrl": "/problem-44-Word Search/"
  },"485": {
    "doc": "Implement Stack using Queues",
    "title": "Implement Stack using Queues",
    "content": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty). Implement the MyStack class: . | void push(int x) Pushes element x to the top of the stack. | int pop() Removes the element on the top of the stack and returns it. | int top() Returns the element on the top of the stack. | boolean empty() Returns true if the stack is empty, false otherwise. | . Notes: . You must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid. Depending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue’s standard operations. Example 1: . Input [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] Output [null, null, null, 2, 2, false] . Explanation . MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // return 2 myStack.pop(); // return 2 myStack.empty(); // return False . Constraints: . | 1 &lt;= x &lt;= 9 | At most 100 calls will be made to push, pop, top, and empty. | All the calls to pop and top are valid. | . Follow-up: Can you implement the stack using only one queue? . Solution . ",
    "url": "https://1001anjan.github.io/problem-45-Implement-Stack-using-Queues/",
    "relUrl": "/problem-45-Implement-Stack-using-Queues/"
  },"486": {
    "doc": "Remove Duplicates from Sorted Array II",
    "title": "Remove Duplicates from Sorted Array II",
    "content": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 1 &lt;= nums.length &lt;= 3 * 10^4 | -10^4 &lt;= nums[i] &lt;= 10^4 | nums is sorted in non-decreasing order. | . Solution: . ",
    "url": "https://1001anjan.github.io/problem-45-Remove%20Duplicates%20from%20Sorted%20Array%20II/",
    "relUrl": "/problem-45-Remove Duplicates from Sorted Array II/"
  },"487": {
    "doc": "Invert Binary Tree",
    "title": "Invert Binary Tree",
    "content": "Given the root of a binary tree, invert the tree, and return its root. Example 1: . Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if(root == null) return root; TreeNode ptr; ptr = root.left; root.left = root.right; root.right = ptr; invertTree(root.left); invertTree(root.right); return root; } } . ",
    "url": "https://1001anjan.github.io/problem-46-Invert-Binary-Tree/",
    "relUrl": "/problem-46-Invert-Binary-Tree/"
  },"488": {
    "doc": "Power of Two",
    "title": "Power of Two",
    "content": "Given an integer n, return true if it is a power of two. Otherwise, return false. An integer n is a power of two, if there exists an integer x such that n == 2x. Example 1: . Input: n = 1 Output: true Explanation: 20 = 1 . Example 2: . Input: n = 16 Output: true Explanation: 24 = 16 . Example 3: . Input: n = 3 Output: false . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isPowerOfTwo(int n) { if(n == 1) return true; if(n == 0) return false; while(n&gt;=0){ if(n == 0) return true; if(n == 2) return true; if(n % 2 == 1) return false; n = n/2; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-47-Power-of-Two/",
    "relUrl": "/problem-47-Power-of-Two/"
  },"489": {
    "doc": "Palindrome Linked List",
    "title": "Palindrome Linked List",
    "content": "Given the head of a singly linked list, return true if it is a palindrome. Example 1: . Input: head = [1,2,2,1] Output: true . Example 2: . Input: head = [1,2] Output: false . Constraints: . | The number of nodes in the list is in the range [1, 105]. | 0 &lt;= Node.val &lt;= 9 | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public boolean isPalindrome(ListNode head) { ListNode slow, fast; slow = fast = head; while(fast != null &amp;&amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } if(fast != null) slow = slow.next; slow = reverseList(slow); return compareList(head, slow); } public ListNode reverseList(ListNode head){ ListNode ptr = null, qtr; while(head != null){ qtr = ptr; ptr = head; head = head.next; ptr.next = qtr; } return ptr; } public boolean compareList(ListNode l1, ListNode l2){ while(l1 != null &amp;&amp; l2 != null){ if(l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; } // if(l1 != null || l2 != null) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-48-Palindrome-Linked-List/",
    "relUrl": "/problem-48-Palindrome-Linked-List/"
  },"490": {
    "doc": "Lowest Common Ancestor of a Binary Search Tree",
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "content": "Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).” . Example 1: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2: . Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3: . Input: root = [2,1], p = 2, q = 1 Output: 2 . Constraints: . | The number of nodes in the tree is in the range [2, 105]. | -109 &lt;= Node.val &lt;= 109 | All Node.val are unique. | p != q | p and q will exist in the BST. | . Solution: . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if ( p.val &lt; root.val &amp;&amp; q.val &lt; root.val ) return this.lowestCommonAncestor(root.left, p, q); if ( p.val &gt; root.val &amp;&amp; q.val &gt; root.val ) return this.lowestCommonAncestor(root.right, p, q); return root; } } . ",
    "url": "https://1001anjan.github.io/problem-49-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/",
    "relUrl": "/problem-49-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"
  },"491": {
    "doc": "Reverse Integer",
    "title": "Reverse Integer",
    "content": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0. Assume the environment does not allow you to store 64-bit integers (signed or unsigned). Example 1: . Input: x = 123 Output: 321 . Example 2: . Input: x = -123 Output: -321 . Example 3: . Input: x = 120 Output: 21 . Constraints: . | -2^31 &lt;= x &lt;= 2^31 - 1 | . Solution: . class Solution { public int reverse(int x) { long rev = 0; while(x != 0){ rev = rev * 10 + x % 10; x = x / 10; } if(rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE) return 0; return (int)rev; } } . class Solution { public int reverse(int x) { int rev =0; boolean neg = false; if(x&lt;0){ x = x*-1; neg = true; } while(x&gt;0){ if(rev&gt;Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE/10 &amp;&amp; x%10&gt;Integer.MAX_VALUE%10)) return 0; rev = rev*10 + x%10 ; x = x/10; } if(neg) return rev*-1; return rev; } } . ",
    "url": "https://1001anjan.github.io/problem-5-Reverse%20Integer/",
    "relUrl": "/problem-5-Reverse Integer/"
  },"492": {
    "doc": "Valid Parentheses",
    "title": "Valid Parentheses",
    "content": "Given a string s containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[’ and ‘]’, determine if the input string is valid. An input string is valid if: . | Open brackets must be closed by the same type of brackets. | Open brackets must be closed in the correct order. | . Example 1: . Input: s = \"()\" Output: true . Example 2: . Input: s = \"()[]{}\" Output: true . Example 3: . Input: s = \"(]\" Output: false . Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of parentheses only ‘()[]{}’. | . class Solution { public boolean isValid(String s) { Stack&lt;Character&gt; stack = new Stack(); for(int i = 0; i&lt;s.length(); i++){ if(s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '['){ stack.push(s.charAt(i)); }else{ if(stack.isEmpty()) return false; if(s.charAt(i) != getCorrospondingBracket(stack.pop())) return false; } } if(stack.isEmpty()) return true; return false; } private char getCorrospondingBracket(char c){ switch(c){ case '(': return ')'; case '{': return '}'; case '[': return ']'; default : return '*'; } } } . ",
    "url": "https://1001anjan.github.io/problem-5-valid-parentheses/",
    "relUrl": "/problem-5-valid-parentheses/"
  },"493": {
    "doc": "Delete Node in a Linked List",
    "title": "Delete Node in a Linked List",
    "content": "Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. It is guaranteed that the node to be deleted is not a tail node in the list. Example 1: . Input: head = [4,5,1,9], node = 5 Output: [4,1,9] Explanation: You are given the second node with value 5, the linked list should become 4 -&gt; 1 -&gt; 9 after calling your function. Constraints: . | The number of the nodes in the given list is in the range [2, 1000]. | -1000 &lt;= Node.val &lt;= 1000 | The value of each node in the list is unique. | The node to be deleted is in the list and is not a tail node | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public void deleteNode(ListNode node) { //We are not going to delete the given node //We will delete the node next to it //Because for deleting the given node we need its previous node //And will copy its value to the given node //Storing the vaue of the next node to the given node int nextNodeVal = node.next.val; //Then removing that next node node.next = node.next.next; //And simply copy the value node.val = nextNodeVal; } } . ",
    "url": "https://1001anjan.github.io/problem-50-Delete-Node-in-a-Linked-List/",
    "relUrl": "/problem-50-Delete-Node-in-a-Linked-List/"
  },"494": {
    "doc": "Valid Anagram",
    "title": "Valid Anagram",
    "content": "Given two strings s and t, return true if t is an anagram of s, and false otherwise. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Example 1: . Input: s = \"anagram\", t = \"nagaram\" Output: true . Example 2: . Input: s = \"rat\", t = \"car\" Output: false . Constraints: . | 1 &lt;= s.length, t.length &lt;= 5 * 104 | s and t consist of lowercase English letters. | . Solution . class Solution { public boolean isAnagram(String s, String t) { if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; map1 = new HashMap&lt;Character, Integer&gt;(); Map&lt;Character, Integer&gt; map2 = new HashMap&lt;Character, Integer&gt;(); for(int i=0; i&lt;s.length(); i++){ if(map1.containsKey(s.charAt(i))){ map1.put(s.charAt(i), map1.get(s.charAt(i))+1); }else{ map1.put(s.charAt(i), 1); } if(map2.containsKey(t.charAt(i))){ map2.put(t.charAt(i), map2.get(t.charAt(i))+1); }else{ map2.put(t.charAt(i), 1); } } for(Character ch : map1.keySet()){ if(!map2.containsKey(ch)) return false; if((int)map1.get(ch) != (int)map2.get(ch)) return false; } return true; } } . try using simple map or only using array . class Solution { public boolean isAnagram(String s, String t) { int[] arr = new int[26]; if(s.length() != t.length()) return false; for(char a: s.toCharArray()) arr[a - 'a']++; for(char b : t.toCharArray()) arr[b - 'a']--; for(int i : arr){ if(i &gt; 0) return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-51-Valid-Anagram/",
    "relUrl": "/problem-51-Valid-Anagram/"
  },"495": {
    "doc": "Binary Tree Paths",
    "title": "Binary Tree Paths",
    "content": "Given the root of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children. Example 1: . Input: root = [1,2,3,null,5] Output: [\"1-&gt;2-&gt;5\",\"1-&gt;3\"] . Constraints: . | The number of nodes in the tree is in the range [1, 100]. | -100 &lt;= Node.val &lt;= 100 | . Solution . Non-recursive . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class NodeMap{ public TreeNode head; public StringBuilder sb; NodeMap(TreeNode head, String val){ sb = new StringBuilder(val); this.head = head; } } class Solution { public List&lt;String&gt; binaryTreePaths(TreeNode root) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); Stack&lt;NodeMap&gt; stack = new Stack&lt;NodeMap&gt;(); stack.push(new NodeMap(root, String.valueOf(root.val))); NodeMap nodeMap; while(!stack.isEmpty()){ nodeMap = stack.pop(); if(nodeMap.head.left == null &amp;&amp; nodeMap.head.right == null){ list.add(nodeMap.sb.toString().substring(0,nodeMap.sb.length())); } if(nodeMap.head.right != null){ stack.push(new NodeMap(nodeMap.head.right, nodeMap.sb.toString()+\"-&gt;\"+String.valueOf(nodeMap.head.right.val))); } if(nodeMap.head.left != null){ stack.push(new NodeMap(nodeMap.head.left, nodeMap.sb.toString()+\"-&gt;\"+String.valueOf(nodeMap.head.left.val))); } } return list; } } . Recursive . class Solution { List&lt;String&gt; res = new ArrayList&lt;&gt;(); public List&lt;String&gt; binaryTreePaths(TreeNode root) { helper(root, new StringBuilder()); return res; } public void helper(TreeNode node, StringBuilder sb) { if (node == null) return; int len = sb.length(); sb.append(node.val); if (node.left == null &amp;&amp; node.right == null) { res.add(sb.toString()); } else { sb.append(\"-&gt;\"); helper(node.left, sb); helper(node.right, sb); } // deleting the extra characters we added sb.setLength(len); } } . ",
    "url": "https://1001anjan.github.io/problem-52-Binary-Tree-Paths/",
    "relUrl": "/problem-52-Binary-Tree-Paths/"
  },"496": {
    "doc": "Add Digits",
    "title": "Add Digits",
    "content": "Given an integer num, repeatedly add all its digits until the result has only one digit, and return it. Example 1: . Input: num = 38 Output: 2 Explanation: The process is 38 --&gt; 3 + 8 --&gt; 11 11 --&gt; 1 + 1 --&gt; 2 Since 2 has only one digit, return it. Example 2: . Input: num = 0 Output: 0 . Constraints: . | 0 &lt;= num &lt;= 231 - 1 | . Solution . class Solution { public int addDigits(int num) { if (num == 0) return 0; if (num % 9 == 0) return 9; return num % 9; } } . class Solution { public int addDigits(int num) { if(num&lt;10) return num; while(num&gt;9){ num = getNext(num); } return num; } public int getNext(int n){ int sum = 0; while(n&gt;0){ sum = sum + n%10; n = n/10; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-53-Add-Digits/",
    "relUrl": "/problem-53-Add-Digits/"
  },"497": {
    "doc": "Ugly Number",
    "title": "Ugly Number",
    "content": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5. Given an integer n, return true if n is an ugly number. Example 1: . Input: n = 6 Output: true Explanation: 6 = 2 × 3 . Example 2: . Input: n = 1 Output: true Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5. Example 3: . Input: n = 14 Output: false Explanation: 14 is not ugly since it includes the prime factor 7. Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isUgly(int n) { if (n==0) return false; while (n!=1) { if (n%2==0) n=n/2; else if (n%3==0) n=n/3; else if (n%5==0) n=n/5; else return false; } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-54-Ugly-Number/",
    "relUrl": "/problem-54-Ugly-Number/"
  },"498": {
    "doc": "Missing Number",
    "title": "Missing Number",
    "content": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: . Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: . Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: . Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: . | n == nums.length | 1 &lt;= n &lt;= 104 | 0 &lt;= nums[i] &lt;= n | All the numbers of nums are unique. | . Solution . ",
    "url": "https://1001anjan.github.io/problem-55-Missing-Number/",
    "relUrl": "/problem-55-Missing-Number/"
  },"499": {
    "doc": "Missing Number",
    "title": "Missing Number",
    "content": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Example 1: . Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2: . Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3: . Input: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. Constraints: . | n == nums.length | 1 &lt;= n &lt;= 104 | 0 &lt;= nums[i] &lt;= n | All the numbers of nums are unique. | . Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity? . Solution . class Solution { public int missingNumber(int[] nums) { int len=nums.length; int sum = len*(len+1)/2; for(int items:nums){ sum-=items; } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-56-Missing-Number/",
    "relUrl": "/problem-56-Missing-Number/"
  },"500": {
    "doc": "Move Zeroes",
    "title": "Move Zeroes",
    "content": "Given an integer array nums, move all 0’s to the end of it while maintaining the relative order of the non-zero elements. Note that you must do this in-place without making a copy of the array. Example 1: . Input: nums = [0,1,0,3,12] Output: [1,3,12,0,0] . Example 2: . Input: nums = [0] Output: [0] . Constraints: . | 1 &lt;= nums.length &lt;= 104 | -231 &lt;= nums[i] &lt;= 231 - 1 | . Solution . Faster . class Solution { public void moveZeroes(int[] nums) { int cnt = 0; for (int i = 0; i &lt; nums.length; i++) { if (nums[i] != 0) { if (i &gt; cnt) { nums[cnt] = nums[i]; } cnt++; } } while (cnt &lt; nums.length) { nums[cnt++] = 0; } } } . class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = 0; int temp; while(i&lt;nums.length &amp;&amp; j&lt;nums.length){ while(i&lt;nums.length &amp;&amp; nums[i] != 0) i++; j = i; while(j&lt;nums.length &amp;&amp; nums[j] == 0) j++; if(i&lt;nums.length &amp;&amp; j&lt;nums.length){ nums[i] = nums[j]; nums[j] = 0; } i++; } } } . without maintaining order . class Solution { public void moveZeroes(int[] nums) { int i = 0; int j = nums.length - 1; int temp; while(i&lt;j){ while(i&lt;=j &amp;&amp; nums[i] != 0) i++; while(j&gt;=0 &amp;&amp; nums[j] == 0) j--; if(i&lt;nums.length-1 &amp;&amp; j&gt;=0){ temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; i++; j--; } } } } . ",
    "url": "https://1001anjan.github.io/problem-57-Move-Zeroes/",
    "relUrl": "/problem-57-Move-Zeroes/"
  },"501": {
    "doc": "Nim Game",
    "title": "Nim Game",
    "content": "You are playing the following Nim Game with your friend: . | Initially, there is a heap of stones on the table. | You and your friend will alternate taking turns, and you go first. | On each turn, the person whose turn it is will remove 1 to 3 stones from the heap. | The one who removes the last stone is the winner. | Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false. | . Example 1: . Input: n = 4 Output: false . Explanation: These are the possible outcomes: . | You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins. | You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins. | You remove 3 stones. Your friend removes the last stone. Your friend wins. In all outcomes, your friend wins. Example 2: . Input: n = 1 Output: true . Example 3: . Input: n = 2 Output: true . Constraints: . | 1 &lt;= n &lt;= 231 - 1 | . | . Solution . class Solution { public boolean canWinNim(int n) { return n%4 != 0; } } . ",
    "url": "https://1001anjan.github.io/problem-58-Nim-Game/",
    "relUrl": "/problem-58-Nim-Game/"
  },"502": {
    "doc": "Power of Three",
    "title": "Power of Three",
    "content": "Given an integer n, return true if it is a power of three. Otherwise, return false. An integer n is a power of three, if there exists an integer x such that n == 3x. Example 1: . Input: n = 27 Output: true . Example 2: . Input: n = 0 Output: false . Example 3: . Input: n = 9 Output: true . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . public class Solution { public boolean isPowerOfThree(int n) { if (n &lt; 1) { return false; } while (n % 3 == 0) { n /= 3; } return n == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-59-Power-of-Three/",
    "relUrl": "/problem-59-Power-of-Three/"
  },"503": {
    "doc": "Merge Two Sorted Lists",
    "title": "Merge Two Sorted Lists",
    "content": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Example 1: . Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] . Example 2: . Input: list1 = [], list2 = [] Output: [] . Example 3: . Input: list1 = [], list2 = [0] Output: [0] . Constraints: . | The number of nodes in both lists is in the range [0, 50]. | -100 &lt;= Node.val &lt;= 100 | Both list1 and list2 are sorted in non-decreasing order. | . Solution . /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.val = val; } * ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */ class Solution { public ListNode mergeTwoLists(ListNode list1, ListNode list2) { if(list1 == null ) return list2; if(list2 == null ) return list1; ListNode res, ptr; // create first node if(list1.val &lt; list2.val){ res = list1; list1 = list1.next; }else{ res = list2; list2 = list2.next; } res.next = null; ptr = res; // process both lists while(list1 != null &amp;&amp; list2 != null){ if(list1.val &lt; list2.val){ ptr.next = list1; list1 = list1.next; }else{ ptr.next = list2; list2 = list2.next; } ptr = ptr.next; } // handle remaining elements if(list1 != null){ ptr.next = list1; } if(list2 != null){ ptr.next = list2; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-6-merge-two-sorted-lists/",
    "relUrl": "/problem-6-merge-two-sorted-lists/"
  },"504": {
    "doc": "String to Integer (atoi)",
    "title": "String to Integer (atoi)",
    "content": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++’s atoi function). The algorithm for myAtoi(string s) is as follows: . Read in and ignore any leading whitespace. Check if the next character (if not already at the end of the string) is ‘-‘ or ‘+’. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present. Read in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored. Convert these digits into an integer (i.e. “123” -&gt; 123, “0032” -&gt; 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2). If the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1. Return the integer as the final result. Note: . Only the space character ‘ ‘ is considered a whitespace character. Do not ignore any characters other than the leading whitespace or the rest of the string after the digits. Example 1: . Input: s = \"42\" Output: 42 Explanation: The underlined characters are what is read in, the caret is the current reader position. Step 1: \"42\" (no characters read because there is no leading whitespace) ^ Step 2: \"42\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"42\" (\"42\" is read in) ^ The parsed integer is 42. Since 42 is in the range [-2^31, 2^31 - 1], the final result is 42. Example 2: . Input: s = \" -42\" Output: -42 Explanation: Step 1: \" -42\" (leading whitespace is read and ignored) ^ Step 2: \" -42\" ('-' is read, so the result should be negative) ^ Step 3: \" -42\" (\"42\" is read in) ^ The parsed integer is -42. Since -42 is in the range [-2^31, 2^31 - 1], the final result is -42. Example 3: . Input: s = \"4193 with words\" Output: 4193 Explanation: Step 1: \"4193 with words\" (no characters read because there is no leading whitespace) ^ Step 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+') ^ Step 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit) ^ The parsed integer is 4193. Since 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193. Constraints: . | 0 &lt;= s.length &lt;= 200 | s consists of English letters (lower-case and upper-case), digits (0-9), ‘ ‘, ‘+’, ‘-‘, and ‘.’. | . Solution: . class Solution { public int myAtoi(String s) { int result = 0; int i = 0; int n = s.length() - 1; if(n &lt; 0) return 0; // ignore leading space while(i &lt;= n &amp;&amp; s.charAt(i) == ' ') i++; //ignore leading letter // while(i &lt;= n &amp;&amp; Character.isLetter(s.charAt(i))) i++; if(i &gt; n) return result; int sign = 1; if(s.charAt(i) == '-') { sign = -1; i++; }else if(s.charAt(i) == '+') i++; if(i &gt; n) return result; char ch = s.charAt(i); while(i &lt;= n &amp;&amp; Character.isDigit(ch)){ int d = ch - '0'; if(result &gt; Integer.MAX_VALUE/10 || (result == Integer.MAX_VALUE/10 &amp;&amp; d &gt; Integer.MAX_VALUE%10)) { return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE; } result = result * 10 + d; i++; if(i &lt;= n ) ch = s.charAt(i); } return result * sign; } } . ",
    "url": "https://1001anjan.github.io/problem-6-String%20to%20Integer%20(atoi)/",
    "relUrl": "/problem-6-String to Integer (atoi)/"
  },"505": {
    "doc": "Counting Bits",
    "title": "Counting Bits",
    "content": "Given an integer n, return an array ans of length n + 1 such that for each i (0 &lt;= i &lt;= n), ans[i] is the number of 1’s in the binary representation of i. Example 1: . Input: n = 2 Output: [0,1,1] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 . Example 2: . Input: n = 5 Output: [0,1,1,2,1,2] Explanation: 0 --&gt; 0 1 --&gt; 1 2 --&gt; 10 3 --&gt; 11 4 --&gt; 100 5 --&gt; 101 . Constraints: . | 0 &lt;= n &lt;= 105 | . Solution . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; ans[0] = 0; for(int i = 1; i &lt;= n;i++){ ans[i] = (i &amp;1) + ans[i/2]; } return ans; } } . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; for(int i=0; i&lt;n+1; i++){ ans[i] = count(Integer.toBinaryString(i)); } return ans; } public int count(String s){ int c = 0; for(int i=0; i&lt;s.length(); i++) if(s.charAt(i) == '1') c++; return c; } } . class Solution { public int[] countBits(int n) { int[] ans = new int[n+1]; int[] dp = new int[n+1]; for(int i=0; i&lt;=n; i++) dp[i] = -1; for (int i=0; i&lt;=n; i++) { ans[i] = bits(i, dp); } return ans; } int bits(int n, int[] dp) { if (n == 0) return 0; if (n == 1) return 1; if (dp[n] != -1) return dp[n]; int rem, quo; quo = n / 2; rem = n % 2; return dp[n] = (rem + bits(quo, dp)); } } . ",
    "url": "https://1001anjan.github.io/problem-60-Counting-Bits/",
    "relUrl": "/problem-60-Counting-Bits/"
  },"506": {
    "doc": "Power of Four",
    "title": "Power of Four",
    "content": "Given an integer n, return true if it is a power of four. Otherwise, return false. An integer n is a power of four, if there exists an integer x such that n == 4x. Example 1: . Input: n = 16 Output: true . Example 2: . Input: n = 5 Output: false . Example 3: . Input: n = 1 Output: true . Constraints: . | -231 &lt;= n &lt;= 231 - 1 | . Solution . class Solution { public boolean isPowerOfFour(int n) { if(n == 0) return false; while(n &gt; 1){ if(n%4 != 0) return false; n = n/4; } return n == 1; } } . ",
    "url": "https://1001anjan.github.io/problem-61-a-Power-of-Four/",
    "relUrl": "/problem-61-a-Power-of-Four/"
  },"507": {
    "doc": "Reverse String",
    "title": "Reverse String",
    "content": "Write a function that reverses a string. The input string is given as an array of characters s. You must do this by modifying the input array in-place with O(1) extra memory. Example 1: . Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"] Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] . Example 2: . Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] . Constraints: . | 1 &lt;= s.length &lt;= 105 | s[i] is a printable ascii character. | . Solution . class Solution { public void reverseString(char[] s) { int i = 0; int j = s.length - 1; char ch; while(i&lt;=j){ ch = s[i]; s[i] = s[j]; s[j] = ch; i++; j--; } } } . ",
    "url": "https://1001anjan.github.io/problem-61-b-Reverse-String/",
    "relUrl": "/problem-61-b-Reverse-String/"
  },"508": {
    "doc": "Reverse Vowels of a String",
    "title": "Reverse Vowels of a String",
    "content": "Given a string s, reverse only all the vowels in the string and return it. The vowels are ‘a’, ‘e’, ‘i’, ‘o’, and ‘u’, and they can appear in both cases. Example 1: . Input: s = \"hello\" Output: \"holle\" . Example 2: . Input: s = \"leetcode\" Output: \"leotcede\" . Constraints: . | 1 &lt;= s.length &lt;= 3 * 105 | s consist of printable ASCII characters. | . Solution . class Solution { public String reverseVowels(String s) { char[] str = new char[s.length()]; str = s.toCharArray(); int i = 0; int j = s.length() - 1; char ch; while(i&lt;j){ while(i&lt;j &amp;&amp; !isVowel(str[i])) i++; while(i&lt;j &amp;&amp; !isVowel(str[j])) j--; if(i&lt;j){ ch = str[i]; str[i] = str[j]; str[j] = ch; i++; j--; } } return String.valueOf(str); } public boolean isVowel(char ch){ if(ch == 'A' || ch =='a' || ch == 'e' || ch == 'E' || ch == 'I' || ch =='i' || ch == 'O' || ch == 'o' || ch == 'u' || ch == 'U') return true; return false; } } . ",
    "url": "https://1001anjan.github.io/problem-64-Reverse-Vowels-of-a-String/",
    "relUrl": "/problem-64-Reverse-Vowels-of-a-String/"
  },"509": {
    "doc": "Intersection of Two Arrays",
    "title": "Intersection of Two Arrays",
    "content": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order. Example 1: . Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] . Example 2: . Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution . class Solution { public int[] set_intersection(HashSet&lt;Integer&gt; set1, HashSet&lt;Integer&gt; set2) { int [] output = new int[set1.size()]; int idx = 0; for (Integer s : set1) if (set2.contains(s)) output[idx++] = s; return Arrays.copyOf(output, idx); } public int[] intersection(int[] nums1, int[] nums2) { HashSet&lt;Integer&gt; set1 = new HashSet&lt;Integer&gt;(); for (Integer n : nums1) set1.add(n); HashSet&lt;Integer&gt; set2 = new HashSet&lt;Integer&gt;(); for (Integer n : nums2) set2.add(n); if (set1.size() &lt; set2.size()) return set_intersection(set1, set2); else return set_intersection(set2, set1); } } . ",
    "url": "https://1001anjan.github.io/problem-65-Intersection-of-Two-Arrays/",
    "relUrl": "/problem-65-Intersection-of-Two-Arrays/"
  },"510": {
    "doc": "Intersection of Two Arrays II",
    "title": "Intersection of Two Arrays II",
    "content": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. Example 1: . Input: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2,2] . Example 2: . Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [4,9] Explanation: [9,4] is also accepted. Constraints: . | 1 &lt;= nums1.length, nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 1000 | . Solution . class Solution { public int[] intersect(int[] nums1, int[] nums2) { Arrays.sort(nums1); Arrays.sort(nums2); int i = 0; int j = 0; int[] ans = new int[Math.min(nums1.length, nums2.length)]; int k = 0; while(i&lt;nums1.length &amp;&amp; j&lt;nums2.length){ if(nums1[i] == nums2[j]){ ans[k] = nums1[i]; k++; i++; j++; }else if(nums1[i]&gt;nums2[j]) j++; else i++; } return Arrays.copyOf(ans,k); } } . ",
    "url": "https://1001anjan.github.io/problem-66-Intersection-of-Two-Arrays-II/",
    "relUrl": "/problem-66-Intersection-of-Two-Arrays-II/"
  },"511": {
    "doc": "Valid Perfect Square",
    "title": "Valid Perfect Square",
    "content": "Given a positive integer num, write a function which returns True if num is a perfect square else False. Follow up: Do not use any built-in library function such as sqrt. Example 1: . Input: num = 16 Output: true . Example 2: . Input: num = 14 Output: false . Constraints: . | 1 &lt;= num &lt;= 2^31 - 1 | . Solution . class Solution { public boolean isPerfectSquare(int num) { int start = 0; int end = num; if(num == 1) return true; while (start &lt;= end){ long mid = start + (end - start)/2; if(mid * mid == num) return true; if(num &gt; mid * mid) start = (int)mid + 1; if(num &lt; mid * mid) end = (int)mid - 1; } return false; } } . ",
    "url": "https://1001anjan.github.io/problem-67-Valid-Perfect-Square/",
    "relUrl": "/problem-67-Valid-Perfect-Square/"
  },"512": {
    "doc": "Guess Number Higher or Lower",
    "title": "Guess Number Higher or Lower",
    "content": "We are playing the Guess Game. The game is as follows: . I pick a number from 1 to n. You have to guess which number I picked. Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess. You call a pre-defined API int guess(int num), which returns three possible results: . | -1: Your guess is higher than the number I picked (i.e. num &gt; pick). | 1: Your guess is lower than the number I picked (i.e. num &lt; pick). | 0: your guess is equal to the number I picked (i.e. num == pick). | Return the number that I picked. | . Example 1: . Input: n = 10, pick = 6 Output: 6 . Example 2: . Input: n = 1, pick = 1 Output: 1 . Example 3: . Input: n = 2, pick = 1 Output: 1 . Constraints: . | 1 &lt;= n &lt;= 231 - 1 | 1 &lt;= pick &lt;= n | . Solution . Binary search . /** * Forward declaration of guess API. * @param num your guess * @return -1 if num is higher than the picked number * 1 if num is lower than the picked number * otherwise return 0 * int guess(int num); */ public class Solution extends GuessGame { public int guessNumber(int n) { int s = 1; int e = n; int r; int mid = -1; while(true){ mid = (s+e)/2; r = guess(mid); if(r == 0) break;; if(r == 1){ s = mid+1; }else{ e = mid-1; } } return mid; } } . Ternary Search . ",
    "url": "https://1001anjan.github.io/problem-68-Guess-Number-Higher-or-Lower/",
    "relUrl": "/problem-68-Guess-Number-Higher-or-Lower/"
  },"513": {
    "doc": "Ransom Note",
    "title": "Ransom Note",
    "content": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise. Each letter in magazine can only be used once in ransomNote. Example 1: . Input: ransomNote = \"a\", magazine = \"b\" Output: false . Example 2: . Input: ransomNote = \"aa\", magazine = \"ab\" Output: false . Example 3: . Input: ransomNote = \"aa\", magazine = \"aab\" Output: true . Constraints: . | 1 &lt;= ransomNote.length, magazine.length &lt;= 105 | ransomNote and magazine consist of lowercase English letters. | . Solution . class Solution { public boolean canConstruct(String ransomNote, String magazine) { if(ransomNote.length()&gt;magazine.length()) return false; Map&lt;Character,Integer&gt; m1 = new HashMap&lt;Character, Integer&gt;(); Map&lt;Character,Integer&gt; m2 = new HashMap&lt;Character, Integer&gt;(); for(int i = 0; i &lt;ransomNote.length(); i++){ if(m1.containsKey(ransomNote.charAt(i))){ m1.put(ransomNote.charAt(i),(int)m1.get(ransomNote.charAt(i))+1); }else{ m1.put(ransomNote.charAt(i),1); } } for(int i = 0; i &lt;magazine.length(); i++){ if(m2.containsKey(magazine.charAt(i))){ m2.put(magazine.charAt(i),(int)m2.get(magazine.charAt(i))+1); }else{ m2.put(magazine.charAt(i),1); } } for(Map.Entry&lt;Character,Integer&gt; e : m1.entrySet()){ if(!m2.containsKey(e.getKey())) return false; else if((int)e.getValue() &gt; (int)m2.get(e.getKey())) return false; } return true; } } . Faster Solution . class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] count=new int[26]; for(int i=0;i&lt;magazine.length();i++){ char ch=magazine.charAt(i); count[ch-'a']++; } for(int i=0;i&lt;ransomNote.length();i++){ char ch=ransomNote.charAt(i); if(--count[ch-'a']&lt;0){ return false; } } return true; } } . ",
    "url": "https://1001anjan.github.io/problem-69-Ransom-Note/",
    "relUrl": "/problem-69-Ransom-Note/"
  },"514": {
    "doc": "Container With Most Water",
    "title": "Container With Most Water",
    "content": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]). Find two lines that together with the x-axis form a container, such that the container contains the most water. Return the maximum amount of water a container can store. Notice that you may not slant the container. Example 1: . Input: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2: . Input: height = [1,1] Output: 1 . Constraints: . | n == height.length | 2 &lt;= n &lt;= 10^5 | 0 &lt;= height[i] &lt;= 10^4 | . Solution: . class Solution { public int maxArea(int[] height) { int max = 0, s = 0, e = height.length - 1; while( s &lt; e){ int h; if(height[s] &gt; height[e]){ h = height[e]; max = Math.max(max, h * (e - s)); e--; }else{ h = height[s]; max = Math.max(max, h * (e - s)); s++; } } return max; } } . ",
    "url": "https://1001anjan.github.io/problem-7-Container%20With%20Most%20Water/",
    "relUrl": "/problem-7-Container With Most Water/"
  },"515": {
    "doc": "Remove Duplicates from Sorted Array",
    "title": "Remove Duplicates from Sorted Array",
    "content": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int[] expectedNums = [...]; // The expected answer with correct length int k = removeDuplicates(nums); // Calls your implementation assert k == expectedNums.length; for (int i = 0; i &lt; k; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 1 &lt;= nums.length &lt;= 3 * 104 | -100 &lt;= nums[i] &lt;= 100 | nums is sorted in non-decreasing order. | . Solution . class Solution { public int removeDuplicates(int[] nums) { int i = 0; for(int j = 1; j&lt;nums.length; j++){ if(nums[j-1] == nums[j]) continue; nums[++i] = nums[j]; } return i+1; } } . ",
    "url": "https://1001anjan.github.io/problem-7-remove-duplicates-from-sorted-array/",
    "relUrl": "/problem-7-remove-duplicates-from-sorted-array/"
  },"516": {
    "doc": "First Unique Character in a String",
    "title": "First Unique Character in a String",
    "content": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1. Example 1: . Input: s = \"leetcode\" Output: 0 . Example 2: . Input: s = \"loveleetcode\" Output: 2 . Example 3: . Input: s = \"aabb\" Output: -1 . Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of only lowercase English letters. | . Solution . class Solution { public int firstUniqChar(String s) { Map&lt;Character,Integer&gt; m = new HashMap&lt;Character,Integer&gt;(); for(int i=0; i&lt;s.length(); i++){ if(m.containsKey(s.charAt(i))) m.put(s.charAt(i),(int)m.get(s.charAt(i))+1); else m.put(s.charAt(i),1); } for(int i=0; i&lt;s.length(); i++){ if((int)m.get(s.charAt(i)) == 1) return i; } return -1; } } . Without hashMap . class Solution { public int firstUniqChar(String s) { int[] count = new int[26]; int n = s.length(); // build char count bucket : &lt;charIndex, count&gt; for (int i = 0; i &lt; n; i++) { int index = s.charAt(i) - 'a'; count[index]++; } // find the index for (int i = 0; i &lt; n; i++) { int index = s.charAt(i) - 'a'; if (count[index] == 1) { return i; } } return -1; } } . ",
    "url": "https://1001anjan.github.io/problem-70-First-Unique-Character-in-a-String/",
    "relUrl": "/problem-70-First-Unique-Character-in-a-String/"
  },"517": {
    "doc": "Find the Difference",
    "title": "Find the Difference",
    "content": "You are given two strings s and t. String t is generated by random shuffling string s and then add one more letter at a random position. Return the letter that was added to t. Example 1: . Input: s = \"abcd\", t = \"abcde\" Output: \"e\" Explanation: 'e' is the letter that was added. Example 2: . Input: s = \"\", t = \"y\" Output: \"y\" . Constraints: . | 0 &lt;= s.length &lt;= 1000 | t.length == s.length + 1 | s and t consist of lowercase English letters. | . Solution . class Solution { public char findTheDifference(String s, String t) { int ch[] = new int[26]; for(int i=0; i&lt;t.length(); i++){ ch[t.charAt(i) - 'a']++; } for(int i=0; i&lt;s.length(); i++){ ch[s.charAt(i) - 'a']--; } for(int i = 0; i&lt;26; i++){ if(ch[i] == 1) return (char)('a'+i); } return '1'; } } . Using XOR . class Solution { public char findTheDifference(String s, String t) { char res = 0; for(char ch: s.toCharArray()) { res ^= ch; } for(char ch: t.toCharArray()) { res ^= ch; } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-71-Find-the-Difference/",
    "relUrl": "/problem-71-Find-the-Difference/"
  },"518": {
    "doc": "Is Subsequence",
    "title": "Is Subsequence",
    "content": "Given two strings s and t, return true if s is a subsequence of t, or false otherwise. A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., “ace” is a subsequence of “abcde” while “aec” is not). Example 1: . Input: s = \"abc\", t = \"ahbgdc\" Output: true . Example 2: . Input: s = \"axc\", t = \"ahbgdc\" Output: false . Constraints: . | 0 &lt;= s.length &lt;= 100 | 0 &lt;= t.length &lt;= 104 | s and t consist only of lowercase English letters. | . Solution: . class Solution { public boolean isSubsequence(String s, String t) { int k = 0; int l = s.length(); if(l == 0) return true; for(int i = 0; i &lt; t.length(); i++){ if(t.charAt(i) == s.charAt(k)) k++; if(k == l) return true; } if(k &gt;= l) return true; return false; } } . class Solution { public boolean isSubsequence(String s, String t) { int i = 0, j = 0; int sLength = s.length(); int tLength = t.length(); while(i &lt; sLength &amp;&amp; j &lt; tLength){ if(s.charAt(i) == t.charAt(j)){ i++; } j++; } return i == sLength; } } . ",
    "url": "https://1001anjan.github.io/problem-72-Is-Subsequence/",
    "relUrl": "/problem-72-Is-Subsequence/"
  },"519": {
    "doc": "Sum of Left Leaves",
    "title": "Sum of Left Leaves",
    "content": "Given the root of a binary tree, return the sum of all left leaves. A leaf is a node with no children. A left leaf is a leaf that is the left child of another node. Example 1: . Input: root = [3,9,20,null,null,15,7] Output: 24 Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively. Example 2: . Input: root = [1] Output: 0 . Constraints: . | The number of nodes in the tree is in the range [1, 1000]. | -1000 &lt;= Node.val &lt;= 1000 | . Solution . /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class NodeMap{ public TreeNode head; public char f; NodeMap(TreeNode t, char c){ head = t; f = c; } } class Solution { public int sumOfLeftLeaves(TreeNode root) { Stack&lt;NodeMap&gt; s = new Stack&lt;NodeMap&gt;(); NodeMap m = new NodeMap(root,'*'); s.push(m); int sum = 0; NodeMap t; while(!s.isEmpty()){ t = s.pop(); if(t.f == 'L' &amp;&amp; t.head.left == null &amp;&amp; t.head.right == null) sum = sum + t.head.val; if(t.head.left != null ) s.push(new NodeMap(t.head.left, 'L')); if(t.head.right != null) s.push(new NodeMap(t.head.right, 'R')); } return sum; } } . ",
    "url": "https://1001anjan.github.io/problem-73-Sum-of-Left-Leaves/",
    "relUrl": "/problem-73-Sum-of-Left-Leaves/"
  },"520": {
    "doc": "Convert a Number to Hexadecimal",
    "title": "Convert a Number to Hexadecimal",
    "content": "Given an integer num, return a string representing its hexadecimal representation. For negative integers, two’s complement method is used. All the letters in the answer string should be lowercase characters, and there should not be any leading zeros in the answer except for the zero itself. Note: You are not allowed to use any built-in library method to directly solve this problem. Example 1: . Input: num = 26 Output: \"1a\" . Example 2: . Input: num = -1 Output: \"ffffffff\" . Constraints: . | -231 &lt;= num &lt;= 231 - 1 | . Solution: . class Solution { public String toHex(int num) { return Integer.toHexString(num); } } . ",
    "url": "https://1001anjan.github.io/problem-74-Convert-a-Number-to-Hexadecimal/",
    "relUrl": "/problem-74-Convert-a-Number-to-Hexadecimal/"
  },"521": {
    "doc": "Longest Palindrome",
    "title": "Longest Palindrome",
    "content": "Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters. Letters are case sensitive, for example, “Aa” is not considered a palindrome here. Example 1: . Input: s = \"abccccdd\" Output: 7 Explanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7. Example 2: . Input: s = \"a\" Output: 1 . Example 3: . Input: s = \"bb\" Output: 2 . Constraints: . | 1 &lt;= s.length &lt;= 2000 | s consists of lowercase and/or uppercase English letters only. | . Solution . class Solution { public int longestPalindrome(String s) { Map&lt;Character, Integer&gt; m = new HashMap&lt;Character,Integer&gt;(); for(int i = 0; i&lt;s.length(); i++){ m.put(s.charAt(i), m.getOrDefault(s.charAt(i),0)+1); } int a = 0; for(int i : m.values()){ if(i%2 == 0){ a = a + i; }else if(i&gt;1){ a += i - 1; } } if(s.length() &gt; a) return a+1; return a; } } . Faster approach . class Solution { public int longestPalindrome(String s) { int[] count = new int[128]; for (char c: s.toCharArray()) count[c]++; int ans = 0; for (int v: count) { ans += v / 2 * 2; if (ans % 2 == 0 &amp;&amp; v % 2 == 1) ans++; } return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-75-Longest-Palindrome/",
    "relUrl": "/problem-75-Longest-Palindrome/"
  },"522": {
    "doc": "Third Maximum Number",
    "title": "Third Maximum Number",
    "content": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number. Example 1: . Input: nums = [3,2,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2. The third distinct maximum is 1. Example 2: . Input: nums = [1,2] Output: 2 Explanation: The first distinct maximum is 2. The second distinct maximum is 1. The third distinct maximum does not exist, so the maximum (2) is returned instead. Example 3: . Input: nums = [2,2,3,1] Output: 1 Explanation: The first distinct maximum is 3. The second distinct maximum is 2 (both 2's are counted together since they have the same value). The third distinct maximum is 1. Constraints: . | 1 &lt;= nums.length &lt;= 104 | -231 &lt;= nums[i] &lt;= 231 - 1 | . Solution: . class Solution { public int thirdMax(int[] nums) { long max = Long.MIN_VALUE; long secondMax = max; long thirdMax = secondMax; for(int i = 0 ;i&lt;nums.length;i++){ if(nums[i]&gt;max){ thirdMax = secondMax; secondMax = max; max = nums[i]; } else if(nums[i]&lt;max &amp;&amp; nums[i]&gt;secondMax){ thirdMax = secondMax; secondMax = nums[i]; } else if(nums[i]&lt;secondMax &amp;&amp; nums[i]&gt;thirdMax){ thirdMax = nums[i]; } } return thirdMax==Long.MIN_VALUE ? (int) max : (int) thirdMax; } } . ",
    "url": "https://1001anjan.github.io/problem-76-Third-Maximum-Number/",
    "relUrl": "/problem-76-Third-Maximum-Number/"
  },"523": {
    "doc": "Add Strings",
    "title": "Add Strings",
    "content": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string. You must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly. Example 1: . Input: num1 = \"11\", num2 = \"123\" Output: \"134\" . Example 2: . Input: num1 = \"456\", num2 = \"77\" Output: \"533\" . Example 3: . Input: num1 = \"0\", num2 = \"0\" Output: \"0\" . Constraints: . | 1 &lt;= num1.length, num2.length &lt;= 104 | num1 and num2 consist of only digits. | num1 and num2 don’t have any leading zeros except for the zero itself. | . Solution: . class Solution { public String addStrings(String num1, String num2) { int c = 0; int v; int i = num1.length() - 1; int j = num2.length() - 1; StringBuilder sb = new StringBuilder(); while(i&gt;=0 &amp;&amp; j&gt;=0){ v = (num1.charAt(i) -48 + num2.charAt(j) -48 + c)%10; c = (num1.charAt(i) -48 + num2.charAt(j) -48 + c)/10; sb.append(v); i--; j--; } while(i&gt;=0){ v = (num1.charAt(i) -48 + c)%10; c = (num1.charAt(i) -48 + c)/10; sb.append(v); i--; } while(j&gt;=0){ v = (num2.charAt(j) -48 + c)%10; c = (num2.charAt(j) -48 + c)/10; sb.append(v); j--; } if(c&gt;=1) sb.append(c); return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-77-Add-Strings/",
    "relUrl": "/problem-77-Add-Strings/"
  },"524": {
    "doc": "Number of Segments in a String",
    "title": "Number of Segments in a String",
    "content": "Given a string s, return the number of segments in the string. A segment is defined to be a contiguous sequence of non-space characters. Example 1: . Input: s = \"Hello, my name is John\" Output: 5 Explanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"] . Example 2: . Input: s = \"Hello\" Output: 1 . Constraints: . | 0 &lt;= s.length &lt;= 300 | s consists of lowercase and uppercase English letters, digits, or one of the following characters “!@#$%^&amp;*()_+-=’,.:”. | The only space character in s is ‘ ‘. | . Solution . class Solution { public int countSegments(String s) { if(s.length() == 0) return 0; String[] ar = s.split(\" \"); int len = ar.length; for(String st : ar){ if(st.length() == 0) len--; } return len; } } . ",
    "url": "https://1001anjan.github.io/problem-78-Number-of-Segments-in-a-String/",
    "relUrl": "/problem-78-Number-of-Segments-in-a-String/"
  },"525": {
    "doc": "Find All Numbers Disappeared in an Array",
    "title": "Find All Numbers Disappeared in an Array",
    "content": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Example 1: . Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] . Example 2: . Input: nums = [1,1] Output: [2] . Constraints: . | n == nums.length | 1 &lt;= n &lt;= 105 | 1 &lt;= nums[i] &lt;= n | . Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Solution: . class Solution { public List findDisappearedNumbers(int[] arr) { int i = 0; List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); while(i&lt;arr.length){ if(arr[i] == -1){ i++; continue; } if(arr[arr[i] -1] == -1){ i++; continue; }else if(arr[i] == i+1){ arr[i] = -1; i++; } else{ int t = arr[arr[i]-1]; arr[arr[i] -1] = -1; arr[i] = t; } } for(int k = 0; k&lt;arr.length; k++){ if(arr[k] != -1){ l.add(k+1); } } return l; } } . ",
    "url": "https://1001anjan.github.io/problem-79-Find-All-Numbers-Disappeared-in-an-Array/",
    "relUrl": "/problem-79-Find-All-Numbers-Disappeared-in-an-Array/"
  },"526": {
    "doc": "Integer to Roman",
    "title": "Integer to Roman",
    "content": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 . For example, 2 is written as II in Roman numeral, just two one’s added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: . | I can be placed before V (5) and X (10) to make 4 and 9. | X can be placed before L (50) and C (100) to make 40 and 90. | C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. | . Example 1: . Input: num = 3 Output: \"III\" Explanation: 3 is represented as 3 ones. Example 2: . Input: num = 58 Output: \"LVIII\" Explanation: L = 50, V = 5, III = 3. Example 3: . Input: num = 1994 Output: \"MCMXCIV\" Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. Constraints: . | 1 &lt;= num &lt;= 3999 | . Solution: . class Solution { public String intToRoman(int num) { StringBuilder sb = new StringBuilder(); // Comparator for sotring decending order TreeMap&lt;Integer, String&gt; tm = new TreeMap&lt;&gt;((a,b)-&gt;(b - a)); tm.put(1000,\"M\"); tm.put(900,\"CM\"); tm.put(500,\"D\"); tm.put(400,\"CD\"); tm.put(100,\"C\"); tm.put(90,\"XC\"); tm.put(50,\"L\"); tm.put(40,\"XL\"); tm.put(10,\"X\"); tm.put(9,\"IX\"); tm.put(5,\"V\"); tm.put(4,\"IV\"); tm.put(1,\"I\"); for(Map.Entry&lt;Integer,String&gt; entry : tm.entrySet()){ int key = entry.getKey(); while(num &gt;= key){ sb.append(entry.getValue()); num -= key; } } return sb.toString(); } } . class Solution { public static String intToRoman(int num) { String M[] = {\"\", \"M\", \"MM\", \"MMM\"}; String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}; String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}; String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}; return new StringBuilder() .append(M[num/1000]) .append(C[(num%1000)/100]) .append(X[(num%100)/10]) .append(I[num%10]).toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-8-Integer%20to%20Roman/",
    "relUrl": "/problem-8-Integer to Roman/"
  },"527": {
    "doc": "Remove Element",
    "title": "Remove Element",
    "content": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The relative order of the elements may be changed. Since it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements. Return k after placing the final result in the first k slots of nums. Do not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory. Custom Judge: . The judge will test your solution with the following code: . int[] nums = [...]; // Input array int val = ...; // Value to remove int[] expectedNums = [...]; // The expected answer with correct length. // It is sorted with no values equaling val. int k = removeElement(nums, val); // Calls your implementation assert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i &lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } . If all assertions pass, then your solution will be accepted. Example 1: . Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2: . Input: nums = [0,1,2,2,3,0,4,2], val = 2 Output: 5, nums = [0,1,4,0,3,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4. Note that the five elements can be returned in any order. It does not matter what you leave beyond the returned k (hence they are underscores). Constraints: . | 0 &lt;= nums.length &lt;= 100 | 0 &lt;= nums[i] &lt;= 50 | 0 &lt;= val &lt;= 100 | . Solution . class Solution { public int removeElement(int[] nums, int val) { int i = 0; for(int j = 0; j&lt;nums.length; j++){ if(nums[j] == val) continue; nums[i++] = nums[j]; } return i; } } . ",
    "url": "https://1001anjan.github.io/problem-8-remove-element/",
    "relUrl": "/problem-8-remove-element/"
  },"528": {
    "doc": "Assign Cookies",
    "title": "Assign Cookies",
    "content": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number. Example 1: . Input: g = [1,2,3], s = [1,1] Output: 1 Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content. You need to output 1. Example 2: . Input: g = [1,2], s = [1,2,3] Output: 2 Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. You have 3 cookies and their sizes are big enough to gratify all of the children, You need to output 2. Constraints: . | 1 &lt;= g.length &lt;= 3 * 104 | 0 &lt;= s.length &lt;= 3 * 104 | 1 &lt;= g[i], s[j] &lt;= 231 - 1 | . Solution . class Solution { public int findContentChildren(int[] g, int[] s) { int c = 0; Arrays.sort(g); Arrays.sort(s); int k = 0; for(int i = 0; i&lt;s.length; i++){ if(k&lt;g.length &amp;&amp; g[k]&lt;=s[i]){ c++; k++; } } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-80-Assign-Cookies/",
    "relUrl": "/problem-80-Assign-Cookies/"
  },"529": {
    "doc": "Hamming Distance",
    "title": "Hamming Distance",
    "content": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, return the Hamming distance between them. Example 1: . Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. Example 2: . Input: x = 3, y = 1 Output: 1 . Constraints: . | 0 &lt;= x, y &lt;= 231 - 1 | . Solution . class Solution { public int hammingDistance(int x, int y) { int r = x ^ y; int c = 0; while(r&gt;0){ c = c + r%2; r = r/2; } return c; } } . ",
    "url": "https://1001anjan.github.io/problem-81-Hamming-Distance/",
    "relUrl": "/problem-81-Hamming-Distance/"
  },"530": {
    "doc": "Island Perimeter",
    "title": "Island Perimeter",
    "content": "You are given row x col grid representing a map where grid[i][j] = 1 represents land and grid[i][j] = 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn’t have “lakes”, meaning the water inside isn’t connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don’t exceed 100. Determine the perimeter of the island. Example 1: . Input: grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]] Output: 16 Explanation: The perimeter is the 16 yellow stripes in the image above. Example 2: . Input: grid = [[1]] Output: 4 . Example 3: . Input: grid = [[1,0]] Output: 4 . Constraints: . | row == grid.length | col == grid[i].length | 1 &lt;= row, col &lt;= 100 | grid[i][j] is 0 or 1. | There is exactly one island in grid. | . Solution . class Solution { public int islandPerimeter(int[][] grid) { int p = 0; for(int i = 0; i&lt;grid.length; i++){ for(int j = 0 ; j&lt;grid[0].length; j++){ if(grid[i][j] == 1){ if(i == 0) p++; if(j == 0) p++; if(i == grid.length - 1) p++; if(j == grid[0].length -1) p++; if(i&gt;0 &amp;&amp; grid[i-1][j] == 0) p++; if(i+1&lt;grid.length &amp;&amp; grid[i+1][j] == 0) p++; if(j&gt;0 &amp;&amp; grid[i][j-1] == 0) p++; if(j+1&lt;grid[0].length &amp;&amp; grid[i][j+1] == 0) p++; } } } return p; } } . ",
    "url": "https://1001anjan.github.io/problem-82-Island%20Perimeter/",
    "relUrl": "/problem-82-Island Perimeter/"
  },"531": {
    "doc": "Number Complement",
    "title": "Number Complement",
    "content": "The complement of an integer is the integer you get when you flip all the 0’s to 1’s and all the 1’s to 0’s in its binary representation. | For example, The integer 5 is “101” in binary and its complement is “010” which is the integer 2. Given an integer num, return its complement. | . Example 1: . Input: num = 5 Output: 2 Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. Example 2: . Input: num = 1 Output: 0 Explanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0. Constraints: . | 1 &lt;= num &lt; 231 | . Solution . class Solution { public int findComplement(int num) { int numberOfBits = (int)(Math.floor(Math.log(num) / Math.log(2))) + 1; return ((1 &lt;&lt; numberOfBits) - 1) ^ num; } } . Faster solution . class Solution { public int findComplement(int num) { int mask = 0; while(mask &lt; num) mask = mask &lt;&lt; 1 | 1; int ans = (~ num) &amp; mask ; return ans; } } . ",
    "url": "https://1001anjan.github.io/problem-83-Number-Complement/",
    "relUrl": "/problem-83-Number-Complement/"
  },"532": {
    "doc": "Max Consecutive Ones",
    "title": "Max Consecutive Ones",
    "content": "Given a binary array nums, return the maximum number of consecutive 1’s in the array. Example 1: . Input: nums = [1,1,0,1,1,1] Output: 3 Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Example 2: . Input: nums = [1,0,1,1,0,1] Output: 2 . Constraints: . | 1 &lt;= nums.length &lt;= 105 | nums[i] is either 0 or 1. | . Solution . class Solution { public int findMaxConsecutiveOnes(int[] nums) { int m = 0; int p = 0; int i = 0; while(i&lt;nums.length){ if(nums[i] == 0) { i++; continue; } while(i&lt;nums.length &amp;&amp; nums[i] == 1){ m++; i++; } if(m&gt;p){ p = m; } m = 0; } return p; } } . ",
    "url": "https://1001anjan.github.io/problem-84-Max-Consecutive-Ones/",
    "relUrl": "/problem-84-Max-Consecutive-Ones/"
  },"533": {
    "doc": "License Key Formatting",
    "title": "License Key Formatting",
    "content": "You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k. We want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase. Return the reformatted license key. Example 1: . Input: s = \"5F3Z-2e-9-w\", k = 4 Output: \"5F3Z-2E9W\" Explanation: The string s has been split into two parts, each part has 4 characters. Note that the two extra dashes are not needed and can be removed. Example 2: . Input: s = \"2-5g-3-J\", k = 2 Output: \"2-5G-3J\" Explanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above. Constraints: . | 1 &lt;= s.length &lt;= 105 | s consists of English letters, digits, and dashes ‘-‘. | 1 &lt;= k &lt;= 104 | . Solution . class Solution { public String licenseKeyFormatting(String s, int k) { StringBuilder sb = new StringBuilder(); int count = 0; for(int i = s.length()-1;i&gt;=0;i--){ if(s.charAt(i) != '-'){ if(count == k){ count = 0; sb = sb.append(\"-\"); } sb = sb.append(Character.toUpperCase(s.charAt(i))); count++; } } return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-85-License-Key-Formatting/",
    "relUrl": "/problem-85-License-Key-Formatting/"
  },"534": {
    "doc": "Construct the Rectangle",
    "title": "Construct the Rectangle",
    "content": "A web developer needs to know how to design a web page’s size. So, given a specific rectangular web page’s area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements: . The area of the rectangular web page you designed must equal to the given target area. The width W should not be larger than the length L, which means L &gt;= W. The difference between length L and width W should be as small as possible. Return an array [L, W] where L and W are the length and width of the web page you designed in sequence. Example 1: . Input: area = 4 Output: [2,2] Explanation: The target area is 4, and all the possible ways to construct it are [1,4], [2,2], [4,1]. But according to requirement 2, [1,4] is illegal; according to requirement 3, [4,1] is not optimal compared to [2,2]. So the length L is 2, and the width W is 2. Example 2: . Input: area = 37 Output: [37,1] . Example 3: . Input: area = 122122 Output: [427,286] . Constraints: . | 1 &lt;= area &lt;= 107 | . Solution . class Solution { public int[] constructRectangle(int area) { for(int i = (int)Math.sqrt(area);i&gt;0;i--){ if(area%i == 0){ return new int[]{area/i,i}; } } return null; } } . ",
    "url": "https://1001anjan.github.io/problem-86-Construct-the-Rectangle/",
    "relUrl": "/problem-86-Construct-the-Rectangle/"
  },"535": {
    "doc": "Teemo Attacking",
    "title": "Teemo Attacking",
    "content": "Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack. You are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration. Return the total number of seconds that Ashe is poisoned. Example 1: . Input: timeSeries = [1,4], duration = 2 Output: 4 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5. Ashe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total. Example 2: . Input: timeSeries = [1,2], duration = 2 Output: 3 Explanation: Teemo's attacks on Ashe go as follows: - At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2. - At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3. Ashe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total. Constraints: . | 1 &lt;= timeSeries.length &lt;= 104 | 0 &lt;= timeSeries[i], duration &lt;= 107 | timeSeries is sorted in non-decreasing order. | . Solution: . class Solution { public int findPoisonedDuration(int[] timeSeries, int duration) { int n = timeSeries.length; if (n == 0) return 0; int total = 0; for(int i = 0; i &lt; n - 1; ++i) total += Math.min(timeSeries[i + 1] - timeSeries[i], duration); return total + duration; } } . ",
    "url": "https://1001anjan.github.io/problem-87-Teemo-Attacking/",
    "relUrl": "/problem-87-Teemo-Attacking/"
  },"536": {
    "doc": "Next Greater Element I",
    "title": "Next Greater Element I",
    "content": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array. You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2. For each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1. Return an array ans of length nums1.length such that ans[i] is the next greater element as described above. Example 1: . Input: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. - 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. - 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: . Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows: - 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. - 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. Constraints: . | 1 &lt;= nums1.length &lt;= nums2.length &lt;= 1000 | 0 &lt;= nums1[i], nums2[i] &lt;= 104 | All integers in nums1 and nums2 are unique. | All the integers of nums1 also appear in nums2. | . Follow up: Could you find an O(nums1.length + nums2.length) solution? . Solution: . class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int[] ans = new int[nums1.length]; boolean f = false; for(int i = 0; i&lt;nums1.length; i++){ f = false; for(int j = 0; j&lt;nums2.length; j++){ if(nums1[i] == nums2[j]){ for(int k = j+1; k&lt;nums2.length; k++){ if(nums2[k] &gt; nums2[j]){ ans[i] = nums2[k]; f = true; break; } if(k == nums2.length) { ans[i] = -1; } } if(f) break; else ans[i] = -1; } } } return ans; } } . class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { int resGreater[]=new int[nums2.length-1]; resGreater=nextGreaterElementRight(nums2); HashMap&lt;Integer,Integer&gt; hm=new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums2.length;i++){ hm.put(nums2[i],resGreater[i]); } int result[]=new int[nums1.length]; for(int i=0;i&lt;nums1.length;i++){ result[i]=hm.get(nums1[i]); } return result; } public int[] nextGreaterElementRight(int[] nums1){ int res[]=new int[nums1.length]; Stack&lt;Integer&gt; st=new Stack&lt;Integer&gt;(); st.push(nums1[nums1.length-1]); res[nums1.length-1]=-1; for(int i=nums1.length-2;i&gt;=0;i--){ int res1=0; while(!st.isEmpty()&amp;&amp;nums1[i]&gt;st.peek()){ st.pop(); } if(!st.isEmpty()&amp;&amp;nums1[i]&lt;st.peek()){ res1=st.peek(); res[i]=res1; st.push(nums1[i]); } else if(st.isEmpty()){ res[i]=-1; st.push(nums1[i]); } } return res; } } . ",
    "url": "https://1001anjan.github.io/problem-88-Next-Greater-Element-I/",
    "relUrl": "/problem-88-Next-Greater-Element-I/"
  },"537": {
    "doc": "Keyboard Row",
    "title": "Keyboard Row",
    "content": "Given an array of strings words, return the words that can be typed using letters of the alphabet on only one row of American keyboard like the image below. In the American keyboard: . | the first row consists of the characters “qwertyuiop”, | the second row consists of the characters “asdfghjkl”, and | the third row consists of the characters “zxcvbnm”. | . Example 1: . Input: words = [\"Hello\",\"Alaska\",\"Dad\",\"Peace\"] Output: [\"Alaska\",\"Dad\"] . Example 2: . Input: words = [\"omk\"] Output: [] . Example 3: . Input: words = [\"adsdf\",\"sfd\"] Output: [\"adsdf\",\"sfd\"] . Constraints: . | 1 &lt;= words.length &lt;= 20 | 1 &lt;= words[i].length &lt;= 100 | words[i] consists of English letters (both lowercase and uppercase). | . class Solution { public String[] findWords(String[] words) { ArrayList&lt;String&gt; str = new ArrayList&lt;String&gt;(); String[] keys = new String[3]; keys[0] = \"QqWwEeRrTtYyUuIiOoPp\"; keys[1] = \"AaSsDdFfGgHhJjKkLl\"; keys[2] = \"ZzXxCcVvBbNnMm\"; for(String word : words){ char ch = word.charAt(0); int key = -1; if(keys[0].contains(String.valueOf(ch))) key = 0; if(keys[1].contains(String.valueOf(ch))) key = 1; if(keys[2].contains(String.valueOf(ch))) key = 2; if(key != -1){ int i=1; for(; i&lt;word.length(); i++){ if(!keys[key].contains(String.valueOf(word.charAt(i)))) break; } if(i == word.length()) str.add(word); } } return str.toArray(new String[str.size()]); } } . ",
    "url": "https://1001anjan.github.io/problem-89-Keyboard-Row/",
    "relUrl": "/problem-89-Keyboard-Row/"
  },"538": {
    "doc": "3Sum",
    "title": "3Sum",
    "content": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0. Notice that the solution set must not contain duplicate triplets. Example 1: . Input: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2: . Input: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3: . Input: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0. Constraints: . | 3 &lt;= nums.length &lt;= 3000 | -10^5 &lt;= nums[i] &lt;= 10^5 | . Solution: . class Solution { public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) { Set&lt;List&lt;Integer&gt;&gt; ans = new HashSet&lt;&gt;(); Arrays.sort(nums); System.out.println(); for(int i = 0; i &lt; nums.length - 1; i++){ int l = i + 1; int u = nums.length - 1; while(l &lt; u){ int s = nums[l] + nums[u] + nums[i]; if(s == 0){ ans.add(Arrays.asList(nums[i], nums[l], nums[u])); l++; u--; }else if(s &gt; 0){ u--; }else{ l++; } } } return new ArrayList(ans); } } . ",
    "url": "https://1001anjan.github.io/problem-9-3Sum/",
    "relUrl": "/problem-9-3Sum/"
  },"539": {
    "doc": "Implement strStr()",
    "title": "Implement strStr()",
    "content": "Implement strStr(). Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. Clarification: . What should we return when needle is an empty string? This is a great question to ask during an interview. For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C’s strstr() and Java’s indexOf(). Example 1: . Input: haystack = \"hello\", needle = \"ll\" Output: 2 . Example 2: . Input: haystack = \"aaaaa\", needle = \"bba\" Output: -1 . Constraints: . | 1 &lt;= haystack.length, needle.length &lt;= 104 | haystack and needle consist of only lowercase English characters. | . Solution . class Solution { public int strStr(String haystack, String needle) { if(needle.equals(\"\") || needle == null) return 0; int j = 0; int res = -1; for(int i=0; i&lt;haystack.length(); i++){ if(haystack.charAt(i) == needle.charAt(j)){ if(j == 0){ res = i; } j++; if(j == needle.length()) return res; }else{ if(res != -1){ i = res; } res = -1; j = 0; } } if(j != needle.length()) return -1; return res; } } . ",
    "url": "https://1001anjan.github.io/problem-9-implement-strStr/",
    "relUrl": "/problem-9-implement-strStr/"
  },"540": {
    "doc": "Find Mode in Binary Search Tree",
    "title": "Find Mode in Binary Search Tree",
    "content": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order. Assume a BST is defined as follows: . The left subtree of a node contains only nodes with keys less than or equal to the node’s key. The right subtree of a node contains only nodes with keys greater than or equal to the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: . Input: root = [1,null,2,2] Output: [2] . Example 2: . Input: root = [0] Output: [0] . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -105 &lt;= Node.val &lt;= 105 | . Follow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count). Solution: . class Solution { private TreeNode pre = null; private int max = 1; private int cnt = 1; // counts for leftmost node self public int[] findMode(TreeNode root) { List&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); inOrder(root, nums); int[] arr = new int[nums.size()]; for (int i = 0; i &lt; nums.size(); i++) arr[i] = nums.get(i); return arr; } private void inOrder(TreeNode root, List&lt;Integer&gt; nums) { if (root == null) { return; } // in-order traversal, left-root-right inOrder(root.left, nums); // if consecutive integers are the same if (pre != null) { cnt = (pre.val == root.val) ? cnt + 1 : 1; } // if current value's frequency is larger than the max one if (cnt &gt; max) { max = cnt; nums.clear(); nums.add(root.val); } else if (cnt == max) { // frequency equals, add current root value nums.add(root.val); } pre = root; // update pre node inOrder(root.right, nums); // in-order } } . class Solution { TreeNode pre = null; int max = 1; int count = 1; public int[] findMode(TreeNode root) { List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); traverseInorder(root, list); return list.stream().mapToInt(i-&gt;i).toArray(); } public void traverseInorder(TreeNode root, List&lt;Integer&gt; list){ if(root == null) return; traverseInorder(root.left, list); if(pre != null){ count = (pre.val == root.val)? count+1: 1; } if(count&gt;max){ max = count; list.clear(); list.add(root.val); }else if(count == max){ list.add(root.val); } pre = root; traverseInorder(root.right, list); } } . ",
    "url": "https://1001anjan.github.io/problem-90-Find-Mode-in-Binary-Search-Tree/",
    "relUrl": "/problem-90-Find-Mode-in-Binary-Search-Tree/"
  },"541": {
    "doc": "Base 7",
    "title": "Base 7",
    "content": "Given an integer num, return a string of its base 7 representation. Example 1: . Input: num = 100 Output: \"202\" . Example 2: . Input: num = -7 Output: \"-10\" . Constraints: . | -107 &lt;= num &lt;= 107 | . Solution: . class Solution { public String convertToBase7(int num) { if(num == 0) return \"0\"; boolean sign = false; if(num&lt;0){ num = num*-1; sign = true; } StringBuffer sb = new StringBuffer(); int base7 = 0; while(num&gt;0){ sb.append(num%7) ; num = num/7; } if(sign) return \"-\" + sb.reverse().toString(); else return sb.reverse().toString(); } } . ",
    "url": "https://1001anjan.github.io/problem-91-Base-7/",
    "relUrl": "/problem-91-Base-7/"
  },"542": {
    "doc": "Relative Ranks",
    "title": "Relative Ranks",
    "content": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique. The athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank: . | The 1st place athlete’s rank is “Gold Medal”. | The 2nd place athlete’s rank is “Silver Medal”. | The 3rd place athlete’s rank is “Bronze Medal”. | For the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete’s rank is “x”). | . Return an array answer of size n where answer[i] is the rank of the ith athlete. Example 1: . Input: score = [5,4,3,2,1] Output: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"] Explanation: The placements are [1st, 2nd, 3rd, 4th, 5th]. Example 2: . Input: score = [10,3,8,9,4] Output: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"] Explanation: The placements are [1st, 5th, 3rd, 2nd, 4th]. Constraints: . | n == score.length | 1 &lt;= n &lt;= 104 | 0 &lt;= score[i] &lt;= 106 | All the values in score are unique. | . Solution: . class Solution { public String[] findRelativeRanks(int[] score) { String[] result = new String[score.length]; List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int i: score) temp.add(i); Collections.sort(temp, Collections.reverseOrder()); int index; for(int i = 0; i&lt;score.length; i++){ index = temp.indexOf(score[i]); if(index == 0){ result[i] = \"Gold Medal\"; }else if(index == 1){ result[i] = \"Silver Medal\"; }else if(index == 2){ result[i] = \"Bronze Medal\"; }else{ result[i] = String.valueOf(index+1); } } return result; } } . class Solution { public String[] findRelativeRanks(int[] score) { int a[]=new int[score.length]; for(int i=0;i&lt;score.length;i++){ a[i]=score[i]; } Arrays.sort(score); String ans[]=new String[score.length]; for(int i=score.length;i&gt;0;i--){ String rank=GetRank(score,i); int index=Search(a,score[i-1]); ans[index]=rank; } return ans; } static String GetRank(int score[],int pos){ if(pos==score.length){ return \"Gold Medal\"; } else if(pos==score.length-1){ return \"Silver Medal\"; } else if(pos==score.length-2){ return \"Bronze Medal\"; } else { int a=score.length-pos+1; String s=Integer.toString(a); return s; } } static int Search(int a[],int target){ for(int i=0;i&lt;a.length;i++){ if(target==a[i]){ return i; } } return -1; } } . class Solution { public String[] findRelativeRanks(int[] score) { final String GOLD = \"Gold Medal\"; final String SILVER = \"Silver Medal\"; final String BRONZE = \"Bronze Medal\"; final String[] result = new String[score.length]; PriorityQueue&lt;Integer[]&gt; pq = new PriorityQueue&lt;&gt;((arr1, arr2) -&gt; arr2[0] - arr1[0]); for (int i = 0; i &lt; score.length; i++) { pq.add(new Integer[]{score[i], i}); } int k = 1; while (!pq.isEmpty()) { if (k &lt;= 3) { if (k == 1) result[pq.poll()[1]] = GOLD; if (k == 2) result[pq.poll()[1]] = SILVER; if (k == 3) result[pq.poll()[1]] = BRONZE; } else{ result[pq.poll()[1]] = String.valueOf(k); } k++; } return result; } } . ",
    "url": "https://1001anjan.github.io/problem-92-Relative-Ranks/",
    "relUrl": "/problem-92-Relative-Ranks/"
  },"543": {
    "doc": "Perfect Number",
    "title": "Perfect Number",
    "content": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly. Given an integer n, return true if n is a perfect number, otherwise return false. Example 1: . Input: num = 28 Output: true Explanation: 28 = 1 + 2 + 4 + 7 + 14 1, 2, 4, 7, and 14 are all divisors of 28. Example 2: . Input: num = 7 Output: false . Constraints: . | 1 &lt;= num &lt;= 108 | . Solution: . class Solution { public boolean checkPerfectNumber(int num) { int sum = 0; for(int i = 1; i&lt;=num/2; i++){ if(num%i == 0) sum += i; if(sum&gt;num) return false; } if(sum == num) return true; return false; } } . https://leetcode.com/problems/perfect-number/solution/ . class Solution { public boolean checkPerfectNumber(int num) { if (num &lt;= 0) { return false; } int sum = 0; for (int i = 1; i * i &lt;= num; i++) { if (num % i == 0) { sum += i; if (i * i != num) { sum += num / i; } } } return sum - num == num; } } . ",
    "url": "https://1001anjan.github.io/problem-93-Perfect-Number/",
    "relUrl": "/problem-93-Perfect-Number/"
  },"544": {
    "doc": "Fibonacci Number",
    "title": "Fibonacci Number",
    "content": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is, . F(0) = 0, F(1) = 1 F(n) = F(n - 1) + F(n - 2), for n &gt; 1. Given n, calculate F(n). Example 1: . Input: n = 2 Output: 1 Explanation: F(2) = F(1) + F(0) = 1 + 0 = 1. Example 2: . Input: n = 3 Output: 2 Explanation: F(3) = F(2) + F(1) = 1 + 1 = 2. Example 3: . Input: n = 4 Output: 3 Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3. Constraints: . | 0 &lt;= n &lt;= 30 | . Solution . class Solution { public int fib(int n) { if(n == 0) return 0; if(n == 1) return 1; return fib(n-1) + fib(n-2); } } . class Solution { Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); public int fib(int n) { if(map.containsKey(n)) return map.get(n); if(n == 0) return 0; if(n == 1) return 1; map.put(n,fib(n-1) + fib(n-2)); return map.get(n); } } . ",
    "url": "https://1001anjan.github.io/problem-94-Fibonacci-Number/",
    "relUrl": "/problem-94-Fibonacci-Number/"
  },"545": {
    "doc": "Detect Capital",
    "title": "Detect Capital",
    "content": "We define the usage of capitals in a word to be right when one of the following cases holds: . | All letters in this word are capitals, like “USA”. | All letters in this word are not capitals, like “leetcode”. | Only the first letter in this word is capital, like “Google”. | Given a string word, return true if the usage of capitals in it is right. | . Example 1: . Input: word = \"USA\" Output: true . Example 2: . Input: word = \"FlaG\" Output: false . Constraints: . | 1 &lt;= word.length &lt;= 100 | word consists of lowercase and uppercase English letters. | . Solution: . class Solution { public boolean detectCapitalUse(String word) { if(Character.isUpperCase(word.charAt(0))){ String s1 = word.toUpperCase(); if(word.equals(s1)) return true; s1 = word.charAt(0) + word.substring(1,word.length()).toLowerCase(); if(word.equals(s1)) return true; return false; }else{ String s1 = word.toLowerCase(); if(word.equals(s1)) return true; return false; } } } . class Solution { public boolean detectCapitalUse(String word) { return word.matches(\"[A-Z]*|.[a-z]*\"); } } . Faster . class Solution { public boolean detectCapitalUse(String word) { int n = word.length(); if (n == 1) { return true; } // case 1: All capital if (Character.isUpperCase(word.charAt(0)) &amp;&amp; Character.isUpperCase(word.charAt(1))) { for (int i = 2; i &lt; n; i++) { if (Character.isLowerCase(word.charAt(i))) { return false; } } // case 2 and case 3 } else { for (int i = 1; i &lt; n; i++) { if (Character.isUpperCase(word.charAt(i))) { return false; } } } // if pass one of the cases return true; } } . ",
    "url": "https://1001anjan.github.io/problem-95-Detect-Capital/",
    "relUrl": "/problem-95-Detect-Capital/"
  },"546": {
    "doc": "Minimum Absolute Difference in BST",
    "title": "Minimum Absolute Difference in BST",
    "content": "Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree. Example 1: . Input: root = [4,2,6,1,3] Output: 1 . Example 2: . Input: root = [1,0,48,null,null,12,49] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [2, 104]. | 0 &lt;= Node.val &lt;= 105 | . Solution . ",
    "url": "https://1001anjan.github.io/problem-96-Minimum-Absolute-Difference-in-BST/",
    "relUrl": "/problem-96-Minimum-Absolute-Difference-in-BST/"
  },"547": {
    "doc": "Reverse String II",
    "title": "Reverse String II",
    "content": "Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string. f there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original. Example 1: . Input: s = \"abcdefg\", k = 2 Output: \"bacdfeg\" . Example 2: . Input: s = \"abcd\", k = 2 Output: \"bacd\" . Constraints: . | 1 &lt;= s.length &lt;= 104 | s consists of only lowercase English letters. | 1 &lt;= k &lt;= 104 | . Solution: . class Solution { public String reverseStr(String s, int k) { int p = 0; char [] str = s.toCharArray(); while(p&lt;str.length){ // if reverse segment int l = p; int u = p + k -1; if(u &gt;= str.length) u = str.length - 1; while(l&lt;u){ char ch = str[l]; str[l] = str[u]; str[u] = ch; l++; u--; } p = p + 2*k; } return new String(str); } } . ",
    "url": "https://1001anjan.github.io/problem-97-Reverse-String-II/",
    "relUrl": "/problem-97-Reverse-String-II/"
  },"548": {
    "doc": "Diameter of Binary Tree",
    "title": "Diameter of Binary Tree",
    "content": "Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root. The length of a path between two nodes is represented by the number of edges between them. Example 1: . Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2: . Input: root = [1,2] Output: 1 . Constraints: . | The number of nodes in the tree is in the range [1, 104]. | -100 &lt;= Node.val &lt;= 100 | . Solution: . class Solution { public int diameterOfBinaryTree(TreeNode root) { // here we are using diameter array as reference to store value and not a diameter int variable to store the value int[] diameter = new int[1]; helper(root,diameter); return diameter[0]; } public int helper(TreeNode root, int[] diameter){ if(root == null) return 0; int leftHeight = helper(root.left,diameter); int rightHeight = helper(root.right,diameter); // checking whether the previous diameter is max or new diameter is max diameter[0] = Math.max(diameter[0],leftHeight + rightHeight); // here returning the max height which can either be left one or right one by adding current node as well return 1 + Math.max(leftHeight , rightHeight); } } . ",
    "url": "https://1001anjan.github.io/problem-98-Diameter-of-Binary-Tree/",
    "relUrl": "/problem-98-Diameter-of-Binary-Tree/"
  },"549": {
    "doc": "Student Attendance Record I",
    "title": "Student Attendance Record I",
    "content": "You are given a string s representing an attendance record for a student where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters: . | ‘A’: Absent. | ‘L’: Late. | ‘P’: Present. The student is eligible for an attendance award if they meet both of the following criteria: . | The student was absent (‘A’) for strictly fewer than 2 days total. | The student was never late (‘L’) for 3 or more consecutive days. | Return true if the student is eligible for an attendance award, or false otherwise. | . Example 1: . Input: s = \"PPALLP\" Output: true Explanation: The student has fewer than 2 absences and was never late 3 or more consecutive days. Example 2: . Input: s = \"PPALLL\" Output: false Explanation: The student was late 3 consecutive days in the last 3 days, so is not eligible for the award. Constraints: . | 1 &lt;= s.length &lt;= 1000 | s[i] is either ‘A’, ‘L’, or ‘P’. | . Solution: . class Solution { public boolean checkRecord(String s) { int abs = 0; int late = 0; int i = 0; while(i&lt;s.length()){ char ch = s.charAt(i); if(ch == 'A') abs++; if(ch == 'L'){ late++; i++; while(i&lt;s.length()){ ch = s.charAt(i); if(ch != 'L'){ i--; break; }else{ late++; i++; } } if(late&gt;=3) return false; late = 0; } i++; } if(abs&gt;=2 ) return false; return true; } } . ",
    "url": "https://1001anjan.github.io/problem-99-Student-Attendance-Record-I/",
    "relUrl": "/problem-99-Student-Attendance-Record-I/"
  },"550": {
    "doc": "Search",
    "title": "Search",
    "content": " ",
    "url": "https://1001anjan.github.io/docs/search/",
    "relUrl": "/docs/search/"
  },"551": {
    "doc": "Search",
    "title": "Table of contents",
    "content": ". | TOC | . Just the Docs uses lunr.js to add a client-side search interface powered by a JSON index that Jekyll generates. All search results are shown in an auto-complete style interface (there is no search results page). By default, all generated HTML pages are indexed using the following data points: . | Page title | Page content | Page URL | . ",
    "url": "https://1001anjan.github.io/docs/search/#table-of-contents",
    "relUrl": "/docs/search/#table-of-contents"
  },"552": {
    "doc": "Search",
    "title": "Enable search in configuration",
    "content": "In your site’s _config.yml, enable search: . # Enable or disable the site search # Supports true (default) or false search_enabled: true . Search granularity . Pages are split into sections that can be searched individually. The sections are defined by the headings on the page. Each section is displayed in a separate search result. # Split pages into sections that can be searched individually # Supports 1 - 6, default: 2 search.heading_level: 2 . Search previews . A search result can contain previews that show where the search words are found in the specific section. # Maximum amount of previews per search result # Default: 3 search.previews: 3 # Maximum amount of words to display before a matched word in the preview # Default: 5 search.preview_words_before: 5 # Maximum amount of words to display after a matched word in the preview # Default: 10 search.preview_words_after: 10 . Search tokenizer . The default is for hyphens to separate tokens in search terms: gem-based is equivalent to gem based, matching either word. To allow search for hyphenated words: . # Set the search token separator # Default: /[\\s\\-/]+/ # Example: enable support for hyphenated search words search.tokenizer_separator: /[\\s/]+/ . Display URL in search results . # Display the relative url in search results # Supports true (default) or false search.rel_url: false . Display search button . The search button displays in the bottom right corner of the screen and triggers the search input when clicked. # Enable or disable the search button that appears in the bottom right corner of every page # Supports true or false (default) search.button: true . ",
    "url": "https://1001anjan.github.io/docs/search/#enable-search-in-configuration",
    "relUrl": "/docs/search/#enable-search-in-configuration"
  },"553": {
    "doc": "Search",
    "title": "Hiding pages from search",
    "content": "Sometimes you might have a page that you don’t want to be indexed for the search nor to show up in search results, e.g, a 404 page. To exclude a page from search, add the search_exclude: true parameter to the page’s YAML front matter: . Example . --- layout: default title: Page not found nav_exclude: true search_exclude: true --- . ",
    "url": "https://1001anjan.github.io/docs/search/#hiding-pages-from-search",
    "relUrl": "/docs/search/#hiding-pages-from-search"
  },"554": {
    "doc": "Search",
    "title": "Generate search index when used as a gem",
    "content": "If you use Just the Docs as a remote theme, you do not need the following steps. If you use the theme as a gem, you must initialize the search by running this rake command that comes with just-the-docs: . $ bundle exec just-the-docs rake search:init . This command creates the assets/js/zzzz-search-data.json file that Jekyll uses to create your search index. Alternatively, you can create the file manually with this content. ",
    "url": "https://1001anjan.github.io/docs/search/#generate-search-index-when-used-as-a-gem",
    "relUrl": "/docs/search/#generate-search-index-when-used-as-a-gem"
  }
}
